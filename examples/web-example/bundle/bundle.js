/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var raml1Parser = __webpack_require__(1)


	var onClick = function() {

		var url = document.getElementById('inputUrl').value

	    raml1Parser.loadApi(url,{
	    		fsResolver: {
	    			content: function(path){ return fs.readFileSync(path).toString(); },
	    			list: function(path){ return fs.readDirSync(path); }
	    		},
	    		httpResolver:{
	    			getResource: function(path){
	    				var xhr = new XMLHttpRequest();
	    				xhr.open("get", path, false);
	    				xhr.send();
	    				var response = toResponse(xhr);
	    				return response;
	    			},
	    			getResourceAsync: function(path){
	    				var xhr = new XMLHttpRequest();
	    				return new Promise(function(resolve, reject){
	    					xhr.open("get", path, true);
	    					xhr.onload = function() {
	    						var response = toResponse(xhr);
	    		                resolve(response);
	    		            };
	    		            xhr.onerror = function() {
	    		                return Promise.reject({errorMessage:"Network Error"});
	    		            };
	    		            xhr.send();
	    				});
	    			}
	    		}
	    	}).then(function(api){

		    	var titleField = document.getElementById('apiTitle');

		    	titleField.value = api.title();

		    	var str = "";
		    	api.allResources().map(function(x){return x.completeRelativeUri()}).sort().forEach(function(x){
		    		str += x + '\n';
		    	});
		    	var resourcesField = document.getElementById('apiResources')
		    	resourcesField.value = str;
	    });
	}
	document.getElementById('rootButton').addEventListener('click', onClick);

	function toResponse(xhr){
		var status = xhr.status;
		if(status>300&&status<400){
			response = { errorMessage: "Redirect is not supported in thes implementation of HttpResolver" }
	    }
		else if(status>399){
			var msg = "Network error";
			if(xhr.statusText){
				msg += ": " + xhr.statusText;
			}
			response = { errorMessage: msg }
		}
		else{
			response = { content: xhr.responseText };
		}
		return response;
	}


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports =
	/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		var RamlWrapper = __webpack_require__(1);
		function loadApiSync(apiPath, extensionsAndOverlays, options) {
		    return RamlWrapper.loadApiSync(apiPath, extensionsAndOverlays, options);
		}
		exports.loadApiSync = loadApiSync;
		function loadApi(apiPath, extensionsAndOverlays, options) {
		    return RamlWrapper.loadApi(apiPath, extensionsAndOverlays, options);
		}
		exports.loadApi = loadApi;


	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * <p>See <a href="http://raml.org">http://raml.org</a> for more information about RAML.</p>
		 *
		 * <p>This parser is at a beta state of development, as part of the API Workbench development cycle (<a href="http://apiworkbench.com">http://apiworkbench.com</a>).</p>
		 *
		 * <p><a href="https://github.com/raml-org/raml-js-parser-2/blob/master/documentation/GettingStarted.md">Getting Started Guide</a> describes the first steps with the parser.</p>
		 *
		 * <h2>Installation</h2>
		 *
		 * <pre><code>git clone https://github.com/raml-org/raml-js-parser-2
		 *
		 * cd raml-js-parser-2
		 *
		 * npm install
		 *
		 * node test/test.js  //here you should observe JSON representation of XKCD API in your console
		 *
		 * node test/testAsync.js  //same as above but in asynchronous mode
		 * </code></pre>
		 *
		 * <h2>Usage</h2>
		 *
		 * <ul>
		 * <li>For parser usage example refer to <code>test/test.js</code></li>
		 * <li>For asynchrounous usage example refer to <code>test/testAsync.js</code></li>
		 * </ul>
		 **/
		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var hl = __webpack_require__(2);
		var services = __webpack_require__(49);
		var core = __webpack_require__(75);
		var apiLoader = __webpack_require__(76);
		var helper = __webpack_require__(65);
		var RAMLLanguageElementImpl = (function (_super) {
		    __extends(RAMLLanguageElementImpl, _super);
		    function RAMLLanguageElementImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLLanguageElementImpl.prototype.wrapperClassName = function () {
		        return "RAMLLanguageElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLLanguageElementImpl.prototype.getKind = function () {
		        return "RAMLLanguageElement";
		    };
		    /**
		     * The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
		     **/
		    RAMLLanguageElementImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    RAMLLanguageElementImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]
		     **/
		    RAMLLanguageElementImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    RAMLLanguageElementImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    return RAMLLanguageElementImpl;
		})(core.BasicNodeImpl);
		exports.RAMLLanguageElementImpl = RAMLLanguageElementImpl;
		var ValueTypeImpl = (function (_super) {
		    __extends(ValueTypeImpl, _super);
		    function ValueTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ValueTypeImpl.prototype.wrapperClassName = function () {
		        return "ValueTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ValueTypeImpl.prototype.getKind = function () {
		        return "ValueType";
		    };
		    /**
		     * @return String representation of the node value
		     **/
		    ValueTypeImpl.prototype.value = function () {
		        return this.attr.value();
		    };
		    return ValueTypeImpl;
		})(core.AttributeNodeImpl);
		exports.ValueTypeImpl = ValueTypeImpl;
		var NumberTypeImpl = (function (_super) {
		    __extends(NumberTypeImpl, _super);
		    function NumberTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    NumberTypeImpl.prototype.wrapperClassName = function () {
		        return "NumberTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    NumberTypeImpl.prototype.getKind = function () {
		        return "NumberType";
		    };
		    return NumberTypeImpl;
		})(ValueTypeImpl);
		exports.NumberTypeImpl = NumberTypeImpl;
		var BooleanTypeImpl = (function (_super) {
		    __extends(BooleanTypeImpl, _super);
		    function BooleanTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    BooleanTypeImpl.prototype.wrapperClassName = function () {
		        return "BooleanTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    BooleanTypeImpl.prototype.getKind = function () {
		        return "BooleanType";
		    };
		    return BooleanTypeImpl;
		})(ValueTypeImpl);
		exports.BooleanTypeImpl = BooleanTypeImpl;
		var ReferenceImpl = (function (_super) {
		    __extends(ReferenceImpl, _super);
		    function ReferenceImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ReferenceImpl.prototype.wrapperClassName = function () {
		        return "ReferenceImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ReferenceImpl.prototype.getKind = function () {
		        return "Reference";
		    };
		    /**
		     * @return StructuredValue object representing the node value
		     **/
		    ReferenceImpl.prototype.value = function () {
		        return core.toStructuredValue(this.attr);
		    };
		    return ReferenceImpl;
		})(core.AttributeNodeImpl);
		exports.ReferenceImpl = ReferenceImpl;
		var ResourceTypeRefImpl = (function (_super) {
		    __extends(ResourceTypeRefImpl, _super);
		    function ResourceTypeRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceTypeRefImpl.prototype.wrapperClassName = function () {
		        return "ResourceTypeRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceTypeRefImpl.prototype.getKind = function () {
		        return "ResourceTypeRef";
		    };
		    return ResourceTypeRefImpl;
		})(ReferenceImpl);
		exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
		var TraitRefImpl = (function (_super) {
		    __extends(TraitRefImpl, _super);
		    function TraitRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    TraitRefImpl.prototype.wrapperClassName = function () {
		        return "TraitRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    TraitRefImpl.prototype.getKind = function () {
		        return "TraitRef";
		    };
		    return TraitRefImpl;
		})(ReferenceImpl);
		exports.TraitRefImpl = TraitRefImpl;
		var SecuritySchemeRefImpl = (function (_super) {
		    __extends(SecuritySchemeRefImpl, _super);
		    function SecuritySchemeRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemeRefImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemeRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemeRefImpl.prototype.getKind = function () {
		        return "SecuritySchemeRef";
		    };
		    return SecuritySchemeRefImpl;
		})(ReferenceImpl);
		exports.SecuritySchemeRefImpl = SecuritySchemeRefImpl;
		/**
		 * Annotations allow you to attach information to your API
		 **/
		var AnnotationRefImpl = (function (_super) {
		    __extends(AnnotationRefImpl, _super);
		    function AnnotationRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    AnnotationRefImpl.prototype.wrapperClassName = function () {
		        return "AnnotationRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    AnnotationRefImpl.prototype.getKind = function () {
		        return "AnnotationRef";
		    };
		    return AnnotationRefImpl;
		})(ReferenceImpl);
		exports.AnnotationRefImpl = AnnotationRefImpl;
		var DataElementRefImpl = (function (_super) {
		    __extends(DataElementRefImpl, _super);
		    function DataElementRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DataElementRefImpl.prototype.wrapperClassName = function () {
		        return "DataElementRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DataElementRefImpl.prototype.getKind = function () {
		        return "DataElementRef";
		    };
		    return DataElementRefImpl;
		})(ReferenceImpl);
		exports.DataElementRefImpl = DataElementRefImpl;
		/**
		 * Elements to which this Annotation can be applied (enum)
		 **/
		var AnnotationTargetImpl = (function (_super) {
		    __extends(AnnotationTargetImpl, _super);
		    function AnnotationTargetImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    AnnotationTargetImpl.prototype.wrapperClassName = function () {
		        return "AnnotationTargetImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    AnnotationTargetImpl.prototype.getKind = function () {
		        return "AnnotationTarget";
		    };
		    return AnnotationTargetImpl;
		})(ValueTypeImpl);
		exports.AnnotationTargetImpl = AnnotationTargetImpl;
		var pointerImpl = (function (_super) {
		    __extends(pointerImpl, _super);
		    function pointerImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    pointerImpl.prototype.wrapperClassName = function () {
		        return "pointerImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    pointerImpl.prototype.getKind = function () {
		        return "pointer";
		    };
		    return pointerImpl;
		})(ValueTypeImpl);
		exports.pointerImpl = pointerImpl;
		var StringTypeImpl = (function (_super) {
		    __extends(StringTypeImpl, _super);
		    function StringTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    StringTypeImpl.prototype.wrapperClassName = function () {
		        return "StringTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    StringTypeImpl.prototype.getKind = function () {
		        return "StringType";
		    };
		    return StringTypeImpl;
		})(ValueTypeImpl);
		exports.StringTypeImpl = StringTypeImpl;
		/**
		 * This type currently serves both for absolute and relative urls
		 **/
		var UriTemplateImpl = (function (_super) {
		    __extends(UriTemplateImpl, _super);
		    function UriTemplateImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    UriTemplateImpl.prototype.wrapperClassName = function () {
		        return "UriTemplateImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    UriTemplateImpl.prototype.getKind = function () {
		        return "UriTemplate";
		    };
		    return UriTemplateImpl;
		})(StringTypeImpl);
		exports.UriTemplateImpl = UriTemplateImpl;
		/**
		 * This  type describes relative uri templates
		 **/
		var RelativeUriStringImpl = (function (_super) {
		    __extends(RelativeUriStringImpl, _super);
		    function RelativeUriStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RelativeUriStringImpl.prototype.wrapperClassName = function () {
		        return "RelativeUriStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RelativeUriStringImpl.prototype.getKind = function () {
		        return "RelativeUriString";
		    };
		    return RelativeUriStringImpl;
		})(UriTemplateImpl);
		exports.RelativeUriStringImpl = RelativeUriStringImpl;
		/**
		 * This  type describes absolute uri templates
		 **/
		var FullUriTemplateStringImpl = (function (_super) {
		    __extends(FullUriTemplateStringImpl, _super);
		    function FullUriTemplateStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FullUriTemplateStringImpl.prototype.wrapperClassName = function () {
		        return "FullUriTemplateStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FullUriTemplateStringImpl.prototype.getKind = function () {
		        return "FullUriTemplateString";
		    };
		    return FullUriTemplateStringImpl;
		})(UriTemplateImpl);
		exports.FullUriTemplateStringImpl = FullUriTemplateStringImpl;
		var StatusCodeStringImpl = (function (_super) {
		    __extends(StatusCodeStringImpl, _super);
		    function StatusCodeStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    StatusCodeStringImpl.prototype.wrapperClassName = function () {
		        return "StatusCodeStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    StatusCodeStringImpl.prototype.getKind = function () {
		        return "StatusCodeString";
		    };
		    return StatusCodeStringImpl;
		})(StringTypeImpl);
		exports.StatusCodeStringImpl = StatusCodeStringImpl;
		/**
		 * This  type describes fixed uris
		 **/
		var FixedUriStringImpl = (function (_super) {
		    __extends(FixedUriStringImpl, _super);
		    function FixedUriStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FixedUriStringImpl.prototype.wrapperClassName = function () {
		        return "FixedUriStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FixedUriStringImpl.prototype.getKind = function () {
		        return "FixedUriString";
		    };
		    return FixedUriStringImpl;
		})(StringTypeImpl);
		exports.FixedUriStringImpl = FixedUriStringImpl;
		var ContentTypeImpl = (function (_super) {
		    __extends(ContentTypeImpl, _super);
		    function ContentTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ContentTypeImpl.prototype.wrapperClassName = function () {
		        return "ContentTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ContentTypeImpl.prototype.getKind = function () {
		        return "ContentType";
		    };
		    return ContentTypeImpl;
		})(StringTypeImpl);
		exports.ContentTypeImpl = ContentTypeImpl;
		var ValidityExpressionImpl = (function (_super) {
		    __extends(ValidityExpressionImpl, _super);
		    function ValidityExpressionImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ValidityExpressionImpl.prototype.wrapperClassName = function () {
		        return "ValidityExpressionImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ValidityExpressionImpl.prototype.getKind = function () {
		        return "ValidityExpression";
		    };
		    return ValidityExpressionImpl;
		})(StringTypeImpl);
		exports.ValidityExpressionImpl = ValidityExpressionImpl;
		var DateFormatSpecImpl = (function (_super) {
		    __extends(DateFormatSpecImpl, _super);
		    function DateFormatSpecImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DateFormatSpecImpl.prototype.wrapperClassName = function () {
		        return "DateFormatSpecImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DateFormatSpecImpl.prototype.getKind = function () {
		        return "DateFormatSpec";
		    };
		    return DateFormatSpecImpl;
		})(StringTypeImpl);
		exports.DateFormatSpecImpl = DateFormatSpecImpl;
		var FunctionalInterfaceImpl = (function (_super) {
		    __extends(FunctionalInterfaceImpl, _super);
		    function FunctionalInterfaceImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FunctionalInterfaceImpl.prototype.wrapperClassName = function () {
		        return "FunctionalInterfaceImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FunctionalInterfaceImpl.prototype.getKind = function () {
		        return "FunctionalInterface";
		    };
		    return FunctionalInterfaceImpl;
		})(StringTypeImpl);
		exports.FunctionalInterfaceImpl = FunctionalInterfaceImpl;
		/**
		 * Schema at this moment only two subtypes are supported (json schema and xsd)
		 **/
		var SchemaStringImpl = (function (_super) {
		    __extends(SchemaStringImpl, _super);
		    function SchemaStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SchemaStringImpl.prototype.wrapperClassName = function () {
		        return "SchemaStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SchemaStringImpl.prototype.getKind = function () {
		        return "SchemaString";
		    };
		    return SchemaStringImpl;
		})(StringTypeImpl);
		exports.SchemaStringImpl = SchemaStringImpl;
		/**
		 * JSON schema
		 **/
		var JSonSchemaStringImpl = (function (_super) {
		    __extends(JSonSchemaStringImpl, _super);
		    function JSonSchemaStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    JSonSchemaStringImpl.prototype.wrapperClassName = function () {
		        return "JSonSchemaStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    JSonSchemaStringImpl.prototype.getKind = function () {
		        return "JSonSchemaString";
		    };
		    return JSonSchemaStringImpl;
		})(SchemaStringImpl);
		exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
		/**
		 * XSD schema
		 **/
		var XMLSchemaStringImpl = (function (_super) {
		    __extends(XMLSchemaStringImpl, _super);
		    function XMLSchemaStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    XMLSchemaStringImpl.prototype.wrapperClassName = function () {
		        return "XMLSchemaStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    XMLSchemaStringImpl.prototype.getKind = function () {
		        return "XMLSchemaString";
		    };
		    return XMLSchemaStringImpl;
		})(SchemaStringImpl);
		exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
		/**
		 * Examples at this moment only two subtypes are supported (json  and xml)
		 **/
		var ExampleStringImpl = (function (_super) {
		    __extends(ExampleStringImpl, _super);
		    function ExampleStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ExampleStringImpl.prototype.wrapperClassName = function () {
		        return "ExampleStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ExampleStringImpl.prototype.getKind = function () {
		        return "ExampleString";
		    };
		    return ExampleStringImpl;
		})(StringTypeImpl);
		exports.ExampleStringImpl = ExampleStringImpl;
		var RAMLPointerImpl = (function (_super) {
		    __extends(RAMLPointerImpl, _super);
		    function RAMLPointerImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLPointerImpl.prototype.wrapperClassName = function () {
		        return "RAMLPointerImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLPointerImpl.prototype.getKind = function () {
		        return "RAMLPointer";
		    };
		    return RAMLPointerImpl;
		})(StringTypeImpl);
		exports.RAMLPointerImpl = RAMLPointerImpl;
		var RAMLSelectorImpl = (function (_super) {
		    __extends(RAMLSelectorImpl, _super);
		    function RAMLSelectorImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLSelectorImpl.prototype.wrapperClassName = function () {
		        return "RAMLSelectorImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLSelectorImpl.prototype.getKind = function () {
		        return "RAMLSelector";
		    };
		    return RAMLSelectorImpl;
		})(StringTypeImpl);
		exports.RAMLSelectorImpl = RAMLSelectorImpl;
		/**
		 * This sub type of the string represents mime types
		 **/
		var MimeTypeImpl = (function (_super) {
		    __extends(MimeTypeImpl, _super);
		    function MimeTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MimeTypeImpl.prototype.wrapperClassName = function () {
		        return "MimeTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MimeTypeImpl.prototype.getKind = function () {
		        return "MimeType";
		    };
		    return MimeTypeImpl;
		})(StringTypeImpl);
		exports.MimeTypeImpl = MimeTypeImpl;
		/**
		 * [GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)
		 **/
		var MarkdownStringImpl = (function (_super) {
		    __extends(MarkdownStringImpl, _super);
		    function MarkdownStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MarkdownStringImpl.prototype.wrapperClassName = function () {
		        return "MarkdownStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MarkdownStringImpl.prototype.getKind = function () {
		        return "MarkdownString";
		    };
		    return MarkdownStringImpl;
		})(StringTypeImpl);
		exports.MarkdownStringImpl = MarkdownStringImpl;
		var DocumentationItemImpl = (function (_super) {
		    __extends(DocumentationItemImpl, _super);
		    function DocumentationItemImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DocumentationItemImpl.prototype.wrapperClassName = function () {
		        return "DocumentationItemImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DocumentationItemImpl.prototype.getKind = function () {
		        return "DocumentationItem";
		    };
		    /**
		     * Title of documentation section
		     **/
		    DocumentationItemImpl.prototype.title = function () {
		        return _super.prototype.attribute.call(this, 'title', this.toString);
		    };
		    /**
		     * @hidden
		     * Set title value
		     **/
		    DocumentationItemImpl.prototype.setTitle = function (param) {
		        this.highLevel().attrOrCreate("title").setValue("" + param);
		        return this;
		    };
		    /**
		     * Content of documentation section
		     **/
		    DocumentationItemImpl.prototype.content = function () {
		        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    return DocumentationItemImpl;
		})(RAMLLanguageElementImpl);
		exports.DocumentationItemImpl = DocumentationItemImpl;
		var ScriptSpecImpl = (function (_super) {
		    __extends(ScriptSpecImpl, _super);
		    function ScriptSpecImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createScriptSpec(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ScriptSpecImpl.prototype.wrapperClassName = function () {
		        return "ScriptSpecImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ScriptSpecImpl.prototype.getKind = function () {
		        return "ScriptSpec";
		    };
		    ScriptSpecImpl.prototype.language = function () {
		        return _super.prototype.attribute.call(this, 'language', this.toString);
		    };
		    /**
		     * @hidden
		     * Set language value
		     **/
		    ScriptSpecImpl.prototype.setLanguage = function (param) {
		        this.highLevel().attrOrCreate("language").setValue("" + param);
		        return this;
		    };
		    ScriptSpecImpl.prototype.content = function () {
		        return _super.prototype.attribute.call(this, 'content', this.toString);
		    };
		    /**
		     * @hidden
		     * Set content value
		     **/
		    ScriptSpecImpl.prototype.setContent = function (param) {
		        this.highLevel().attrOrCreate("content").setValue("" + param);
		        return this;
		    };
		    return ScriptSpecImpl;
		})(RAMLLanguageElementImpl);
		exports.ScriptSpecImpl = ScriptSpecImpl;
		var ApiDescriptionImpl = (function (_super) {
		    __extends(ApiDescriptionImpl, _super);
		    function ApiDescriptionImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createApiDescription(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ApiDescriptionImpl.prototype.wrapperClassName = function () {
		        return "ApiDescriptionImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ApiDescriptionImpl.prototype.getKind = function () {
		        return "ApiDescription";
		    };
		    ApiDescriptionImpl.prototype.apiFiles = function () {
		        return _super.prototype.elements.call(this, 'apiFiles');
		    };
		    ApiDescriptionImpl.prototype.script = function () {
		        return _super.prototype.elements.call(this, 'script');
		    };
		    ApiDescriptionImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', this.toString);
		    };
		    /**
		     * @hidden
		     * Set type value
		     **/
		    ApiDescriptionImpl.prototype.setType = function (param) {
		        this.highLevel().attrOrCreate("type").setValue("" + param);
		        return this;
		    };
		    return ApiDescriptionImpl;
		})(RAMLLanguageElementImpl);
		exports.ApiDescriptionImpl = ApiDescriptionImpl;
		var CallbackAPIDescriptionImpl = (function (_super) {
		    __extends(CallbackAPIDescriptionImpl, _super);
		    function CallbackAPIDescriptionImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createCallbackAPIDescription(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    CallbackAPIDescriptionImpl.prototype.wrapperClassName = function () {
		        return "CallbackAPIDescriptionImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    CallbackAPIDescriptionImpl.prototype.getKind = function () {
		        return "CallbackAPIDescription";
		    };
		    CallbackAPIDescriptionImpl.prototype.callbackFor = function () {
		        return _super.prototype.element.call(this, 'callbackFor');
		    };
		    return CallbackAPIDescriptionImpl;
		})(ApiDescriptionImpl);
		exports.CallbackAPIDescriptionImpl = CallbackAPIDescriptionImpl;
		var RAMLProjectImpl = (function (_super) {
		    __extends(RAMLProjectImpl, _super);
		    function RAMLProjectImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLProject(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLProjectImpl.prototype.wrapperClassName = function () {
		        return "RAMLProjectImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLProjectImpl.prototype.getKind = function () {
		        return "RAMLProject";
		    };
		    RAMLProjectImpl.prototype.relatedProjects = function () {
		        return _super.prototype.elements.call(this, 'relatedProjects');
		    };
		    RAMLProjectImpl.prototype.declaredApis = function () {
		        return _super.prototype.elements.call(this, 'declaredApis');
		    };
		    RAMLProjectImpl.prototype.license = function () {
		        return _super.prototype.attribute.call(this, 'license', this.toString);
		    };
		    /**
		     * @hidden
		     * Set license value
		     **/
		    RAMLProjectImpl.prototype.setLicense = function (param) {
		        this.highLevel().attrOrCreate("license").setValue("" + param);
		        return this;
		    };
		    RAMLProjectImpl.prototype.overview = function () {
		        return _super.prototype.attribute.call(this, 'overview', this.toString);
		    };
		    /**
		     * @hidden
		     * Set overview value
		     **/
		    RAMLProjectImpl.prototype.setOverview = function (param) {
		        this.highLevel().attrOrCreate("overview").setValue("" + param);
		        return this;
		    };
		    RAMLProjectImpl.prototype.url = function () {
		        return _super.prototype.attribute.call(this, 'url', this.toString);
		    };
		    /**
		     * @hidden
		     * Set url value
		     **/
		    RAMLProjectImpl.prototype.setUrl = function (param) {
		        this.highLevel().attrOrCreate("url").setValue("" + param);
		        return this;
		    };
		    return RAMLProjectImpl;
		})(RAMLLanguageElementImpl);
		exports.RAMLProjectImpl = RAMLProjectImpl;
		/**
		 * Security schema type allows you to contribute your own security schema type with settings and optinal configurator for plugging into client sdks auth mechanism
		 **/
		var SecuritySchemaTypeImpl = (function (_super) {
		    __extends(SecuritySchemaTypeImpl, _super);
		    function SecuritySchemaTypeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaType(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemaTypeImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemaTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemaTypeImpl.prototype.getKind = function () {
		        return "SecuritySchemaType";
		    };
		    /**
		     * You may declare settings needed to use this type of security security schemas
		     **/
		    SecuritySchemaTypeImpl.prototype.requiredSettings = function () {
		        return _super.prototype.elements.call(this, 'requiredSettings');
		    };
		    /**
		     * The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.
		     * This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation.
		     **/
		    SecuritySchemaTypeImpl.prototype.describedBy = function () {
		        return _super.prototype.element.call(this, 'describedBy');
		    };
		    return SecuritySchemaTypeImpl;
		})(RAMLLanguageElementImpl);
		exports.SecuritySchemaTypeImpl = SecuritySchemaTypeImpl;
		var TypeDeclarationImpl = (function (_super) {
		    __extends(TypeDeclarationImpl, _super);
		    function TypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    TypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "TypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    TypeDeclarationImpl.prototype.getKind = function () {
		        return "TypeDeclaration";
		    };
		    /**
		     * name of the parameter
		     **/
		    TypeDeclarationImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    TypeDeclarationImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * When extending from a type you can define new facets (which can then be set to concrete values by subtypes).
		     **/
		    TypeDeclarationImpl.prototype.facets = function () {
		        return _super.prototype.elements.call(this, 'facets');
		    };
		    /**
		     * Alias for the equivalent "type" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "type" property, as the "schema" alias for that property name may be removed in a future RAML version. The "type" property allows for XML and JSON schemas.
		     **/
		    TypeDeclarationImpl.prototype.schema = function () {
		        return _super.prototype.attribute.call(this, 'schema', this.toString);
		    };
		    /**
		     * @hidden
		     * Set schema value
		     **/
		    TypeDeclarationImpl.prototype.setSchema = function (param) {
		        this.highLevel().attrOrCreate("schema").setValue("" + param);
		        return this;
		    };
		    TypeDeclarationImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    TypeDeclarationImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    /**
		     * A base type which the current type extends, or more generally a type expression.
		     **/
		    TypeDeclarationImpl.prototype["type"] = function () {
		        return _super.prototype.attributes.call(this, 'type', this.toString);
		    };
		    /**
		     * @hidden
		     * Set type value
		     **/
		    TypeDeclarationImpl.prototype.setType = function (param) {
		        this.highLevel().attrOrCreate("type").setValue("" + param);
		        return this;
		    };
		    /**
		     * Location of the parameter (can not be edited by user)
		     **/
		    TypeDeclarationImpl.prototype.location = function () {
		        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ModelLocationImpl(attr); });
		    };
		    /**
		     * Kind of location
		     **/
		    TypeDeclarationImpl.prototype.locationKind = function () {
		        return _super.prototype.attribute.call(this, 'locationKind', function (attr) { return new LocationKindImpl(attr); });
		    };
		    /**
		     * Provides default value for a property
		     **/
		    TypeDeclarationImpl.prototype["default"] = function () {
		        return _super.prototype.attribute.call(this, 'default', this.toString);
		    };
		    /**
		     * @hidden
		     * Set default value
		     **/
		    TypeDeclarationImpl.prototype.setDefault = function (param) {
		        this.highLevel().attrOrCreate("default").setValue("" + param);
		        return this;
		    };
		    /**
		     * An example of an instance of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
		     **/
		    TypeDeclarationImpl.prototype.example = function () {
		        return _super.prototype.attribute.call(this, 'example', this.toString);
		    };
		    /**
		     * @hidden
		     * Set example value
		     **/
		    TypeDeclarationImpl.prototype.setExample = function (param) {
		        this.highLevel().attrOrCreate("example").setValue("" + param);
		        return this;
		    };
		    /**
		     * An object containing named examples of instances of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
		     **/
		    TypeDeclarationImpl.prototype.examples = function () {
		        return _super.prototype.elements.call(this, 'examples');
		    };
		    /**
		     * The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated.
		     **/
		    TypeDeclarationImpl.prototype.repeat = function () {
		        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set repeat value
		     **/
		    TypeDeclarationImpl.prototype.setRepeat = function (param) {
		        this.highLevel().attrOrCreate("repeat").setValue("" + param);
		        return this;
		    };
		    /**
		     * Sets if property is optional or not
		     **/
		    TypeDeclarationImpl.prototype.required = function () {
		        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set required value
		     **/
		    TypeDeclarationImpl.prototype.setRequired = function (param) {
		        this.highLevel().attrOrCreate("required").setValue("" + param);
		        return this;
		    };
		    /**
		     * An alternate, human-friendly name for the type
		     **/
		    TypeDeclarationImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    TypeDeclarationImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the type
		     **/
		    TypeDeclarationImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    TypeDeclarationImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    /**
		     * Runtime representation of type represented by this AST node
		     **/
		    TypeDeclarationImpl.prototype.runtimeType = function () {
		        return helper.runtimeType(this);
		    };
		    return TypeDeclarationImpl;
		})(RAMLLanguageElementImpl);
		exports.TypeDeclarationImpl = TypeDeclarationImpl;
		var ModelLocationImpl = (function () {
		    function ModelLocationImpl(attr) {
		        this.attr = attr;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ModelLocationImpl.prototype.wrapperClassName = function () {
		        return "ModelLocationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ModelLocationImpl.prototype.getKind = function () {
		        return "ModelLocation";
		    };
		    return ModelLocationImpl;
		})();
		exports.ModelLocationImpl = ModelLocationImpl;
		var LocationKindImpl = (function () {
		    function LocationKindImpl(attr) {
		        this.attr = attr;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    LocationKindImpl.prototype.wrapperClassName = function () {
		        return "LocationKindImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    LocationKindImpl.prototype.getKind = function () {
		        return "LocationKind";
		    };
		    return LocationKindImpl;
		})();
		exports.LocationKindImpl = LocationKindImpl;
		var ExampleSpecImpl = (function (_super) {
		    __extends(ExampleSpecImpl, _super);
		    function ExampleSpecImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createExampleSpec(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ExampleSpecImpl.prototype.wrapperClassName = function () {
		        return "ExampleSpecImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ExampleSpecImpl.prototype.getKind = function () {
		        return "ExampleSpec";
		    };
		    /**
		     * The example itself
		     **/
		    ExampleSpecImpl.prototype.content = function () {
		        return _super.prototype.attribute.call(this, 'content', this.toString);
		    };
		    /**
		     * @hidden
		     * Set content value
		     **/
		    ExampleSpecImpl.prototype.setContent = function (param) {
		        this.highLevel().attrOrCreate("content").setValue("" + param);
		        return this;
		    };
		    /**
		     * By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate.
		     **/
		    ExampleSpecImpl.prototype.strict = function () {
		        return _super.prototype.attribute.call(this, 'strict', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set strict value
		     **/
		    ExampleSpecImpl.prototype.setStrict = function (param) {
		        this.highLevel().attrOrCreate("strict").setValue("" + param);
		        return this;
		    };
		    ExampleSpecImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    ExampleSpecImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * An alternate, human-friendly name for the example
		     **/
		    ExampleSpecImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    ExampleSpecImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the example
		     **/
		    ExampleSpecImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    ExampleSpecImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    return ExampleSpecImpl;
		})(RAMLLanguageElementImpl);
		exports.ExampleSpecImpl = ExampleSpecImpl;
		/**
		 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
		 **/
		var FileTypeDeclarationImpl = (function (_super) {
		    __extends(FileTypeDeclarationImpl, _super);
		    function FileTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createFileTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FileTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "FileTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FileTypeDeclarationImpl.prototype.getKind = function () {
		        return "FileTypeDeclaration";
		    };
		    /**
		     * It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type * /* should be a valid value.
		     **/
		    FileTypeDeclarationImpl.prototype.fileTypes = function () {
		        return _super.prototype.attributes.call(this, 'fileTypes', function (attr) { return new ContentTypeImpl(attr); });
		    };
		    /**
		     * The minLength attribute specifies the parameter value's minimum number of bytes.
		     **/
		    FileTypeDeclarationImpl.prototype.minLength = function () {
		        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minLength value
		     **/
		    FileTypeDeclarationImpl.prototype.setMinLength = function (param) {
		        this.highLevel().attrOrCreate("minLength").setValue("" + param);
		        return this;
		    };
		    /**
		     * The maxLength attribute specifies the parameter value's maximum number of bytes.
		     **/
		    FileTypeDeclarationImpl.prototype.maxLength = function () {
		        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maxLength value
		     **/
		    FileTypeDeclarationImpl.prototype.setMaxLength = function (param) {
		        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
		        return this;
		    };
		    return FileTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.FileTypeDeclarationImpl = FileTypeDeclarationImpl;
		var ArrayTypeDeclarationImpl = (function (_super) {
		    __extends(ArrayTypeDeclarationImpl, _super);
		    function ArrayTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createArrayTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ArrayTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "ArrayTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ArrayTypeDeclarationImpl.prototype.getKind = function () {
		        return "ArrayTypeDeclaration";
		    };
		    /**
		     * Should items in array be unique
		     **/
		    ArrayTypeDeclarationImpl.prototype.uniqueItems = function () {
		        return _super.prototype.attribute.call(this, 'uniqueItems', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set uniqueItems value
		     **/
		    ArrayTypeDeclarationImpl.prototype.setUniqueItems = function (param) {
		        this.highLevel().attrOrCreate("uniqueItems").setValue("" + param);
		        return this;
		    };
		    /**
		     * Array component type.
		     **/
		    ArrayTypeDeclarationImpl.prototype.items = function () {
		        return _super.prototype.element.call(this, 'items');
		    };
		    /**
		     * Minimum amount of items in array
		     **/
		    ArrayTypeDeclarationImpl.prototype.minItems = function () {
		        return _super.prototype.attribute.call(this, 'minItems', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minItems value
		     **/
		    ArrayTypeDeclarationImpl.prototype.setMinItems = function (param) {
		        this.highLevel().attrOrCreate("minItems").setValue("" + param);
		        return this;
		    };
		    /**
		     * Maximum amount of items in array
		     **/
		    ArrayTypeDeclarationImpl.prototype.maxItems = function () {
		        return _super.prototype.attribute.call(this, 'maxItems', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maxItems value
		     **/
		    ArrayTypeDeclarationImpl.prototype.setMaxItems = function (param) {
		        this.highLevel().attrOrCreate("maxItems").setValue("" + param);
		        return this;
		    };
		    return ArrayTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.ArrayTypeDeclarationImpl = ArrayTypeDeclarationImpl;
		var UnionTypeDeclarationImpl = (function (_super) {
		    __extends(UnionTypeDeclarationImpl, _super);
		    function UnionTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createUnionTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    UnionTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "UnionTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    UnionTypeDeclarationImpl.prototype.getKind = function () {
		        return "UnionTypeDeclaration";
		    };
		    /**
		     * Type property name to be used as a discriminator or boolean
		     **/
		    UnionTypeDeclarationImpl.prototype.discriminator = function () {
		        return _super.prototype.attribute.call(this, 'discriminator', this.toString);
		    };
		    /**
		     * @hidden
		     * Set discriminator value
		     **/
		    UnionTypeDeclarationImpl.prototype.setDiscriminator = function (param) {
		        this.highLevel().attrOrCreate("discriminator").setValue("" + param);
		        return this;
		    };
		    return UnionTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.UnionTypeDeclarationImpl = UnionTypeDeclarationImpl;
		var ObjectTypeDeclarationImpl = (function (_super) {
		    __extends(ObjectTypeDeclarationImpl, _super);
		    function ObjectTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createObjectTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ObjectTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "ObjectTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ObjectTypeDeclarationImpl.prototype.getKind = function () {
		        return "ObjectTypeDeclaration";
		    };
		    /**
		     * The properties that instances of this type may or must have.
		     **/
		    ObjectTypeDeclarationImpl.prototype.properties = function () {
		        return _super.prototype.elements.call(this, 'properties');
		    };
		    /**
		     * The minimum number of properties allowed for instances of this type.
		     **/
		    ObjectTypeDeclarationImpl.prototype.minProperties = function () {
		        return _super.prototype.attribute.call(this, 'minProperties', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minProperties value
		     **/
		    ObjectTypeDeclarationImpl.prototype.setMinProperties = function (param) {
		        this.highLevel().attrOrCreate("minProperties").setValue("" + param);
		        return this;
		    };
		    /**
		     * The maximum number of properties allowed for instances of this type.
		     **/
		    ObjectTypeDeclarationImpl.prototype.maxProperties = function () {
		        return _super.prototype.attribute.call(this, 'maxProperties', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maxProperties value
		     **/
		    ObjectTypeDeclarationImpl.prototype.setMaxProperties = function (param) {
		        this.highLevel().attrOrCreate("maxProperties").setValue("" + param);
		        return this;
		    };
		    /**
		     * JSON schema style syntax for declaring maps
		     **/
		    ObjectTypeDeclarationImpl.prototype.additionalProperties = function () {
		        return _super.prototype.element.call(this, 'additionalProperties');
		    };
		    /**
		     * JSON schema style syntax for declaring key restricted maps
		     **/
		    ObjectTypeDeclarationImpl.prototype.patternProperties = function () {
		        return _super.prototype.elements.call(this, 'patternProperties');
		    };
		    /**
		     * Type property name to be used as discriminator, or boolean
		     **/
		    ObjectTypeDeclarationImpl.prototype.discriminator = function () {
		        return _super.prototype.attribute.call(this, 'discriminator', function (attr) { return new pointerImpl(attr); });
		    };
		    /**
		     * The value of discriminator for the type.
		     **/
		    ObjectTypeDeclarationImpl.prototype.discriminatorValue = function () {
		        return _super.prototype.attribute.call(this, 'discriminatorValue', this.toString);
		    };
		    /**
		     * @hidden
		     * Set discriminatorValue value
		     **/
		    ObjectTypeDeclarationImpl.prototype.setDiscriminatorValue = function (param) {
		        this.highLevel().attrOrCreate("discriminatorValue").setValue("" + param);
		        return this;
		    };
		    return ObjectTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.ObjectTypeDeclarationImpl = ObjectTypeDeclarationImpl;
		/**
		 * Value must be a string
		 **/
		var StringTypeDeclarationImpl = (function (_super) {
		    __extends(StringTypeDeclarationImpl, _super);
		    function StringTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createStringTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    StringTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "StringTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    StringTypeDeclarationImpl.prototype.getKind = function () {
		        return "StringTypeDeclaration";
		    };
		    /**
		     * Regular expression that this string should path
		     **/
		    StringTypeDeclarationImpl.prototype.pattern = function () {
		        return _super.prototype.attribute.call(this, 'pattern', this.toString);
		    };
		    /**
		     * @hidden
		     * Set pattern value
		     **/
		    StringTypeDeclarationImpl.prototype.setPattern = function (param) {
		        this.highLevel().attrOrCreate("pattern").setValue("" + param);
		        return this;
		    };
		    /**
		     * Minimum length of the string
		     **/
		    StringTypeDeclarationImpl.prototype.minLength = function () {
		        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minLength value
		     **/
		    StringTypeDeclarationImpl.prototype.setMinLength = function (param) {
		        this.highLevel().attrOrCreate("minLength").setValue("" + param);
		        return this;
		    };
		    /**
		     * Maximum length of the string
		     **/
		    StringTypeDeclarationImpl.prototype.maxLength = function () {
		        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maxLength value
		     **/
		    StringTypeDeclarationImpl.prototype.setMaxLength = function (param) {
		        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
		     **/
		    StringTypeDeclarationImpl.prototype.enum = function () {
		        return _super.prototype.attributes.call(this, 'enum', this.toString);
		    };
		    /**
		     * @hidden
		     * Set enum value
		     **/
		    StringTypeDeclarationImpl.prototype.setEnum = function (param) {
		        this.highLevel().attrOrCreate("enum").setValue("" + param);
		        return this;
		    };
		    return StringTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.StringTypeDeclarationImpl = StringTypeDeclarationImpl;
		/**
		 * Value must be a boolean
		 **/
		var BooleanTypeDeclarationImpl = (function (_super) {
		    __extends(BooleanTypeDeclarationImpl, _super);
		    function BooleanTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    BooleanTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "BooleanTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    BooleanTypeDeclarationImpl.prototype.getKind = function () {
		        return "BooleanTypeDeclaration";
		    };
		    return BooleanTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.BooleanTypeDeclarationImpl = BooleanTypeDeclarationImpl;
		/**
		 * Value must be a boolean
		 **/
		var ValueTypeDeclarationImpl = (function (_super) {
		    __extends(ValueTypeDeclarationImpl, _super);
		    function ValueTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createValueTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ValueTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "ValueTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ValueTypeDeclarationImpl.prototype.getKind = function () {
		        return "ValueTypeDeclaration";
		    };
		    return ValueTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.ValueTypeDeclarationImpl = ValueTypeDeclarationImpl;
		/**
		 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
		 **/
		var NumberTypeDeclarationImpl = (function (_super) {
		    __extends(NumberTypeDeclarationImpl, _super);
		    function NumberTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createNumberTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    NumberTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "NumberTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    NumberTypeDeclarationImpl.prototype.getKind = function () {
		        return "NumberTypeDeclaration";
		    };
		    /**
		     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
		     **/
		    NumberTypeDeclarationImpl.prototype.minimum = function () {
		        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minimum value
		     **/
		    NumberTypeDeclarationImpl.prototype.setMinimum = function (param) {
		        this.highLevel().attrOrCreate("minimum").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
		     **/
		    NumberTypeDeclarationImpl.prototype.maximum = function () {
		        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maximum value
		     **/
		    NumberTypeDeclarationImpl.prototype.setMaximum = function (param) {
		        this.highLevel().attrOrCreate("maximum").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
		     **/
		    NumberTypeDeclarationImpl.prototype.enum = function () {
		        return _super.prototype.attributes.call(this, 'enum', this.toString);
		    };
		    /**
		     * @hidden
		     * Set enum value
		     **/
		    NumberTypeDeclarationImpl.prototype.setEnum = function (param) {
		        this.highLevel().attrOrCreate("enum").setValue("" + param);
		        return this;
		    };
		    /**
		     * Value format
		     **/
		    NumberTypeDeclarationImpl.prototype.format = function () {
		        return _super.prototype.attribute.call(this, 'format', this.toString);
		    };
		    /**
		     * @hidden
		     * Set format value
		     **/
		    NumberTypeDeclarationImpl.prototype.setFormat = function (param) {
		        this.highLevel().attrOrCreate("format").setValue("" + param);
		        return this;
		    };
		    /**
		     * A numeric instance is valid against "multipleOf" if the result of the division of the instance by this keyword's value is an integer.
		     **/
		    NumberTypeDeclarationImpl.prototype.multipleOf = function () {
		        return _super.prototype.attribute.call(this, 'multipleOf', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set multipleOf value
		     **/
		    NumberTypeDeclarationImpl.prototype.setMultipleOf = function (param) {
		        this.highLevel().attrOrCreate("multipleOf").setValue("" + param);
		        return this;
		    };
		    return NumberTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.NumberTypeDeclarationImpl = NumberTypeDeclarationImpl;
		/**
		 * Value MUST be a integer.
		 **/
		var IntegerTypeDeclarationImpl = (function (_super) {
		    __extends(IntegerTypeDeclarationImpl, _super);
		    function IntegerTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    IntegerTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "IntegerTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    IntegerTypeDeclarationImpl.prototype.getKind = function () {
		        return "IntegerTypeDeclaration";
		    };
		    IntegerTypeDeclarationImpl.prototype.format = function () {
		        return _super.prototype.attribute.call(this, 'format', this.toString);
		    };
		    /**
		     * @hidden
		     * Set format value
		     **/
		    IntegerTypeDeclarationImpl.prototype.setFormat = function (param) {
		        this.highLevel().attrOrCreate("format").setValue("" + param);
		        return this;
		    };
		    return IntegerTypeDeclarationImpl;
		})(NumberTypeDeclarationImpl);
		exports.IntegerTypeDeclarationImpl = IntegerTypeDeclarationImpl;
		var RAMLPointerElementImpl = (function (_super) {
		    __extends(RAMLPointerElementImpl, _super);
		    function RAMLPointerElementImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLPointerElement(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLPointerElementImpl.prototype.wrapperClassName = function () {
		        return "RAMLPointerElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLPointerElementImpl.prototype.getKind = function () {
		        return "RAMLPointerElement";
		    };
		    RAMLPointerElementImpl.prototype.target = function () {
		        return _super.prototype.attribute.call(this, 'target', function (attr) { return new RAMLSelectorImpl(attr); });
		    };
		    return RAMLPointerElementImpl;
		})(TypeDeclarationImpl);
		exports.RAMLPointerElementImpl = RAMLPointerElementImpl;
		var RAMLExpressionImpl = (function (_super) {
		    __extends(RAMLExpressionImpl, _super);
		    function RAMLExpressionImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLExpression(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLExpressionImpl.prototype.wrapperClassName = function () {
		        return "RAMLExpressionImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLExpressionImpl.prototype.getKind = function () {
		        return "RAMLExpression";
		    };
		    return RAMLExpressionImpl;
		})(TypeDeclarationImpl);
		exports.RAMLExpressionImpl = RAMLExpressionImpl;
		var ScriptHookElementImpl = (function (_super) {
		    __extends(ScriptHookElementImpl, _super);
		    function ScriptHookElementImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createScriptHookElement(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ScriptHookElementImpl.prototype.wrapperClassName = function () {
		        return "ScriptHookElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ScriptHookElementImpl.prototype.getKind = function () {
		        return "ScriptHookElement";
		    };
		    /**
		     * Typescript file defining interface which this scrip should comply to
		     **/
		    ScriptHookElementImpl.prototype.declaredIn = function () {
		        return _super.prototype.attribute.call(this, 'declaredIn', this.toString);
		    };
		    /**
		     * @hidden
		     * Set declaredIn value
		     **/
		    ScriptHookElementImpl.prototype.setDeclaredIn = function (param) {
		        this.highLevel().attrOrCreate("declaredIn").setValue("" + param);
		        return this;
		    };
		    /**
		     * Name of the interface which scripts should comply to
		     **/
		    ScriptHookElementImpl.prototype.interfaceName = function () {
		        return _super.prototype.attribute.call(this, 'interfaceName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set interfaceName value
		     **/
		    ScriptHookElementImpl.prototype.setInterfaceName = function (param) {
		        this.highLevel().attrOrCreate("interfaceName").setValue("" + param);
		        return this;
		    };
		    return ScriptHookElementImpl;
		})(TypeDeclarationImpl);
		exports.ScriptHookElementImpl = ScriptHookElementImpl;
		var SchemaElementImpl = (function (_super) {
		    __extends(SchemaElementImpl, _super);
		    function SchemaElementImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createSchemaElement(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SchemaElementImpl.prototype.wrapperClassName = function () {
		        return "SchemaElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SchemaElementImpl.prototype.getKind = function () {
		        return "SchemaElement";
		    };
		    return SchemaElementImpl;
		})(TypeDeclarationImpl);
		exports.SchemaElementImpl = SchemaElementImpl;
		/**
		 * Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. or according to specified date format
		 **/
		var DateTypeDeclarationImpl = (function (_super) {
		    __extends(DateTypeDeclarationImpl, _super);
		    function DateTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createDateTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DateTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "DateTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DateTypeDeclarationImpl.prototype.getKind = function () {
		        return "DateTypeDeclaration";
		    };
		    DateTypeDeclarationImpl.prototype.dateFormat = function () {
		        return _super.prototype.attribute.call(this, 'dateFormat', function (attr) { return new DateFormatSpecImpl(attr); });
		    };
		    return DateTypeDeclarationImpl;
		})(TypeDeclarationImpl);
		exports.DateTypeDeclarationImpl = DateTypeDeclarationImpl;
		var HasNormalParametersImpl = (function (_super) {
		    __extends(HasNormalParametersImpl, _super);
		    function HasNormalParametersImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createHasNormalParameters(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    HasNormalParametersImpl.prototype.wrapperClassName = function () {
		        return "HasNormalParametersImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    HasNormalParametersImpl.prototype.getKind = function () {
		        return "HasNormalParameters";
		    };
		    /**
		     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
		     **/
		    HasNormalParametersImpl.prototype.queryParameters = function () {
		        return _super.prototype.elements.call(this, 'queryParameters');
		    };
		    /**
		     * Headers that allowed at this position
		     **/
		    HasNormalParametersImpl.prototype.headers = function () {
		        return _super.prototype.elements.call(this, 'headers');
		    };
		    HasNormalParametersImpl.prototype.queryString = function () {
		        return _super.prototype.element.call(this, 'queryString');
		    };
		    return HasNormalParametersImpl;
		})(RAMLLanguageElementImpl);
		exports.HasNormalParametersImpl = HasNormalParametersImpl;
		var MethodBaseImpl = (function (_super) {
		    __extends(MethodBaseImpl, _super);
		    function MethodBaseImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MethodBaseImpl.prototype.wrapperClassName = function () {
		        return "MethodBaseImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MethodBaseImpl.prototype.getKind = function () {
		        return "MethodBase";
		    };
		    /**
		     * Information about the expected responses to a request
		     **/
		    MethodBaseImpl.prototype.responses = function () {
		        return _super.prototype.elements.call(this, 'responses');
		    };
		    /**
		     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.
		     * Resources CAN have alternate representations. For example, an API might support both JSON and XML representations.
		     * A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
		     **/
		    MethodBaseImpl.prototype.body = function () {
		        return _super.prototype.elements.call(this, 'body');
		    };
		    /**
		     * A method can override the protocols specified in the resource or at the API root, by employing this property.
		     **/
		    MethodBaseImpl.prototype.protocols = function () {
		        return _super.prototype.attributes.call(this, 'protocols', this.toString);
		    };
		    /**
		     * @hidden
		     * Set protocols value
		     **/
		    MethodBaseImpl.prototype.setProtocols = function (param) {
		        this.highLevel().attrOrCreate("protocols").setValue("" + param);
		        return this;
		    };
		    /**
		     * Instantiation of applyed traits
		     **/
		    MethodBaseImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
		     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
		     **/
		    MethodBaseImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
		    };
		    return MethodBaseImpl;
		})(HasNormalParametersImpl);
		exports.MethodBaseImpl = MethodBaseImpl;
		var ResponseImpl = (function (_super) {
		    __extends(ResponseImpl, _super);
		    function ResponseImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResponseImpl.prototype.wrapperClassName = function () {
		        return "ResponseImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResponseImpl.prototype.getKind = function () {
		        return "Response";
		    };
		    /**
		     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
		     **/
		    ResponseImpl.prototype.code = function () {
		        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeStringImpl(attr); });
		    };
		    /**
		     * Detailed information about any response headers returned by this method
		     **/
		    ResponseImpl.prototype.headers = function () {
		        return _super.prototype.elements.call(this, 'headers');
		    };
		    /**
		     * The body of the response: a body declaration
		     **/
		    ResponseImpl.prototype.body = function () {
		        return _super.prototype.elements.call(this, 'body');
		    };
		    /**
		     * An alternate, human-friendly name for the response
		     **/
		    ResponseImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    ResponseImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the response
		     **/
		    ResponseImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    ResponseImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    /**
		     * true for codes < 400 and false otherwise
		     **/
		    ResponseImpl.prototype.isOkRange = function () {
		        return helper.isOkRange(this);
		    };
		    return ResponseImpl;
		})(RAMLLanguageElementImpl);
		exports.ResponseImpl = ResponseImpl;
		var TraitImpl = (function (_super) {
		    __extends(TraitImpl, _super);
		    function TraitImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    TraitImpl.prototype.wrapperClassName = function () {
		        return "TraitImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    TraitImpl.prototype.getKind = function () {
		        return "Trait";
		    };
		    /**
		     * Name of the trait
		     **/
		    TraitImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    TraitImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    TraitImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    TraitImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    /**
		     * You may import library locally here it contents is accessible only inside of this trait
		     **/
		    TraitImpl.prototype.uses = function () {
		        return _super.prototype.elements.call(this, 'uses');
		    };
		    return TraitImpl;
		})(MethodBaseImpl);
		exports.TraitImpl = TraitImpl;
		var LibraryBaseImpl = (function (_super) {
		    __extends(LibraryBaseImpl, _super);
		    function LibraryBaseImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createLibraryBase(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    LibraryBaseImpl.prototype.wrapperClassName = function () {
		        return "LibraryBaseImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    LibraryBaseImpl.prototype.getKind = function () {
		        return "LibraryBase";
		    };
		    LibraryBaseImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    LibraryBaseImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * Alias for the equivalent "types" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the "types" property, as the "schemas" alias for that property name may be removed in a future RAML version. The "types" property allows for XML and JSON schemas.
		     **/
		    LibraryBaseImpl.prototype.schemas = function () {
		        return _super.prototype.elements.call(this, 'schemas');
		    };
		    /**
		     * Declarations of (data) types for use within this API
		     **/
		    LibraryBaseImpl.prototype.types = function () {
		        return _super.prototype.elements.call(this, 'types');
		    };
		    /**
		     * Declarations of traits for use within this API
		     **/
		    LibraryBaseImpl.prototype.traits = function () {
		        return _super.prototype.elements.call(this, 'traits');
		    };
		    /**
		     * Declarations of resource types for use within this API
		     **/
		    LibraryBaseImpl.prototype.resourceTypes = function () {
		        return _super.prototype.elements.call(this, 'resourceTypes');
		    };
		    /**
		     * Declarations of annotation types for use by annotations
		     **/
		    LibraryBaseImpl.prototype.annotationTypes = function () {
		        return _super.prototype.elements.call(this, 'annotationTypes');
		    };
		    /**
		     * Security schemas types declarations
		     **/
		    LibraryBaseImpl.prototype.securitySchemaTypes = function () {
		        return _super.prototype.elements.call(this, 'securitySchemaTypes');
		    };
		    /**
		     * Declarations of security schemes for use within this API.
		     **/
		    LibraryBaseImpl.prototype.securitySchemes = function () {
		        return _super.prototype.elements.call(this, 'securitySchemes');
		    };
		    /**
		     * Importing libraries
		     **/
		    LibraryBaseImpl.prototype.uses = function () {
		        return _super.prototype.elements.call(this, 'uses');
		    };
		    return LibraryBaseImpl;
		})(RAMLLanguageElementImpl);
		exports.LibraryBaseImpl = LibraryBaseImpl;
		var LibraryImpl = (function (_super) {
		    __extends(LibraryImpl, _super);
		    function LibraryImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createLibrary(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    LibraryImpl.prototype.wrapperClassName = function () {
		        return "LibraryImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    LibraryImpl.prototype.getKind = function () {
		        return "Library";
		    };
		    /**
		     * contains description of why library exist
		     **/
		    LibraryImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    LibraryImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    return LibraryImpl;
		})(LibraryBaseImpl);
		exports.LibraryImpl = LibraryImpl;
		var MethodImpl = (function (_super) {
		    __extends(MethodImpl, _super);
		    function MethodImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MethodImpl.prototype.wrapperClassName = function () {
		        return "MethodImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MethodImpl.prototype.getKind = function () {
		        return "Method";
		    };
		    MethodImpl.prototype.signature = function () {
		        return _super.prototype.attribute.call(this, 'signature', function (attr) { return new SchemaStringImpl(attr); });
		    };
		    /**
		     * Method that can be called
		     **/
		    MethodImpl.prototype.method = function () {
		        return _super.prototype.attribute.call(this, 'method', this.toString);
		    };
		    /**
		     * @hidden
		     * Set method value
		     **/
		    MethodImpl.prototype.setMethod = function (param) {
		        this.highLevel().attrOrCreate("method").setValue("" + param);
		        return this;
		    };
		    /**
		     * An alternate, human-friendly name for the method (in the resource's context).
		     **/
		    MethodImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    MethodImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the method (in the resource's context)
		     **/
		    MethodImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Specifies the query string needed by this method. Mutually exclusive with queryParameters.
		     **/
		    MethodImpl.prototype.queryString = function () {
		        return _super.prototype.element.call(this, 'queryString');
		    };
		    /**
		     * Detailed information about any query parameters needed by this method. Mutually exclusive with queryString.
		     **/
		    MethodImpl.prototype.queryParameters = function () {
		        return _super.prototype.elements.call(this, 'queryParameters');
		    };
		    /**
		     * Detailed information about any request headers needed by this method.
		     **/
		    MethodImpl.prototype.headers = function () {
		        return _super.prototype.elements.call(this, 'headers');
		    };
		    /**
		     * Some methods admit request bodies, which are described by this property.
		     **/
		    MethodImpl.prototype.body = function () {
		        return _super.prototype.elements.call(this, 'body');
		    };
		    /**
		     * A list of the traits to apply to this method. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section.
		     **/
		    MethodImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    MethodImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    /**
		     * The security schemes that apply to this method
		     **/
		    MethodImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
		    };
		    /**
		     * For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
		     **/
		    MethodImpl.prototype.parentResource = function () {
		        return helper.parentResource(this);
		    };
		    /**
		     * Api owning the resource as a sibling
		     **/
		    MethodImpl.prototype.ownerApi = function () {
		        return helper.ownerApi(this);
		    };
		    /**
		     * For methods of Resources: `{parent Resource relative path} {methodName}`.
		     * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
		     * For other methods throws Exception.
		     **/
		    MethodImpl.prototype.methodId = function () {
		        return helper.methodId(this);
		    };
		    return MethodImpl;
		})(MethodBaseImpl);
		exports.MethodImpl = MethodImpl;
		var SecuritySchemePartImpl = (function (_super) {
		    __extends(SecuritySchemePartImpl, _super);
		    function SecuritySchemePartImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemePart(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemePartImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemePartImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemePartImpl.prototype.getKind = function () {
		        return "SecuritySchemePart";
		    };
		    /**
		     * Headers that allowed at this position
		     **/
		    SecuritySchemePartImpl.prototype.headers = function () {
		        return _super.prototype.elements.call(this, 'headers');
		    };
		    /**
		     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
		     **/
		    SecuritySchemePartImpl.prototype.queryParameters = function () {
		        return _super.prototype.elements.call(this, 'queryParameters');
		    };
		    /**
		     * Specifies the query string, used by the schema in order to authorize the request. Mutually exclusive with queryParameters.
		     **/
		    SecuritySchemePartImpl.prototype.queryString = function () {
		        return _super.prototype.element.call(this, 'queryString');
		    };
		    /**
		     * Optional array of responses, describing the possible responses that could be sent. See [[raml-10-spec-responses|Responses]] section.
		     **/
		    SecuritySchemePartImpl.prototype.responses = function () {
		        return _super.prototype.elements.call(this, 'responses');
		    };
		    /**
		     * Instantiation of applyed traits
		     **/
		    SecuritySchemePartImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
		     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
		     **/
		    SecuritySchemePartImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
		    };
		    /**
		     * An alternate, human-friendly name for the security scheme part
		     **/
		    SecuritySchemePartImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    SecuritySchemePartImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the security scheme part
		     **/
		    SecuritySchemePartImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Annotations to be applied to this security scheme part. Annotations are any property whose key begins with "(" and ends with ")" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See [[raml-10-spec-annotations|the section on annotations]].
		     **/
		    SecuritySchemePartImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    return SecuritySchemePartImpl;
		})(MethodBaseImpl);
		exports.SecuritySchemePartImpl = SecuritySchemePartImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var AbstractSecuritySchemeImpl = (function (_super) {
		    __extends(AbstractSecuritySchemeImpl, _super);
		    function AbstractSecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createAbstractSecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    AbstractSecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "AbstractSecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    AbstractSecuritySchemeImpl.prototype.getKind = function () {
		        return "AbstractSecurityScheme";
		    };
		    AbstractSecuritySchemeImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    AbstractSecuritySchemeImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
		     **/
		    AbstractSecuritySchemeImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', this.toString);
		    };
		    /**
		     * @hidden
		     * Set type value
		     **/
		    AbstractSecuritySchemeImpl.prototype.setType = function (param) {
		        this.highLevel().attrOrCreate("type").setValue("" + param);
		        return this;
		    };
		    /**
		     * The description MAY be used to describe a securityScheme.
		     **/
		    AbstractSecuritySchemeImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes.
		     * Including the security scheme description completes an API documentation.
		     **/
		    AbstractSecuritySchemeImpl.prototype.describedBy = function () {
		        return _super.prototype.element.call(this, 'describedBy');
		    };
		    /**
		     * The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared.
		     * It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more.
		     **/
		    AbstractSecuritySchemeImpl.prototype.settings = function () {
		        return _super.prototype.element.call(this, 'settings');
		    };
		    return AbstractSecuritySchemeImpl;
		})(RAMLLanguageElementImpl);
		exports.AbstractSecuritySchemeImpl = AbstractSecuritySchemeImpl;
		var SecuritySchemeSettingsImpl = (function (_super) {
		    __extends(SecuritySchemeSettingsImpl, _super);
		    function SecuritySchemeSettingsImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemeSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemeSettingsImpl.prototype.getKind = function () {
		        return "SecuritySchemeSettings";
		    };
		    return SecuritySchemeSettingsImpl;
		})(core.BasicNodeImpl);
		exports.SecuritySchemeSettingsImpl = SecuritySchemeSettingsImpl;
		var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
		    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
		    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
		        return "OAuth1SecuritySchemeSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.getKind = function () {
		        return "OAuth1SecuritySchemeSettings";
		    };
		    /**
		     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
		        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriStringImpl(attr); });
		    };
		    /**
		     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
		        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriStringImpl(attr); });
		    };
		    /**
		     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
		        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriStringImpl(attr); });
		    };
		    OAuth1SecuritySchemeSettingsImpl.prototype.signatures = function () {
		        return _super.prototype.attributes.call(this, 'signatures', this.toString);
		    };
		    /**
		     * @hidden
		     * Set signatures value
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.setSignatures = function (param) {
		        this.highLevel().attrOrCreate("signatures").setValue("" + param);
		        return this;
		    };
		    return OAuth1SecuritySchemeSettingsImpl;
		})(SecuritySchemeSettingsImpl);
		exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
		var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
		    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
		    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
		        return "OAuth2SecuritySchemeSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.getKind = function () {
		        return "OAuth2SecuritySchemeSettings";
		    };
		    /**
		     * The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2. Not required forby implicit grant type.
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
		        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriStringImpl(attr); });
		    };
		    /**
		     * The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1. Required forby authorization_code and implicit grant types.
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
		        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriStringImpl(attr); });
		    };
		    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
		        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
		    };
		    /**
		     * @hidden
		     * Set authorizationGrants value
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
		        this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
		        return this;
		    };
		    /**
		     * A list of scopes supported by the security scheme as defined in RFC6749 [RFC6749] Section 3.3
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
		        return _super.prototype.attributes.call(this, 'scopes', this.toString);
		    };
		    /**
		     * @hidden
		     * Set scopes value
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
		        this.highLevel().attrOrCreate("scopes").setValue("" + param);
		        return this;
		    };
		    return OAuth2SecuritySchemeSettingsImpl;
		})(SecuritySchemeSettingsImpl);
		exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
		var PassThroughSecuritySchemeSettingsImpl = (function (_super) {
		    __extends(PassThroughSecuritySchemeSettingsImpl, _super);
		    function PassThroughSecuritySchemeSettingsImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createPassThroughSecuritySchemeSettings(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    PassThroughSecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
		        return "PassThroughSecuritySchemeSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    PassThroughSecuritySchemeSettingsImpl.prototype.getKind = function () {
		        return "PassThroughSecuritySchemeSettings";
		    };
		    PassThroughSecuritySchemeSettingsImpl.prototype.queryParameterName = function () {
		        return _super.prototype.attribute.call(this, 'queryParameterName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set queryParameterName value
		     **/
		    PassThroughSecuritySchemeSettingsImpl.prototype.setQueryParameterName = function (param) {
		        this.highLevel().attrOrCreate("queryParameterName").setValue("" + param);
		        return this;
		    };
		    PassThroughSecuritySchemeSettingsImpl.prototype.headerName = function () {
		        return _super.prototype.attribute.call(this, 'headerName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set headerName value
		     **/
		    PassThroughSecuritySchemeSettingsImpl.prototype.setHeaderName = function (param) {
		        this.highLevel().attrOrCreate("headerName").setValue("" + param);
		        return this;
		    };
		    return PassThroughSecuritySchemeSettingsImpl;
		})(SecuritySchemeSettingsImpl);
		exports.PassThroughSecuritySchemeSettingsImpl = PassThroughSecuritySchemeSettingsImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var OAuth2SecuritySchemeImpl = (function (_super) {
		    __extends(OAuth2SecuritySchemeImpl, _super);
		    function OAuth2SecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OAuth2SecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "OAuth2SecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OAuth2SecuritySchemeImpl.prototype.getKind = function () {
		        return "OAuth2SecurityScheme";
		    };
		    OAuth2SecuritySchemeImpl.prototype.settings = function () {
		        return _super.prototype.element.call(this, 'settings');
		    };
		    return OAuth2SecuritySchemeImpl;
		})(AbstractSecuritySchemeImpl);
		exports.OAuth2SecuritySchemeImpl = OAuth2SecuritySchemeImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var OAuth1SecuritySchemeImpl = (function (_super) {
		    __extends(OAuth1SecuritySchemeImpl, _super);
		    function OAuth1SecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OAuth1SecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "OAuth1SecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OAuth1SecuritySchemeImpl.prototype.getKind = function () {
		        return "OAuth1SecurityScheme";
		    };
		    OAuth1SecuritySchemeImpl.prototype.settings = function () {
		        return _super.prototype.element.call(this, 'settings');
		    };
		    return OAuth1SecuritySchemeImpl;
		})(AbstractSecuritySchemeImpl);
		exports.OAuth1SecuritySchemeImpl = OAuth1SecuritySchemeImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var PassThroughSecuritySchemeImpl = (function (_super) {
		    __extends(PassThroughSecuritySchemeImpl, _super);
		    function PassThroughSecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createPassThroughSecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    PassThroughSecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "PassThroughSecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    PassThroughSecuritySchemeImpl.prototype.getKind = function () {
		        return "PassThroughSecurityScheme";
		    };
		    PassThroughSecuritySchemeImpl.prototype.settings = function () {
		        return _super.prototype.element.call(this, 'settings');
		    };
		    return PassThroughSecuritySchemeImpl;
		})(AbstractSecuritySchemeImpl);
		exports.PassThroughSecuritySchemeImpl = PassThroughSecuritySchemeImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var BasicSecuritySchemeImpl = (function (_super) {
		    __extends(BasicSecuritySchemeImpl, _super);
		    function BasicSecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createBasicSecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    BasicSecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "BasicSecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    BasicSecuritySchemeImpl.prototype.getKind = function () {
		        return "BasicSecurityScheme";
		    };
		    return BasicSecuritySchemeImpl;
		})(AbstractSecuritySchemeImpl);
		exports.BasicSecuritySchemeImpl = BasicSecuritySchemeImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var DigestSecuritySchemeImpl = (function (_super) {
		    __extends(DigestSecuritySchemeImpl, _super);
		    function DigestSecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createDigestSecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DigestSecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "DigestSecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DigestSecuritySchemeImpl.prototype.getKind = function () {
		        return "DigestSecurityScheme";
		    };
		    return DigestSecuritySchemeImpl;
		})(AbstractSecuritySchemeImpl);
		exports.DigestSecuritySchemeImpl = DigestSecuritySchemeImpl;
		/**
		 * Declares globally referable security schema definition
		 **/
		var CustomSecuritySchemeImpl = (function (_super) {
		    __extends(CustomSecuritySchemeImpl, _super);
		    function CustomSecuritySchemeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createCustomSecurityScheme(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    CustomSecuritySchemeImpl.prototype.wrapperClassName = function () {
		        return "CustomSecuritySchemeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    CustomSecuritySchemeImpl.prototype.getKind = function () {
		        return "CustomSecurityScheme";
		    };
		    return CustomSecuritySchemeImpl;
		})(AbstractSecuritySchemeImpl);
		exports.CustomSecuritySchemeImpl = CustomSecuritySchemeImpl;
		var ResourceBaseImpl = (function (_super) {
		    __extends(ResourceBaseImpl, _super);
		    function ResourceBaseImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResourceBase(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceBaseImpl.prototype.wrapperClassName = function () {
		        return "ResourceBaseImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceBaseImpl.prototype.getKind = function () {
		        return "ResourceBase";
		    };
		    /**
		     * Methods that are part of this resource type definition
		     **/
		    ResourceBaseImpl.prototype.methods = function () {
		        return _super.prototype.elements.call(this, 'methods');
		    };
		    /**
		     * A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section. Individual methods may override this declaration
		     **/
		    ResourceBaseImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * The resource type which this resource inherits. . See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section.
		     **/
		    ResourceBaseImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
		    };
		    /**
		     * The security schemes that apply to all methods declared (implicitly or explicitly) for this resource.
		     **/
		    ResourceBaseImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
		    };
		    /**
		     * Detailed information about any URI parameters of this resource
		     **/
		    ResourceBaseImpl.prototype.uriParameters = function () {
		        return _super.prototype.elements.call(this, 'uriParameters');
		    };
		    return ResourceBaseImpl;
		})(RAMLLanguageElementImpl);
		exports.ResourceBaseImpl = ResourceBaseImpl;
		var ResourceTypeImpl = (function (_super) {
		    __extends(ResourceTypeImpl, _super);
		    function ResourceTypeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceTypeImpl.prototype.wrapperClassName = function () {
		        return "ResourceTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceTypeImpl.prototype.getKind = function () {
		        return "ResourceType";
		    };
		    /**
		     * Name of the resource type
		     **/
		    ResourceTypeImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    ResourceTypeImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    ResourceTypeImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    ResourceTypeImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    /**
		     * You may import library locally here it contents is accessible only inside of this resource type
		     **/
		    ResourceTypeImpl.prototype.uses = function () {
		        return _super.prototype.elements.call(this, 'uses');
		    };
		    return ResourceTypeImpl;
		})(ResourceBaseImpl);
		exports.ResourceTypeImpl = ResourceTypeImpl;
		var ResourceImpl = (function (_super) {
		    __extends(ResourceImpl, _super);
		    function ResourceImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceImpl.prototype.wrapperClassName = function () {
		        return "ResourceImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceImpl.prototype.getKind = function () {
		        return "Resource";
		    };
		    ResourceImpl.prototype.signature = function () {
		        return _super.prototype.attribute.call(this, 'signature', function (attr) { return new SchemaStringImpl(attr); });
		    };
		    /**
		     * Relative URL of this resource from the parent resource
		     **/
		    ResourceImpl.prototype.relativeUri = function () {
		        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriStringImpl(attr); });
		    };
		    /**
		     * A nested resource is identified as any property whose name begins with a slash ("/") and is therefore treated as a relative URI.
		     **/
		    ResourceImpl.prototype.resources = function () {
		        return _super.prototype.elements.call(this, 'resources');
		    };
		    /**
		     * An alternate, human-friendly name for the resource.
		     **/
		    ResourceImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    ResourceImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the resource.
		     **/
		    ResourceImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    ResourceImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    /**
		     * Path relative to API root
		     **/
		    ResourceImpl.prototype.completeRelativeUri = function () {
		        return helper.completeRelativeUri(this);
		    };
		    /**
		     * baseUri of owning Api concatenated with completeRelativeUri
		     **/
		    ResourceImpl.prototype.absoluteUri = function () {
		        return helper.absoluteUri(this);
		    };
		    /**
		     * Parent resource for non top level resources
		     **/
		    ResourceImpl.prototype.parentResource = function () {
		        return helper.parent(this);
		    };
		    /**
		     * Get child resource by its relative path
		     **/
		    ResourceImpl.prototype.getChildResource = function (relPath) {
		        return helper.getChildResource(this, relPath);
		    };
		    /**
		     * Get child method by its name
		     **/
		    ResourceImpl.prototype.getChildMethod = function (method) {
		        return helper.getChildMethod(this, method);
		    };
		    /**
		     * Api owning the resource as a sibling
		     **/
		    ResourceImpl.prototype.ownerApi = function () {
		        return helper.ownerApi(this);
		    };
		    /**
		     * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
		     * Consider a fragment of RAML specification:
		     * ```yaml
		     * /resource/{objectId}/{propertyId}:
		     * uriParameters:
		     * objectId:
		     * ```
		     * Here `propertyId` uri parameter is not described in the `uriParameters` node.
		     * Thus, it is not among Resource.uriParameters(), but it is among Resource.allUriParameters().
		     **/
		    ResourceImpl.prototype.allUriParameters = function () {
		        return helper.uriParameters(this);
		    };
		    /**
		     * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.allBaseUriParameters()`
		     * for `Api` owning the `Resource` and `Resource.allUriParameters()`.
		     **/
		    ResourceImpl.prototype.absoluteUriParameters = function () {
		        return helper.absoluteUriParameters(this);
		    };
		    return ResourceImpl;
		})(ResourceBaseImpl);
		exports.ResourceImpl = ResourceImpl;
		var AnnotationTypeDeclarationImpl = (function (_super) {
		    __extends(AnnotationTypeDeclarationImpl, _super);
		    function AnnotationTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createAnnotationTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    AnnotationTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "AnnotationTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    AnnotationTypeDeclarationImpl.prototype.getKind = function () {
		        return "AnnotationTypeDeclaration";
		    };
		    /**
		     * Whether multiple instances of annotations of this type may be applied simultaneously at the same location
		     **/
		    AnnotationTypeDeclarationImpl.prototype.allowMultiple = function () {
		        return _super.prototype.attribute.call(this, 'allowMultiple', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set allowMultiple value
		     **/
		    AnnotationTypeDeclarationImpl.prototype.setAllowMultiple = function (param) {
		        this.highLevel().attrOrCreate("allowMultiple").setValue("" + param);
		        return this;
		    };
		    /**
		     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
		     **/
		    AnnotationTypeDeclarationImpl.prototype.allowedTargets = function () {
		        return _super.prototype.attributes.call(this, 'allowedTargets', function (attr) { return new AnnotationTargetImpl(attr); });
		    };
		    return AnnotationTypeDeclarationImpl;
		})(RAMLLanguageElementImpl);
		exports.AnnotationTypeDeclarationImpl = AnnotationTypeDeclarationImpl;
		var RAMLSimpleElementImpl = (function (_super) {
		    __extends(RAMLSimpleElementImpl, _super);
		    function RAMLSimpleElementImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLSimpleElementImpl.prototype.wrapperClassName = function () {
		        return "RAMLSimpleElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLSimpleElementImpl.prototype.getKind = function () {
		        return "RAMLSimpleElement";
		    };
		    return RAMLSimpleElementImpl;
		})(core.BasicNodeImpl);
		exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
		var ImportDeclarationImpl = (function (_super) {
		    __extends(ImportDeclarationImpl, _super);
		    function ImportDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createImportDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ImportDeclarationImpl.prototype.wrapperClassName = function () {
		        return "ImportDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ImportDeclarationImpl.prototype.getKind = function () {
		        return "ImportDeclaration";
		    };
		    /**
		     * Name prefix (without dot) used to refer imported declarations
		     **/
		    ImportDeclarationImpl.prototype.key = function () {
		        return _super.prototype.attribute.call(this, 'key', this.toString);
		    };
		    /**
		     * @hidden
		     * Set key value
		     **/
		    ImportDeclarationImpl.prototype.setKey = function (param) {
		        this.highLevel().attrOrCreate("key").setValue("" + param);
		        return this;
		    };
		    /**
		     * Content of the declared namespace
		     **/
		    ImportDeclarationImpl.prototype.value = function () {
		        return _super.prototype.element.call(this, 'value');
		    };
		    return ImportDeclarationImpl;
		})(RAMLSimpleElementImpl);
		exports.ImportDeclarationImpl = ImportDeclarationImpl;
		/**
		 * Content of the schema
		 **/
		var GlobalSchemaImpl = (function (_super) {
		    __extends(GlobalSchemaImpl, _super);
		    function GlobalSchemaImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    GlobalSchemaImpl.prototype.wrapperClassName = function () {
		        return "GlobalSchemaImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    GlobalSchemaImpl.prototype.getKind = function () {
		        return "GlobalSchema";
		    };
		    /**
		     * Name of the global schema, used to refer on schema content
		     **/
		    GlobalSchemaImpl.prototype.key = function () {
		        return _super.prototype.attribute.call(this, 'key', this.toString);
		    };
		    /**
		     * @hidden
		     * Set key value
		     **/
		    GlobalSchemaImpl.prototype.setKey = function (param) {
		        this.highLevel().attrOrCreate("key").setValue("" + param);
		        return this;
		    };
		    /**
		     * Content of the schema
		     **/
		    GlobalSchemaImpl.prototype.value = function () {
		        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
		    };
		    return GlobalSchemaImpl;
		})(RAMLSimpleElementImpl);
		exports.GlobalSchemaImpl = GlobalSchemaImpl;
		var ApiImpl = (function (_super) {
		    __extends(ApiImpl, _super);
		    function ApiImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ApiImpl.prototype.wrapperClassName = function () {
		        return "ApiImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ApiImpl.prototype.getKind = function () {
		        return "Api";
		    };
		    /**
		     * Short plain-text label for the API
		     **/
		    ApiImpl.prototype.title = function () {
		        return _super.prototype.attribute.call(this, 'title', this.toString);
		    };
		    /**
		     * @hidden
		     * Set title value
		     **/
		    ApiImpl.prototype.setTitle = function (param) {
		        this.highLevel().attrOrCreate("title").setValue("" + param);
		        return this;
		    };
		    /**
		     * The version of the API, e.g. "v1"
		     **/
		    ApiImpl.prototype.version = function () {
		        return _super.prototype.attribute.call(this, 'version', this.toString);
		    };
		    /**
		     * @hidden
		     * Set version value
		     **/
		    ApiImpl.prototype.setVersion = function (param) {
		        this.highLevel().attrOrCreate("version").setValue("" + param);
		        return this;
		    };
		    /**
		     * A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI.
		     **/
		    ApiImpl.prototype.baseUri = function () {
		        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateStringImpl(attr); });
		    };
		    /**
		     * Named parameters used in the baseUri (template)
		     **/
		    ApiImpl.prototype.baseUriParameters = function () {
		        return _super.prototype.elements.call(this, 'baseUriParameters');
		    };
		    /**
		     * The protocols supported by the API
		     **/
		    ApiImpl.prototype.protocols = function () {
		        return _super.prototype.attributes.call(this, 'protocols', this.toString);
		    };
		    /**
		     * @hidden
		     * Set protocols value
		     **/
		    ApiImpl.prototype.setProtocols = function (param) {
		        this.highLevel().attrOrCreate("protocols").setValue("" + param);
		        return this;
		    };
		    /**
		     * The default media type to use for request and response bodies (payloads), e.g. "application/json"
		     **/
		    ApiImpl.prototype.mediaType = function () {
		        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
		    };
		    /**
		     * The security schemes that apply to every resource and method in the API
		     **/
		    ApiImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemeRefImpl(attr); });
		    };
		    /**
		     * The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc
		     **/
		    ApiImpl.prototype.resources = function () {
		        return _super.prototype.elements.call(this, 'resources');
		    };
		    /**
		     * Additional overall documentation for the API
		     **/
		    ApiImpl.prototype.documentation = function () {
		        return _super.prototype.elements.call(this, 'documentation');
		    };
		    /**
		     * The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
		     **/
		    ApiImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    ApiImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    ApiImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    ApiImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * A longer, human-friendly description of the API
		     **/
		    ApiImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
		     **/
		    ApiImpl.prototype.annotations = function () {
		        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
		    };
		    /**
		     * Security schemas types declarations
		     **/
		    ApiImpl.prototype.securitySchemaTypes = function () {
		        return _super.prototype.elements.call(this, 'securitySchemaTypes');
		    };
		    /**
		     * Equivalent API with traits and resource types expanded
		     **/
		    ApiImpl.prototype.expand = function () {
		        return helper.expandTraitsAndResourceTypes(this);
		    };
		    /**
		     * Retrieve all traits including those defined in libraries
		     **/
		    ApiImpl.prototype.allTraits = function () {
		        return helper.allTraits(this);
		    };
		    /**
		     * Retrieve all resource types including those defined in libraries
		     **/
		    ApiImpl.prototype.allResourceTypes = function () {
		        return helper.allResourceTypes(this);
		    };
		    /**
		     * Get child resource by its relative path
		     **/
		    ApiImpl.prototype.getChildResource = function (relPath) {
		        return helper.getChildResource(this, relPath);
		    };
		    /**
		     * Retrieve all resources of the Api
		     **/
		    ApiImpl.prototype.allResources = function () {
		        return helper.allResources(this);
		    };
		    /**
		     * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
		     * Consider a fragment of RAML specification:
		     * ```yaml
		     * version: v1
		     * baseUri: https://{organization}.example.com/{version}/{service}
		     * baseUriParameters:
		     * service:
		     * ```
		     * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node.
		     * Thus, they are not among `Api.baseUriParameters()`, but they are among `Api.allBaseUriParameters()`.
		     **/
		    ApiImpl.prototype.allBaseUriParameters = function () {
		        return helper.baseUriParameters(this);
		    };
		    /**
		     * Protocols used by the API. Returns the `protocols` property value if it is specified.
		     * Otherwise, returns protocol, specified in the base URI.
		     **/
		    ApiImpl.prototype.allProtocols = function () {
		        return helper.allProtocols(this);
		    };
		    return ApiImpl;
		})(LibraryBaseImpl);
		exports.ApiImpl = ApiImpl;
		var OverlayImpl = (function (_super) {
		    __extends(OverlayImpl, _super);
		    function OverlayImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOverlay(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OverlayImpl.prototype.wrapperClassName = function () {
		        return "OverlayImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OverlayImpl.prototype.getKind = function () {
		        return "Overlay";
		    };
		    /**
		     * contains description of why overlay exist
		     **/
		    OverlayImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    OverlayImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    OverlayImpl.prototype.masterRef = function () {
		        return _super.prototype.attribute.call(this, 'masterRef', this.toString);
		    };
		    /**
		     * @hidden
		     * Set masterRef value
		     **/
		    OverlayImpl.prototype.setMasterRef = function (param) {
		        this.highLevel().attrOrCreate("masterRef").setValue("" + param);
		        return this;
		    };
		    /**
		     * Short plain-text label for the API
		     **/
		    OverlayImpl.prototype.title = function () {
		        return _super.prototype.attribute.call(this, 'title', this.toString);
		    };
		    /**
		     * @hidden
		     * Set title value
		     **/
		    OverlayImpl.prototype.setTitle = function (param) {
		        this.highLevel().attrOrCreate("title").setValue("" + param);
		        return this;
		    };
		    return OverlayImpl;
		})(ApiImpl);
		exports.OverlayImpl = OverlayImpl;
		var ExtensionImpl = (function (_super) {
		    __extends(ExtensionImpl, _super);
		    function ExtensionImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createExtension(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ExtensionImpl.prototype.wrapperClassName = function () {
		        return "ExtensionImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ExtensionImpl.prototype.getKind = function () {
		        return "Extension";
		    };
		    /**
		     * contains description of why extension exist
		     **/
		    ExtensionImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    ExtensionImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    ExtensionImpl.prototype.masterRef = function () {
		        return _super.prototype.attribute.call(this, 'masterRef', this.toString);
		    };
		    /**
		     * @hidden
		     * Set masterRef value
		     **/
		    ExtensionImpl.prototype.setMasterRef = function (param) {
		        this.highLevel().attrOrCreate("masterRef").setValue("" + param);
		        return this;
		    };
		    /**
		     * Short plain-text label for the API
		     **/
		    ExtensionImpl.prototype.title = function () {
		        return _super.prototype.attribute.call(this, 'title', this.toString);
		    };
		    /**
		     * @hidden
		     * Set title value
		     **/
		    ExtensionImpl.prototype.setTitle = function (param) {
		        this.highLevel().attrOrCreate("title").setValue("" + param);
		        return this;
		    };
		    return ExtensionImpl;
		})(ApiImpl);
		exports.ExtensionImpl = ExtensionImpl;
		/**
		 * @hidden
		 **/
		function createApi(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Api");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createLibraryBase(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("LibraryBase");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLLanguageElement(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("RAMLLanguageElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createDocumentationItem(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("DocumentationItem");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createScriptSpec(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ScriptSpec");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createApiDescription(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ApiDescription");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createCallbackAPIDescription(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("CallbackAPIDescription");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLProject(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("RAMLProject");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSecuritySchemaType(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("SecuritySchemaType");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("TypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createExampleSpec(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ExampleSpec");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createFileTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("FileTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createArrayTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ArrayTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createUnionTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("UnionTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createObjectTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ObjectTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createStringTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("StringTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createBooleanTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("BooleanTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createValueTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ValueTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createNumberTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("NumberTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createIntegerTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("IntegerTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLPointerElement(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("RAMLPointerElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLExpression(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("RAMLExpression");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createScriptHookElement(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ScriptHookElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSchemaElement(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("SchemaElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createDateTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("DateTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSecuritySchemePart(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("SecuritySchemePart");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createMethodBase(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("MethodBase");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createHasNormalParameters(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("HasNormalParameters");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResponse(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Response");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createTrait(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Trait");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createLibrary(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Library");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createMethod(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Method");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createAbstractSecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("AbstractSecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSecuritySchemeSettings(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("SecuritySchemeSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOAuth1SecuritySchemeSettings(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("OAuth1SecuritySchemeSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOAuth2SecuritySchemeSettings(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("OAuth2SecuritySchemeSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createPassThroughSecuritySchemeSettings(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("PassThroughSecuritySchemeSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOAuth2SecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("OAuth2SecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOAuth1SecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("OAuth1SecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createPassThroughSecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("PassThroughSecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createBasicSecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("BasicSecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createDigestSecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("DigestSecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createCustomSecurityScheme(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("CustomSecurityScheme");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResourceBase(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ResourceBase");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResourceType(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ResourceType");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResource(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Resource");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createAnnotationTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("AnnotationTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createGlobalSchema(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("GlobalSchema");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLSimpleElement(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("RAMLSimpleElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createImportDeclaration(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("ImportDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOverlay(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Overlay");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createExtension(key) {
		    var universe = hl.universeProvider("RAML10");
		    var nc = universe.type("Extension");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		function loadApiSync(apiPath, arg1, arg2) {
		    return apiLoader.loadApi(apiPath, arg1, arg2).getOrElse(null);
		}
		exports.loadApiSync = loadApiSync;
		function loadApi(apiPath, arg1, arg2) {
		    return apiLoader.loadApiAsync(apiPath, arg1, arg2);
		}
		exports.loadApi = loadApi;


	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var ds = __webpack_require__(3);
		var universes = __webpack_require__(54);
		(function (NodeKind) {
		    NodeKind[NodeKind["BASIC"] = 0] = "BASIC";
		    NodeKind[NodeKind["NODE"] = 1] = "NODE";
		    NodeKind[NodeKind["ATTRIBUTE"] = 2] = "ATTRIBUTE";
		})(exports.NodeKind || (exports.NodeKind = {}));
		var NodeKind = exports.NodeKind;
		(function (IssueCode) {
		    IssueCode[IssueCode["UNRESOLVED_REFERENCE"] = 0] = "UNRESOLVED_REFERENCE";
		    IssueCode[IssueCode["YAML_ERROR"] = 1] = "YAML_ERROR";
		    IssueCode[IssueCode["UNKNOWN_NODE"] = 2] = "UNKNOWN_NODE";
		    IssueCode[IssueCode["MISSING_REQUIRED_PROPERTY"] = 3] = "MISSING_REQUIRED_PROPERTY";
		    IssueCode[IssueCode["PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE"] = 4] = "PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE";
		    //TODO IMPLEMENT
		    IssueCode[IssueCode["KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT"] = 5] = "KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT";
		    IssueCode[IssueCode["UNABLE_TO_RESOLVE_INCLUDE_FILE"] = 6] = "UNABLE_TO_RESOLVE_INCLUDE_FILE";
		    IssueCode[IssueCode["INVALID_VALUE_SCHEMA"] = 7] = "INVALID_VALUE_SCHEMA";
		    IssueCode[IssueCode["MISSED_CONTEXT_REQUIREMENT"] = 8] = "MISSED_CONTEXT_REQUIREMENT";
		    IssueCode[IssueCode["NODE_HAS_VALUE"] = 9] = "NODE_HAS_VALUE";
		    IssueCode[IssueCode["ONLY_OVERRIDE_ALLOWED"] = 10] = "ONLY_OVERRIDE_ALLOWED";
		})(exports.IssueCode || (exports.IssueCode = {}));
		var IssueCode = exports.IssueCode;
		;
		var Problem = (function () {
		    function Problem() {
		        this.code = 0;
		    }
		    Problem.prototype.isOk = function () {
		        return this.code == 0;
		    };
		    return Problem;
		})();
		exports.Problem = Problem;
		function ast2Object(node) {
		    var result = {};
		    node.attrs().forEach(function (x) {
		        result[x.property().nameId()] = x.value();
		    });
		    node.elements().forEach(function (x) {
		        var m = result[x.property().nameId()];
		        if (Array.isArray(m)) {
		            m.push(ast2Object(x));
		        }
		        result[x.property().nameId()] = x.property().isMultiValue() ? [ast2Object(x)] : ast2Object(x);
		    });
		    return result;
		}
		exports.ast2Object = ast2Object;
		exports.universeProvider = __webpack_require__(77);
		var hlImpl = __webpack_require__(5);
		exports.getDefinitionSystemType = function (contents, ast) {
		    var spec = "";
		    var ptype = "Api";
		    var num = 0;
		    var pt = 0;
		    for (var n = 0; n < contents.length; n++) {
		        var c = contents.charAt(n);
		        if (c == '\r' || c == '\n') {
		            if (spec) {
		                ptype = contents.substring(pt, n).trim();
		            }
		            else {
		                spec = contents.substring(0, n).trim();
		            }
		            break;
		        }
		        if (c == ' ') {
		            num++;
		            if (!spec && num == 2) {
		                spec = contents.substring(0, n);
		                pt = n;
		            }
		        }
		    }
		    var localUniverse = spec == "#%RAML 1.0" ? new ds.Universe("RAML10", exports.universeProvider("RAML10"), "RAML10") : new ds.Universe("RAML08", exports.universeProvider("RAML08"));
		    if (ptype == 'API') {
		        ptype = "Api";
		    }
		    if (ptype == 'NamedExample') {
		        ptype = "ExampleSpec";
		    }
		    if (ptype == 'DataType') {
		        ptype = "TypeDeclaration";
		    }
		    if (ptype == 'SecurityScheme') {
		        ptype = "AbstractSecurityScheme";
		    }
		    localUniverse.setTopLevel(ptype);
		    localUniverse.setTypedVersion(spec);
		    // localUniverse.setDescription(spec);
		    return { ptype: ptype, localUniverse: localUniverse };
		};
		function fromUnit(l) {
		    if (l == null)
		        return null;
		    var contents = l.contents();
		    var ast = l.ast();
		    var __ret = exports.getDefinitionSystemType(contents, ast);
		    var ptype = __ret.ptype;
		    var localUniverse = __ret.localUniverse;
		    var apiType = localUniverse.type(ptype);
		    if (!apiType)
		        apiType = localUniverse.type("Api");
		    var api = new hlImpl.ASTNodeImpl(ast, null, apiType, null);
		    api.setUniverse(localUniverse);
		    return api;
		}
		exports.fromUnit = fromUnit;
		function globalId(h) {
		    if (h.parent()) {
		        return globalId(h.parent()) + "/" + h.localId();
		    }
		}
		exports.globalId = globalId;
		function nodeAtPosition(h, position) {
		    var ch = h.children();
		    var len = ch.length;
		    var res = null;
		    for (var num = 0; num < len; num++) {
		        var cn = ch[num];
		        if (cn.lowLevel().start() > position) {
		            break;
		        }
		        if (cn.lowLevel().end() < position) {
		            continue;
		        }
		        var nm = nodeAtPosition(cn, position);
		        if (nm != null) {
		            return nm;
		        }
		        return cn;
		    }
		}
		exports.nodeAtPosition = nodeAtPosition;
		/**
		 * Shortcut for checking node type
		 * @param node
		 */
		function kindBasic(node) {
		    return node.getKind() == 0 /* BASIC */;
		}
		exports.kindBasic = kindBasic;
		/**
		 * Shortcut for checking node type
		 * @param node
		 */
		function kindAttribute(node) {
		    return node.getKind() == 2 /* ATTRIBUTE */;
		}
		exports.kindAttribute = kindAttribute;
		/**
		 * Shortcut for checking node type
		 * @param node
		 */
		function kindNode(node) {
		    return node.getKind() == 1 /* NODE */;
		}
		exports.kindNode = kindNode;
		function isResourceNode(node) {
		    return kindNode(node) && node.definition && (node.definition().key() == universes.Universe08.Resource || node.definition().key() == universes.Universe10.Resource);
		}
		exports.isResourceNode = isResourceNode;
		function isResourceWithSignature(node) {
		    if (!isResourceNode(node)) {
		        return false;
		    }
		    var hNode = node;
		    var uriAttribute = hNode.attr(universes.Universe10.Resource.properties.relativeUri.name);
		    if (uriAttribute && uriAttribute.value() && typeof uriAttribute.value() == "string" && uriAttribute.value().indexOf(".") >= 0) {
		        var signature = hNode.attrValue(universes.Universe10.Resource.properties.signature.name);
		        if (!signature)
		            return false;
		        if (typeof signature == "string" && signature.length == 0)
		            return false;
		        return true;
		    }
		    return false;
		}
		exports.isResourceWithSignature = isResourceWithSignature;
		function isRAML10(node) {
		    var text = node.lowLevel().unit().contents();
		    return text.indexOf("#%RAML 1.0") >= 0;
		}
		exports.isRAML10 = isRAML10;
		function isRAML08(node) {
		    var text = node.lowLevel().unit().contents();
		    return text.indexOf("#%RAML 0.8") >= 0;
		}
		exports.isRAML08 = isRAML08;
		/**
		 * Shortcut for checking node type and getting it as attribute
		 * Returns null for non-attributes
		 * @param node
		 */
		function asAttribute(node) {
		    if (!node.getKind) {
		        return null;
		    }
		    if (node.getKind() != 2 /* ATTRIBUTE */) {
		        return null;
		    }
		    return node;
		}
		exports.asAttribute = asAttribute;
		/**
		 * Shortcut for checking node type
		 * @param node
		 */
		function asNode(node) {
		    if (!node.getKind) {
		        return null;
		    }
		    if (node.getKind() != 1 /* NODE */) {
		        return null;
		    }
		    return node;
		}
		exports.asNode = asNode;
		/**
		 * Checks if specified node is library
		 * @param node
		 * @returns {IHighLevelNode|boolean}
		 */
		function isLibrary(node) {
		    return asNode(node) && asNode(node).definition().key() == universes.Universe10.Library;
		}
		exports.isLibrary = isLibrary;
		/**
		 * Check is specified node is library and returns library name. Returns null otherwise.
		 * @param node
		 * @returns {any}
		 */
		function getLibraryName(node) {
		    if (!isLibrary(node)) {
		        return null;
		    }
		    return asNode(node).attrValue("name");
		}
		exports.getLibraryName = getLibraryName;


	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var _ = __webpack_require__(4);
		var hlimpl = __webpack_require__(5);
		var selector = __webpack_require__(124);
		var universes = __webpack_require__(54);
		var typeSystem = __webpack_require__(63);
		var ramlServices = __webpack_require__(49);
		function registerAdapters(a) {
		    if (a instanceof typeSystem.AbstractType) {
		        a.addAdapter(new ramlServices.RAMLService(a));
		    }
		    if (a instanceof typeSystem.Property) {
		        a.addAdapter(new ramlServices.RAMLPropertyService(a));
		    }
		}
		var injector = {
		    inject: function (a) {
		        registerAdapters(a);
		    }
		};
		typeSystem.registerInjector(injector);
		var Annotation = (function () {
		    function Annotation(_name) {
		        this._name = _name;
		    }
		    Annotation.prototype.name = function () {
		        return this._name;
		    };
		    return Annotation;
		})();
		exports.Annotation = Annotation;
		var ValueRequirement = (function () {
		    function ValueRequirement(name, value) {
		        this.name = name;
		        this.value = value;
		    }
		    return ValueRequirement;
		})();
		exports.ValueRequirement = ValueRequirement;
		var AbstractType = (function (_super) {
		    __extends(AbstractType, _super);
		    function AbstractType() {
		        _super.apply(this, arguments);
		    }
		    return AbstractType;
		})(typeSystem.AbstractType);
		exports.AbstractType = AbstractType;
		var ValueType = (function (_super) {
		    __extends(ValueType, _super);
		    function ValueType() {
		        _super.apply(this, arguments);
		    }
		    return ValueType;
		})(typeSystem.ValueType);
		exports.ValueType = ValueType;
		var EnumType = (function (_super) {
		    __extends(EnumType, _super);
		    function EnumType() {
		        _super.apply(this, arguments);
		        this.values = [];
		    }
		    return EnumType;
		})(ValueType);
		exports.EnumType = EnumType;
		var ReferenceType = (function (_super) {
		    __extends(ReferenceType, _super);
		    function ReferenceType(name, path, referenceTo, _universe) {
		        _super.call(this, name, _universe, path);
		        this.referenceTo = referenceTo;
		    }
		    ReferenceType.prototype.getReferencedType = function () {
		        return this.universe().type(this.referenceTo);
		    };
		    ReferenceType.prototype.hasStructure = function () {
		        var rt = this.getReferencedType();
		        if (rt) {
		            if (rt.key() == universes.Universe10.AnnotationTypeDeclaration) {
		                return true;
		            }
		            return rt.getAdapter(ramlServices.RAMLService).isInlinedTemplates() || (rt.getAdapter(ramlServices.RAMLService).findMembersDeterminer() != null) || rt.key() == universes.Universe08.SecuritySchema || rt.key() === universes.Universe10.AbstractSecurityScheme; //FIXME
		        }
		        else {
		            return false;
		        }
		    };
		    return ReferenceType;
		})(ValueType);
		exports.ReferenceType = ReferenceType;
		var NodeClass = (function (_super) {
		    __extends(NodeClass, _super);
		    function NodeClass(_name, universe, path, _description) {
		        if (_description === void 0) { _description = ""; }
		        _super.call(this, _name, universe, path);
		    }
		    NodeClass.prototype.isUserDefined = function () {
		        return false;
		    };
		    NodeClass.prototype.getRepresentationOf = function () {
		        return this.getAdapter(ramlServices.RAMLService).getRepresentationOf();
		    };
		    NodeClass.prototype.allProperties = function (v) {
		        if (v === void 0) { v = {}; }
		        return _super.prototype.allProperties.call(this, v);
		    };
		    return NodeClass;
		})(typeSystem.StructuredType);
		exports.NodeClass = NodeClass;
		var UserDefinedClass = (function (_super) {
		    __extends(UserDefinedClass, _super);
		    function UserDefinedClass(name, universe, hl, path, description) {
		        _super.call(this, name, universe, path, description);
		        this.getAdapter(ramlServices.RAMLService).setDeclaringNode(hl);
		    }
		    UserDefinedClass.prototype.key = function () {
		        return null;
		    };
		    UserDefinedClass.prototype.isUserDefined = function () {
		        return true;
		    };
		    UserDefinedClass.prototype.contributeFacets = function (x) {
		        this.findFacets(this.getAdapter(ramlServices.RAMLService).getDeclaringNode(), x);
		    };
		    UserDefinedClass.prototype.findFacets = function (node, x) {
		        if (node) {
		            var chd = node.lowLevel().children();
		            var mi = _.find(chd, function (x) { return x.key() == "minProperties"; });
		            if (mi) {
		                x[mi.key()] = mi;
		            }
		            var mi = _.find(chd, function (x) { return x.key() == "maxProperties"; });
		            if (mi) {
		                x[mi.key()] = mi;
		            }
		        }
		    };
		    UserDefinedClass.prototype.typeId = function () {
		        var rs = this.nameId();
		        var node = this.getAdapter(ramlServices.RAMLService).getDeclaringNode();
		        if (node) {
		            rs = rs + node.lowLevel().start() + node.lowLevel().unit().absolutePath();
		        }
		        return rs;
		    };
		    UserDefinedClass.prototype.isValueType = function () {
		        if (this._value) {
		            return true;
		        }
		        if (this.isAssignableFrom("ObjectTypeDeclaration")) {
		            return false;
		        }
		        return false;
		    };
		    return UserDefinedClass;
		})(NodeClass);
		exports.UserDefinedClass = UserDefinedClass;
		var AnnotationType = (function (_super) {
		    __extends(AnnotationType, _super);
		    function AnnotationType() {
		        _super.apply(this, arguments);
		    }
		    AnnotationType.prototype.allProperties = function (ps) {
		        if (ps === void 0) { ps = {}; }
		        var rs = this.superTypes()[0].allProperties();
		        if (rs.length == 0) {
		            var up = new UserDefinedProp("value");
		            up.withDomain(this);
		            up._node = this.getAdapter(ramlServices.RAMLService).getDeclaringNode();
		            up.withCanBeValue();
		            up.withRequired(false);
		            var tp = this.superTypes()[0];
		            rs = [];
		            up.withRange(tp.getAdapter(ramlServices.RAMLService).getRepresentationOf().getAdapter(ramlServices.RAMLService).toRuntime());
		            rs.push(up);
		        }
		        return rs;
		    };
		    AnnotationType.prototype.getKey = function (n) {
		        var up = new UserDefinedProp("name");
		        //up.withDomain(this);
		        up.withRange(this.universe().type(universes.Universe10.StringType.name));
		        up.withFromParentKey(true);
		        var node = this.getAdapter(ramlServices.RAMLService).getDeclaringNode();
		        //node:ll.ILowLevelASTNode, parent:hl.IHighLevelNode, private _def:hl.IValueTypeDefinition, private _prop:hl.IProperty, private fromKey:boolean = false
		        return new hlimpl.ASTPropImpl(n, node, up.range(), up, true);
		        //rs.push(up);
		    };
		    AnnotationType.prototype.isAnnotationType = function () {
		        return true;
		    };
		    return AnnotationType;
		})(UserDefinedClass);
		exports.AnnotationType = AnnotationType;
		var Universe = (function (_super) {
		    __extends(Universe, _super);
		    function Universe(name, _parent, v) {
		        if (name === void 0) { name = ""; }
		        if (_parent === void 0) { _parent = null; }
		        if (v === void 0) { v = "RAML08"; }
		        _super.call(this, name);
		        this._parent = _parent;
		        this._classes = [];
		        this._uversion = "RAML08";
		        this.aMap = {};
		        this._uversion = v;
		    }
		    Universe.prototype.matched = function () {
		        if (this.matchedObjects) {
		            return this.matchedObjects;
		        }
		        if (this._parent) {
		            return this._parent.matched();
		        }
		        if (this._uversion == "RAML08") {
		            this.matchedObjects = universes.Universe08;
		            return this.matchedObjects;
		        }
		        else {
		            this.matchedObjects = universes.Universe10;
		            return this.matchedObjects;
		        }
		    };
		    Universe.prototype.setTopLevel = function (t) {
		        this._topLevel = t;
		    };
		    Universe.prototype.getTopLevel = function () {
		        return this._topLevel;
		    };
		    Universe.prototype.setTypedVersion = function (tv) {
		        this._typedVersion = tv;
		    };
		    Universe.prototype.getTypedVersion = function () {
		        return this._typedVersion;
		    };
		    Universe.prototype.version = function () {
		        return this._uversion;
		    };
		    Universe.prototype.setUniverseVersion = function (version) {
		        this._uversion = version;
		    };
		    Universe.prototype.types = function () {
		        var result = [].concat(this._classes);
		        if (this._parent != null) {
		            result = result.concat(this._parent.types());
		        }
		        return result;
		    };
		    Universe.prototype.type = function (name) {
		        if (this.aMap[name]) {
		            return this.aMap[name];
		        }
		        var tp = _.find(this._classes, function (x) { return x.nameId() == name; });
		        if (tp == null) {
		            if (this._parent) {
		                var tp = this._parent.type(name);
		                if (tp instanceof AbstractType) {
		                    var at = tp;
		                    at._universe = this; //FIXME
		                }
		            }
		        }
		        return tp;
		    };
		    Universe.prototype.register = function (t) {
		        this._classes.push(t);
		        if (t instanceof NodeClass) {
		            this._classes.forEach(function (x) {
		                if (x instanceof NodeClass) {
		                    var nc = x;
		                    if (nc.getAdapter(ramlServices.RAMLService).getExtendedType() == t) {
		                        t.getAdapter(ramlServices.RAMLService).getRuntimeExtenders().push(x);
		                    }
		                }
		            });
		        }
		        return this;
		    };
		    Universe.prototype.registerAlias = function (a, t) {
		        this.aMap[a] = t;
		    };
		    Universe.prototype.unregister = function (t) {
		        this._classes = this._classes.filter(function (x) { return x != t; });
		        var st = t.superTypes();
		        st.forEach(function (x) {
		            var a = x;
		            a._superTypes = a._superTypes.filter(function (x) { return x != t; });
		        });
		        st = t.subTypes();
		        st.forEach(function (x) {
		            var a = x;
		            a._subTypes = a._subTypes.filter(function (x) { return x != t; });
		        });
		        return this;
		    };
		    Universe.prototype.registerSuperClass = function (t0, t1) {
		        var a0 = t0;
		        var a1 = t1;
		        a0._superTypes.push(t1);
		        a1._subTypes.push(t0);
		    };
		    return Universe;
		})(typeSystem.Described);
		exports.Universe = Universe;
		function prop(name, desc, domain, range) {
		    var prop = new Property(name, desc);
		    return prop.withDomain(domain).withRange(range);
		}
		exports.prop = prop;
		var ChildValueConstraint = (function () {
		    function ChildValueConstraint(name, value) {
		        this.name = name;
		        this.value = value;
		    }
		    return ChildValueConstraint;
		})();
		exports.ChildValueConstraint = ChildValueConstraint;
		var Property = (function (_super) {
		    __extends(Property, _super);
		    function Property() {
		        _super.apply(this, arguments);
		        this._isFromParentValue = false;
		        this._isFromParentKey = false;
		        this._key = false;
		        this._describes = null;
		        this._selfNode = false;
		        this._noDirectParse = false;
		        this._contextReq = [];
		        this.determinesChildValues = [];
		    }
		    Property.prototype.withNoDirectParse = function () {
		        this._noDirectParse = true;
		    };
		    Property.prototype.isNoDirectParse = function () {
		        return this._noDirectParse;
		    };
		    Property.prototype.withSelfNode = function () {
		        this._selfNode = true;
		    };
		    Property.prototype.isSelfNode = function () {
		        return this._selfNode;
		    };
		    Property.prototype.matchKey = function (k) {
		        if (this._groupName != null) {
		            if (this.isAnnotation()) {
		                if (k.charAt(0) == '(' && k.charAt(k.length - 1) == ')') {
		                    return true;
		                }
		                return false;
		            }
		            return this._groupName == k;
		        }
		        else {
		            return _super.prototype.matchKey.call(this, k);
		        }
		    };
		    Property.prototype.getSelector = function (h) {
		        var sl = this._selector;
		        if (sl instanceof selector.Selector) {
		            return sl;
		        }
		        if (!h) {
		            return null;
		        }
		        if (this._selector) {
		            return selector.parse(h, this._selector);
		        }
		        return null;
		    };
		    Property.prototype.setSelector = function (s) {
		        this._selector = s;
		        return this;
		    };
		    Property.prototype.valueDocProvider = function () {
		        return this._vprovider;
		    };
		    Property.prototype.setValueDocProvider = function (v) {
		        this._vprovider = v;
		        return this;
		    };
		    Property.prototype.suggester = function () {
		        return this._suggester;
		    };
		    Property.prototype.setValueSuggester = function (s) {
		        this._suggester = s;
		    };
		    Property.prototype.enumOptions = function () {
		        if (this._enumOptions && typeof this._enumOptions == 'string') {
		            return [this._enumOptions + ""];
		        }
		        return this._enumOptions;
		    };
		    Property.prototype.getOftenKeys = function () {
		        return this._oftenKeys;
		    };
		    Property.prototype.withOftenKeys = function (keys) {
		        this._oftenKeys = keys;
		        return this;
		    };
		    Property.prototype.withCanBeValue = function () {
		        this._canBeValue = true;
		        return this;
		    };
		    Property.prototype.withInherited = function (w) {
		        this._isInherited = w;
		    };
		    Property.prototype.isInherited = function () {
		        return this._isInherited;
		    };
		    Property.prototype.isAllowNull = function () {
		        return this._allowsNull;
		    };
		    Property.prototype.withAllowNull = function () {
		        this._allowsNull = true;
		    };
		    Property.prototype.getCanBeDuplicator = function () {
		        return this._canBeDuplicator;
		    };
		    Property.prototype.canBeValue = function () {
		        return this._canBeValue;
		    };
		    Property.prototype.setCanBeDuplicator = function () {
		        this._canBeDuplicator = true;
		        return true;
		    };
		    Property.prototype.inheritedContextValue = function () {
		        return this._inheritsValueFromContext;
		    };
		    Property.prototype.withInheritedContextValue = function (v) {
		        this._inheritsValueFromContext = v;
		        return this;
		    };
		    Property.prototype.withContextRequirement = function (name, value) {
		        this._contextReq.push({ name: name, value: value });
		    };
		    Property.prototype.getContextRequirements = function () {
		        return this._contextReq;
		    };
		    Property.prototype.withDescribes = function (a) {
		        this._describes = a;
		        return this;
		    };
		    Property.prototype.describesAnnotation = function () {
		        return this._describes != null;
		    };
		    Property.prototype.describedAnnotation = function () {
		        return this._describes;
		    };
		    Property.prototype.isReference = function () {
		        return this.range() instanceof ReferenceType;
		    };
		    Property.prototype.referencesTo = function () {
		        return this.range().getReferencedType();
		    };
		    Property.prototype.newInstanceName = function () {
		        if (this._newInstanceName) {
		            return this._newInstanceName;
		        }
		        return this.range().nameId();
		    };
		    Property.prototype.withThisPropertyDeclaresFields = function (b) {
		        if (b === void 0) { b = true; }
		        this._declaresFields = b;
		        return this;
		    };
		    Property.prototype.isThisPropertyDeclaresTypeFields = function () {
		        return this._declaresFields;
		    };
		    Property.prototype.withNewInstanceName = function (name) {
		        this._newInstanceName = name;
		        return this;
		    };
		    Property.prototype.addChildValueConstraint = function (c) {
		        this.determinesChildValues.push(c);
		    };
		    Property.prototype.getChildValueConstraints = function () {
		        return this.determinesChildValues;
		    };
		    Property.prototype.childRestrictions = function () {
		        return this.determinesChildValues;
		    };
		    Property.prototype.id = function () {
		        if (this._id) {
		            return this._id;
		        }
		        if (!this._groupName) {
		            return null;
		        }
		        if (this.domain().getAdapter(ramlServices.RAMLService).getDeclaringNode()) {
		            return null;
		        }
		        this._id = this._groupName + this.domain().nameId();
		        return this._id;
		    };
		    Property.prototype.isAnnotation = function () {
		        return this._groupName == universes.Universe10.Api.properties.annotations.name && this.domain() && !this.domain().isUserDefined();
		    };
		    Property.prototype.withFromParentValue = function (v) {
		        if (v === void 0) { v = true; }
		        this._isFromParentValue = v;
		        return this;
		    };
		    Property.prototype.withFromParentKey = function (v) {
		        if (v === void 0) { v = true; }
		        this._isFromParentKey = v;
		        return this;
		    };
		    Property.prototype.isFromParentKey = function () {
		        return this._isFromParentKey;
		    };
		    Property.prototype.isFromParentValue = function () {
		        return this._isFromParentValue;
		    };
		    Property.prototype.withGroupName = function (gname) {
		        this._groupName = gname;
		        return this;
		    };
		    Property.prototype.unmerge = function () {
		        this._groupName = this.nameId();
		        return this;
		    };
		    Property.prototype.merge = function () {
		        this._groupName = null;
		        return this;
		    };
		    Property.prototype.withKey = function (isKey) {
		        this._key = isKey;
		        return this;
		    };
		    /**
		     * TODO THIS STUFF SHOULD BE MORE ABSTRACT (LATER...)
		     * @param keyShouldStartFrom
		     * @returns {Property}
		     */
		    Property.prototype.isKey = function () {
		        return this._key;
		    };
		    Property.prototype.isMerged = function () {
		        return this._groupName == null;
		    };
		    Property.prototype.isPrimitive = function () {
		        if (!this.range()) {
		            return true;
		        }
		        var key = this.range().key();
		        if (key == universes.Universe08.StringType || key == universes.Universe10.StringType) {
		            return true;
		        }
		        if (key == universes.Universe08.NumberType || key == universes.Universe10.NumberType) {
		            return true;
		        }
		        if (key == universes.Universe08.BooleanType || key == universes.Universe10.BooleanType) {
		            return true;
		        }
		        return false;
		    };
		    Property.prototype.groupName = function () {
		        return this._groupName;
		    };
		    Property.prototype.key = function () {
		        //TODO implement that
		        return null;
		    };
		    return Property;
		})(typeSystem.Property);
		exports.Property = Property;
		var Array = (function (_super) {
		    __extends(Array, _super);
		    function Array() {
		        _super.apply(this, arguments);
		    }
		    Array.prototype.findFacets = function (node, x) {
		        if (node) {
		            var chd = node.lowLevel().children();
		            var mi = _.find(chd, function (x) { return x.key() == "minItems"; });
		            if (mi) {
		                x[mi.key()] = mi;
		            }
		            var mi = _.find(chd, function (x) { return x.key() == "maxItems"; });
		            if (mi) {
		                x[mi.key()] = mi;
		            }
		            var mi = _.find(chd, function (x) { return x.key() == "uniqueItems"; });
		            if (mi) {
		                x[mi.key()] = mi;
		            }
		        }
		    };
		    return Array;
		})(typeSystem.Array);
		exports.Array = Array;
		var ExternalType = (function (_super) {
		    __extends(ExternalType, _super);
		    function ExternalType() {
		        _super.apply(this, arguments);
		    }
		    ExternalType.prototype.isUserDefined = function () {
		        return true;
		    };
		    return ExternalType;
		})(NodeClass);
		exports.ExternalType = ExternalType;
		var Union = (function (_super) {
		    __extends(Union, _super);
		    function Union() {
		        _super.apply(this, arguments);
		    }
		    return Union;
		})(typeSystem.Union);
		exports.Union = Union;
		var UserDefinedProp = (function (_super) {
		    __extends(UserDefinedProp, _super);
		    function UserDefinedProp() {
		        _super.apply(this, arguments);
		    }
		    UserDefinedProp.prototype.withDisplayName = function (name) {
		        this._displayName = name;
		    };
		    UserDefinedProp.prototype.getDisplayName = function () {
		        return this._displayName;
		    };
		    UserDefinedProp.prototype.node = function () {
		        return this._node;
		    };
		    return UserDefinedProp;
		})(Property);
		exports.UserDefinedProp = UserDefinedProp;


	/***/ },
	/* 4 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(2);

	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var hl = __webpack_require__(2);
		var _ = __webpack_require__(4);
		var proxy = __webpack_require__(6);
		var builder = __webpack_require__(119);
		var mutators = __webpack_require__(120);
		var linter = __webpack_require__(55);
		var typeBuilder = __webpack_require__(50);
		var search = __webpack_require__(53);
		var universes = __webpack_require__(54);
		var jsyaml = __webpack_require__(15);
		var textutil = __webpack_require__(48);
		var ModelFactory = __webpack_require__(121);
		var services = __webpack_require__(49);
		function qName(x, context) {
		    var dr = search.declRoot(context);
		    var nm = x.name();
		    var o = nm;
		    var ind = nm.indexOf("<"); //TODO SCOPE IT
		    if (ind != -1) {
		        nm = nm.substring(0, ind);
		    }
		    while (true) {
		        var np = x.parent();
		        if (!np || np == dr) {
		            break;
		        }
		        else {
		            if (np.definition().key() == universes.Universe10.Library && np.parent()) {
		                nm = np.name() + "." + nm;
		            }
		            x = np;
		        }
		    }
		    return nm;
		}
		exports.qName = qName;
		var BasicASTNode = (function () {
		    function BasicASTNode(_node, _parent) {
		        this._node = _node;
		        this._parent = _parent;
		        this._implicit = false;
		        this.values = {};
		        if (_node) {
		            _node.setHighLevelParseResult(this);
		        }
		    }
		    BasicASTNode.prototype.getKind = function () {
		        return 0 /* BASIC */;
		    };
		    BasicASTNode.prototype.hashkey = function () {
		        if (!this._hashkey)
		            this._hashkey = this.parent() ? this.parent().hashkey() + "/" + this.name() : this.name();
		        return this._hashkey;
		    };
		    BasicASTNode.prototype.root = function () {
		        if (this.parent()) {
		            return this.parent().root();
		        }
		        return this;
		    };
		    BasicASTNode.prototype.getLowLevelStart = function () {
		        if (this.lowLevel().kind() === jsyaml.Kind.SCALAR) {
		            return this.lowLevel().start();
		        }
		        return this.lowLevel().keyStart();
		    };
		    BasicASTNode.prototype.getLowLevelEnd = function () {
		        if (this.lowLevel().kind() === jsyaml.Kind.SCALAR) {
		            return this.lowLevel().end();
		        }
		        return this.lowLevel().keyEnd();
		    };
		    BasicASTNode.prototype.isSameNode = function (n) {
		        if (n) {
		            if (n.lowLevel().actual() == this.lowLevel().actual()) {
		                return true;
		            }
		        }
		        return false;
		    };
		    BasicASTNode.prototype.checkContextValue = function (name, value, thisObj) {
		        var vl = this.computedValue(name);
		        if (vl && vl.indexOf(value) != -1) {
		            return true; //FIXME
		        }
		        return value == vl || value == 'false';
		    };
		    BasicASTNode.prototype.printDetails = function (indent) {
		        return (indent ? indent : "") + "Unkown\n";
		    };
		    /**
		     * Used for test comparison of two trees. Touching this will require AST tests update.
		     * @param indent
		     * @returns {string}
		     */
		    BasicASTNode.prototype.testSerialize = function (indent) {
		        return (indent ? indent : "") + "Unkown\n";
		    };
		    BasicASTNode.prototype.errors = function () {
		        var errors = [];
		        var q = {
		            accept: function (c) {
		                errors.push(c);
		            },
		            begin: function () {
		            },
		            end: function () {
		            }
		        };
		        this.validate(q);
		        return errors;
		    };
		    BasicASTNode.prototype.markCh = function () {
		        var n = this.lowLevel();
		        n = n._node ? n._node : n;
		        if (n['markCh']) {
		            return true;
		        }
		        n['markCh'] = 1;
		    };
		    BasicASTNode.prototype.unmarkCh = function () {
		        var n = this.lowLevel();
		        n = n._node ? n._node : n;
		        delete n['markCh'];
		    };
		    BasicASTNode.prototype.validate = function (v) {
		        linter.validate(this, v);
		    };
		    BasicASTNode.prototype.allowRecursive = function () {
		        return false;
		    };
		    BasicASTNode.prototype.setComputed = function (name, v) {
		        this.values[name] = v;
		    };
		    BasicASTNode.prototype.computedValue = function (name) {
		        var vl = this.values[name];
		        if (!vl && this.parent()) {
		            return this.parent().computedValue(name);
		        }
		        return vl;
		    };
		    BasicASTNode.prototype.lowLevel = function () {
		        return this._node;
		    };
		    BasicASTNode.prototype.name = function () {
		        var c = this.lowLevel().key();
		        if (!c) {
		            return "";
		        }
		        return c;
		    };
		    BasicASTNode.prototype.parent = function () {
		        return this._parent;
		    };
		    BasicASTNode.prototype.setParent = function (parent) {
		        this._parent = parent;
		    };
		    BasicASTNode.prototype.isElement = function () {
		        return false;
		    };
		    BasicASTNode.prototype.directChildren = function () {
		        return this.children();
		    };
		    BasicASTNode.prototype.children = function () {
		        return [];
		    };
		    BasicASTNode.prototype.isAttached = function () {
		        return this.parent() != null;
		    };
		    BasicASTNode.prototype.isImplicit = function () {
		        return this._implicit;
		    };
		    BasicASTNode.prototype.isAttr = function () {
		        return false;
		    };
		    BasicASTNode.prototype.isUnknown = function () {
		        return true;
		    };
		    BasicASTNode.prototype.id = function () {
		        var _this = this;
		        if (this._parent) {
		            var parentId = this.parent().id();
		            parentId += "." + this.name();
		            var sameName = this.parent().directChildren().filter(function (x) { return x.name() == _this.name(); });
		            if (sameName.length > 1) {
		                var ind = sameName.indexOf(this);
		                parentId += "[" + ind + "]";
		            }
		            return parentId;
		        }
		        return "";
		    };
		    BasicASTNode.prototype.localId = function () {
		        return this.name();
		    };
		    BasicASTNode.prototype.fullLocalId = function () {
		        var _this = this;
		        if (this._parent) {
		            var result = "." + this.name();
		            var sameName = this.parent().directChildren().filter(function (x) { return x.name() == _this.name(); });
		            if (sameName.length > 1) {
		                var ind = sameName.indexOf(this);
		                result += "[" + ind + "]";
		            }
		            return result;
		        }
		        return this.localId();
		    };
		    BasicASTNode.prototype.property = function () {
		        return null;
		    };
		    return BasicASTNode;
		})();
		exports.BasicASTNode = BasicASTNode;
		var StructuredValue = (function () {
		    function StructuredValue(node, _parent, _pr, kv) {
		        if (kv === void 0) { kv = null; }
		        this.node = node;
		        this._parent = _parent;
		        this.kv = kv;
		        this._pr = _pr;
		    }
		    StructuredValue.prototype.valueName = function () {
		        var res = null;
		        if (this.kv) {
		            res = this.kv;
		        }
		        res = this.node.key();
		        if (this._pr && this._pr.isAnnotation()) {
		            if (res && res.charAt(0) == '(') {
		                res = res.substring(1, res.length - 1);
		            }
		        }
		        return res;
		    };
		    StructuredValue.prototype.children = function () {
		        return this.node.children().map(function (x) { return new StructuredValue(x, null, null); });
		    };
		    StructuredValue.prototype.lowLevel = function () {
		        return this.node;
		    };
		    StructuredValue.prototype.toHighlevel = function (parent) {
		        if (!parent && this._parent)
		            parent = this._parent;
		        var vn = this.valueName();
		        var cands = this._pr.getAdapter(services.RAMLPropertyService).referenceTargets(parent).filter(function (x) { return qName(x, parent) == vn; });
		        if (cands && cands[0]) {
		            var tp = typeBuilder.typeFromNode(cands[0]);
		            var node = new ASTNodeImpl(this.node, parent, tp, this._pr);
		            if (this._pr) {
		                this._pr.childRestrictions().forEach(function (y) {
		                    node.setComputed(y.name, y.value);
		                });
		            }
		            return node;
		        }
		        return null;
		    };
		    return StructuredValue;
		})();
		exports.StructuredValue = StructuredValue;
		var ASTPropImpl = (function (_super) {
		    __extends(ASTPropImpl, _super);
		    function ASTPropImpl(node, parent, _def, _prop, fromKey) {
		        if (fromKey === void 0) { fromKey = false; }
		        _super.call(this, node, parent);
		        this._def = _def;
		        this._prop = _prop;
		        this.fromKey = fromKey;
		    }
		    ASTPropImpl.prototype.definition = function () {
		        return this._def;
		    };
		    ASTPropImpl.prototype.isString = function () {
		        if (this._def) {
		            if (this._def.key() === universes.Universe08.StringType || this._def.key() == universes.Universe10.StringType) {
		                return true;
		            }
		        }
		        return false;
		    };
		    ASTPropImpl.prototype.getKind = function () {
		        return 2 /* ATTRIBUTE */;
		    };
		    ASTPropImpl.prototype.owningWrapper = function () {
		        return {
		            node: this.parent().wrapperNode(),
		            property: this.name()
		        };
		    };
		    ASTPropImpl.prototype.patchType = function (t) {
		        this._def = t;
		    };
		    ASTPropImpl.prototype.findReferenceDeclaration = function () {
		        var _this = this;
		        var targets = this.property().getAdapter(services.RAMLPropertyService).referenceTargets(this.parent());
		        var vl = this.value();
		        if (vl instanceof StructuredValue) {
		            var st = vl;
		            var nm = st.valueName();
		        }
		        else {
		            var nm = "" + vl;
		        }
		        var t = _.find(targets, function (x) { return qName(x, _this.parent()) == nm; });
		        return t;
		    };
		    ASTPropImpl.prototype.findReferencedValue = function () {
		        var c = this.findReferenceDeclaration();
		        if (c) {
		            var vl = c.attr("value");
		            var ck = c.definition().key();
		            if (ck === universes.Universe08.GlobalSchema || ck === universes.Universe10.GlobalSchema) {
		                if (vl) {
		                    var actualValue = vl.value();
		                    if (actualValue) {
		                        var rf = this._def.getAdapter(services.RAMLService).isValid(this.parent(), actualValue, vl.property());
		                        return rf;
		                    }
		                }
		                return null;
		            }
		        }
		        return c;
		    };
		    ASTPropImpl.prototype.isElement = function () {
		        return false;
		    };
		    ASTPropImpl.prototype.property = function () {
		        return this._prop;
		    };
		    ASTPropImpl.prototype.convertMultivalueToString = function (value) {
		        //|\n  xxx\n  yyy\n  zzz
		        var gap = 0;
		        var pos = 2;
		        while (value[pos] == ' ') {
		            gap++;
		            pos++;
		        }
		        //console.log('gap: ' + gap);
		        var lines = textutil.splitOnLines(value);
		        lines = lines.map(function (line) {
		            //console.log('line: ' + line);
		            return line.substring(gap, line.length);
		        });
		        return lines.join('');
		    };
		    ASTPropImpl.prototype.value = function () {
		        if (this._computed) {
		            return this.computedValue(this.property().nameId());
		        }
		        if (this.fromKey) {
		            return this._node.key();
		        }
		        if (this.property().isAnnotation() && this._node.key() && this._node.key() != 'annotations') {
		            return new StructuredValue(this._node, this.parent(), this._prop);
		        }
		        var actualValue = this._node.value(); //TODO FIXME
		        if (this.property().isSelfNode()) {
		            if (!actualValue || actualValue instanceof jsyaml.ASTNode) {
		                actualValue = this._node;
		                if (actualValue.children().length == 0) {
		                    actualValue = null;
		                }
		            }
		        }
		        if (actualValue instanceof jsyaml.ASTNode || actualValue instanceof proxy.LowLevelProxyNode) {
		            return new StructuredValue(actualValue, this.parent(), this._prop);
		        }
		        if (textutil.isMultiLineValue(actualValue)) {
		            var res = this.convertMultivalueToString(actualValue);
		            //console.log('converted: [' + textutil.replaceNewlines(res) + ']');
		            return res;
		        }
		        return actualValue;
		    };
		    ASTPropImpl.prototype.name = function () {
		        return this._prop.nameId();
		    };
		    ASTPropImpl.prototype.printDetails = function (indent) {
		        var className = this.definition().nameId();
		        var definitionClassName = this.property().range().nameId();
		        var result = (indent ? indent : "") + (this.name() + " : " + className + "[" + definitionClassName + "]" + "  =  " + this.value()) + "\n";
		        if (this.value() instanceof StructuredValue) {
		            var structuredHighLevel = this.value().toHighlevel();
		            if (structuredHighLevel && structuredHighLevel.printDetails) {
		                result += structuredHighLevel.printDetails(indent + "\t");
		            }
		        }
		        return result;
		    };
		    /**
		     * Used for test comparison of two trees. Touching this will require AST tests update.
		     * @param indent
		     * @returns {string}
		     */
		    ASTPropImpl.prototype.testSerialize = function (indent) {
		        var className = this.definition().nameId();
		        var result = (indent ? indent : "") + (this.name() + " : " + className + "  =  " + this.value()) + "\n";
		        if (this.value() instanceof StructuredValue) {
		            var structuredHighLevel = this.value().toHighlevel();
		            if (structuredHighLevel && structuredHighLevel.testSerialize) {
		                result += structuredHighLevel.testSerialize((indent ? indent : "") + "  ");
		            }
		            else {
		                var lowLevel = this.value().lowLevel();
		                var dump = lowLevel.dump();
		                var indentedDump = "";
		                var dumpLines = dump.split("\n");
		                dumpLines.forEach(function (dumpLine) { return indentedDump += ((indent ? indent : "") + "  " + dumpLine + "\n"); });
		                result += indentedDump + "\n";
		            }
		        }
		        return result;
		    };
		    ASTPropImpl.prototype.isAttr = function () {
		        return true;
		    };
		    ASTPropImpl.prototype.isUnknown = function () {
		        return false;
		    };
		    ASTPropImpl.prototype.setValue = function (value) {
		        mutators.setValue(this, value);
		    };
		    ASTPropImpl.prototype.setKey = function (value) {
		        mutators.setKey(this, value);
		    };
		    ASTPropImpl.prototype.children = function () {
		        return [];
		    };
		    ASTPropImpl.prototype.addStringValue = function (value) {
		        mutators.addStringValue(this, value);
		    };
		    ASTPropImpl.prototype.addStructuredValue = function (sv) {
		        mutators.addStructuredValue(this, sv);
		    };
		    ASTPropImpl.prototype.addValue = function (value) {
		        if (!this.property().isMultiValue())
		            throw new Error("setValue(string) only apply to multi-values properties");
		        if (typeof value == 'string') {
		            this.addStringValue(value);
		        }
		        else {
		            this.addStructuredValue(value);
		        }
		    };
		    ASTPropImpl.prototype.isEmbedded = function () {
		        var keyname = this.lowLevel().asMapping().key.value;
		        //console.log('propery: ' + this.property().name());
		        //console.log('mapping: ' + keyname);
		        return this.property().canBeValue() && keyname != this.property().nameId();
		    };
		    ASTPropImpl.prototype.remove = function () {
		        mutators.removeAttr(this);
		    };
		    ASTPropImpl.prototype.setValues = function (values) {
		        mutators.setValues(this, values);
		    };
		    ASTPropImpl.prototype.isEmpty = function () {
		        if (!this.property().isMultiValue())
		            throw new Error("isEmpty() only apply to multi-values attributes");
		        //console.log('remove: ' + this.name());
		        var node = this.parent();
		        var llnode = node.lowLevel();
		        //node.lowLevel().show('Parent:');
		        var attrs = node.attributes(this.name());
		        //console.log('attributes: ' + attrs.length);
		        if (attrs.length == 0) {
		            return true;
		        }
		        else if (attrs.length == 1) {
		            var anode = attrs[0].lowLevel();
		            //console.log('attribute : ' + anode.kindName());
		            //anode.show("ATTR:");
		            if (anode.isMapping()) {
		                // that's crazy but it means zero length array indeed )
		                return true;
		            }
		            else {
		                return false;
		            }
		        }
		        else {
		            return false;
		        }
		    };
		    return ASTPropImpl;
		})(BasicASTNode);
		exports.ASTPropImpl = ASTPropImpl;
		var nodeBuilder = new builder.BasicNodeBuilder();
		(function (OveralMergeMode) {
		    OveralMergeMode[OveralMergeMode["MERGE"] = 0] = "MERGE";
		    OveralMergeMode[OveralMergeMode["AGGREGATE"] = 1] = "AGGREGATE";
		})(exports.OveralMergeMode || (exports.OveralMergeMode = {}));
		var OveralMergeMode = exports.OveralMergeMode;
		var ASTNodeImpl = (function (_super) {
		    __extends(ASTNodeImpl, _super);
		    function ASTNodeImpl(node, parent, _def, _prop) {
		        _super.call(this, node, parent);
		        this._def = _def;
		        this._prop = _prop;
		        this._expanded = false;
		        this._allowQuestion = false;
		        this._subTypesCache = null;
		        this._auxChecked = false;
		        /**
		         * Depending on the merge mode, overlays and extensions are either merged with the master, or their trees are joined via aggregation
		         * @type {OveralMergeMode}
		         */
		        this.overlayMergeMode = 1 /* AGGREGATE */;
		        if (node) {
		            node.setHighLevelNode(this);
		        }
		    }
		    ASTNodeImpl.prototype.patchProp = function (pr) {
		        this._prop = pr;
		    };
		    ASTNodeImpl.prototype.getKind = function () {
		        return 1 /* NODE */;
		    };
		    ASTNodeImpl.prototype.wrapperNode = function () {
		        if (!this._wrapperNode) {
		            this._wrapperNode = ModelFactory.buildWrapperNode(this);
		        }
		        return this._wrapperNode;
		    };
		    ASTNodeImpl.prototype.propertiesAllowedToUse = function () {
		        var _this = this;
		        return this.definition().allProperties().filter(function (x) { return _this.isAllowedToUse(x); });
		    };
		    ASTNodeImpl.prototype.isAllowedToUse = function (p) {
		        var _this = this;
		        var ok = true;
		        if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
		            return false;
		        }
		        p.getContextRequirements().forEach(function (y) {
		            if (y.name.indexOf('(') != -1) {
		                //TODO HANDLE IT LATER
		                return true;
		            }
		            var vl = _this.computedValue(y.name);
		            if (vl) {
		                ok = ok && (vl == y.value);
		            }
		            else {
		                if (y.value) {
		                    ok = false;
		                }
		            }
		        });
		        return ok;
		    };
		    ASTNodeImpl.prototype.allowRecursive = function () {
		        if (this.definition().getAdapter(services.RAMLService).isUserDefined()) {
		            return true;
		        }
		        return false;
		    };
		    ASTNodeImpl.prototype.setWrapperNode = function (node) {
		        this._wrapperNode = node;
		    };
		    ASTNodeImpl.prototype.setAssociatedType = function (d) {
		        this._associatedDef = d;
		    };
		    ASTNodeImpl.prototype.associatedType = function () {
		        return this._associatedDef;
		    };
		    ASTNodeImpl.prototype.knownIds = function () {
		        return this._knownIds;
		    };
		    ASTNodeImpl.prototype.findById = function (id) {
		        var _this = this;
		        var v = this._knownIds;
		        if (!v) {
		            this._knownIds = {};
		            var all = search.allChildren(this);
		            all.forEach(function (x) { return _this._knownIds[x.id()] = x; });
		        }
		        return this._knownIds[id];
		    };
		    ASTNodeImpl.prototype.isAuxilary = function () {
		        if (this._isAux) {
		            return true;
		        }
		        if (this._auxChecked) {
		            return false;
		        }
		        this._auxChecked = true;
		        var masterApi = this.getMaster();
		        if (masterApi) {
		            this._isAux = true;
		            this.initilizeKnownIDs(masterApi);
		            return true;
		        }
		        return false;
		    };
		    ASTNodeImpl.prototype.initilizeKnownIDs = function (api) {
		        var _this = this;
		        this._knownIds = {};
		        var allChildren = search.allChildren(api);
		        allChildren.forEach(function (x) { return _this._knownIds[x.id()] = x; });
		        this._knownIds[""] = api;
		    };
		    ASTNodeImpl.prototype.getMaster = function () {
		        if (this.masterApi) {
		            return this.masterApi;
		        }
		        return this.calculateMasterByRef();
		    };
		    /**
		     * Forcefully sets a master unit for this API, which may be different from the one, current unit points to
		     * via masterRef.
		     * @param master
		     */
		    ASTNodeImpl.prototype.overrideMaster = function (master) {
		        this.masterApi = master;
		        this.resetAuxilaryState();
		    };
		    ASTNodeImpl.prototype.setMergeMode = function (mergeMode) {
		        this.overlayMergeMode = mergeMode;
		        this.resetAuxilaryState();
		    };
		    ASTNodeImpl.prototype.getMergeMode = function () {
		        return this.overlayMergeMode;
		    };
		    ASTNodeImpl.prototype.calculateMasterByRef = function () {
		        var masterReference = _.find(this.lowLevel().children(), function (x) { return x.key() == universes.Universe10.Overlay.properties.masterRef.name; });
		        if (!masterReference || !masterReference.value()) {
		            return null;
		        }
		        var masterPath = masterReference.value();
		        var masterUnit = this.lowLevel().unit().project().resolve(this.lowLevel().unit().path(), masterPath);
		        if (!masterUnit) {
		            return null;
		        }
		        var result = hl.fromUnit(masterUnit);
		        result.setMergeMode(this.overlayMergeMode);
		        return result;
		    };
		    ASTNodeImpl.prototype.resetAuxilaryState = function () {
		        this._isAux = false;
		        this._auxChecked = false;
		        this._knownIds = {};
		        this.clearChildrenCache();
		    };
		    ASTNodeImpl.prototype.printDetails = function (indent) {
		        var result = "";
		        if (!indent)
		            indent = "";
		        var classname = this.definition().nameId();
		        var definitionClasName = this.property() ? this.property().range().nameId() : "";
		        var parentPropertyName = this.property() ? this.property().nameId() : "";
		        result += indent + classname + "[" + definitionClasName + "]" + " <--- " + parentPropertyName + "\n";
		        this.children().forEach(function (child) {
		            result += child.printDetails(indent + "\t");
		        });
		        return result;
		    };
		    /**
		     * Used for test comparison of two trees. Touching this will require AST tests update.
		     * @param indent
		     * @returns {string}
		     */
		    ASTNodeImpl.prototype.testSerialize = function (indent) {
		        var result = "";
		        if (!indent)
		            indent = "";
		        var classname = this.definition().nameId();
		        var parentPropertyName = this.property() ? this.property().nameId() : "";
		        result += indent + classname + " <-- " + parentPropertyName + "\n";
		        this.children().forEach(function (child) {
		            if (child.testSerialize) {
		                result += child.testSerialize(indent + "  ");
		            }
		        });
		        return result;
		    };
		    ASTNodeImpl.prototype.getExtractedChildren = function () {
		        var r = this.root();
		        if (r.isAuxilary()) {
		            if (r._knownIds) {
		                var i = r._knownIds[this.id()];
		                if (i) {
		                    return i.children();
		                }
		            }
		            return [];
		        }
		        return [];
		    };
		    ASTNodeImpl.prototype.allowsQuestion = function () {
		        return this._allowQuestion || this.definition().getAdapter(services.RAMLService).getAllowQuestion();
		    };
		    ASTNodeImpl.prototype.findReferences = function () {
		        var rs = [];
		        search.refFinder(this.root(), this, rs);
		        //filtering out equal results
		        var filteredReferences = [];
		        rs.forEach(function (ref) {
		            if (!_.find(filteredReferences, function (existing) { return existing == ref; })) {
		                filteredReferences.push(ref);
		            }
		        });
		        return filteredReferences;
		    };
		    ASTNodeImpl.prototype.name = function () {
		        var ka = _.find(this.directChildren(), function (x) { return x.property() && x.property().getAdapter(services.RAMLPropertyService).isKey(); });
		        if (ka && ka instanceof ASTPropImpl) {
		            var c = ka.value();
		            if (c) {
		                var io = c.indexOf(':');
		                if (io != -1) {
		                    return c.substring(0, io);
		                }
		            }
		            return c;
		        }
		        return _super.prototype.name.call(this);
		    };
		    ASTNodeImpl.prototype.findElementAtOffset = function (n) {
		        return this._findNode(this, n, n);
		    };
		    ASTNodeImpl.prototype.isElement = function () {
		        return true;
		    };
		    ASTNodeImpl.prototype.universe = function () {
		        if (this._universe) {
		            return this._universe;
		        }
		        return this.definition().universe();
		    };
		    ASTNodeImpl.prototype.setUniverse = function (u) {
		        this._universe = u;
		    };
		    ASTNodeImpl.prototype._findNode = function (n, offset, end) {
		        var _this = this;
		        if (n == null) {
		            return null;
		        }
		        if (n.lowLevel()) {
		            //var node:ASTNode=<ASTNode>n;
		            if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
		                var res = n;
		                //TODO INCLUDES
		                n.elements().forEach(function (x) {
		                    if (x.lowLevel().unit() != n.lowLevel().unit()) {
		                        return;
		                    }
		                    var m = _this._findNode(x, offset, end);
		                    if (m) {
		                        res = m;
		                    }
		                });
		                return res;
		            }
		        }
		        return null;
		    };
		    ASTNodeImpl.prototype.isStub = function () {
		        return (!this.lowLevel().unit()) || this.lowLevel().unit().isStubUnit();
		    };
		    ASTNodeImpl.prototype.add = function (node) {
		        mutators.addToNode(this, node);
		    };
		    ASTNodeImpl.prototype.remove = function (node) {
		        mutators.removeNodeFrom(this, node);
		    };
		    ASTNodeImpl.prototype.dump = function (flavor) {
		        return this._node.dump();
		    };
		    ASTNodeImpl.prototype.patchType = function (d) {
		        this._def = d;
		        var ass = this._associatedDef;
		        this._associatedDef = null;
		        this._children = null;
		    };
		    ASTNodeImpl.prototype.children = function () {
		        if (this._children) {
		            return this.mergeChildren(this._children, this.getExtractedChildren());
		        }
		        if (this._node) {
		            this._children = nodeBuilder.process(this, this._node.children());
		            this._children = this._children.filter(function (x) { return x != null; });
		            //FIXME
		            return this.mergeChildren(this._children, this.getExtractedChildren());
		        }
		        return [];
		    };
		    ASTNodeImpl.prototype.mergeChildren = function (originalChildren, masterChildren) {
		        var _this = this;
		        var root = this.root();
		        if (root.overlayMergeMode == 1 /* AGGREGATE */) {
		            //simply joining the sets
		            return originalChildren.concat(masterChildren);
		        }
		        else if (root.overlayMergeMode == 0 /* MERGE */) {
		            var result = [];
		            originalChildren.forEach(function (originalChild) {
		                var masterCounterpart = _.find(masterChildren, function (masterChild) { return masterChild.fullLocalId() == originalChild.fullLocalId(); });
		                if (!masterCounterpart) {
		                    //we dont have a counterpart, so simply adding to result
		                    result.push(originalChild);
		                }
		                else {
		                    //there is a counterpart, so deciding what to do:
		                    _this.mergeChild(result, originalChild, masterCounterpart);
		                }
		            });
		            masterChildren.forEach(function (masterChild) {
		                var originalCounterpart = _.find(originalChildren, function (originalChild) { return masterChild.fullLocalId() == originalChild.fullLocalId(); });
		                if (!originalCounterpart) {
		                    //we dont have a counterpart, so simply adding to result
		                    result.push(masterChild);
		                }
		            });
		            return result;
		        }
		        return null;
		    };
		    ASTNodeImpl.prototype.mergeChild = function (result, originalChild, masterChild) {
		        if (originalChild.getKind() != masterChild.getKind()) {
		            //should not happen theoretically
		            result.push(originalChild);
		            result.push(masterChild);
		            return;
		        }
		        if (originalChild.getKind() == 1 /* NODE */) {
		            result.push(originalChild);
		            return;
		        }
		        else if (originalChild.getKind() == 2 /* ATTRIBUTE */) {
		            //if ((<ASTPropImpl>originalChild).name() == "displayName" ||
		            //    (<ASTPropImpl>originalChild).name() == "title") {
		            //    console.log("OriginalChildForDisplayName: " + (<ASTPropImpl>originalChild).value())
		            //    console.log("MasterChildForDisplayName: " + (<ASTPropImpl>masterChild).value())
		            //
		            //}
		            result.push(originalChild);
		            return;
		        }
		        else if (originalChild.getKind() == 0 /* BASIC */) {
		            //we do not know what to do with basic nodes, so adding both.
		            result.push(originalChild);
		            result.push(masterChild);
		            return;
		        }
		    };
		    ASTNodeImpl.prototype.directChildren = function () {
		        if (this._children) {
		            return this._children;
		        }
		        if (this._node) {
		            this._children = nodeBuilder.process(this, this._node.children());
		            return this._children;
		        }
		        return [];
		    };
		    ASTNodeImpl.prototype.resetChildren = function () {
		        this._children = null;
		    };
		    ASTNodeImpl.prototype.isEmptyRamlFile = function () {
		        var llroot = this.lowLevel().root();
		        return llroot.isScalar();
		    };
		    ASTNodeImpl.prototype.initRamlFile = function () {
		        mutators.initEmptyRAMLFile(this);
		    };
		    ASTNodeImpl.prototype.createAttr = function (n, v) {
		        mutators.createAttr(this, n, v);
		    };
		    ASTNodeImpl.prototype.isAttr = function () {
		        return false;
		    };
		    ASTNodeImpl.prototype.isUnknown = function () {
		        return false;
		    };
		    ASTNodeImpl.prototype.value = function () {
		        return this._node.value();
		    };
		    ASTNodeImpl.prototype.valuesOf = function (propName) {
		        var pr = this._def.property(propName);
		        if (pr != null) {
		            return this.elements().filter(function (x) { return x.property() == pr; });
		        }
		        return [];
		    };
		    ASTNodeImpl.prototype.attr = function (n) {
		        return _.find(this.attrs(), function (y) { return y.name() == n; });
		    };
		    ASTNodeImpl.prototype.attrOrCreate = function (name) {
		        var a = this.attr(name);
		        if (!a)
		            this.createAttr(name, '');
		        return this.attr(name);
		    };
		    ASTNodeImpl.prototype.attrValue = function (n) {
		        var a = this.attr(n);
		        return a ? a.value() : null;
		    };
		    ASTNodeImpl.prototype.attributes = function (n) {
		        return _.filter(this.attrs(), function (y) { return y.name() == n; });
		    };
		    ASTNodeImpl.prototype.attrs = function () {
		        return this.children().filter(function (x) { return x.isAttr(); });
		    };
		    ASTNodeImpl.prototype.elements = function () {
		        return this.children().filter(function (x) { return !x.isAttr() && !x.isUnknown(); });
		    };
		    ASTNodeImpl.prototype.element = function (n) {
		        var r = this.elementsOfKind(n);
		        if (r.length > 0) {
		            return r[0];
		        }
		        return null;
		    };
		    ASTNodeImpl.prototype.elementsOfKind = function (n) {
		        var r = this.elements().filter(function (x) { return x.property().nameId() == n; });
		        return r;
		    };
		    ASTNodeImpl.prototype.definition = function () {
		        return this._def;
		    };
		    ASTNodeImpl.prototype.property = function () {
		        return this._prop;
		    };
		    ASTNodeImpl.prototype.isExpanded = function () {
		        return this._expanded;
		    };
		    ASTNodeImpl.prototype.copy = function () {
		        return new ASTNodeImpl(this.lowLevel().copy(), this.parent(), this.definition(), this.property());
		    };
		    ASTNodeImpl.prototype.clearChildrenCache = function () {
		        this._children = null;
		    };
		    return ASTNodeImpl;
		})(BasicASTNode);
		exports.ASTNodeImpl = ASTNodeImpl;


	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {

		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var yaml = __webpack_require__(7);
		var json = __webpack_require__(8);
		var stringify = __webpack_require__(118);
		var Error = __webpack_require__(9);
		var impl = __webpack_require__(15);
		var util = __webpack_require__(11);
		var universes = __webpack_require__(54);
		var LowLevelProxyNode = (function () {
		    function LowLevelProxyNode(_parent, _transformer) {
		        this._parent = _parent;
		        this._transformer = _transformer;
		    }
		    LowLevelProxyNode.prototype.actual = function () {
		        if (this._originalNode) {
		            return this._originalNode.actual();
		        }
		        return this;
		    };
		    LowLevelProxyNode.prototype.transformer = function () {
		        return this._transformer;
		    };
		    LowLevelProxyNode.prototype.originalNode = function () {
		        return this._originalNode;
		    };
		    LowLevelProxyNode.prototype.start = function () {
		        return this._originalNode.start();
		    };
		    LowLevelProxyNode.prototype.end = function () {
		        return this._originalNode.end();
		    };
		    LowLevelProxyNode.prototype.value = function () {
		        throw new Error('The method must be overridden');
		    };
		    LowLevelProxyNode.prototype.includeErrors = function () {
		        return this._originalNode.includeErrors();
		    };
		    LowLevelProxyNode.prototype.includePath = function () {
		        return this._originalNode.includePath();
		    };
		    LowLevelProxyNode.prototype.setKeyOverride = function (_key) {
		        this._keyOverride = _key;
		    };
		    LowLevelProxyNode.prototype.key = function () {
		        if (this._keyOverride) {
		            return this._keyOverride;
		        }
		        return this._originalNode.key();
		    };
		    LowLevelProxyNode.prototype.children = function () {
		        throw new Error('The method must be overridden');
		    };
		    LowLevelProxyNode.prototype.parent = function () {
		        return this._parent;
		    };
		    LowLevelProxyNode.prototype.unit = function () {
		        return this._originalNode.unit();
		    };
		    LowLevelProxyNode.prototype.anchorId = function () {
		        return this._originalNode.anchorId();
		    };
		    LowLevelProxyNode.prototype.errors = function () {
		        return this._originalNode.errors();
		    };
		    LowLevelProxyNode.prototype.anchoredFrom = function () {
		        return this._originalNode.anchoredFrom();
		    };
		    LowLevelProxyNode.prototype.includedFrom = function () {
		        return this._originalNode.includedFrom();
		    };
		    LowLevelProxyNode.prototype.visit = function (v) {
		        if (v(this)) {
		            this.children().forEach(function (x) { return x.visit(v); });
		        }
		    };
		    //TODO
		    LowLevelProxyNode.prototype.addChild = function (n) {
		    };
		    //TODO
		    LowLevelProxyNode.prototype.execute = function (cmd) {
		    };
		    //TODO
		    LowLevelProxyNode.prototype.dump = function () {
		        return null;
		    };
		    //TODO
		    LowLevelProxyNode.prototype.dumpToObject = function () {
		        return json.serialize(this);
		    };
		    LowLevelProxyNode.prototype.keyStart = function () {
		        return this._originalNode.keyStart();
		    };
		    LowLevelProxyNode.prototype.keyEnd = function () {
		        return this._originalNode.keyEnd();
		    };
		    LowLevelProxyNode.prototype.valueStart = function () {
		        return this._originalNode.valueStart();
		    };
		    LowLevelProxyNode.prototype.valueEnd = function () {
		        return this._originalNode.valueEnd();
		    };
		    LowLevelProxyNode.prototype.isValueLocal = function () {
		        return this._originalNode.isValueLocal();
		    };
		    LowLevelProxyNode.prototype.kind = function () {
		        return this._originalNode.kind();
		    };
		    LowLevelProxyNode.prototype.valueKind = function () {
		        return this._originalNode.valueKind();
		    };
		    LowLevelProxyNode.prototype.show = function (msg) {
		        this._originalNode.show(msg);
		    };
		    LowLevelProxyNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
		        this._highLevelParseResult = highLevelParseResult;
		    };
		    LowLevelProxyNode.prototype.highLevelParseResult = function () {
		        return this._highLevelParseResult;
		    };
		    LowLevelProxyNode.prototype.setHighLevelNode = function (highLevel) {
		        this._highLevelNode = highLevel;
		    };
		    LowLevelProxyNode.prototype.highLevelNode = function () {
		        return this._highLevelNode;
		    };
		    LowLevelProxyNode.prototype.text = function (unitText) {
		        throw new Error("not implemented");
		    };
		    LowLevelProxyNode.prototype.copy = function () {
		        throw new Error("not implemented");
		    };
		    LowLevelProxyNode.prototype.markup = function (json) {
		        throw new Error("not implemented");
		    };
		    LowLevelProxyNode.prototype.nodeDefinition = function () {
		        return impl.getDefinitionForLowLevelNode(this);
		    };
		    LowLevelProxyNode.prototype.includesContents = function () {
		        return this._originalNode.includesContents();
		    };
		    return LowLevelProxyNode;
		})();
		exports.LowLevelProxyNode = LowLevelProxyNode;
		var LowLevelCompositeNode = (function (_super) {
		    __extends(LowLevelCompositeNode, _super);
		    function LowLevelCompositeNode(node, parent, transformer) {
		        _super.call(this, parent, transformer);
		        //Colliding nodes of the initioal AST
		        this._adoptedNodes = [];
		        var primaryParent = this.parent() ? this.parent().primaryNode() : null;
		        this._originalNode = new LowLevelValueTransformingNode(node, primaryParent, transformer);
		        this._adoptedNodes.push(this.primaryNode());
		    }
		    LowLevelCompositeNode.prototype.adoptedNodes = function () {
		        return this._adoptedNodes;
		    };
		    LowLevelCompositeNode.prototype.primaryNode = function () {
		        return this._originalNode;
		    };
		    LowLevelCompositeNode.prototype.parent = function () {
		        return this._parent;
		    };
		    LowLevelCompositeNode.prototype.adopt = function (node, transformer) {
		        if (!transformer) {
		            transformer = this._transformer;
		        }
		        var primaryParent = this.parent() ? this.parent().primaryNode() : null;
		        var tNode = new LowLevelValueTransformingNode(node, primaryParent, transformer);
		        this._adoptedNodes.push(tNode);
		        if (this._children) {
		            this._children.forEach(function (x) { return x._parent = null; });
		        }
		        this._children = null;
		        if (this.highLevelNode()) {
		            this.highLevelNode().resetChildren();
		        }
		    };
		    LowLevelCompositeNode.prototype.value = function () {
		        var valuableNodes = this._adoptedNodes.filter(function (x) { return x.value() != null; });
		        if (valuableNodes.length > 0) {
		            return valuableNodes[0].value();
		        }
		        return this._originalNode.value();
		    };
		    LowLevelCompositeNode.prototype.children = function () {
		        var _this = this;
		        if (this._children) {
		            return this._children;
		        }
		        var result = [];
		        var canBeMap = false;
		        var canBeSeq = false;
		        this._adoptedNodes.forEach(function (x) {
		            if (x.children() && x.children().length > 0) {
		                canBeSeq = true;
		                if (x.children()[0].key()) {
		                    canBeMap = true;
		                }
		            }
		        });
		        if (canBeMap) {
		            result = this.collectChildrenWithKeys();
		        }
		        else if (canBeSeq) {
		            result = this.collectChildrenWithKeys();
		            var map = {};
		            this._adoptedNodes.forEach(function (x) { return x.children().filter(function (y) { return !y.key(); }).forEach(function (y) {
		                var isPrimary = x == _this.primaryNode();
		                var key = _this.buildKey(y);
		                if (!isPrimary && map[key]) {
		                    //filtering away values with repeating keys
		                    //primary node is not subjected to filtration
		                    return;
		                }
		                map[key] = true;
		                var transformer = x.transformer() ? x.transformer() : _this.transformer();
		                var ch = (y instanceof LowLevelValueTransformingNode) ? y.originalNode() : y;
		                result.push(new LowLevelCompositeNode(ch, _this, transformer));
		            }); });
		        }
		        else {
		            result = [];
		        }
		        this._children = result;
		        return result;
		    };
		    LowLevelCompositeNode.prototype.buildKey = function (y) {
		        var obj = json.serialize(y);
		        var def = this.nodeDefinition();
		        if (def && (def.key() == universes.Universe08.TraitRef || def.key() == universes.Universe08.ResourceTypeRef || def.key() == universes.Universe10.TraitRef || def.key() == universes.Universe10.ResourceTypeRef)) {
		            if (typeof obj == 'object') {
		                var keys = Object.keys(obj);
		                if (keys.length > 0) {
		                    obj = keys[0];
		                }
		            }
		        }
		        return stringify(obj);
		    };
		    LowLevelCompositeNode.prototype.collectChildrenWithKeys = function () {
		        var _this = this;
		        var result = [];
		        var m = {};
		        this._adoptedNodes.forEach(function (x) {
		            var isPrimary = x == _this.primaryNode();
		            x.originalNode().children().forEach(function (y) {
		                var key = y.key();
		                if (!key) {
		                    return;
		                }
		                if (util.stringEndsWith(key, '?')) {
		                    key = key.substring(0, key.length - 1);
		                }
		                var arr = m[key];
		                if (!arr) {
		                    arr = [];
		                    m[key] = arr;
		                }
		                arr.push({ node: y, transformer: x.transformer(), isPrimary: isPrimary });
		            });
		        });
		        Object.keys(m).forEach(function (key) {
		            var arr = m[key];
		            var allOptional = true;
		            var hasPrimaryChildren = false;
		            arr.forEach(function (x) {
		                allOptional = allOptional && util.stringEndsWith(x.node.key(), '?');
		                hasPrimaryChildren = hasPrimaryChildren || x.isPrimary;
		            });
		            if (hasPrimaryChildren) {
		                var primaryChildren = [];
		                arr.filter(function (x) { return x.isPrimary; }).forEach(function (x) {
		                    var tr = x.transformer ? x.transformer : _this.transformer();
		                    primaryChildren.push(new LowLevelCompositeNode(x.node, _this, tr));
		                });
		                var primaryChild = primaryChildren[0];
		                arr.filter(function (x) { return !x.isPrimary; }).forEach(function (x) {
		                    primaryChild.adopt(x.node, x.transformer);
		                });
		                primaryChildren.forEach(function (x) { return result.push(x); });
		            }
		            else if (!allOptional) {
		                var tr = arr[0].transformer ? arr[0].transformer : _this.transformer();
		                var primaryChild = new LowLevelCompositeNode(arr[0].node, _this, tr);
		                for (var i = 1; i < arr.length; i++) {
		                    primaryChild.adopt(arr[i].node, arr[i].transformer);
		                }
		                result.push(primaryChild);
		            }
		        });
		        return result;
		    };
		    LowLevelCompositeNode.prototype.valueKind = function () {
		        if (this._originalNode.kind() != 1 /* MAPPING */) {
		            return null;
		        }
		        for (var i = 0; i < this._adoptedNodes.length; i++) {
		            var node = this._adoptedNodes[i];
		            if (node.value()) {
		                return node.valueKind();
		            }
		        }
		        return null;
		    };
		    LowLevelCompositeNode.prototype.includePath = function () {
		        for (var i = 0; i < this._adoptedNodes.length; i++) {
		            var node = this._adoptedNodes[i];
		            if (node.value() != null) {
		                return node.includePath();
		            }
		        }
		        return null;
		    };
		    LowLevelCompositeNode.prototype.key = function () {
		        var keys = this._adoptedNodes.map(function (x) { return x.key(); }).filter(function (x) { return x != null && !util.stringEndsWith(x, '?'); });
		        if (keys.length > 0) {
		            return keys[0];
		        }
		        return _super.prototype.key.call(this);
		    };
		    return LowLevelCompositeNode;
		})(LowLevelProxyNode);
		exports.LowLevelCompositeNode = LowLevelCompositeNode;
		var LowLevelValueTransformingNode = (function (_super) {
		    __extends(LowLevelValueTransformingNode, _super);
		    function LowLevelValueTransformingNode(node, parent, transformer) {
		        _super.call(this, parent, transformer);
		        this._originalNode = node;
		    }
		    LowLevelValueTransformingNode.prototype.value = function () {
		        var val = this.originalNode().value();
		        var t = this.transformer();
		        if (t) {
		            var transformationResult = t.transform(val);
		            val = transformationResult.value;
		        }
		        return val;
		    };
		    LowLevelValueTransformingNode.prototype.children = function () {
		        var _this = this;
		        return this.originalNode().children().map(function (x) { return new LowLevelValueTransformingNode(x, _this, _this._transformer); });
		    };
		    LowLevelValueTransformingNode.prototype.parent = function () {
		        return this._parent;
		    };
		    return LowLevelValueTransformingNode;
		})(LowLevelProxyNode);
		exports.LowLevelValueTransformingNode = LowLevelValueTransformingNode;


	/***/ },
	/* 7 */
	/***/ function(module, exports) {

		/// <reference path="../../../typings/tsd.d.ts" />
		(function (Kind) {
		    Kind[Kind["SCALAR"] = 0] = "SCALAR";
		    Kind[Kind["MAPPING"] = 1] = "MAPPING";
		    Kind[Kind["MAP"] = 2] = "MAP";
		    Kind[Kind["SEQ"] = 3] = "SEQ";
		    Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
		    Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
		})(exports.Kind || (exports.Kind = {}));
		var Kind = exports.Kind;
		function newMapping(key, value) {
		    var end = (value ? value.endPosition : key.endPosition + 1); //FIXME.workaround, end should be defied by position of ':'
		    //console.log('key: ' + key.value + ' ' + key.startPosition + '..' + key.endPosition + ' ' + value + ' end: ' + end);
		    var node = {
		        key: key,
		        value: value,
		        startPosition: key.startPosition,
		        endPosition: end,
		        kind: 1 /* MAPPING */,
		        parent: null,
		        errors: []
		    };
		    return node;
		}
		exports.newMapping = newMapping;
		function newAnchorRef(key, start, end, value) {
		    return {
		        errors: [],
		        referencesAnchor: key,
		        value: value,
		        startPosition: start,
		        endPosition: end,
		        kind: 4 /* ANCHOR_REF */,
		        parent: null
		    };
		}
		exports.newAnchorRef = newAnchorRef;
		function newScalar(v) {
		    if (v === void 0) { v = ""; }
		    return {
		        errors: [],
		        startPosition: -1,
		        endPosition: -1,
		        value: v,
		        kind: 0 /* SCALAR */,
		        parent: null,
		        doubleQuoted: false
		    };
		}
		exports.newScalar = newScalar;
		function newItems() {
		    return {
		        errors: [],
		        startPosition: -1,
		        endPosition: -1,
		        items: [],
		        kind: 3 /* SEQ */,
		        parent: null
		    };
		}
		exports.newItems = newItems;
		function newSeq() {
		    return newItems();
		}
		exports.newSeq = newSeq;
		function newMap(mappings) {
		    return {
		        errors: [],
		        startPosition: -1,
		        endPosition: -1,
		        mappings: mappings ? mappings : [],
		        kind: 2 /* MAP */,
		        parent: null
		    };
		}
		exports.newMap = newMap;


	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		/**
		 * Created by kor on 05/05/15.
		 */
		var Error = __webpack_require__(9);
		var lowlevel = __webpack_require__(10);
		var yaml = __webpack_require__(7);
		var util = __webpack_require__(11);
		var llImpl = __webpack_require__(15);
		var CompilationUnit = (function () {
		    function CompilationUnit(_absolutePath, _path, _content, _project, _isTopoLevel, serializeOptions) {
		        if (serializeOptions === void 0) { serializeOptions = {}; }
		        this._absolutePath = _absolutePath;
		        this._path = _path;
		        this._content = _content;
		        this._project = _project;
		        this._isTopoLevel = _isTopoLevel;
		        this.serializeOptions = serializeOptions;
		        this._node = new AstNode(this, JSON.parse(this._content), null, serializeOptions);
		    }
		    CompilationUnit.prototype.absolutePath = function () {
		        return this._absolutePath;
		    };
		    CompilationUnit.prototype.clone = function () {
		        return null;
		    };
		    CompilationUnit.prototype.contents = function () {
		        return this._content;
		    };
		    CompilationUnit.prototype.lexerErrors = function () {
		        return [];
		    };
		    CompilationUnit.prototype.path = function () {
		        return this._content;
		    };
		    CompilationUnit.prototype.isTopLevel = function () {
		        return this._isTopoLevel;
		    };
		    CompilationUnit.prototype.ast = function () {
		        return this._node;
		    };
		    CompilationUnit.prototype.isDirty = function () {
		        return true;
		    };
		    CompilationUnit.prototype.getIncludeNodes = function () {
		        return [];
		    };
		    CompilationUnit.prototype.resolveAsync = function (p) {
		        return null;
		    };
		    CompilationUnit.prototype.isRAMLUnit = function () {
		        return true;
		    };
		    CompilationUnit.prototype.project = function () {
		        return this._project;
		    };
		    CompilationUnit.prototype.updateContent = function (newContent) {
		    };
		    CompilationUnit.prototype.ramlVersion = function () {
		        throw new Error('not implemented');
		    };
		    CompilationUnit.prototype.lineMapper = function () {
		        return new lowlevel.LineMapperImpl(this.contents(), this.absolutePath());
		    };
		    CompilationUnit.prototype.resolve = function (p) {
		        return null;
		    }; // TODO FIXME 
		    return CompilationUnit;
		})();
		exports.CompilationUnit = CompilationUnit;
		//export interface IProject{
		//    units():ICompilationUnit[];//returns units with apis in this folder
		//
		//    execute(cmd:CompositeCommand)
		//
		//    executeTextChange(textCommand:TextChangeCommand);//this may result in broken nodes?
		//
		//    addListener(listener:IASTListener);
		//
		//    removeListener(listener:IASTListener)
		//
		//    addTextChangeListener(listener:ITextChangeCommandListener);
		//    removeTextChangeListener(listener:ITextChangeCommandListener);
		//}
		//export interface IASTListener{
		//    (delta:ASTDelta)
		//}
		//
		//export interface ITextChangeCommandListener{
		//    (delta:TextChangeCommand)
		//}
		//export class ASTDelta{
		//    commands:ASTChangeCommand[]
		//}
		//export interface ASTVisitor{
		//    (node:ILowLevelASTNode):boolean
		//}
		var AstNode = (function () {
		    function AstNode(_unit, _object, _parent, options, _key) {
		        var _this = this;
		        if (options === void 0) { options = {}; }
		        this._unit = _unit;
		        this._object = _object;
		        this._parent = _parent;
		        this.options = options;
		        this._key = _key;
		        if (this._object instanceof Object) {
		            Object.keys(this._object).forEach(function (x) {
		                var u = unescapeKey(x, _this.options);
		                if (u != x) {
		                    var val = _this._object[x];
		                    delete _this._object[x];
		                    _this._object[u] = val;
		                }
		            });
		        }
		    }
		    AstNode.prototype.start = function () {
		        return -1;
		    };
		    AstNode.prototype.end = function () {
		        return -1;
		    };
		    AstNode.prototype.value = function () {
		        return this._object;
		    };
		    AstNode.prototype.actual = function () {
		        return this._object;
		    };
		    AstNode.prototype.includeErrors = function () {
		        return [];
		    };
		    AstNode.prototype.includePath = function () {
		        return null;
		    };
		    AstNode.prototype.key = function () {
		        return this._key;
		    };
		    AstNode.prototype.children = function () {
		        var _this = this;
		        if (!this._object) {
		            return [];
		        }
		        if (Array.isArray(this._object)) {
		            return this._object.map(function (x) { return new AstNode(_this._unit, x, _this, _this.options); });
		        }
		        else if (this._object instanceof Object) {
		            return Object.keys(this._object).map(function (x) { return new AstNode(_this._unit, _this._object[x], _this, _this.options, x); });
		        }
		        else {
		            return [];
		        }
		    };
		    AstNode.prototype.parent = function () {
		        return this._parent;
		    };
		    AstNode.prototype.unit = function () {
		        return this._unit;
		    };
		    AstNode.prototype.anchorId = function () {
		        return null;
		    };
		    AstNode.prototype.errors = function () {
		        return [];
		    };
		    AstNode.prototype.anchoredFrom = function () {
		        return this;
		    };
		    AstNode.prototype.includedFrom = function () {
		        return this;
		    };
		    AstNode.prototype.visit = function (v) {
		        if (v(this)) {
		            this.children().forEach(function (x) { return x.visit(v); });
		        }
		    };
		    AstNode.prototype.dumpToObject = function () {
		        return this._object;
		    };
		    AstNode.prototype.addChild = function (n) {
		    };
		    AstNode.prototype.execute = function (cmd) {
		    };
		    AstNode.prototype.dump = function () {
		        return JSON.stringify(this._object);
		    };
		    AstNode.prototype.keyStart = function () {
		        return -1;
		    };
		    AstNode.prototype.keyEnd = function () {
		        return -1;
		    };
		    AstNode.prototype.valueStart = function () {
		        return -1;
		    };
		    AstNode.prototype.valueEnd = function () {
		        return -1;
		    };
		    AstNode.prototype.isValueLocal = function () {
		        return true;
		    };
		    AstNode.prototype.kind = function () {
		        if (Array.isArray(this._object)) {
		            return 3 /* SEQ */;
		        }
		        else if (this._object instanceof Object) {
		            return 2 /* MAP */;
		        }
		        else {
		            return 0 /* SCALAR */;
		        }
		    };
		    AstNode.prototype.valueKind = function () {
		        return null;
		    };
		    AstNode.prototype.show = function (msg) {
		    };
		    AstNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
		        this._highLevelParseResult = highLevelParseResult;
		    };
		    AstNode.prototype.highLevelParseResult = function () {
		        return this._highLevelParseResult;
		    };
		    AstNode.prototype.setHighLevelNode = function (highLevel) {
		        this._highLevelNode = highLevel;
		    };
		    AstNode.prototype.highLevelNode = function () {
		        return this._highLevelNode;
		    };
		    AstNode.prototype.text = function (unitText) {
		        throw new Error("not implemented");
		    };
		    AstNode.prototype.copy = function () {
		        throw new Error("not implemented");
		    };
		    AstNode.prototype.markup = function (json) {
		        throw new Error("not implemented");
		    };
		    AstNode.prototype.nodeDefinition = function () {
		        return llImpl.getDefinitionForLowLevelNode(this);
		    };
		    AstNode.prototype.includesContents = function () {
		        return false;
		    };
		    return AstNode;
		})();
		exports.AstNode = AstNode;
		function serialize(node, options) {
		    if (options === void 0) { options = {}; }
		    if (node.children().length == 0) {
		        if (node.value()) {
		            return node.value();
		        }
		        return '';
		    }
		    if (!node.children()[0].key()) {
		        var arr = [];
		        node.children().forEach(function (x) {
		            arr.push(serialize(x, options));
		        });
		        return arr;
		    }
		    else {
		        var obj = {};
		        node.children().forEach(function (x) {
		            obj[escapeKey(x.key(), options)] = serialize(x, options);
		        });
		        if (options && options.writeErrors) {
		            var errors = collectErrors(node);
		            if (errors != null && errors.length > 0) {
		                obj['__$errors__'] = errors;
		            }
		        }
		        return obj;
		    }
		}
		exports.serialize = serialize;
		function collectErrors(node) {
		    var errors = [].concat(node.errors());
		    node.children().forEach(function (ch) {
		        var children = ch.children();
		        if (children.length == 0) {
		            ch.errors().forEach(function (e) { return errors.push(e); });
		            return;
		        }
		        if (!children[0].key()) {
		            children.forEach(function (x) {
		                if (x.children().length == 0) {
		                    x.errors().forEach(function (e) { return errors.push(e); });
		                }
		            });
		        }
		    });
		    return errors;
		}
		function escapeKey(key, options) {
		    if (!options || !key) {
		        return key;
		    }
		    if (options.escapeNumericKeys && key.replace(/\d/g, '').trim().length == 0) {
		        return '__$EscapedKey$__' + key;
		    }
		    return key;
		}
		function unescapeKey(key, options) {
		    if (!key) {
		        return key;
		    }
		    if (options.escapeNumericKeys && util.stringStartsWith(key, '__$EscapedKey$__') && key.substring('__$EscapedKey$__'.length).replace(/\d/g, '').trim().length == 0) {
		        return key.substring('__$EscapedKey$__'.length);
		    }
		    return key;
		}


	/***/ },
	/* 9 */
	/***/ function(module, exports) {

		'use strict';
		var YAMLException = (function () {
		    function YAMLException(reason, mark) {
		        if (mark === void 0) { mark = null; }
		        this.name = 'YAMLException';
		        this.reason = reason;
		        this.mark = mark;
		        this.message = this.toString(false);
		    }
		    YAMLException.prototype.toString = function (compact) {
		        if (compact === void 0) { compact = false; }
		        var result;
		        result = 'JS-YAML: ' + (this.reason || '(unknown reason)');
		        if (!compact && this.mark) {
		            result += ' ' + this.mark.toString();
		        }
		        return result;
		    };
		    return YAMLException;
		})();
		module.exports = YAMLException;


	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		/**
		 * Created by kor on 05/05/15.
		 */
		var Error = __webpack_require__(9);
		var ASTDelta = (function () {
		    function ASTDelta() {
		    }
		    return ASTDelta;
		})();
		exports.ASTDelta = ASTDelta;
		(function (CommandKind) {
		    CommandKind[CommandKind["ADD_CHILD"] = 0] = "ADD_CHILD";
		    CommandKind[CommandKind["REMOVE_CHILD"] = 1] = "REMOVE_CHILD";
		    CommandKind[CommandKind["MOVE_CHILD"] = 2] = "MOVE_CHILD";
		    CommandKind[CommandKind["CHANGE_KEY"] = 3] = "CHANGE_KEY";
		    CommandKind[CommandKind["CHANGE_VALUE"] = 4] = "CHANGE_VALUE";
		    CommandKind[CommandKind["INIT_RAML_FILE"] = 5] = "INIT_RAML_FILE";
		})(exports.CommandKind || (exports.CommandKind = {}));
		var CommandKind = exports.CommandKind;
		var TextChangeCommand = (function () {
		    function TextChangeCommand(offset, replacementLength, text, unit, target) {
		        if (target === void 0) { target = null; }
		        this.offset = offset;
		        this.replacementLength = replacementLength;
		        this.text = text;
		        this.unit = unit;
		        this.target = target;
		    }
		    return TextChangeCommand;
		})();
		exports.TextChangeCommand = TextChangeCommand;
		var CompositeCommand = (function () {
		    function CompositeCommand() {
		        this.commands = [];
		    }
		    return CompositeCommand;
		})();
		exports.CompositeCommand = CompositeCommand;
		var ASTChangeCommand = (function () {
		    function ASTChangeCommand(kind, target, value, position) {
		        this.toSeq = false;
		        this.kind = kind;
		        this.target = target;
		        this.value = value;
		        this.position = position;
		    }
		    return ASTChangeCommand;
		})();
		exports.ASTChangeCommand = ASTChangeCommand;
		function setAttr(t, value) {
		    return new ASTChangeCommand(4 /* CHANGE_VALUE */, t, value, -1);
		}
		exports.setAttr = setAttr;
		function setAttrStructured(t, value) {
		    return new ASTChangeCommand(4 /* CHANGE_VALUE */, t, value.lowLevel(), -1);
		}
		exports.setAttrStructured = setAttrStructured;
		function setKey(t, value) {
		    return new ASTChangeCommand(3 /* CHANGE_KEY */, t, value, -1);
		}
		exports.setKey = setKey;
		function removeNode(t, child) {
		    return new ASTChangeCommand(1 /* REMOVE_CHILD */, t, child, -1);
		}
		exports.removeNode = removeNode;
		function insertNode(t, child, insertAfter, toSeq) {
		    if (insertAfter === void 0) { insertAfter = null; }
		    if (toSeq === void 0) { toSeq = false; }
		    var s = new ASTChangeCommand(0 /* ADD_CHILD */, t, child, -1);
		    s.insertionPoint = insertAfter;
		    s.toSeq = toSeq;
		    return s;
		}
		exports.insertNode = insertNode;
		function initRamlFile(root, newroot) {
		    return new ASTChangeCommand(5 /* INIT_RAML_FILE */, root, newroot, -1);
		}
		exports.initRamlFile = initRamlFile;
		var LineMapperImpl = (function () {
		    function LineMapperImpl(content, absPath) {
		        this.content = content;
		        this.absPath = absPath;
		    }
		    LineMapperImpl.prototype.position = function (_pos) {
		        var pos = _pos;
		        this.initMapping();
		        for (var i = 0; i < this.mapping.length; i++) {
		            var lineLength = this.mapping[i];
		            if (pos < lineLength) {
		                return {
		                    line: i,
		                    column: pos,
		                    position: _pos
		                };
		            }
		            pos -= lineLength;
		        }
		        throw new Error("Character position exceeds text length: " + _pos + " > + " + this.content.length + ".\nUnit path: " + this.absPath);
		    };
		    LineMapperImpl.prototype.initMapping = function () {
		        if (this.mapping != null) {
		            return;
		        }
		        if (this.content == null) {
		            throw new Error("\"Line Mapper has been given null content" + (this.absPath != null ? ('. Path: ' + this.absPath) : 'and null path.'));
		        }
		        this.mapping = [];
		        var ind = 0;
		        var l = this.content.length;
		        for (var i = 0; i < l; i++) {
		            if (this.content.charAt(i) == '\n') {
		                if (i < l - 1 && this.content.charAt(i + 1) == '\r') {
		                    this.mapping.push(i - ind + 2);
		                    ind = i + 2;
		                    i++;
		                }
		                else {
		                    this.mapping.push(i - ind + 1);
		                    ind = i + 1;
		                }
		            }
		            else if (this.content.charAt(i) == '\r') {
		                this.mapping.push(i - ind + 1);
		                ind = i + 1;
		            }
		        }
		        this.mapping.push(l - ind);
		    };
		    return LineMapperImpl;
		})();
		exports.LineMapperImpl = LineMapperImpl;


	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var _ = __webpack_require__(4);
		var Opt = __webpack_require__(12);
		exports.defined = function (x) { return (x !== null) && (x !== undefined); };
		/**
		 * Arrays of Objects are common in RAML08.
		 * @param x
		 * @returns {{}}
		 */
		function flattenArrayOfObjects(x) {
		    var res = {};
		    x.forEach(function (v) { return Object.keys(v).forEach(function (k) { return res[k] = v[k]; }); });
		    return res;
		}
		exports.flattenArrayOfObjects = flattenArrayOfObjects;
		function find(xs, f) {
		    return new Opt(_.find(xs || [], f));
		}
		exports.find = find;
		exports.isInstance = function (v, C) { return (v instanceof C) ? [v] : []; };
		exports.ifInstanceOf = function (v, C, f) { return (v instanceof C) ? f(v) : null; };
		function toTuples(map) {
		    return Object.keys(map).map(function (k) { return [k, map[k]]; });
		}
		exports.toTuples = toTuples;
		function fromTuples(tuples) {
		    var obj = {};
		    tuples.forEach(function (x) { return obj[x[0]] = x[1]; });
		    return obj;
		}
		exports.fromTuples = fromTuples;
		exports.collectInstancesOf = function (xs, C) { return tap([], function (res) { return xs.forEach(function (v) { return exports.ifInstanceOf(v, C, function (x) { return res.push(x); }); }); }); };
		exports.collectInstancesOfInMap = function (map, C) {
		    return Object.keys(map).map(function (k) { return [k, map[k]]; }).filter(function (x) { return x[1] instanceof C; }).map(function (x) { return x; });
		};
		exports.asArray = function (v) { return exports.defined(v) ? ((v instanceof Array) ? v : [v]) : []; };
		exports.shallowCopy = function (obj) { return tap({}, function (copy) { return Object.keys(obj).forEach(function (k) { return copy[k] = obj[k]; }); }); };
		exports.flatMap = function (xs, f) { return exports.flatten(xs.map(f)); };
		exports.flatten = function (xss) { return Array.prototype.concat.apply([], xss); };
		exports.takeWhile = function (xs, f) { return tap([], function (res) {
		    for (var i = 0; i < xs.length; i++) {
		        if (!f(xs[i]))
		            break;
		        res.push(xs[i]);
		    }
		}); };
		function tap(v, f) {
		    f(v);
		    return v;
		}
		exports.tap = tap;
		function kv(obj, iter) {
		    if (typeof obj === 'object')
		        Object.keys(obj).forEach(function (k) { return iter(k, obj[k]); });
		}
		exports.kv = kv;
		function indexed(objects, key, delKey) {
		    if (delKey === void 0) { delKey = false; }
		    var obj = {};
		    objects.forEach(function (original) {
		        var copy = exports.shallowCopy(original);
		        if (delKey)
		            delete copy[key];
		        obj[original[key]] = copy;
		    });
		    return obj;
		}
		exports.indexed = indexed;
		function stringEndsWith(str, search) {
		    var dif = str.length - search.length;
		    return dif >= 0 && str.lastIndexOf(search) === dif;
		}
		exports.stringEndsWith = stringEndsWith;
		function stringStartsWith(str, search) {
		    return str.length - search.length >= 0 && str.substring(0, search.length) === search;
		}
		exports.stringStartsWith = stringStartsWith;
		function lazypropkeyfilter(k) {
		    return k[k.length - 1] == "_"; // ends with underscore
		}
		exports.lazypropkeyfilter = lazypropkeyfilter;
		function lazyprop(obj, key, func) {
		    var result, ready = false;
		    obj[key] = function () {
		        if (!ready) {
		            ready = true;
		            result = func.apply(obj);
		        }
		        return result;
		    };
		}
		function lazyprops(obj, keyfilter) {
		    if (keyfilter === void 0) { keyfilter = lazypropkeyfilter; }
		    for (var k in obj) {
		        if (keyfilter(k)) {
		            exports.ifInstanceOf(obj[k], Function, function (vf) { return (vf.length === 0) ? lazyprop(obj, k, vf) : null; });
		        }
		    }
		}
		exports.lazyprops = lazyprops;
		function iff(v, f) {
		    if (v !== undefined)
		        f(v);
		}
		exports.iff = iff;
		function isRAMLUrl(str) {
		    if (typeof str !== 'string' || str == '')
		        return false;
		    return stringEndsWith(str, ".raml");
		}
		exports.isRAMLUrl = isRAMLUrl;
		function getAllRequiredExternalModulesFromCode(code) {
		    var match;
		    var mods = [];
		    // both quoting styles
		    var r1 = new RegExp("require\\('([^']+)'\\)", "gi");
		    while (match = r1.exec(code)) {
		        mods.push(match[1]);
		    }
		    var r2 = new RegExp('require\\("([^"]+)"\\)', "gi");
		    while (match = r2.exec(code)) {
		        mods.push(match[1]);
		    }
		    mods = _.unique(mods).filter(function (x) { return x != ""; });
		    mods.sort();
		    return mods;
		}
		exports.getAllRequiredExternalModulesFromCode = getAllRequiredExternalModulesFromCode;
		exports.serial = (function () {
		    var i = 0;
		    return function () { return i++; };
		})();
		function isEssential(arg) {
		    return typeof arg !== 'undefined' && arg != null;
		}
		exports.isEssential = isEssential;
		function firstToUpper(q) {
		    if (q.length == 0) {
		        return q;
		    }
		    return q.charAt(0).toUpperCase() + q.substr(1);
		}
		exports.firstToUpper = firstToUpper;
		function updateObject(source, target, addNewFields) {
		    if (addNewFields === void 0) { addNewFields = false; }
		    var keySet = Object.keys(target);
		    if (addNewFields) {
		        var map = {};
		        keySet.forEach(function (x) { return map[x] = true; });
		        Object.keys(source).forEach(function (x) { return map[x] = true; });
		        keySet = Object.keys(map);
		    }
		    keySet.forEach(function (x) {
		        var value = source[x];
		        if (value instanceof Object) {
		            if (!target[x]) {
		                target[x] = {};
		            }
		            updateObject(value, target[x], true);
		        }
		        else if (value != undefined) {
		            target[x] = source[x];
		        }
		    });
		}
		exports.updateObject = updateObject;
		;
		/**
		 * In 'str' replace all occurences of 'map' keys to their values.
		 */
		function replaceMap(str, map) {
		    Object.keys(map).forEach(function (x) { return str = replace(str, x, map[x]); });
		    return str;
		}
		exports.replaceMap = replaceMap;
		/**
		 * Replace all occurences of 'x' in 'str' to 'r' without thinking if 'x' can be passed without
		 * escaping as argument to RegExp constructor
		 */
		function replace(str, x, r) {
		    var result = '';
		    var prev = 0;
		    for (var i = str.indexOf(x); i < str.length && i >= 0; i = str.indexOf(x, prev)) {
		        result += str.substring(prev, i);
		        result += r;
		        prev = i + x.length;
		    }
		    result += str.substring(prev, str.length);
		    return result;
		}
		exports.replace = replace;


	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../typings/tsd.d.ts" />
		var invariant = __webpack_require__(13);
		var exists = function (v) { return (v != null); };
		var globalEmptyOpt;
		var Opt = (function () {
		    function Opt(_value) {
		        var _this = this;
		        this._value = _value;
		        this._isDefined = false;
		        this._isEmpty = true;
		        this._arr = undefined;
		        this.getOrThrow = function () {
		            invariant(_this._isDefined, 'Opt is empty. Use `Opt#getOrElse` or check `Opt#isDefined`.');
		            return _this._value;
		        };
		        this.value = function () { return _this._value; };
		        this.isDefined = function () { return _this._isDefined; };
		        this.isEmpty = function () { return _this._isEmpty; };
		        this.toArray = function () { return _this._arr || (_this._arr = _this._isDefined ? [_this._value] : []); };
		        this.getOrElse = function (v) { return _this._isDefined ? _this._value : v; };
		        this.getOrElseF = function (v) { return _this._isDefined ? _this._value : v(); };
		        this.map = function (f) { return _this._isEmpty ? Opt.empty() : new Opt(f(_this._value)); };
		        this.flatMap = function (f) { return _this.map(f).getOrElse(Opt.empty()); };
		        this.equals = function (other) {
		            invariant(other instanceof Opt, 'Expected other to be an `Opt`, but got `%s`', typeof other);
		            return (_this._isDefined === other.isDefined()) && (_this._value === other.value());
		        };
		        if (exists(this._value)) {
		            this._isDefined = true;
		            this._isEmpty = false;
		        }
		    }
		    Opt.prototype.forEach = function (fn) {
		        if (this.isDefined()) {
		            fn(this._value);
		        }
		    };
		    /**
		     * You can always create an empty option by hand just by calling new Opt<T>()
		     * but calling this method will return a global instance instead of allocating a new one each time
		     */
		    Opt.empty = function () { return (globalEmptyOpt || (globalEmptyOpt = new Opt())); };
		    return Opt;
		})();
		module.exports = Opt;


	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {/**
		 * Copyright 2013-2015, Facebook, Inc.
		 * All rights reserved.
		 *
		 * This source code is licensed under the BSD-style license found in the
		 * LICENSE file in the root directory of this source tree. An additional grant
		 * of patent rights can be found in the PATENTS file in the same directory.
		 */

		'use strict';

		/**
		 * Use invariant() to assert state which your program assumes to be true.
		 *
		 * Provide sprintf-style format (only %s is supported) and arguments
		 * to provide information about what broke and what you were
		 * expecting.
		 *
		 * The invariant message will be stripped in production, but the invariant
		 * will remain to ensure logic does not differ in production.
		 */

		var invariant = function(condition, format, a, b, c, d, e, f) {
		  if (process.env.NODE_ENV !== 'production') {
		    if (format === undefined) {
		      throw new Error('invariant requires an error message argument');
		    }
		  }

		  if (!condition) {
		    var error;
		    if (format === undefined) {
		      error = new Error(
		        'Minified exception occurred; use the non-minified dev environment ' +
		        'for the full error message and additional helpful warnings.'
		      );
		    } else {
		      var args = [a, b, c, d, e, f];
		      var argIndex = 0;
		      error = new Error(
		        format.replace(/%s/g, function() { return args[argIndex++]; })
		      );
		      error.name = 'Invariant Violation';
		    }

		    error.framesToPop = 1; // we don't care about invariant's own frame
		    throw error;
		  }
		};

		module.exports = invariant;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(14)))

	/***/ },
	/* 14 */
	/***/ function(module, exports) {

		// shim for using process in browser

		var process = module.exports = {};
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;

		function cleanUpNextTick() {
		    draining = false;
		    if (currentQueue.length) {
		        queue = currentQueue.concat(queue);
		    } else {
		        queueIndex = -1;
		    }
		    if (queue.length) {
		        drainQueue();
		    }
		}

		function drainQueue() {
		    if (draining) {
		        return;
		    }
		    var timeout = setTimeout(cleanUpNextTick);
		    draining = true;

		    var len = queue.length;
		    while(len) {
		        currentQueue = queue;
		        queue = [];
		        while (++queueIndex < len) {
		            if (currentQueue) {
		                currentQueue[queueIndex].run();
		            }
		        }
		        queueIndex = -1;
		        len = queue.length;
		    }
		    currentQueue = null;
		    draining = false;
		    clearTimeout(timeout);
		}

		process.nextTick = function (fun) {
		    var args = new Array(arguments.length - 1);
		    if (arguments.length > 1) {
		        for (var i = 1; i < arguments.length; i++) {
		            args[i - 1] = arguments[i];
		        }
		    }
		    queue.push(new Item(fun, args));
		    if (queue.length === 1 && !draining) {
		        setTimeout(drainQueue, 0);
		    }
		};

		// v8 likes predictible objects
		function Item(fun, array) {
		    this.fun = fun;
		    this.array = array;
		}
		Item.prototype.run = function () {
		    this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};

		function noop() {}

		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;

		process.binding = function (name) {
		    throw new Error('process.binding is not supported');
		};

		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
		    throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };


	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var yaml = __webpack_require__(7);
		var lowlevel = __webpack_require__(10);
		var path = __webpack_require__(16);
		var fs = __webpack_require__(17);
		var parser = __webpack_require__(18);
		var dumper = __webpack_require__(47);
		var Error = __webpack_require__(9);
		var textutil = __webpack_require__(48);
		var services = __webpack_require__(49);
		var rr = __webpack_require__(111);
		var SimpleExecutor = __webpack_require__(115);
		var util = __webpack_require__(11);
		var URL = __webpack_require__(117);
		exports.Kind = {
		    SCALAR: 0 /* SCALAR */
		};
		var MarkupIndentingBuffer = (function () {
		    function MarkupIndentingBuffer(indent) {
		        this.text = '';
		        this.indent = indent;
		    }
		    MarkupIndentingBuffer.prototype.isLastNL = function () {
		        return this.text.length > 0 && this.text[this.text.length - 1] == '\n';
		    };
		    MarkupIndentingBuffer.prototype.addWithIndent = function (lev, s) {
		        if (this.isLastNL()) {
		            this.text += textutil.indent(lev);
		            this.text += this.indent;
		        }
		        this.text += s;
		    };
		    MarkupIndentingBuffer.prototype.addChar = function (ch) {
		        if (this.isLastNL()) {
		            this.text += this.indent;
		        }
		        this.text += ch;
		    };
		    MarkupIndentingBuffer.prototype.append = function (s) {
		        for (var i = 0; i < s.length; i++) {
		            this.addChar(s[i]);
		        }
		    };
		    return MarkupIndentingBuffer;
		})();
		exports.MarkupIndentingBuffer = MarkupIndentingBuffer;
		var CompilationUnit = (function () {
		    function CompilationUnit(_path, _content, _tl, _project, _apath) {
		        this._path = _path;
		        this._content = _content;
		        this._tl = _tl;
		        this._project = _project;
		        this._apath = _apath;
		    }
		    CompilationUnit.prototype.isStubUnit = function () {
		        return this.stu;
		    };
		    CompilationUnit.prototype.resolveAsync = function (p) {
		        var unit = this._project.resolveAsync(this._path, p);
		        return unit;
		    };
		    CompilationUnit.prototype.getIncludeNodes = function () {
		        var ast = this.ast();
		        var arr = [];
		        ast.gatherIncludes(arr);
		        return arr;
		    };
		    CompilationUnit.prototype.cloneToProject = function (p) {
		        var newUnit = new CompilationUnit(this._path, this._content, this._tl, p, this._apath);
		        return newUnit;
		    };
		    CompilationUnit.prototype.clone = function () {
		        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
		        return newUnit;
		    };
		    CompilationUnit.prototype.stub = function () {
		        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
		        newUnit.stu = true;
		        return newUnit;
		    };
		    CompilationUnit.prototype.isDirty = function () {
		        return false;
		    };
		    CompilationUnit.prototype.absolutePath = function () {
		        return this._apath;
		    };
		    CompilationUnit.prototype.isRAMLUnit = function () {
		        var en = path.extname(this._path);
		        return en == '.raml' || en == '.yaml';
		    };
		    CompilationUnit.prototype.contents = function () {
		        return this._content;
		    };
		    CompilationUnit.prototype.resolve = function (p) {
		        var unit = this._project.resolve(this._path, p);
		        return unit;
		    };
		    CompilationUnit.prototype.path = function () {
		        return this._path;
		    };
		    CompilationUnit.prototype.lexerErrors = function () {
		        if (this.errors == null) {
		            this.ast();
		        }
		        return this.errors;
		    };
		    CompilationUnit.prototype.ast = function () {
		        var _this = this;
		        if (this._node) {
		            return this._node;
		        }
		        try {
		            var result = parser.load(this._content, {});
		            this.errors = result.errors;
		            this.errors.forEach(function (x) {
		                if (x.mark) {
		                    x.mark.filePath = _this.absolutePath();
		                }
		            });
		            this._node = new ASTNode(result, this, null, null, null);
		            this._node._errors = this.errors;
		            return this._node;
		        }
		        catch (e) {
		            this.errors = [];
		            this.errors.push(new Error(e.message));
		            //console.log(this._content)
		            //console.log(e)
		            this._node = null;
		            return this._node;
		        }
		    };
		    CompilationUnit.prototype.isTopLevel = function () {
		        return this._tl;
		    };
		    CompilationUnit.prototype.updateContent = function (n) {
		        this._content = n;
		        this.errors = null;
		        this._node = null; //todo incremental update
		        this._lineMapper = null;
		    };
		    CompilationUnit.prototype.updateContentSafe = function (n) {
		        this._content = n;
		        this._lineMapper = null;
		    };
		    CompilationUnit.prototype.project = function () {
		        return this._project;
		    };
		    CompilationUnit.prototype.lineMapper = function () {
		        if (this._lineMapper == null) {
		            this._lineMapper = new lowlevel.LineMapperImpl(this.contents(), this.absolutePath());
		        }
		        return this._lineMapper;
		    };
		    return CompilationUnit;
		})();
		exports.CompilationUnit = CompilationUnit;
		var HTTPResolverImpl = (function () {
		    function HTTPResolverImpl() {
		        this.executor = new SimpleExecutor.SimpleExecutor();
		    }
		    HTTPResolverImpl.prototype.getResource = function (url) {
		        var response = this.executor.execute({
		            method: 'get',
		            url: url
		        });
		        if (!response) {
		            throw new Error("Unable to execute GET " + url);
		        }
		        var result = this.toResponse(response, url);
		        return result;
		    };
		    HTTPResolverImpl.prototype.getResourceAsync = function (url) {
		        var _this = this;
		        return this.executor.executeAsync({
		            method: 'get',
		            url: url
		        }).then(function (x) {
		            if (!x) {
		                return Promise.reject(new Error("Unable to execute GET " + url));
		            }
		            var result = _this.toResponse(x, url);
		            return result;
		        }, function (x) {
		            return Promise.reject(new Error("Unable to execute GET " + url));
		        });
		    };
		    HTTPResolverImpl.prototype.toResponse = function (response, url) {
		        var msg = null;
		        if (response.status >= 400) {
		            msg = "GET " + url + "\nreturned error: " + response.status;
		            if (response.statusText) {
		                msg += " " + response.statusText;
		            }
		        }
		        var content = null;
		        if (response.content && response.content.text) {
		            content = response.content.text;
		        }
		        var result = {
		            content: content,
		            errorMessage: msg
		        };
		        return result;
		    };
		    return HTTPResolverImpl;
		})();
		exports.HTTPResolverImpl = HTTPResolverImpl;
		var FSResolverImpl = (function () {
		    function FSResolverImpl() {
		    }
		    FSResolverImpl.prototype.content = function (path) {
		        if (!fs.existsSync(path)) {
		            return null;
		        }
		        try {
		            return fs.readFileSync(path).toString();
		        }
		        catch (e) {
		            return null;
		        }
		    };
		    FSResolverImpl.prototype.list = function (path) {
		        return fs.readdirSync(path);
		    };
		    FSResolverImpl.prototype.contentAsync = function (path) {
		        return new Promise(function (resolve, reject) {
		            fs.readFile(path, function (err, data) {
		                if (err != null) {
		                    return reject(err);
		                }
		                var content = data.toString();
		                resolve(content);
		            });
		        });
		    };
		    FSResolverImpl.prototype.listAsync = function (path) {
		        return new Promise(function (reject, resolve) {
		            fs.readdir(path, function (err, files) {
		                if (err != null) {
		                    return reject(err);
		                }
		                resolve(files);
		            });
		        });
		    };
		    return FSResolverImpl;
		})();
		exports.FSResolverImpl = FSResolverImpl;
		function copyNode(n) {
		    if (n == null) {
		        return null;
		    }
		    switch (n.kind) {
		        case 0 /* SCALAR */:
		            return {
		                errors: [],
		                startPosition: n.startPosition,
		                endPosition: n.endPosition,
		                value: n.value,
		                kind: 0 /* SCALAR */,
		                parent: n.parent
		            };
		        case 1 /* MAPPING */:
		            var map = n;
		            return {
		                errors: [],
		                key: copyNode(map.key),
		                value: copyNode(map.value),
		                startPosition: map.startPosition,
		                endPosition: map.endPosition,
		                kind: 1 /* MAPPING */,
		                parent: map.parent
		            };
		        case 2 /* MAP */:
		            var ymap = n;
		            return {
		                errors: [],
		                startPosition: n.startPosition,
		                endPosition: n.endPosition,
		                mappings: ymap.mappings.map(function (x) { return copyNode(x); }),
		                kind: 2 /* MAP */,
		                parent: ymap.parent
		            };
		    }
		    return n;
		}
		var innerShift = function (offset, yaNode, shift) {
		    if (!yaNode)
		        return;
		    if (yaNode.startPosition >= offset) {
		        yaNode.startPosition += shift;
		    }
		    if (yaNode.endPosition > offset) {
		        yaNode.endPosition += shift;
		    }
		    //this kind is a separate case
		    if (yaNode.kind == 1 /* MAPPING */) {
		        var m = yaNode;
		        innerShift(offset, m.key, shift);
		        innerShift(offset, m.value, shift);
		    }
		};
		function splitOnLines(text) {
		    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
		    return lines;
		}
		//TODO IMPROVE INDENTS
		function stripIndent(text, indent) {
		    var lines = splitOnLines(text);
		    var rs = [];
		    for (var i = 0; i < lines.length; i++) {
		        if (i == 0) {
		            rs.push(lines[0]);
		        }
		        else {
		            rs.push(lines[i].substring(indent.length));
		        }
		    }
		    return rs.join("");
		}
		var leadingIndent = function (node, text) {
		    var leading = "";
		    var pos = node.start() - 1;
		    while (pos > 0) {
		        var ch = text[pos];
		        //if (ch == '\r' || ch == '\n' || ch != ' ') break;
		        //console.log('char: [' + ch + ']');
		        if (ch != ' ' && ch != '-')
		            break;
		        leading = ' ' + leading;
		        pos--;
		    }
		    return leading;
		};
		function indent(line) {
		    var rs = "";
		    for (var i = 0; i < line.length; i++) {
		        var c = line[i];
		        if (c == '\r' || c == '\n') {
		            continue;
		        }
		        if (c == ' ' || c == '\t') {
		            rs += c;
		            continue;
		        }
		        break;
		    }
		    return rs;
		}
		function indentLines(s, indent) {
		    return s.split("\n").map(function (x) {
		        if (x.trim().length == 0) {
		            return x;
		        }
		        return indent + x;
		    }).join("\n");
		}
		function extraIndent(text, indent) {
		    var lines = splitOnLines(text);
		    var rs = [];
		    for (var i = 0; i < lines.length; i++) {
		        if (i == 0) {
		            rs.push(lines[0]);
		        }
		        else {
		            if (lines[i].trim().length > 0) {
		                rs.push(indent + lines[i]);
		            }
		            else {
		                rs.push("");
		            }
		        }
		    }
		    return rs.join("");
		}
		var Project = (function () {
		    /**
		     *
		     * @param rootPath - path to folder where your root api is located
		     * @param resolver
		     * @param _httpResolver
		     */
		    function Project(rootPath, resolver, _httpResolver) {
		        this.rootPath = rootPath;
		        this.resolver = resolver;
		        this._httpResolver = _httpResolver;
		        this.listeners = [];
		        this.tlisteners = [];
		        this.pathToUnit = {};
		        if (this.resolver == null) {
		            this.resolver = new FSResolverImpl();
		        }
		        if (this._httpResolver == null) {
		            this._httpResolver = new HTTPResolverImpl();
		        }
		    }
		    Project.prototype.cloneWithResolver = function (newResolver, httpResolver) {
		        if (httpResolver === void 0) { httpResolver = null; }
		        var newProject = new Project(this.rootPath, newResolver, httpResolver ? httpResolver : this._httpResolver);
		        for (var unitPath in this.pathToUnit) {
		            newProject.pathToUnit[unitPath] = this.pathToUnit[unitPath].cloneToProject(newProject);
		        }
		        return newProject;
		    };
		    Project.prototype.setCachedUnitContent = function (pth, cnt, tl) {
		        if (tl === void 0) { tl = true; }
		        var relPath = pth;
		        var apath = toAbsolutePath(this.rootPath, pth);
		        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
		        this.pathToUnit[apath] = unit;
		        return unit;
		    };
		    Project.prototype.resolveAsync = function (unitPath, pathInUnit) {
		        if (!pathInUnit) {
		            return Promise.reject(new Error("Unit path is null"));
		        }
		        if (isWebPath(pathInUnit) || path.isAbsolute(pathInUnit)) {
		            return this.unitAsync(pathInUnit, true);
		        }
		        else if (isWebPath(unitPath) || path.isAbsolute(unitPath)) {
		            var absPath = toAbsolutePath(path.dirname(unitPath), pathInUnit);
		            return this.unitAsync(absPath, true);
		        }
		        var absPath = toAbsolutePath(path.dirname(toAbsolutePath(this.rootPath, unitPath)), pathInUnit);
		        return this.unitAsync(absPath, true);
		    };
		    Project.prototype.resolve = function (unitPath, pathInUnit) {
		        if (!pathInUnit) {
		            return null;
		        }
		        if (isWebPath(pathInUnit) || path.isAbsolute(pathInUnit)) {
		            return this.unit(pathInUnit, true);
		        }
		        else if (isWebPath(unitPath) || path.isAbsolute(unitPath)) {
		            var absPath = toAbsolutePath(path.dirname(unitPath), pathInUnit);
		            return this.unit(absPath, true);
		        }
		        var absPath = toAbsolutePath(path.dirname(toAbsolutePath(this.rootPath, unitPath)), pathInUnit);
		        return this.unit(absPath, true);
		    };
		    Project.prototype.units = function () {
		        var _this = this;
		        if (!this.resolver.list) {
		            throw new Error("Provided FSResolver is unable to list files. Please, use ExtendedFSResolver.");
		        }
		        var names = this.resolver.list(this.rootPath).filter(function (x) { return path.extname(x) == '.raml'; });
		        return names.map(function (x) { return _this.unit(x); }).filter(function (y) { return y.isTopLevel(); });
		    };
		    Project.prototype.unitsAsync = function () {
		        var _this = this;
		        if (!this.resolver.listAsync) {
		            return Promise.reject(new Error("Provided FSResolver is unable to list files. Please, use ExtendedFSResolver."));
		        }
		        return this.resolver.listAsync(this.rootPath).then(function (x) {
		            var promises = x.filter(function (x) { return path.extname(x) == '.raml'; }).map(function (x) { return _this.unitAsync(x).then(function (x) {
		                return x.isTopLevel() ? x : null;
		            }, function (x) {
		                return null;
		            }); });
		            return Promise.all(promises).then(function (arr) {
		                return arr.filter(function (x) { return x != null; });
		            });
		        });
		    };
		    Project.prototype.lexerErrors = function () {
		        var results = [];
		        this.units().forEach(function (x) {
		            results = results.concat(x.lexerErrors());
		        });
		        return results;
		    };
		    Project.prototype.deleteUnit = function (p, absolute) {
		        if (absolute === void 0) { absolute = false; }
		        var apath = null;
		        if (isWebPath(p)) {
		            apath = p;
		        }
		        else {
		            apath = absolute ? p : toAbsolutePath(this.rootPath, p);
		        }
		        delete this.pathToUnit[apath];
		    };
		    Project.prototype.unit = function (p, absolute) {
		        if (absolute === void 0) { absolute = false; }
		        var cnt = null;
		        var apath = p;
		        if (isWebPath(p)) {
		            if (this.pathToUnit[apath]) {
		                return this.pathToUnit[apath];
		            }
		            if (this._httpResolver) {
		                var resp = this._httpResolver.getResource(p);
		                if (resp.errorMessage) {
		                    throw new Error(resp.errorMessage);
		                }
		                cnt = resp.content;
		            }
		            else {
		                cnt = rr.readFromCacheOrGet(p);
		            }
		        }
		        else {
		            if (p.charAt(0) == '/' && !absolute) {
		                p = p.substr(1); //TODO REVIEW IT
		            }
		            var apath = toAbsolutePath(this.rootPath, p);
		            if (this.pathToUnit[apath]) {
		                return this.pathToUnit[apath];
		            }
		            if (isWebPath(apath)) {
		                if (this._httpResolver) {
		                    var resp = this._httpResolver.getResource(apath);
		                    if (resp.errorMessage) {
		                        throw new Error(resp.errorMessage);
		                    }
		                    cnt = resp.content;
		                }
		                else {
		                    cnt = rr.readFromCacheOrGet(apath);
		                }
		            }
		            else {
		                cnt = this.resolver.content(apath);
		            }
		        }
		        if (cnt == null) {
		            return null;
		        }
		        var tl = util.stringStartsWith(cnt, "#%RAML");
		        var relPath = (isWebPath(this.rootPath) == isWebPath(apath)) ? path.relative(this.rootPath, apath) : apath;
		        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
		        this.pathToUnit[apath] = unit;
		        return unit;
		    };
		    Project.prototype.unitAsync = function (p, absolute) {
		        var _this = this;
		        if (absolute === void 0) { absolute = false; }
		        var cnt = null;
		        var apath = p;
		        if (isWebPath(p)) {
		            if (this.pathToUnit[apath]) {
		                return Promise.resolve(this.pathToUnit[apath]);
		            }
		            if (this._httpResolver) {
		                var resp = this._httpResolver.getResourceAsync(apath);
		                cnt = resp.then(function (x) {
		                    if (x.errorMessage) {
		                        return Promise.reject(new Error(x.errorMessage));
		                    }
		                    return x.content;
		                });
		            }
		            else {
		                cnt = Promise.resolve(rr.readFromCacheOrGet(apath));
		            }
		        }
		        else {
		            if (p.charAt(0) == '/' && !absolute) {
		                p = p.substr(1); //TODO REVIEW IT
		            }
		            if (absolute) {
		                apath = p;
		            }
		            else {
		                apath = toAbsolutePath(this.rootPath, p);
		            }
		            if (this.pathToUnit[apath]) {
		                return Promise.resolve(this.pathToUnit[apath]);
		            }
		            if (isWebPath(apath)) {
		                if (this._httpResolver) {
		                    var resp = this._httpResolver.getResourceAsync(apath);
		                    cnt = resp.then(function (x) {
		                        if (x.errorMessage) {
		                            return Promise.reject(new Error(x.errorMessage));
		                        }
		                        return x.content;
		                    });
		                }
		                else {
		                    cnt = Promise.resolve(rr.readFromCacheOrGet(apath));
		                }
		            }
		            else {
		                cnt = this.resolver.contentAsync(apath);
		            }
		        }
		        if (cnt == null) {
		            return Promise.resolve(null);
		        }
		        var relPath = (isWebPath(this.rootPath) == isWebPath(apath)) ? path.relative(this.rootPath, apath) : apath;
		        return cnt.then(function (x) {
		            if (!x) {
		                return Promise.reject(new Error("Can note resolve " + apath));
		            }
		            var tl = util.stringStartsWith(x, "#%RAML");
		            var unit = new CompilationUnit(relPath, x, tl, _this, apath);
		            _this.pathToUnit[apath] = unit;
		            return unit;
		        });
		    };
		    Project.prototype.visualizeNewlines = function (s) {
		        var res = '';
		        for (var i = 0; i < s.length; i++) {
		            var ch = s[i];
		            if (ch == '\r')
		                ch = '\\r';
		            if (ch == '\n')
		                ch = '\\n';
		            res += ch;
		        }
		        return res;
		    };
		    Project.prototype.indent = function (node) {
		        //node.show('NODE');
		        var text = node.unit().contents();
		        //console.log('node text: ' + textutil.replaceNewlines(text.substring(node.start(), node.end())));
		        //console.log('node parent: ' + node.parent());
		        //console.log('node unit: ' + node.unit());
		        if (node == node.root()) {
		            //console.log('node is root');
		            return '';
		        }
		        var leading = leadingIndent(node, text);
		        //console.log('leading: [' + leading + '] ' + leading.length);
		        var dmp = splitOnLines(node.dump());
		        if (dmp.length > 1) {
		            if (dmp[1].trim().length > 0) {
		                //console.log('DMP0: [' + dmp[0] + ']');
		                //console.log('DMP1: [' + dmp[1] + ']');
		                var extra = indent(dmp[1]);
		                return leading + extra;
		            }
		        }
		        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
		        return leading + '  ';
		    };
		    Project.prototype.startIndent = function (node) {
		        var text = node.unit().contents();
		        //console.log('Node text:\n' + this.visualizeNewlines(text.substring(node.start(), node.end())));
		        if (node == node.root())
		            return '';
		        var dmp = splitOnLines(node.dump());
		        if (dmp.length > 0) {
		            console.log('FIRST: ' + dmp[0]);
		            var extra = indent(dmp[0]);
		            return extra + '  ';
		        }
		        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
		        return '';
		    };
		    Project.prototype.canWriteInOneLine = function (node) {
		        return false;
		    };
		    Project.prototype.isOneLine = function (node) {
		        return node.text().indexOf('\n') < 0;
		    };
		    Project.prototype.recalcPositionsUp = function (target) {
		        var np = target;
		        while (np) {
		            np.recalcEndPositionFromChilds();
		            np = np.parent();
		        }
		    };
		    Project.prototype.add2 = function (target, node, toSeq, ipoint, json) {
		        if (json === void 0) { json = false; }
		        var unit = target.unit();
		        var api = target.root();
		        //console.log('api: ' + api);
		        var point = null;
		        if (ipoint) {
		            if (ipoint instanceof ASTNode) {
		                //console.log('insertion: ast node');
		                point = ipoint;
		            }
		            if (ipoint instanceof InsertionPoint) {
		                //console.log('insertion: ip');
		                point = ipoint.point;
		            }
		        }
		        //console.log('target: ' + target.kindName() + '/' + target.valueKindName() + ' node: ' + node.kindName());
		        //if(point) point.show('POINT:');
		        if (target.isValueInclude()) {
		            //console.log('insert to include ref');
		            var childs = target.children();
		            if (childs.length == 0) {
		                throw new Error("not implemented: insert into empty include ref");
		            }
		            var parent = childs[0].parent();
		            //console.log('parent: ' + parent);
		            //parent.show('INCLUDE PARENT:');
		            this.add2(parent, node, toSeq, point, json);
		            return;
		        }
		        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
		        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
		        var unitText = target.unit().contents();
		        if (target.valueKind() == 3 /* SEQ */) {
		            target = createSeq(target.valueAsSeq(), target, target.unit());
		        }
		        var json = this.isJson(target);
		        //console.log('target: ' + target.start() + '..' + target.end());
		        var originalIndent = json ? '' : this.indent(target.isSeq() ? target.parent() : target);
		        //console.log('indent: [' + originalIndent + '] ' + originalIndent.length + '; toseq: ' + toSeq + '; json: ' + json);
		        var xindent = originalIndent;
		        var indentLength = originalIndent.length;
		        var isTargetSeq = target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value); //target.valueKind() == yaml.Kind.SEQ || target.isSeq();
		        //toSeq = false;
		        //console.log('target: ' + target.kindName() + '/' + yaml.Kind[target.valueKind()] + '; toseq: ' + toSeq);
		        //target.root().show("API:");
		        //target.show("TARGET:");
		        //console.log('oindent: ' + originalIndent.length);
		        toSeq = toSeq; // || isTargetSeq;
		        if (toSeq) {
		            if (json) {
		            }
		            else {
		                if (isTargetSeq) {
		                    xindent += "  ";
		                    indentLength += 2;
		                }
		            }
		        }
		        //console.log('xindent: ' + xindent.length);
		        var buf = new MarkupIndentingBuffer(xindent);
		        //target.show('TARGET:');
		        //node.show('NODE1');
		        node.markupNode(buf, node._actualNode(), 0, json);
		        var text = buf.text;
		        //node.show('NODE2', 0, text);
		        //console.log('TEXT TO ADD0: ' + textutil.replaceNewlines(text));
		        if (toSeq) {
		            //if(target.valueKind() == yaml.Kind.SEQ) {
		            var trimText = textutil.trimEnd(text);
		            var trimLen = text.length - trimText.length;
		            if (trimLen > 0) {
		                //console.log('trim len: ' + trimLen);
		                var textlen = text.length;
		                text = text.substring(0, textlen - trimLen);
		                node.shiftNodes(textlen - trimLen, -trimLen);
		            }
		        }
		        //target.show('TARGET2');
		        //node.show('NODE2', 0, text);
		        //console.log('TEXT TO ADD1: ' + textutil.replaceNewlines(text));
		        //console.log('TEXT TO ADD:\n' + this.visualizeNewlines(text));
		        //console.log('toseq: ' + toSeq);
		        if (toSeq && !json) {
		            if (node.highLevelNode()) {
		            }
		            //console.log('target: ' + target.kindName());
		            if (target.isMapping()) {
		            }
		            if (target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value)) {
		                //console.log('--- make it seq');
		                text = originalIndent + '- ' + text;
		            }
		            else {
		                //console.log('--- keep it map');
		                text = originalIndent + text;
		            }
		        }
		        else {
		            text = originalIndent + text;
		        }
		        //console.log('TEXT TO ADD2: ' + textutil.replaceNewlines(text));
		        //target.show('TARGET3');
		        var pos = target.end();
		        //console.log('insert to target end: ' + pos+ ' ; point: ' + point);
		        if (point) {
		            //point.show("POINT");
		            if (point != target) {
		                pos = point.end();
		            }
		            else {
		                if (json && toSeq) {
		                }
		                else {
		                    pos = target.keyEnd() + 1;
		                    pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
		                }
		            }
		        }
		        else {
		            if (json && toSeq) {
		                var seq = target.asSeq();
		                if (seq) {
		                    if (seq.items.length > 0) {
		                        pos = seq.items[seq.items.length - 1].endPosition;
		                    }
		                    else {
		                        pos = seq.endPosition - 1;
		                    }
		                }
		            }
		            else {
		                if (ipoint && (ipoint instanceof InsertionPoint)) {
		                    //ipoint.show('insertion point provided');
		                    var ip = ipoint;
		                    if (ip.type == 1 /* START */) {
		                        pos = target.keyEnd() + 1;
		                        pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
		                    }
		                }
		            }
		        }
		        //console.log('insert poition: ' + pos);
		        var insertionRange = new textutil.TextRange(unitText, 0, pos);
		        pos = insertionRange.extendToNewlines().reduceSpaces().endpos();
		        if (json && target.isSeq()) {
		            var seq = target.asSeq();
		            if (seq.items.length > 0) {
		                text = ', ' + text;
		                indentLength += 2;
		            }
		        }
		        else if (pos > 0 && unitText[pos - 1] != '\n') {
		            text = "\n" + text;
		            indentLength++;
		        }
		        var suffixLen = 0;
		        if (toSeq && !json) {
		            text += '\n';
		            suffixLen++;
		        }
		        //console.log('FINAL TEXT TO ADD: [' + textutil.replaceNewlines(text) + '] at position ' + pos);
		        var newtext = unitText.substring(0, pos) + text + unitText.substring(pos, unitText.length);
		        var cu = unit;
		        cu.updateContentSafe(newtext);
		        this.executeReplace(new textutil.TextRange(unitText, pos, pos), text, cu);
		        //console.log('shift root from position: ' + pos);
		        target.root().shiftNodes(pos, indentLength + (node.end() - node.start()) + suffixLen);
		        //console.log('node len: ' + (node.end()-node.start()));
		        //console.log('text len: ' + text.length);
		        //(<ASTNode>target.root()).shiftNodes(pos, text.length+indentLength);
		        //target.show('TARGET2:');
		        //node.show('NODE TO ADD:');
		        if (point) {
		            var childs = target.children();
		            var index = -1;
		            for (var i = 0; i < childs.length; i++) {
		                var x = childs[i];
		                if (x.start() == point.start() && x.end() == point.end()) {
		                    index = i;
		                    break;
		                }
		            }
		            //console.log('index: ' + index);
		            if (index >= 0) {
		                target.addChild(node, index + 1);
		            }
		            else {
		                target.addChild(node);
		            }
		        }
		        else {
		            target.addChild(node);
		        }
		        node.shiftNodes(0, pos + indentLength);
		        //target.show('TARGET UPDATED:');
		        this.recalcPositionsUp(target);
		        //target.show('TARGET UPDATED POSITIONS:');
		        //api.show('ROOT UPDATED POSITIONS:');
		        node.setUnit(target.unit());
		        node.visit(function (n) {
		            var node = n;
		            node.setUnit(target.unit());
		            return true;
		        });
		    };
		    Project.prototype.isJsonMap = function (node) {
		        if (!node.isMap())
		            return false;
		        var text = node.text().trim();
		        return text.length >= 2 && text[0] == '{' && text[text.length - 1] == '}';
		    };
		    Project.prototype.isJsonSeq = function (node) {
		        if (!node.isSeq())
		            return false;
		        var text = node.text().trim();
		        return text.length >= 2 && text[0] == '[' && text[text.length - 1] == ']';
		    };
		    Project.prototype.isJson = function (node) {
		        return this.isJsonMap(node) || this.isJsonSeq(node);
		    };
		    Project.prototype.remove = function (unit, target, node) {
		        var parent = node.parent();
		        node._oldText = node.dump();
		        //node.showParents('PARENTS:');
		        //console.log('REMOVE NODE: ' + node.kindName() + ' from ' + target.kindName());
		        //console.log('INITIAL SELECTION: [' + textutil.replaceNewlines(range.text()) + ']');
		        //console.log('  text: \n' + unitText.substring(startpos,endpos));
		        if (this.isOneLine(node) && node.isMapping() && node.parent().isMap()) {
		            var mapnode = node.parent();
		            if (mapnode.asMap().mappings.length == 1 && mapnode.parent() != null) {
		                //console.log('REMOVE MAP INSTEAD!');
		                this.remove(unit, mapnode.parent(), mapnode);
		                return;
		            }
		        }
		        if (this.isOneLine(node) && node.isScalar() && node.parent().isSeq()) {
		            var seqnode = node.parent();
		            var seqn = seqnode.asSeq();
		            //console.log('SEQ: ' + seqn.items.length);
		            if (seqn.items.length == 1) {
		                //console.log('REMOVE SEQ INSTEAD!');
		                this.remove(unit, seqnode.parent(), seqnode);
		                return;
		            }
		        }
		        if (target.isMapping() && node.isSeq()) {
		            //console.log('remove seq from mapping');
		            var map = target.parent();
		            //console.log('REMOVE MAPPING INSTEAD!');
		            this.remove(unit, map, target);
		            return;
		        }
		        //target.show('TARGET:');
		        //node.show('NODE:');
		        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
		        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
		        var parentRange = new textutil.TextRange(unit.contents(), parent.start(), parent.end());
		        var originalStartPos = range.startpos();
		        //console.log('REMOVE TEXT: ' +  this.visualizeNewlines(range.text()));
		        if (target.isSeq()) {
		            // extend range to start of line
		            //console.log('RANGE SEQ 0: ' + textutil.replaceNewlines(range.text()));
		            var seq = (node.isSeq() ? node : node.parentOfKind(3 /* SEQ */));
		            //console.log('seq: ' + seq.text() + ' json: ' + this.isJson(seq));
		            if (seq && this.isJson(seq)) {
		                range = range.extendSpaces().extendCharIfAny(',').extendSpaces();
		            }
		            else {
		                range = range.extendToStartOfLine().extendAnyUntilNewLines().extendToNewlines(); //
		            }
		        }
		        if (target.isMap()) {
		            // extend range to end of line
		            //console.log('RANGE MAP 0: [' +  this.visualizeNewlines(range.text()) + ']');
		            range = range.trimEnd().extendAnyUntilNewLines().extendToNewlines();
		            //console.log('RANGE MAP 1: [' +  this.visualizeNewlines(range.text()) + ']');
		            range = range.extendToStartOfLine().extendUntilNewlinesBack();
		        }
		        if (target.kind() == 1 /* MAPPING */) {
		            //console.log('RANGE MAPPING 0: ' +  this.visualizeNewlines(range.text()));
		            //console.log('NODE TEXT: ' + node.text());
		            if (this.isJson(node) && this.isOneLine(node)) {
		            }
		            else {
		                // extend range to end of line
		                //console.log('RANGE MAP 0: ' +  this.visualizeNewlines(range.text()));
		                range = range.extendSpacesUntilNewLines();
		                range = range.extendToNewlines();
		                //console.log('RANGE MAP 2: ' +  this.visualizeNewlines(range.text()));
		                range = range.extendToStartOfLine().extendUntilNewlinesBack();
		            }
		        }
		        if (node.isSeq()) {
		            //console.log('cleanup seq');
		            range = range.reduceSpaces();
		        }
		        //console.log('NODE:\n-----------\n' + range.unitText() + '\n-------------');
		        //console.log('TARGET: ' + target.kindName());
		        //target.show('TARGET');
		        //console.log('FINAL REMOVE TEXT: [' +  this.visualizeNewlines(range.text()) + ']');
		        //console.log('NEW TEXT:\n-----------\n' + range.remove() + '\n-------------');
		        var cu = unit;
		        cu.updateContentSafe(range.remove());
		        this.executeReplace(range, "", cu);
		        //node.parent().show('Before remove');
		        node.parent().removeChild(node);
		        var shift = -range.len();
		        //console.log('shift: ' + shift);
		        target.root().shiftNodes(originalStartPos, shift);
		        this.recalcPositionsUp(target);
		        //this.executeTextChange(new lowlevel.TextChangeCommand(range.startpos(), range.len(), "", unit))
		        //target.show('TARGET AFTER REMOVE:');
		        //target.root().show('API AFTER REMOVE:');
		    };
		    Project.prototype.changeKey = function (unit, attr, newval) {
		        //console.log('set key: ' + newval);
		        var range = new textutil.TextRange(attr.unit().contents(), attr.keyStart(), attr.keyEnd());
		        if (attr.kind() == 1 /* MAPPING */) {
		            var sc = attr._actualNode().key;
		            sc.value = newval;
		            sc.endPosition = sc.startPosition + newval.length;
		        }
		        var cu = unit;
		        this.executeReplace(range, newval, cu);
		        //console.log('new text: ' + this.visualizeNewlines(newtext));
		        var shift = newval.length - range.len();
		        //console.log('shift: ' + shift);
		        attr.root().shiftNodes(range.startpos(), shift, attr);
		        this.recalcPositionsUp(attr);
		    };
		    Project.prototype.executeReplace = function (r, txt, unit) {
		        var command = new lowlevel.TextChangeCommand(r.startpos(), r.endpos() - r.startpos(), txt, unit);
		        unit.project();
		        try {
		            this.tlisteners.forEach(function (x) { return x(command); });
		        }
		        catch (e) {
		            return false;
		        }
		        var newtext = r.replace(txt);
		        unit.updateContentSafe(newtext);
		        return true;
		    };
		    Project.prototype.changeValue = function (unit, attr, newval) {
		        //console.log('set value: ' + newval);mark
		        //console.log('ATTR ' + yaml.Kind[attr.kind()] + '; VALUE: ' + val + ' => ' + newval);
		        //attr.root().show('NODE:');
		        //console.log('TEXT:\n' + attr.unit().contents());
		        var range = new textutil.TextRange(attr.unit().contents(), attr.start(), attr.end());
		        //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
		        //console.log('ATTR: ' + attr.kindName());
		        //attr.root().show('BEFORE');
		        var newNodeText;
		        var prefix = 0;
		        var delta = 0;
		        var replacer = null;
		        var mapping = null;
		        //console.log('attr: ' + attr.kindName());
		        if (attr.kind() == 0 /* SCALAR */) {
		            if (typeof newval == 'string') {
		                attr.asScalar().value = newval;
		                //range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
		                //console.log('Range1: ' + this.visualizeNewlines(range.text()));
		                //console.log('Range0: ' + range.startpos() + '..' + range.endpos());
		                newNodeText = newval;
		            }
		            else {
		                throw new Error("not implemented");
		            }
		        }
		        else if (attr.kind() == 1 /* MAPPING */) {
		            //attr.show('ATTR:');
		            mapping = attr.asMapping();
		            //console.log('mapping val: ' + attr.valueKindName());
		            if (attr.isValueInclude()) {
		                var inc = attr.valueAsInclude();
		                var includePath = inc.value;
		                //console.log("attr.setValue: path: " + includePath);
		                var resolved = attr.unit().resolve(includePath);
		                if (resolved == null) {
		                    console.log("attr.setValue: couldn't resolve: " + includePath);
		                    return; // "can not resolve "+includePath
		                }
		                //console.log("attr.setValue: resolved: " + includePath);
		                if (resolved.isRAMLUnit()) {
		                    //TODO DIFFERENT DATA TYPES, inner references
		                    return;
		                }
		                resolved.updateContent(newval);
		                return;
		            }
		            //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
		            if (mapping.value)
		                range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
		            else
		                range = range.withStart(attr.keyEnd() + 1).withEnd(attr.keyEnd() + 1);
		            //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
		            range = range.reduceNewlinesEnd();
		            //console.log('Range2: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
		            if (newval == null) {
		                newNodeText = '';
		                mapping.value = null;
		            }
		            else if (typeof newval == 'string' || newval == null) {
		                var newstr = newval;
		                var ind = this.indent(attr);
		                //console.log('indent: ' + ind.length);
		                if (newstr && textutil.isMultiLine(newstr)) {
		                    newstr = '' + textutil.makeMutiLine(newstr, ind.length / 2);
		                }
		                newNodeText = newstr;
		                //var valueNode = null;
		                if (!mapping.value) {
		                    console.log('no value');
		                    mapping.value = yaml.newScalar(newstr);
		                    mapping.value.startPosition = attr.keyEnd() + 1;
		                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
		                    mapping.endPosition = mapping.value.endPosition;
		                    if (unit.contents().length > attr.keyEnd() + 1) {
		                        var vlPos = attr.keyEnd() + 1;
		                        if (unit.contents()[vlPos - 1] == ':') {
		                            newNodeText = " " + newNodeText;
		                            mapping.value.startPosition++;
		                            mapping.value.endPosition++;
		                            mapping.endPosition++;
		                            delta++;
		                        }
		                    }
		                }
		                else if (mapping.value.kind == 3 /* SEQ */) {
		                    console.log('seq value');
		                    var v = mapping.value.items[0];
		                    throw "assign value!!!";
		                }
		                else if (mapping.value.kind == 0 /* SCALAR */) {
		                    //console.log('scalar value');
		                    var sc = mapping.value;
		                    var oldtext = sc.value;
		                    //console.log('oldval: ' + sc.value);
		                    //console.log('newstr: ' + newstr + ' ' + newstr.length);
		                    sc.value = newstr;
		                    //console.log('value1: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
		                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
		                    //console.log('value2: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
		                    mapping.endPosition = mapping.value.endPosition;
		                    //console.log('mvalue: ' + mapping.startPosition + '..' + mapping.endPosition);
		                    //console.log('newval: ' + sc.value);
		                    delta += newstr.length - oldtext.length;
		                }
		            }
		            else {
		                var n = newval;
		                if (n.isMapping()) {
		                    newval = createMap([n.asMapping()]);
		                    n = newval;
		                }
		                else if (n.isMap()) {
		                }
		                else {
		                    throw new Error("only MAP/MAPPING nodes allowed as values");
		                }
		                //n.show('NODE1');
		                var buf = new MarkupIndentingBuffer('');
		                n.markupNode(buf, n._actualNode(), 0, true);
		                //n.show('NODE2');
		                newNodeText = '' + buf.text + '';
		                //indent++;
		                //n.shiftNodes(0, 1);
		                //console.log('node text: [[[' + newNodeText + ']]]');
		                //n.show("NN1:", 0, newNodeText);
		                //range = mapping.value? range.withStart(attr.valueStart()).withEnd(attr.valueEnd()) : range.withStart(attr.keyEnd()+1).withEnd(attr.keyEnd()+1 + newNodeText);
		                n.shiftNodes(0, range.startpos() + delta);
		                //n.show("NN2:");
		                replacer = n;
		            }
		        }
		        else {
		            console.log('Unsupported change value case: ' + attr.kindName());
		        }
		        //console.log('RangeX: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
		        //console.log('new node text: ' + newNodeText);
		        var cu = unit;
		        //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
		        //console.log('replace: ' + range.len());
		        //console.log('Range: ' + range.startpos() + '..' + range.endpos());
		        //console.log('OldText: ' + this.visualizeNewlines(cu.contents()));
		        this.executeReplace(range, newNodeText, cu);
		        //var newtext = range.replace(newNodeText);
		        //console.log('NewText: ' + this.visualizeNewlines(newtext));
		        //cu.updateContentSafe(newtext);
		        var shift = newNodeText.length - range.len();
		        //var shift = delta;
		        //attr.root().show('BEFORE SHIFT');
		        //console.log('shift: ' + shift + '; from: ' + (range.endpos() + prefix) + '; delta: ' + delta + '; prefix: ' + prefix);
		        attr.root().shiftNodes(range.endpos() + prefix, shift, attr);
		        //(<ASTNode>attr.root()).shiftNodes(range.endpos()+indent, shift);
		        //attr.show('ATTR2:');
		        if (replacer) {
		            mapping.value = replacer._actualNode();
		        }
		        this.recalcPositionsUp(attr);
		    };
		    Project.prototype.initWithRoot = function (root, newroot) {
		        var shift = root.end();
		        newroot.markup(false);
		        newroot._actualNode().startPosition = shift;
		        newroot._actualNode().endPosition = shift;
		        newroot.setUnit(root.unit());
		    };
		    Project.prototype.execute = function (cmd) {
		        var _this = this;
		        //console.log('Commands: ' + cmd.commands.length);
		        cmd.commands.forEach(function (x) {
		            switch (x.kind) {
		                case 4 /* CHANGE_VALUE */:
		                    var attr = x.target;
		                    var curval = attr.value();
		                    if (!curval) {
		                        curval = "";
		                    }
		                    var newval = x.value;
		                    //console.log('set value: ' + (typeof curval) + ' ==> ' + (typeof newval));
		                    if (typeof curval == 'string' && typeof newval == 'string') {
		                        //console.log('set value: str => str');
		                        if (curval != newval) {
		                            _this.changeValue(attr.unit(), attr, newval);
		                        }
		                    }
		                    else if (typeof curval == 'string' && typeof newval != 'string') {
		                        //console.log('set value: str => obj');
		                        // change structure
		                        //this.changeValue(attr.unit(), attr, null);
		                        _this.changeValue(attr.unit(), attr, newval);
		                    }
		                    else if (typeof curval != 'string' && typeof newval == 'string') {
		                        var newstr = x.value;
		                        if (curval.kind() == 1 /* MAPPING */) {
		                            if (textutil.isMultiLine(newstr)) {
		                                //console.log('multiline');
		                                attr.children().forEach(function (n) {
		                                    _this.remove(attr.unit(), attr, n);
		                                });
		                                _this.changeValue(attr.unit(), attr, newstr);
		                            }
		                            else {
		                                //console.log('singleline');
		                                _this.changeKey(attr.unit(), curval, newstr);
		                            }
		                        }
		                        else {
		                            throw new Error('unsupported case: attribute value conversion: ' + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported');
		                        }
		                    }
		                    else if (typeof curval != 'string' && typeof newval != 'string') {
		                        var newvalnode = newval;
		                        //(<ASTNode>curval).show("OLD:");
		                        //newvalnode.show("NEW:");
		                        if (newvalnode.isMapping()) {
		                            newval = createMap([newvalnode.asMapping()]);
		                        }
		                        //console.log('obj obj: ' + (curval == newval));
		                        if (curval == newval)
		                            break;
		                        // change structure
		                        //console.log('set value: obj => obj');
		                        var node = newval;
		                        var map = node.asMap();
		                        //console.log('attr: ' + attr.kindName() + " " + attr.dump());
		                        attr.children().forEach(function (n) {
		                            _this.remove(attr.unit(), attr, n);
		                        });
		                        node.children().forEach(function (m) {
		                            //this.add2(attr, <ASTNode>m, false, null, true);
		                        });
		                        _this.changeValue(attr.unit(), attr, newval);
		                    }
		                    else {
		                        throw new Error("shouldn't be this case: attribute value conversion " + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported');
		                    }
		                    return;
		                case 3 /* CHANGE_KEY */:
		                    var attr = x.target;
		                    _this.changeKey(attr.unit(), attr, x.value);
		                    return;
		                case 0 /* ADD_CHILD */:
		                    var attr = x.target;
		                    var newValueNode = x.value;
		                    _this.add2(attr, newValueNode, x.toSeq, x.insertionPoint);
		                    return;
		                case 1 /* REMOVE_CHILD */:
		                    var target = x.target;
		                    var node = x.value;
		                    _this.remove(target.unit(), target, node);
		                    return;
		                case 5 /* INIT_RAML_FILE */:
		                    var root = x.target;
		                    var newroot = x.value;
		                    _this.initWithRoot(root, newroot);
		                    return;
		                default:
		                    console.log('UNSUPPORTED COMMAND: ' + lowlevel.CommandKind[x.kind]);
		                    return;
		            }
		        });
		    };
		    Project.prototype.replaceYamlNode = function (target, newNodeContent, offset, shift, unit) {
		        //console.log('New content:\n' + newNodeContent);
		        //target.show('OLD TARGET');
		        var newYamlNode = parser.load(newNodeContent, {});
		        //console.log('new yaml: ' + yaml.Kind[newYamlNode.kind]);
		        this.updatePositions(target.start(), newYamlNode);
		        //console.log('Shift: ' + shift);
		        //(<ASTNode>unit.ast()).shiftNodes(offset, shift);
		        target.root().shiftNodes(offset, shift);
		        var targetParent = target.parent();
		        var targetYamlNode = target._actualNode();
		        var parent = targetYamlNode.parent;
		        newYamlNode.parent = parent;
		        if (targetParent && targetParent.kind() == 2 /* MAP */) {
		            //console.log('MAP!!!');
		            var targetParentMapNode = targetParent._actualNode();
		            targetParentMapNode.mappings = targetParentMapNode.mappings.map(function (x) {
		                if (x != targetYamlNode) {
		                    return x;
		                }
		                return newYamlNode;
		            });
		        }
		        target.updateFrom(newYamlNode);
		        //target.show('MEW TARGET');
		        this.recalcPositionsUp(target);
		    };
		    Project.prototype.executeTextChange2 = function (textCommand) {
		        var cu = textCommand.unit;
		        var unitText = cu.contents();
		        var target = textCommand.target;
		        if (target) {
		            var cnt = unitText.substring(target.start(), target.end());
		            var original = unitText;
		            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
		            var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) + textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
		            cu.updateContentSafe(unitText);
		            if (textCommand.offset > target.start()) {
		                try {
		                    var shift = textCommand.text.length - textCommand.replacementLength;
		                    var offset = textCommand.offset;
		                    target.unit().project().replaceYamlNode(target, newNodeContent, offset, shift, textCommand.unit);
		                }
		                catch (e) {
		                    console.log('New node contents (causes error below): \n' + newNodeContent);
		                    console.log('Reparse error: ' + e.stack);
		                }
		            }
		        }
		        else {
		            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
		        }
		        cu.updateContent(unitText);
		        this.listeners.forEach(function (x) {
		            x(null);
		        });
		        this.tlisteners.forEach(function (x) {
		            x(textCommand);
		        });
		    };
		    Project.prototype.executeTextChange = function (textCommand) {
		        var l0 = new Date().getTime();
		        try {
		            var oc = textCommand.unit.contents();
		            //console.log('Offset: ' + textCommand.offset + '; end: ' + (textCommand.offset + textCommand.replacementLength) + '; len: ' + textCommand.replacementLength);
		            var target = textCommand.target;
		            if (target == null) {
		                target = this.findNode(textCommand.unit.ast(), textCommand.offset, textCommand.offset + textCommand.replacementLength);
		            }
		            var cu = textCommand.unit;
		            if (target) {
		                var cnt = oc.substring(target.start(), target.end());
		                //console.log('Content: ' + cnt);
		                var original = oc;
		                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
		                var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) + textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
		                cu.updateContentSafe(oc);
		                //console.log('UPDATED TEXT: ' + oc);
		                var hasNewLines = breaksTheLine(original, textCommand);
		                if (textCommand.offset > target.start()) {
		                    try {
		                        var newYamlNode = parser.load(newNodeContent, {});
		                        this.updatePositions(target.start(), newYamlNode);
		                        //console.log("Positions updated")
		                        //lets shift all after it
		                        var shift = textCommand.text.length - textCommand.replacementLength;
		                        //console.log('shift: ' + shift);
		                        //console.log('offset: ' + textCommand.offset);
		                        textCommand.unit.ast().shiftNodes(textCommand.offset, shift);
		                        //console.log('Unit AST: ' + textCommand.unit.ast())
		                        if (newYamlNode != null && newYamlNode.kind == 2 /* MAP */) {
		                            var actualResult = newYamlNode.mappings[0];
		                            var targetYamlNode = target._actualNode();
		                            var parent = targetYamlNode.parent;
		                            var cmd = new lowlevel.ASTDelta();
		                            var unit = textCommand.unit;
		                            cmd.commands = [
		                                new lowlevel.ASTChangeCommand(4 /* CHANGE_VALUE */, new ASTNode(copyNode(targetYamlNode), unit, null, null, null), new ASTNode(actualResult, unit, null, null, null), 0)
		                            ];
		                            if (parent && parent.kind == 2 /* MAP */) {
		                                var map = parent;
		                                map.mappings = map.mappings.map(function (x) {
		                                    if (x != targetYamlNode) {
		                                        return x;
		                                    }
		                                    return actualResult;
		                                });
		                            }
		                            actualResult.parent = parent;
		                            //updating low level ast from yaml
		                            this.recalcPositionsUp(target);
		                            target.updateFrom(actualResult);
		                            //console.log("Incremental without listeners: "+(new Date().getTime()-l0));
		                            //console.log("Notify listeners1: " + this.listeners.length + ":" + this.tlisteners.length);
		                            this.listeners.forEach(function (x) {
		                                x(cmd);
		                            });
		                            this.tlisteners.forEach(function (x) {
		                                x(textCommand);
		                            });
		                            //console.log("Incremental update processed");
		                            return;
		                        }
		                    }
		                    catch (e) {
		                        console.log('New node contents (causes error below): \n' + newNodeContent);
		                        console.log('Reparse error: ' + e.stack);
		                    }
		                }
		            }
		            else {
		                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
		            }
		            var t2 = new Date().getTime();
		            //console.log("Full without listeners:"+(t2-l0));
		            //!find node in scope
		            cu.updateContent(oc);
		            //console.log("Notify listeners2: " + this.listeners.length + ":" + this.tlisteners.length);
		            this.listeners.forEach(function (x) {
		                x(null);
		            });
		            this.tlisteners.forEach(function (x) {
		                x(textCommand);
		            });
		        }
		        finally {
		            var t2 = new Date().getTime();
		        }
		    };
		    Project.prototype.updatePositions = function (offset, n) {
		        var _this = this;
		        if (n == null) {
		            return;
		        }
		        if (n.startPosition == -1) {
		            n.startPosition = offset;
		        }
		        else {
		            n.startPosition = offset + n.startPosition;
		        }
		        n.endPosition = offset + n.endPosition;
		        switch (n.kind) {
		            case 2 /* MAP */:
		                var m = n;
		                m.mappings.forEach(function (x) { return _this.updatePositions(offset, x); });
		                break;
		            case 1 /* MAPPING */:
		                var ma = n;
		                this.updatePositions(offset, ma.key);
		                this.updatePositions(offset, ma.value);
		                break;
		            case 0 /* SCALAR */:
		                break;
		            case 3 /* SEQ */:
		                var s = n;
		                s.items.forEach(function (x) { return _this.updatePositions(offset, x); });
		                break;
		        }
		    };
		    Project.prototype.findNode = function (n, offset, end) {
		        var _this = this;
		        if (n == null) {
		            return null;
		        }
		        var node = n;
		        if (n.start() <= offset && n.end() >= end) {
		            var res = n;
		            node.directChildren().forEach(function (x) {
		                var m = _this.findNode(x, offset, end);
		                if (m) {
		                    res = m;
		                }
		            });
		            return res;
		        }
		        return null;
		    };
		    //shiftNodes(n:lowlevel.ILowLevelASTNode, offset:number, shift:number):lowlevel.ILowLevelASTNode{
		    //    var node:ASTNode=<ASTNode>n;
		    //    if (node==null){
		    //        return null;
		    //    }
		    //    node.directChildren().forEach(x=> {
		    //        var m = this.shiftNodes(x, offset, shift);
		    //    })
		    //    var yaNode=(<ASTNode>n)._actualNode();
		    //    if(yaNode) innerShift(offset, yaNode, shift);
		    //    return null;
		    //}
		    Project.prototype.addTextChangeListener = function (listener) {
		        this.tlisteners.push(listener);
		    };
		    Project.prototype.removeTextChangeListener = function (listener) {
		        this.tlisteners = this.tlisteners.filter(function (x) { return x != listener; });
		    };
		    Project.prototype.addListener = function (listener) {
		        this.listeners.push(listener);
		    };
		    Project.prototype.removeListener = function (listener) {
		        this.listeners = this.listeners.filter(function (x) { return x != listener; });
		    };
		    return Project;
		})();
		exports.Project = Project;
		function breaksTheLine(oc, textCommand) {
		    var oldText = oc.substr(textCommand.offset, textCommand.replacementLength);
		    if (oldText.indexOf('\n') != -1) {
		        return true;
		    }
		    if (textCommand.text.indexOf('\n') != -1) {
		        return true;
		    }
		}
		var ASTNode = (function () {
		    function ASTNode(_node, _unit, _parent, _anchor, _include, cacheChildren, _includesContents) {
		        if (cacheChildren === void 0) { cacheChildren = false; }
		        if (_includesContents === void 0) { _includesContents = false; }
		        this._node = _node;
		        this._unit = _unit;
		        this._parent = _parent;
		        this._anchor = _anchor;
		        this._include = _include;
		        this.cacheChildren = cacheChildren;
		        this._includesContents = _includesContents;
		        this._errors = [];
		        if (_node == null) {
		            console.log("null");
		        }
		    }
		    ASTNode.prototype.actual = function () {
		        return this._node;
		    };
		    ASTNode.prototype.yamlNode = function () {
		        return this._node;
		    };
		    ASTNode.prototype.includesContents = function () {
		        return this._includesContents;
		    };
		    ASTNode.prototype.setIncludesContents = function (includesContents) {
		        this._includesContents = includesContents;
		    };
		    ASTNode.prototype.gatherIncludes = function (s, inc, anc, inOneMemberMap) {
		        var _this = this;
		        if (s === void 0) { s = []; }
		        if (inc === void 0) { inc = null; }
		        if (anc === void 0) { anc = null; }
		        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
		        if (this._node == null) {
		            return; //TODO FIXME
		        }
		        var kind = this._node.kind;
		        if (kind == 0 /* SCALAR */) {
		            return;
		        }
		        else if (kind == 2 /* MAP */) {
		            var map = this._node;
		            if (map.mappings.length == 1 && !inOneMemberMap) {
		                new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).gatherIncludes(s);
		            }
		            else {
		                map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); }).forEach(function (x) { return x.gatherIncludes(s); });
		            }
		        }
		        else if (kind == 1 /* MAPPING */) {
		            var mapping = this._node;
		            if (mapping.value == null) {
		            }
		            else {
		                new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren).gatherIncludes(s);
		            }
		        }
		        else if (kind == 3 /* SEQ */) {
		            var seq = this._node;
		            seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); }).forEach(function (x) { return x.gatherIncludes(s); });
		        }
		        else if (kind == 5 /* INCLUDE_REF */) {
		            if (this._unit) {
		                s.push(this);
		            }
		        }
		    };
		    ASTNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
		        this._highLevelParseResult = highLevelParseResult;
		    };
		    ASTNode.prototype.highLevelParseResult = function () {
		        return this._highLevelParseResult;
		    };
		    ASTNode.prototype.setHighLevelNode = function (highLevel) {
		        this._highLevelNode = highLevel;
		    };
		    ASTNode.prototype.highLevelNode = function () {
		        return this._highLevelNode;
		    };
		    ASTNode.prototype.start = function () {
		        return this._node.startPosition;
		    };
		    ASTNode.prototype.errors = function () {
		        return this._errors;
		    };
		    ASTNode.prototype.parent = function () {
		        return this._parent;
		    };
		    ASTNode.prototype.recalcEndPositionFromChilds = function () {
		        var childs = this.children();
		        //if(this.children().length == 0) return;
		        var max = 0;
		        var first = this.children()[0];
		        var last = this.children()[this.children().length - 1];
		        //this.children().forEach(n=> {
		        //    var node: ASTNode = <ASTNode>n;
		        //    if(node._node.endPosition > max) max = node._node.endPosition;
		        //});
		        if (this.isMapping()) {
		            var mapping = this.asMapping();
		            //console.log('reposition: mapping');
		            if (mapping.value) {
		                if (mapping.value.kind == 2 /* MAP */) {
		                    var map = mapping.value;
		                    if (map.startPosition < 0 && first) {
		                        map.startPosition = first.start();
		                    }
		                    if (last)
		                        this._node.endPosition = last._node.endPosition;
		                    //console.log('embedded map: ' + map.startPosition + ".." + map.endPosition);
		                    this._node.endPosition = Math.max(this._node.endPosition, mapping.value.endPosition);
		                }
		                else if (mapping.value.kind == 3 /* SEQ */) {
		                    var seq = mapping.value;
		                    if (seq.startPosition < 0) {
		                        //console.log('*** missed start position');
		                        if (seq.items.length > 0) {
		                            var pos = seq.items[0].startPosition;
		                            var range = new textutil.TextRange(this.unit().contents(), pos, pos);
		                            range = range.extendSpacesBack().extendCharIfAnyBack('-');
		                            seq.startPosition = range.startpos();
		                        }
		                        else {
		                        }
		                    }
		                    //console.log('mapping1     : ' + mapping.startPosition + ".." + mapping.endPosition);
		                    //console.log('embedded seq1: ' + seq.startPosition + ".." + seq.endPosition);
		                    if (seq.items.length > 0) {
		                        var ilast = seq.items[seq.items.length - 1];
		                        this._node.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
		                        seq.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
		                    }
		                }
		                else if (mapping.value.kind == 0 /* SCALAR */) {
		                }
		                else {
		                    if (last)
		                        this._node.endPosition = last._node.endPosition;
		                }
		            }
		        }
		        else {
		            if (last)
		                this._node.endPosition = last._node.endPosition;
		        }
		        //this._node.endPosition = max;;
		    };
		    ASTNode.prototype.isValueLocal = function () {
		        if (this._node.kind == 1 /* MAPPING */) {
		            var knd = this._node.value.kind;
		            return knd != 5 /* INCLUDE_REF */ && knd != 4 /* ANCHOR_REF */;
		        }
		        return true;
		    };
		    ASTNode.prototype.keyStart = function () {
		        if (this._node.kind == 1 /* MAPPING */) {
		            return this._node.key.startPosition;
		        }
		        return -1;
		    };
		    ASTNode.prototype.keyEnd = function () {
		        if (this._node.kind == 1 /* MAPPING */) {
		            return this._node.key.endPosition;
		        }
		        return -1;
		    };
		    ASTNode.prototype.valueStart = function () {
		        if (this._node.kind == 1 /* MAPPING */) {
		            var mapping = this.asMapping();
		            if (mapping.value)
		                return mapping.value.startPosition;
		            else
		                return mapping.endPosition;
		        }
		        return -1;
		    };
		    ASTNode.prototype.valueEnd = function () {
		        if (this._node.kind == 1 /* MAPPING */) {
		            var mn = this.asMapping();
		            return mn.value.endPosition;
		        }
		        return -1;
		    };
		    ASTNode.prototype.end = function () {
		        return this._node.endPosition;
		    };
		    ASTNode.prototype.dump = function () {
		        if (this._oldText) {
		            return this._oldText;
		        }
		        if (this._unit && this._node.startPosition > 0 && this._node.endPosition > 0) {
		            var originalText = this._unit.contents().substring(this._node.startPosition, this._node.endPosition);
		            originalText = stripIndent(originalText, leadingIndent(this, this._unit.contents()));
		            //console.log("L:");
		            //console.log(originalText);
		            return originalText;
		        }
		        return dumper.dump(this.dumpToObject(), {});
		    };
		    ASTNode.prototype.dumpToObject = function (full) {
		        if (full === void 0) { full = false; }
		        return this.dumpNode(this._node, full);
		    };
		    ASTNode.prototype.dumpNode = function (n, full) {
		        var _this = this;
		        if (full === void 0) { full = false; }
		        if (!n) {
		            return null;
		        }
		        if (n.kind == 3 /* SEQ */) {
		            var seq = n;
		            var arr = [];
		            seq.items.forEach(function (x) { return arr.push(_this.dumpNode(x)); });
		            return arr;
		        }
		        if (n.kind == 1 /* MAPPING */) {
		            var c = n;
		            var v = {};
		            var val = c.value;
		            var mm = this.dumpNode(val, full);
		            v["" + this.dumpNode(c.key, full)] = mm;
		            return v;
		        }
		        if (n.kind == 0 /* SCALAR */) {
		            var s = n;
		            return s.value;
		        }
		        if (n.kind == 2 /* MAP */) {
		            var map = n;
		            var res = {};
		            if (map.mappings.length == 1) {
		                if (map.mappings[0].key.value == 'value') {
		                    return this.dumpNode(map.mappings[0].value, full);
		                }
		            }
		            if (map.mappings) {
		                map.mappings.forEach(function (x) {
		                    var ms = _this.dumpNode(x.value, full);
		                    if (ms == null) {
		                        ms = "!$$$novalue";
		                    }
		                    if ((ms + "").length > 0 || full) {
		                        res[_this.dumpNode(x.key, full) + ""] = ms;
		                    }
		                });
		            }
		            return res;
		        }
		    };
		    ASTNode.prototype._actualNode = function () {
		        return this._node;
		    };
		    ASTNode.prototype.execute = function (cmd) {
		        if (this.unit()) {
		            this.unit().project().execute(cmd);
		        }
		        else {
		            cmd.commands.forEach(function (x) {
		                switch (x.kind) {
		                    case 4 /* CHANGE_VALUE */:
		                        var attr = x.target;
		                        var newValue = x.value;
		                        var va = attr._actualNode();
		                        var as = attr.start();
		                        if (va.kind == 1 /* MAPPING */) {
		                            va.value = yaml.newScalar("" + newValue);
		                        }
		                        //this.executeTextChange(new lowlevel.TextChangeCommand(as,attr.value().length,<string>newValue,attr.unit()))
		                        return;
		                    case 3 /* CHANGE_KEY */:
		                        var attr = x.target;
		                        var newValue = x.value;
		                        var va = attr._actualNode();
		                        if (va.kind == 1 /* MAPPING */) {
		                            var sc = va.key;
		                            sc.value = newValue;
		                        }
		                        return;
		                }
		            });
		        }
		    };
		    ASTNode.prototype.updateFrom = function (n) {
		        this._node = n;
		    };
		    ASTNode.prototype.value = function () {
		        if (!this._node) {
		            return "";
		        }
		        if (this._node.kind == 0 /* SCALAR */) {
		            //TODO WHAT IS IT IS INCLUDE ACTUALLY
		            return this._node['value'];
		        }
		        if (this._node.kind == 4 /* ANCHOR_REF */) {
		            var ref = this._node;
		            return new ASTNode(ref.value, this._unit, this, null, null).value();
		        }
		        if (this._node.kind == 1 /* MAPPING */) {
		            var map = this._node;
		            if (map.value == null) {
		                return null;
		            }
		            return new ASTNode(map.value, this._unit, this, null, null).value();
		        }
		        if (this._node.kind == 5 /* INCLUDE_REF */) {
		            //here we should resolve include
		            var includePath = this._node['value'];
		            var resolved = this._unit.resolve(includePath);
		            if (resolved == null) {
		                return "can not resolve " + includePath;
		            }
		            if (resolved.isRAMLUnit()) {
		                //TODO DIFFERENT DATA TYPES, inner references
		                return null;
		            }
		            var text = resolved.contents();
		            if (textutil.isMultiLineValue(text)) {
		                text = textutil.fromMutiLine(text);
		            }
		            return text;
		        }
		        if (this._node.kind == 2 /* MAP */) {
		            var amap = this._node;
		            if (amap.mappings.length == 1) {
		                //handle map with one member case differently
		                return new ASTNode(amap.mappings[0], this._unit, this, null, null);
		            }
		        }
		        if (this._node.kind == 3 /* SEQ */) {
		            var aseq = this._node;
		            if (aseq.items.length == 1 && true) {
		                //handle seq with one member case differently
		                return new ASTNode(aseq.items[0], this._unit, this, null, null).value();
		            }
		        }
		        //this are only kinds which has values
		        return null;
		    };
		    ASTNode.prototype.printDetails = function (indent) {
		        var result = "";
		        if (!indent)
		            indent = "";
		        var typeName = this.kindName();
		        if (this.kind() == 0 /* SCALAR */) {
		            result += indent + "[" + typeName + "]" + " " + this.value() + "\n";
		        }
		        else if (this.kind() == 1 /* MAPPING */ && this._node.value && this._node.value.kind == 0 /* SCALAR */) {
		            result += indent + "[" + typeName + "]" + " " + this.key() + " = " + this.value() + "\n";
		        }
		        else if (this.kind() == 1 /* MAPPING */) {
		            result += indent + "[" + typeName + "]" + " " + this.key() + " = :\n";
		            this.children().forEach(function (child) {
		                result += child.printDetails(indent + "\t");
		            });
		        }
		        else {
		            result += indent + "[" + typeName + "]" + " :\n";
		            this.children().forEach(function (child) {
		                result += child.printDetails(indent + "\t");
		            });
		        }
		        return result;
		    };
		    ASTNode.prototype.visit = function (v) {
		        this.children().forEach(function (x) {
		            if (v(x)) {
		                x.visit(v);
		            }
		        });
		    };
		    ASTNode.prototype.key = function () {
		        if (!this._node) {
		            return "";
		        }
		        if (this._node.kind == 1 /* MAPPING */) {
		            var map = this._node;
		            if (map.key.kind == 3 /* SEQ */) {
		                var items = map.key;
		                var mn = "[";
		                items.items.forEach(function (x) { return mn += x.value; });
		                return mn + "]";
		            }
		            return map.key.value;
		        }
		        //other kinds do not have keys
		        return null;
		    };
		    ASTNode.prototype.addChild = function (n, pos) {
		        if (pos === void 0) { pos = -1; }
		        //this.show('ADD TARGET:');
		        var node = n;
		        //console.log('add-child: ' + this.kindName() + ' .add ' + node.kindName());
		        node._parent = this;
		        this._oldText = null;
		        if (this.isMap()) {
		            //console.log('pos: ' + pos);
		            var map = this.asMap();
		            if (map.mappings == null || map.mappings == undefined) {
		                map.mappings = [];
		            }
		            if (pos >= 0) {
		                map.mappings.splice(pos, 0, node.asMapping());
		            }
		            else {
		                map.mappings.push(node.asMapping());
		            }
		        }
		        else if (this.isMapping()) {
		            var mapping = this.asMapping();
		            var val = mapping.value;
		            //console.log('mapping value: ' + val);
		            if (!mapping.value && node.isMap()) {
		                mapping.value = node._actualNode();
		                return;
		            }
		            if (mapping.value && mapping.value.kind == 0 /* SCALAR */) {
		                // cleanup old value
		                mapping.value = null;
		                val = null;
		            }
		            if (!val) {
		                if (node.isScalar() || node.highLevelNode() && node.highLevelNode().property().getAdapter(services.RAMLPropertyParserService).isEmbedMap()) {
		                    val = yaml.newSeq();
		                }
		                else {
		                    val = yaml.newMap();
		                }
		                mapping.value = val;
		            }
		            if (val.kind == 2 /* MAP */) {
		                var map = val;
		                if (map.mappings == null || map.mappings == undefined) {
		                    map.mappings = [];
		                }
		                if (node.isScalar()) {
		                }
		                if (pos >= 0) {
		                    map.mappings.splice(pos, 0, node.asMapping());
		                }
		                else {
		                    map.mappings.push(node.asMapping());
		                }
		            }
		            else if (val.kind == 3 /* SEQ */) {
		                var seq = val;
		                if (pos >= 0) {
		                    seq.items.splice(pos, 0, node._actualNode());
		                }
		                else {
		                    seq.items.push(node._actualNode());
		                }
		            }
		            else {
		                throw new Error("Insert into mapping with " + yaml.Kind[mapping.value.kind] + " value not supported");
		            }
		        }
		        else if (this.isSeq()) {
		            var seq = this.asSeq();
		            if (pos >= 0) {
		                seq.items.splice(pos, 0, node._actualNode());
		            }
		            else {
		                seq.items.push(node._actualNode());
		            }
		        }
		        else {
		            throw new Error("Insert into " + this.kindName() + " not supported");
		        }
		    };
		    ASTNode.prototype.removeChild = function (n) {
		        this._oldText = null;
		        var node = n;
		        var ynode;
		        var index;
		        //console.log('*** REMOVE FROM: ' + this.kindName());
		        if (this.kind() == 3 /* SEQ */) {
		            //console.log('remove from seq');
		            var seq = this.asSeq();
		            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
		            ynode = node._node;
		            index = seq.items.indexOf(ynode);
		            if (index > -1)
		                seq.items.splice(index, 1);
		        }
		        else if (this.kind() == 2 /* MAP */) {
		            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
		            var map = this.asMap();
		            //console.log('remove from map: ' + map.mappings.length);
		            ynode = node.asMapping();
		            index = map.mappings.indexOf(ynode);
		            //console.log('  index: ' + index);
		            if (index > -1)
		                map.mappings.splice(index, 1);
		        }
		        else if (this.kind() == 1 /* MAPPING */) {
		            //console.log('*** REMOVE FROM MAPPING');
		            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
		            //console.log('remove from mapping with map as value');
		            var mapping = this.asMapping();
		            //this.show("REMOVE TARGET: ***");
		            //node.show("REMOVE NODE: ***");
		            if (node._actualNode() == mapping.value) {
		                // remove right from mapping
		                //console.log('*** remove map from mapping!');
		                mapping.value = null;
		            }
		            else {
		                var map = (mapping.value);
		                ynode = node.asMapping();
		                if (map && map.mappings) {
		                    index = map.mappings.indexOf(ynode);
		                    if (index > -1)
		                        map.mappings.splice(index, 1);
		                }
		            }
		        }
		        else {
		            throw new Error("Delete from " + yaml.Kind[this.kind()] + " unsupported");
		        }
		    };
		    ASTNode.prototype.includeErrors = function () {
		        if (this._node.kind == 1 /* MAPPING */) {
		            var mapping = this._node;
		            if (mapping.value == null) {
		                return [];
		            }
		            return new ASTNode(mapping.value, this._unit, this, this._anchor, this._include).includeErrors();
		        }
		        var rs = [];
		        if (this._node.kind == 5 /* INCLUDE_REF */) {
		            var mapping = this._node;
		            if (mapping.value == null) {
		                return [];
		            }
		            var includePath = this.includePath();
		            var resolved = this._unit.resolve(includePath);
		            if (resolved == null) {
		                rs.push("Can not resolve " + includePath);
		                return rs;
		            }
		            if (resolved.isRAMLUnit()) {
		                var ast = resolved.ast();
		                if (ast) {
		                    return [];
		                }
		                else {
		                    rs.push("" + includePath + " can not be parsed");
		                }
		            }
		        }
		        return rs;
		    };
		    ASTNode.prototype.children = function (inc, anc, inOneMemberMap) {
		        var _this = this;
		        if (inc === void 0) { inc = null; }
		        if (anc === void 0) { anc = null; }
		        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
		        if (this._node == null) {
		            return []; //TODO FIXME
		        }
		        if (this.cacheChildren && this._children) {
		            return this._children;
		        }
		        var result;
		        var kind = this._node.kind;
		        if (kind == 0 /* SCALAR */) {
		            result = [];
		        }
		        else if (kind == 2 /* MAP */) {
		            var map = this._node;
		            if (map.mappings.length == 1 && !inOneMemberMap) {
		                //handle map with one member case differently
		                // q:
		                //  []
		                //   - a
		                //   - b
		                // ->
		                // q:
		                //  a
		                //  b
		                result = new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).children(null, null, true);
		            }
		            else {
		                result = map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
		            }
		        }
		        else if (kind == 1 /* MAPPING */) {
		            var mapping = this._node;
		            if (mapping.value == null) {
		                result = [];
		            }
		            else {
		                var proxy = new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren);
		                result = proxy.children();
		                if (proxy.includesContents()) {
		                    this.setIncludesContents(true);
		                }
		            }
		        }
		        else if (kind == 3 /* SEQ */) {
		            var seq = this._node;
		            result = seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
		        }
		        else if (kind == 5 /* INCLUDE_REF */) {
		            if (this._unit) {
		                var includePath = this.includePath();
		                var resolved = this._unit.resolve(includePath);
		                if (resolved == null) {
		                    result = [];
		                }
		                else if (resolved.isRAMLUnit() && this.canInclude(resolved)) {
		                    var ast = resolved.ast();
		                    if (ast) {
		                        if (this.cacheChildren) {
		                            ast = toChildCahcingNode(ast);
		                        } //else {
		                        //    ast = <ASTNode>toIncludingNode(ast);
		                        //}
		                        result = resolved.ast().children(this, null);
		                        this.setIncludesContents(true);
		                    }
		                }
		            }
		            if (!result) {
		                result = [];
		            }
		        }
		        else if (kind == 4 /* ANCHOR_REF */) {
		            var ref = this._node;
		            result = new ASTNode(ref.value, this._unit, this, null, null, this.cacheChildren).children();
		        }
		        else {
		            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
		        }
		        if (this.cacheChildren) {
		            this._children = result;
		        }
		        return result;
		    };
		    ASTNode.prototype.canInclude = function (unit) {
		        var includedFrom = this.includedFrom();
		        while (includedFrom != null) {
		            if (includedFrom.unit().absolutePath() == unit.absolutePath()) {
		                return false;
		            }
		            includedFrom = includedFrom.includedFrom();
		        }
		        return true;
		    };
		    ASTNode.prototype.directChildren = function (inc, anc, inOneMemberMap) {
		        var _this = this;
		        if (inc === void 0) { inc = null; }
		        if (anc === void 0) { anc = null; }
		        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
		        if (this._node) {
		            switch (this._node.kind) {
		                case 0 /* SCALAR */:
		                    return [];
		                case 2 /* MAP */:
		                    {
		                        var map = this._node;
		                        if (map.mappings.length == 1 && !inOneMemberMap) {
		                            //handle map with one member case differently
		                            return new ASTNode(map.mappings[0].value, this._unit, this, inc, anc).directChildren(null, null, true);
		                        }
		                        return map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
		                    }
		                case 1 /* MAPPING */:
		                    {
		                        var mapping = this._node;
		                        if (mapping.value == null) {
		                            return [];
		                        }
		                        return new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include).directChildren();
		                    }
		                case 3 /* SEQ */:
		                    {
		                        var seq = this._node;
		                        return seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
		                    }
		                case 5 /* INCLUDE_REF */:
		                    {
		                        return [];
		                    }
		                case 4 /* ANCHOR_REF */:
		                    {
		                        return [];
		                    }
		            }
		            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
		        }
		        return [];
		    };
		    ASTNode.prototype.anchorId = function () {
		        return this._node.anchorId;
		    };
		    ASTNode.prototype.unit = function () {
		        return this._unit;
		        //if(this._unit) return this._unit;
		        //if(!this.parent()) return null;
		        //return this.parent().unit();
		    };
		    ASTNode.prototype.setUnit = function (unit) {
		        this._unit = unit;
		    };
		    ASTNode.prototype.includePath = function () {
		        if (this._node.kind == 5 /* INCLUDE_REF */) {
		            var includePath = this._node['value'];
		            return includePath;
		        }
		        else if (this._node.kind == 1 /* MAPPING */) {
		            var mapping = this._node;
		            if (mapping.value == null)
		                return null;
		            return new ASTNode(mapping.value, this._unit, this, null, null).includePath();
		        }
		        return null;
		    };
		    ASTNode.prototype.anchoredFrom = function () {
		        return this._anchor;
		    };
		    ASTNode.prototype.includedFrom = function () {
		        return this._include;
		    };
		    ASTNode.prototype.kind = function () {
		        return this._actualNode().kind;
		    };
		    ASTNode.prototype.valueKind = function () {
		        if (this._node.kind != 1 /* MAPPING */) {
		            return null;
		        }
		        var map = this._node;
		        if (!map.value) {
		            return null;
		        }
		        return map.value.kind;
		    };
		    ASTNode.prototype.valueKindName = function () {
		        var kind = this.valueKind();
		        return kind != undefined ? yaml.Kind[kind] : null;
		    };
		    ASTNode.prototype.kindName = function () {
		        return yaml.Kind[this.kind()];
		    };
		    ASTNode.prototype.indent = function (lev, str) {
		        if (str === void 0) { str = ''; }
		        var leading = '';
		        for (var i = 0; i < lev; i++)
		            leading += '  ';
		        return leading + str;
		    };
		    ASTNode.prototype.replaceNewlines = function (s, rep) {
		        if (rep === void 0) { rep = null; }
		        var res = '';
		        for (var i = 0; i < s.length; i++) {
		            var ch = s[i];
		            if (ch == '\r')
		                ch = rep == null ? '\\r' : rep;
		            if (ch == '\n')
		                ch = rep == null ? '\\n' : rep;
		            res += ch;
		        }
		        return res;
		    };
		    ASTNode.prototype.shortText = function (unittext, maxlen) {
		        if (maxlen === void 0) { maxlen = 50; }
		        var elen = this.end() - this.start();
		        var len = elen;
		        //var len = Math.min(elen,50);
		        var unit = this.unit();
		        if (!unittext && unit) {
		            unittext = unit.contents();
		        }
		        var text;
		        if (!unittext) {
		            text = '[no-unit]';
		        }
		        else {
		            var s = unittext;
		            text = s ? s.substring(this.start(), this.end()) : '[no-text]';
		        }
		        text = "[" + this.start() + ".." + this.end() + "] " + elen + " // " + text + ' //';
		        if (len < elen)
		            text += '...';
		        text = this.replaceNewlines(text);
		        return text;
		    };
		    ASTNode.prototype.nodeShortText = function (node, unittext, maxlen) {
		        if (maxlen === void 0) { maxlen = 50; }
		        var elen = node.endPosition - node.startPosition;
		        var len = elen;
		        //var len = Math.min(elen,50);
		        var unit = this.unit();
		        if (!unittext && unit) {
		            unittext = unit.contents();
		        }
		        var text;
		        if (!unittext) {
		            text = '[no-unit]';
		        }
		        else {
		            var s = unittext;
		            text = s ? s.substring(node.startPosition, node.endPosition) : '[no-text]';
		        }
		        text = "[" + node.startPosition + ".." + node.endPosition + "] " + elen + " // " + text + ' //';
		        if (len < elen)
		            text += '...';
		        text = this.replaceNewlines(text);
		        return text;
		    };
		    ASTNode.prototype.show = function (message, lev, text) {
		        if (message === void 0) { message = null; }
		        if (lev === void 0) { lev = 0; }
		        if (text === void 0) { text = null; }
		        if (message && lev == 0) {
		            console.log(message);
		        }
		        var children = this.children();
		        var desc = this.kindName();
		        var val = this._actualNode().value;
		        if (this.kind() == 1 /* MAPPING */) {
		            desc += '[' + this._actualNode().key.value + ']';
		        }
		        if (val) {
		            desc += "/" + yaml.Kind[val.kind];
		        }
		        else
		            desc += "";
		        if (children.length == 0) {
		            //desc += "/" + this.value();
		            console.log(this.indent(lev) + desc + " // " + this.shortText(text));
		            if (this.isMapping() && this.asMapping().value) {
		                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
		            }
		        }
		        else {
		            console.log(this.indent(lev) + desc + " { // " + this.shortText(text));
		            if (this.isMapping() && this.asMapping().value) {
		                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
		            }
		            children.forEach(function (node) {
		                var n = node;
		                n.show(null, lev + 1, text);
		            });
		            console.log(this.indent(lev) + '}');
		        }
		    };
		    ASTNode.prototype.showParents = function (message, lev) {
		        if (lev === void 0) { lev = 0; }
		        if (message && lev == 0) {
		            console.log(message);
		        }
		        var depth = 0;
		        if (this.parent()) {
		            var n = this.parent();
		            depth = n.showParents(null, lev + 1);
		        }
		        var desc = this.kindName();
		        var val = this._actualNode().value;
		        if (val)
		            desc += "/" + yaml.Kind[val.kind];
		        else
		            desc += "/null";
		        console.log(this.indent(depth) + desc + " // " + this.shortText(null));
		        return depth + 1;
		    };
		    ASTNode.prototype.inlined = function (kind) {
		        return kind == 0 /* SCALAR */ || kind == 5 /* INCLUDE_REF */;
		    };
		    ASTNode.prototype.markupNode = function (xbuf, node, lev, json) {
		        if (json === void 0) { json = false; }
		        var start = xbuf.text.length;
		        switch (node.kind) {
		            case 2 /* MAP */:
		                if (json)
		                    xbuf.append('{');
		                var mappings = node.mappings;
		                for (var i = 0; i < mappings.length; i++) {
		                    if (json && i > 0)
		                        xbuf.append(', ');
		                    this.markupNode(xbuf, mappings[i], lev, json);
		                }
		                if (json)
		                    xbuf.append('}');
		                break;
		            case 3 /* SEQ */:
		                var items = node.items;
		                for (var i = 0; i < items.length; i++) {
		                    xbuf.append(this.indent(lev, '- '));
		                    //this.markupNode(xindent, pos+xbuf.text.length-(lev+1)*2, items[i], lev+1, xbuf);
		                    this.markupNode(xbuf, items[i], lev + 1, json);
		                }
		                break;
		            case 1 /* MAPPING */:
		                var mapping = node;
		                var val = mapping.value;
		                //console.log('mapping: ' + mapping.key.value + ' ' + val.kind);
		                if (json) {
		                    xbuf.append(mapping.key.value);
		                    xbuf.append(': ');
		                    if (val.kind == 0 /* SCALAR */) {
		                        var sc = val;
		                        xbuf.append(sc.value);
		                    }
		                    else if (val.kind == 2 /* MAP */) {
		                        //var mp = <yaml.YamlMap>val;
		                        this.markupNode(xbuf, mapping.value, lev + 1, json);
		                    }
		                    else {
		                        throw new Error("markup not implemented: " + yaml.Kind[val.kind]);
		                    }
		                    break;
		                }
		                xbuf.addWithIndent(lev, mapping.key.value + ':');
		                if (!val) {
		                    xbuf.append('\n');
		                    break;
		                }
		                if (val.kind == 0 /* SCALAR */) {
		                    var sc = val;
		                }
		                //xbuf.append(this.indent(lev, mapping.key.value + ':'));
		                if (mapping.value) {
		                    xbuf.append(this.inlined(mapping.value.kind) ? ' ' : '\n');
		                    this.markupNode(xbuf, mapping.value, lev + 1, json);
		                }
		                else {
		                    xbuf.append('\n');
		                }
		                break;
		            case 0 /* SCALAR */:
		                var sc = node;
		                if (textutil.isMultiLine(sc.value)) {
		                    xbuf.append('|\n');
		                    var lines = splitOnLines(sc.value);
		                    for (var i = 0; i < lines.length; i++) {
		                        xbuf.append(this.indent(lev, lines[i]));
		                    }
		                    xbuf.append('\n');
		                }
		                else {
		                    xbuf.append(sc.value + '\n');
		                }
		                break;
		            case 5 /* INCLUDE_REF */:
		                var ref = node;
		                xbuf.append('!include ' + ref.value + '\n');
		                break;
		            default:
		                throw new Error('Unknown node kind: ' + yaml.Kind[node.kind]);
		                break;
		        }
		        while (start < xbuf.text.length && xbuf.text[start] == ' ')
		            start++;
		        node.startPosition = start;
		        node.endPosition = xbuf.text.length;
		    };
		    ASTNode.prototype.markup = function (json) {
		        if (json === void 0) { json = false; }
		        var buf = new MarkupIndentingBuffer('');
		        this.markupNode(buf, this._actualNode(), 0, json);
		        return buf.text;
		    };
		    ASTNode.prototype.root = function () {
		        var node = this;
		        while (node.parent()) {
		            var p = node.parent();
		            //if(p.isValueInclude()) break; // stop on include
		            node = p;
		        }
		        return node;
		    };
		    ASTNode.prototype.parentOfKind = function (kind) {
		        var p = this.parent();
		        while (p) {
		            if (p.kind() == kind)
		                return p;
		            p = p.parent();
		        }
		        return null;
		    };
		    ASTNode.prototype.find = function (name) {
		        var found = null;
		        //console.log('Looking for: ' + name);
		        this.directChildren().forEach(function (y) {
		            if (y.key() && y.key() == name) {
		                if (!found)
		                    found = y;
		            }
		        });
		        return found;
		    };
		    ASTNode.prototype.shiftNodes = function (offset, shift, exclude) {
		        this.directChildren().forEach(function (x) {
		            if (exclude && exclude.start() == x.start() && exclude.end() == x.end()) {
		            }
		            else {
		                var m = x.shiftNodes(offset, shift, exclude);
		            }
		        });
		        if (exclude && exclude.start() == this.start() && exclude.end() == this.end()) {
		        }
		        else {
		            var yaNode = this._actualNode();
		            if (yaNode)
		                innerShift(offset, yaNode, shift);
		        }
		        return null;
		    };
		    ASTNode.prototype.isMap = function () {
		        return this.kind() == 2 /* MAP */;
		    };
		    ASTNode.prototype.isMapping = function () {
		        return this.kind() == 1 /* MAPPING */;
		    };
		    ASTNode.prototype.isSeq = function () {
		        return this.kind() == 3 /* SEQ */;
		    };
		    ASTNode.prototype.isScalar = function () {
		        return this.kind() == 0 /* SCALAR */;
		    };
		    ASTNode.prototype.asMap = function () {
		        if (!this.isMap())
		            throw new Error("map expected instead of " + this.kindName());
		        return (this._actualNode());
		    };
		    ASTNode.prototype.asMapping = function () {
		        if (!this.isMapping())
		            throw new Error("maping expected instead of " + this.kindName());
		        return (this._actualNode());
		    };
		    ASTNode.prototype.asSeq = function () {
		        if (!this.isSeq())
		            throw new Error("seq expected instead of " + this.kindName());
		        return (this._actualNode());
		    };
		    ASTNode.prototype.asScalar = function () {
		        if (!this.isScalar())
		            throw new Error("scalar expected instead of " + this.kindName());
		        return (this._actualNode());
		    };
		    ASTNode.prototype.isValueSeq = function () {
		        return this.valueKind() == 3 /* SEQ */;
		    };
		    ASTNode.prototype.isValueMap = function () {
		        return this.valueKind() == 2 /* MAP */;
		    };
		    ASTNode.prototype.isValueInclude = function () {
		        return this.valueKind() == 5 /* INCLUDE_REF */;
		    };
		    ASTNode.prototype.isValueScalar = function () {
		        return this.valueKind() == 0 /* SCALAR */;
		    };
		    ASTNode.prototype.valueAsSeq = function () {
		        if (!this.isMapping())
		            throw new Error("mapping expected instead of " + this.kindName());
		        if (this.valueKind() != 3 /* SEQ */)
		            throw new Error("mappng/seq expected instead of mapping/" + this.kindName());
		        return (this.asMapping().value);
		    };
		    ASTNode.prototype.valueAsMap = function () {
		        if (!this.isMapping())
		            throw new Error("mapping expected instead of " + this.kindName());
		        if (this.valueKind() != 2 /* MAP */)
		            throw new Error("mappng/map expected instead of mapping/" + this.kindName());
		        return (this.asMapping().value);
		    };
		    ASTNode.prototype.valueAsScalar = function () {
		        if (!this.isMapping())
		            throw new Error("mapping expected instead of " + this.kindName());
		        if (this.valueKind() != 0 /* SCALAR */)
		            throw new Error("mappng/scalar expected instead of mapping/" + this.kindName());
		        return (this.asMapping().value);
		    };
		    ASTNode.prototype.valueAsInclude = function () {
		        if (!this.isMapping())
		            throw new Error("mapping expected instead of " + this.kindName());
		        if (this.valueKind() != 5 /* INCLUDE_REF */)
		            throw new Error("mappng/include expected instead of mapping/" + this.kindName());
		        return (this.asMapping().value);
		    };
		    ASTNode.prototype.text = function (unitText) {
		        if (unitText === void 0) { unitText = null; }
		        if (!unitText) {
		            if (!this.unit())
		                return '[no-text]';
		            unitText = this.unit().contents();
		        }
		        return unitText.substring(this.start(), this.end());
		    };
		    ASTNode.prototype.copy = function () {
		        var yn = copyNode(this._actualNode());
		        return new ASTNode(yn, this._unit, this._parent, this._anchor, this._include, this._includesContents);
		    };
		    ASTNode.prototype.nodeDefinition = function () {
		        return getDefinitionForLowLevelNode(this);
		    };
		    return ASTNode;
		})();
		exports.ASTNode = ASTNode;
		(function (InsertionPointType) {
		    InsertionPointType[InsertionPointType["NONE"] = 0] = "NONE";
		    InsertionPointType[InsertionPointType["START"] = 1] = "START";
		    InsertionPointType[InsertionPointType["END"] = 2] = "END";
		    InsertionPointType[InsertionPointType["POINT"] = 3] = "POINT";
		})(exports.InsertionPointType || (exports.InsertionPointType = {}));
		var InsertionPointType = exports.InsertionPointType;
		var InsertionPoint = (function () {
		    function InsertionPoint(type, point) {
		        if (point === void 0) { point = null; }
		        this.type = type;
		        this.point = point;
		    }
		    InsertionPoint.after = function (point) {
		        return new InsertionPoint(3 /* POINT */, point);
		    };
		    InsertionPoint.atStart = function () {
		        return new InsertionPoint(1 /* START */);
		    };
		    InsertionPoint.atEnd = function () {
		        return new InsertionPoint(2 /* END */);
		    };
		    InsertionPoint.node = function () {
		        return new InsertionPoint(0 /* NONE */);
		    };
		    InsertionPoint.prototype.show = function (msg) {
		        if (msg) {
		            console.log(msg);
		            console.log('  insertion point type: ' + InsertionPointType[this.type]);
		        }
		        else {
		            console.log('insertion point type: ' + InsertionPointType[this.type]);
		        }
		        if (this.type == 3 /* POINT */ && this.point) {
		            this.point.show();
		        }
		    };
		    return InsertionPoint;
		})();
		exports.InsertionPoint = InsertionPoint;
		function createNode(key) {
		    //console.log('create node: ' + key);
		    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
		    return new ASTNode(node, null, null, null, null);
		}
		exports.createNode = createNode;
		function createMap(mappings) {
		    //console.log('create node: ' + key);
		    var node = yaml.newMap(mappings);
		    return new ASTNode(node, null, null, null, null);
		}
		exports.createMap = createMap;
		function createScalar(value) {
		    var node = yaml.newScalar(value);
		    return new ASTNode(node, null, null, null, null);
		}
		exports.createScalar = createScalar;
		function createSeq(sn, parent, unit) {
		    return new ASTNode(sn, unit, parent, null, null);
		}
		exports.createSeq = createSeq;
		/*
		export function createMappingWithMap(key:string, map: yaml.YAMLNode){
		    //console.log('create node: ' + key);
		    var node:yaml.YAMLNode=yaml.newMapping(yaml.newScalar(key),map);
		    return new ASTNode(node,null,null,null,null);
		}

		export function createMap(){
		    //console.log('create node: ' + key);
		    var node:yaml.YAMLNode=yaml.newMap();
		    return new ASTNode(node,null,null,null,null);
		}
		*/
		function createSeqNode(key) {
		    var node = yaml.newMapping(yaml.newScalar(key), yaml.newItems());
		    return new ASTNode(node, null, null, null, null);
		}
		exports.createSeqNode = createSeqNode;
		function createMapNode(key) {
		    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
		    return new ASTNode(node, null, null, null, null);
		}
		exports.createMapNode = createMapNode;
		function createMapping(key, v) {
		    //console.log('create mapping: ' + key);
		    var node = yaml.newMapping(yaml.newScalar(key), yaml.newScalar(v));
		    return new ASTNode(node, null, null, null, null);
		}
		exports.createMapping = createMapping;
		function toChildCahcingNode(node) {
		    if (!(node instanceof ASTNode)) {
		        return null;
		    }
		    var astNode = node;
		    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, true);
		    result._errors = astNode._errors;
		    return result;
		}
		exports.toChildCahcingNode = toChildCahcingNode;
		function toIncludingNode(node) {
		    if (!(node instanceof ASTNode)) {
		        return null;
		    }
		    var astNode = node;
		    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, false);
		    result._errors = astNode._errors;
		    return result;
		}
		exports.toIncludingNode = toIncludingNode;
		function getDefinitionForLowLevelNode(node) {
		    var hl = node.highLevelNode();
		    if (hl) {
		        return hl.definition();
		    }
		    var parent = node.parent();
		    if (!parent) {
		        return null;
		    }
		    var key = node.key();
		    if (!key) {
		        return null;
		    }
		    var parentDef = parent.nodeDefinition();
		    if (!parentDef) {
		        return null;
		    }
		    if (!parentDef.property) {
		        return null;
		    }
		    var prop = parentDef.property(key);
		    if (!prop) {
		        return null;
		    }
		    return prop.range();
		}
		exports.getDefinitionForLowLevelNode = getDefinitionForLowLevelNode;
		function fetchIncludesAsync(project, apiPath) {
		    var map = {};
		    var errors = {};
		    var nodes = [];
		    var units = [];
		    var processUnits = function (ind) {
		        var lMap = {};
		        while (ind < units.length) {
		            var unit = units[ind];
		            var unitPath = path.dirname(unit.absolutePath());
		            var includeNodes = unit.getIncludeNodes();
		            includeNodes.forEach(function (x) {
		                var ip = x.includePath();
		                var absIncludePath = toAbsolutePath(unitPath, ip);
		                if (map[absIncludePath]) {
		                    return;
		                }
		                if (errors[absIncludePath]) {
		                    x.errors().push(new Error(errors[ip]));
		                    return;
		                }
		                var arr = lMap[absIncludePath];
		                if (!arr) {
		                    arr = [];
		                    lMap[absIncludePath] = arr;
		                }
		                arr.push(x);
		            });
		            ind++;
		        }
		        var unitPaths = Object.keys(lMap);
		        if (unitPaths.length == 0) {
		            return Promise.resolve();
		        }
		        var promises = [];
		        unitPaths.forEach(function (unitPath) {
		            promises.push(project.unitAsync(unitPath).then(function (x) {
		                if (!map[x.absolutePath()]) {
		                    map[x.absolutePath()] = true;
		                    units.push(x);
		                }
		            }, function (x) {
		                lMap[unitPath].forEach(function (node) { return node.errors().push(new Error(x)); });
		                errors[unitPath] = x;
		            }));
		        });
		        return Promise.all(promises).then(function (x) {
		            return processUnits(ind);
		        });
		    };
		    return project.unitAsync(apiPath).then(function (x) {
		        units.push(x);
		        map[x.absolutePath()] = true;
		        return processUnits(0);
		    }).then(function (x) {
		        return units.length > 0 ? units[0] : null;
		    });
		}
		exports.fetchIncludesAsync = fetchIncludesAsync;
		function toAbsolutePath(rootPath, relPath) {
		    if (isWebPath(relPath)) {
		        return relPath;
		    }
		    var apath;
		    if (isWebPath(rootPath)) {
		        var rp = util.stringEndsWith(rootPath, "/") ? rootPath : rootPath + "/";
		        apath = URL.resolve(rp, relPath);
		    }
		    else {
		        apath = path.resolve(rootPath, relPath);
		    }
		    return apath;
		}
		function isWebPath(str) {
		    return util.stringStartsWith(str, "http://") || util.stringStartsWith(str, "https://");
		}


	/***/ },
	/* 16 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(3);

	/***/ },
	/* 17 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(5);

	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		'use strict';
		var loader = __webpack_require__(19);
		var dumper = __webpack_require__(47);
		function deprecated(name) {
		    return function () {
		        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
		    };
		}
		exports.Type = __webpack_require__(24);
		exports.Schema = __webpack_require__(23);
		exports.FAILSAFE_SCHEMA = __webpack_require__(27);
		exports.JSON_SCHEMA = __webpack_require__(26);
		exports.CORE_SCHEMA = __webpack_require__(25);
		exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
		exports.DEFAULT_FULL_SCHEMA = __webpack_require__(42);
		exports.load = loader.load;
		exports.loadAll = loader.loadAll;
		exports.safeLoad = loader.safeLoad;
		exports.safeLoadAll = loader.safeLoadAll;
		exports.dump = dumper.dump;
		exports.safeDump = dumper.safeDump;
		exports.YAMLException = __webpack_require__(9);
		// Deprecared schema names from JS-YAML 2.0.x
		exports.MINIMAL_SCHEMA = __webpack_require__(27);
		exports.SAFE_SCHEMA = __webpack_require__(22);
		exports.DEFAULT_SCHEMA = __webpack_require__(42);
		// Deprecated functions from JS-YAML 1.x.x
		exports.scan = deprecated('scan');
		exports.parse = deprecated('parse');
		exports.compose = deprecated('compose');
		exports.addConstructor = deprecated('addConstructor');


	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../../typings/tsd.d.ts" />
		var ast = __webpack_require__(7);
		'use strict';
		/*eslint-disable max-len,no-use-before-define*/
		var common = __webpack_require__(20);
		var YAMLException = __webpack_require__(9);
		var Mark = __webpack_require__(21);
		var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
		var DEFAULT_FULL_SCHEMA = __webpack_require__(42);
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		var CONTEXT_FLOW_IN = 1;
		var CONTEXT_FLOW_OUT = 2;
		var CONTEXT_BLOCK_IN = 3;
		var CONTEXT_BLOCK_OUT = 4;
		var CHOMPING_CLIP = 1;
		var CHOMPING_STRIP = 2;
		var CHOMPING_KEEP = 3;
		var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
		var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
		var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
		var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
		var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
		function is_EOL(c) {
		    return (c === 0x0A) || (c === 0x0D);
		}
		function is_WHITE_SPACE(c) {
		    return (c === 0x09) || (c === 0x20);
		}
		function is_WS_OR_EOL(c) {
		    return (c === 0x09) || (c === 0x20) || (c === 0x0A) || (c === 0x0D);
		}
		function is_FLOW_INDICATOR(c) {
		    return 0x2C === c || 0x5B === c || 0x5D === c || 0x7B === c || 0x7D === c;
		}
		function fromHexCode(c) {
		    var lc;
		    if ((0x30 <= c) && (c <= 0x39)) {
		        return c - 0x30;
		    }
		    /*eslint-disable no-bitwise*/
		    lc = c | 0x20;
		    if ((0x61 <= lc) && (lc <= 0x66)) {
		        return lc - 0x61 + 10;
		    }
		    return -1;
		}
		function escapedHexLen(c) {
		    if (c === 0x78) {
		        return 2;
		    }
		    if (c === 0x75) {
		        return 4;
		    }
		    if (c === 0x55) {
		        return 8;
		    }
		    return 0;
		}
		function fromDecimalCode(c) {
		    if ((0x30 <= c) && (c <= 0x39)) {
		        return c - 0x30;
		    }
		    return -1;
		}
		function simpleEscapeSequence(c) {
		    return (c === 0x30) ? '\x00' : (c === 0x61) ? '\x07' : (c === 0x62) ? '\x08' : (c === 0x74) ? '\x09' : (c === 0x09) ? '\x09' : (c === 0x6E) ? '\x0A' : (c === 0x76) ? '\x0B' : (c === 0x66) ? '\x0C' : (c === 0x72) ? '\x0D' : (c === 0x65) ? '\x1B' : (c === 0x20) ? ' ' : (c === 0x22) ? '\x22' : (c === 0x2F) ? '/' : (c === 0x5C) ? '\x5C' : (c === 0x4E) ? '\x85' : (c === 0x5F) ? '\xA0' : (c === 0x4C) ? '\u2028' : (c === 0x50) ? '\u2029' : '';
		}
		function charFromCodepoint(c) {
		    if (c <= 0xFFFF) {
		        return String.fromCharCode(c);
		    }
		    // Encode UTF-16 surrogate pair
		    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
		    return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800, ((c - 0x010000) & 0x03FF) + 0xDC00);
		}
		var simpleEscapeCheck = new Array(256); // integer, for fast access
		var simpleEscapeMap = new Array(256);
		for (var i = 0; i < 256; i++) {
		    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
		    simpleEscapeMap[i] = simpleEscapeSequence(i);
		}
		var State = (function () {
		    function State(input, options) {
		        this.errorMap = {};
		        this.errors = [];
		        this.input = input;
		        this.filename = options['filename'] || null;
		        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
		        this.onWarning = options['onWarning'] || null;
		        this.legacy = options['legacy'] || false;
		        this.implicitTypes = this.schema.compiledImplicit;
		        this.typeMap = this.schema.compiledTypeMap;
		        this.length = input.length;
		        this.position = 0;
		        this.line = 0;
		        this.lineStart = 0;
		        this.lineIndent = 0;
		        this.documents = [];
		    }
		    return State;
		})();
		function generateError(state, message) {
		    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line - 1, (state.position - state.lineStart)));
		}
		function throwError(state, message) {
		    //FIXME
		    var error = generateError(state, message);
		    var hash = error.message + error.mark.position;
		    if (!state.errorMap[hash]) {
		        state.errors.push(error);
		        state.errorMap[hash] = 1;
		    }
		    var or = state.position;
		    while (true) {
		        if (state.position >= state.input.length - 1) {
		            return;
		        }
		        var c = state.input.charAt(state.position);
		        if (c == '\n') {
		            state.position--;
		            if (state.position == or) {
		                state.position += 1;
		            }
		            return;
		        }
		        if (c == '\r') {
		            state.position--;
		            if (state.position == or) {
		                state.position += 1;
		            }
		            return;
		        }
		        state.position++;
		    }
		    //throw generateError(state, message);
		}
		function throwWarning(state, message) {
		    var error = generateError(state, message);
		    if (state.onWarning) {
		        state.onWarning.call(null, error);
		    }
		    else {
		    }
		}
		var directiveHandlers = {
		    YAML: function handleYamlDirective(state, name, args) {
		        var match, major, minor;
		        if (null !== state.version) {
		            throwError(state, 'duplication of %YAML directive');
		        }
		        if (1 !== args.length) {
		            throwError(state, 'YAML directive accepts exactly one argument');
		        }
		        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
		        if (null === match) {
		            throwError(state, 'ill-formed argument of the YAML directive');
		        }
		        major = parseInt(match[1], 10);
		        minor = parseInt(match[2], 10);
		        if (1 !== major) {
		            throwError(state, 'unacceptable YAML version of the document');
		        }
		        state.version = args[0];
		        state.checkLineBreaks = (minor < 2);
		        if (1 !== minor && 2 !== minor) {
		            throwWarning(state, 'unsupported YAML version of the document');
		        }
		    },
		    TAG: function handleTagDirective(state, name, args) {
		        var handle, prefix;
		        if (2 !== args.length) {
		            throwError(state, 'TAG directive accepts exactly two arguments');
		        }
		        handle = args[0];
		        prefix = args[1];
		        if (!PATTERN_TAG_HANDLE.test(handle)) {
		            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
		        }
		        if (_hasOwnProperty.call(state.tagMap, handle)) {
		            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
		        }
		        if (!PATTERN_TAG_URI.test(prefix)) {
		            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
		        }
		        state.tagMap[handle] = prefix;
		    }
		};
		function captureSegment(state, start, end, checkJson) {
		    var _position, _length, _character, _result;
		    var scalar = state.result;
		    if (scalar.startPosition == -1) {
		        scalar.startPosition = start;
		    }
		    if (start < end) {
		        _result = state.input.slice(start, end);
		        if (checkJson) {
		            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
		                _character = _result.charCodeAt(_position);
		                if (!(0x09 === _character || 0x20 <= _character && _character <= 0x10FFFF)) {
		                    throwError(state, 'expected valid JSON character');
		                }
		            }
		        }
		        scalar.value += _result;
		        scalar.endPosition = end;
		    }
		}
		function mergeMappings(state, destination, source) {
		    var sourceKeys, key, index, quantity;
		    if (!common.isObject(source)) {
		        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
		    }
		    sourceKeys = Object.keys(source);
		    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
		        key = sourceKeys[index];
		        if (!_hasOwnProperty.call(destination, key)) {
		            destination[key] = source[key];
		        }
		    }
		}
		function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
		    var index, quantity;
		    if (keyNode == null) {
		        return;
		    }
		    //keyNode = String(keyNode);
		    if (null === _result) {
		        _result = {
		            startPosition: keyNode.startPosition,
		            endPosition: valueNode.endPosition,
		            parent: null,
		            errors: [],
		            mappings: [],
		            kind: 2 /* MAP */
		        };
		    }
		    if ('tag:yaml.org,2002:merge' === keyTag) {
		        throw new Error("Should not happen");
		    }
		    else {
		        var mapping = ast.newMapping(keyNode, valueNode);
		        mapping.parent = _result;
		        keyNode.parent = mapping;
		        if (valueNode != null) {
		            valueNode.parent = mapping;
		        }
		        _result.mappings.push(mapping);
		        _result.endPosition = valueNode ? valueNode.endPosition : keyNode.endPosition + 1; //FIXME.workaround should be position of ':' indeed
		    }
		    return _result;
		}
		function readLineBreak(state) {
		    var ch;
		    ch = state.input.charCodeAt(state.position);
		    if (0x0A === ch) {
		        state.position++;
		    }
		    else if (0x0D === ch) {
		        state.position++;
		        if (0x0A === state.input.charCodeAt(state.position)) {
		            state.position++;
		        }
		    }
		    else {
		        throwError(state, 'a line break is expected');
		    }
		    state.line += 1;
		    state.lineStart = state.position;
		}
		function skipSeparationSpace(state, allowComments, checkIndent) {
		    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
		    while (0 !== ch) {
		        while (is_WHITE_SPACE(ch)) {
		            ch = state.input.charCodeAt(++state.position);
		        }
		        if (allowComments && 0x23 === ch) {
		            do {
		                ch = state.input.charCodeAt(++state.position);
		            } while (ch !== 0x0A && ch !== 0x0D && 0 !== ch);
		        }
		        if (is_EOL(ch)) {
		            readLineBreak(state);
		            ch = state.input.charCodeAt(state.position);
		            lineBreaks++;
		            state.lineIndent = 0;
		            while (0x20 === ch) {
		                state.lineIndent++;
		                ch = state.input.charCodeAt(++state.position);
		            }
		        }
		        else {
		            break;
		        }
		    }
		    if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
		        throwWarning(state, 'deficient indentation');
		    }
		    return lineBreaks;
		}
		function testDocumentSeparator(state) {
		    var _position = state.position, ch;
		    ch = state.input.charCodeAt(_position);
		    // Condition state.position === state.lineStart is tested
		    // in parent on each call, for efficiency. No needs to test here again.
		    if ((0x2D === ch || 0x2E === ch) && state.input.charCodeAt(_position + 1) === ch && state.input.charCodeAt(_position + 2) === ch) {
		        _position += 3;
		        ch = state.input.charCodeAt(_position);
		        if (ch === 0 || is_WS_OR_EOL(ch)) {
		            return true;
		        }
		    }
		    return false;
		}
		function writeFoldedLines(state, scalar, count) {
		    if (1 === count) {
		        scalar.value += ' ';
		    }
		    else if (count > 1) {
		        scalar.value += common.repeat('\n', count - 1);
		    }
		}
		function readPlainScalar(state, nodeIndent, withinFlowCollection) {
		    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
		    var state_result = ast.newScalar();
		    state.result = state_result;
		    ch = state.input.charCodeAt(state.position);
		    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 0x23 === ch || 0x26 === ch || 0x2A === ch || 0x21 === ch || 0x7C === ch || 0x3E === ch || 0x27 === ch || 0x22 === ch || 0x25 === ch || 0x40 === ch || 0x60 === ch) {
		        return false;
		    }
		    if (0x3F === ch || 0x2D === ch) {
		        following = state.input.charCodeAt(state.position + 1);
		        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
		            return false;
		        }
		    }
		    state.kind = 'scalar';
		    //state.result = '';
		    captureStart = captureEnd = state.position;
		    hasPendingContent = false;
		    while (0 !== ch) {
		        if (0x3A === ch) {
		            following = state.input.charCodeAt(state.position + 1);
		            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
		                break;
		            }
		        }
		        else if (0x23 === ch) {
		            preceding = state.input.charCodeAt(state.position - 1);
		            if (is_WS_OR_EOL(preceding)) {
		                break;
		            }
		        }
		        else if ((state.position === state.lineStart && testDocumentSeparator(state)) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
		            break;
		        }
		        else if (is_EOL(ch)) {
		            _line = state.line;
		            _lineStart = state.lineStart;
		            _lineIndent = state.lineIndent;
		            skipSeparationSpace(state, false, -1);
		            if (state.lineIndent >= nodeIndent) {
		                hasPendingContent = true;
		                ch = state.input.charCodeAt(state.position);
		                continue;
		            }
		            else {
		                state.position = captureEnd;
		                state.line = _line;
		                state.lineStart = _lineStart;
		                state.lineIndent = _lineIndent;
		                break;
		            }
		        }
		        if (hasPendingContent) {
		            captureSegment(state, captureStart, captureEnd, false);
		            writeFoldedLines(state, state_result, state.line - _line);
		            captureStart = captureEnd = state.position;
		            hasPendingContent = false;
		        }
		        if (!is_WHITE_SPACE(ch)) {
		            captureEnd = state.position + 1;
		        }
		        ch = state.input.charCodeAt(++state.position);
		        if (state.position >= state.input.length) {
		            return false;
		        }
		    }
		    captureSegment(state, captureStart, captureEnd, false);
		    if (state.result.startPosition != -1) {
		        return true;
		    }
		    state.kind = _kind;
		    state.result = _result;
		    return false;
		}
		function readSingleQuotedScalar(state, nodeIndent) {
		    var ch, captureStart, captureEnd;
		    ch = state.input.charCodeAt(state.position);
		    if (0x27 !== ch) {
		        return false;
		    }
		    var scalar = ast.newScalar();
		    state.kind = 'scalar';
		    state.result = scalar;
		    scalar.startPosition = state.position;
		    state.position++;
		    captureStart = captureEnd = state.position;
		    while (0 !== (ch = state.input.charCodeAt(state.position))) {
		        //console.log('ch: <' + String.fromCharCode(ch) + '>');
		        if (0x27 === ch) {
		            captureSegment(state, captureStart, state.position, true);
		            ch = state.input.charCodeAt(++state.position);
		            //console.log('next: <' + String.fromCharCode(ch) + '>');
		            scalar.endPosition = state.position;
		            if (0x27 === ch) {
		                captureStart = captureEnd = state.position;
		                state.position++;
		            }
		            else {
		                return true;
		            }
		        }
		        else if (is_EOL(ch)) {
		            captureSegment(state, captureStart, captureEnd, true);
		            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
		            captureStart = captureEnd = state.position;
		        }
		        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
		            throwError(state, 'unexpected end of the document within a single quoted scalar');
		        }
		        else {
		            state.position++;
		            captureEnd = state.position;
		            scalar.endPosition = state.position;
		        }
		    }
		    throwError(state, 'unexpected end of the stream within a single quoted scalar');
		}
		function readDoubleQuotedScalar(state, nodeIndent) {
		    var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
		    ch = state.input.charCodeAt(state.position);
		    if (0x22 !== ch) {
		        return false;
		    }
		    state.kind = 'scalar';
		    var scalar = ast.newScalar();
		    scalar.doubleQuoted = true;
		    state.result = scalar;
		    scalar.startPosition = state.position;
		    state.position++;
		    captureStart = captureEnd = state.position;
		    while (0 !== (ch = state.input.charCodeAt(state.position))) {
		        if (0x22 === ch) {
		            captureSegment(state, captureStart, state.position, true);
		            state.position++;
		            scalar.endPosition = state.position;
		            return true;
		        }
		        else if (0x5C === ch) {
		            captureSegment(state, captureStart, state.position, true);
		            ch = state.input.charCodeAt(++state.position);
		            if (is_EOL(ch)) {
		                skipSeparationSpace(state, false, nodeIndent);
		            }
		            else if (ch < 256 && simpleEscapeCheck[ch]) {
		                scalar.value += simpleEscapeMap[ch];
		                state.position++;
		            }
		            else if ((tmp = escapedHexLen(ch)) > 0) {
		                hexLength = tmp;
		                hexResult = 0;
		                for (; hexLength > 0; hexLength--) {
		                    ch = state.input.charCodeAt(++state.position);
		                    if ((tmp = fromHexCode(ch)) >= 0) {
		                        hexResult = (hexResult << 4) + tmp;
		                    }
		                    else {
		                        throwError(state, 'expected hexadecimal character');
		                    }
		                }
		                scalar.value += charFromCodepoint(hexResult);
		                state.position++;
		            }
		            else {
		                throwError(state, 'unknown escape sequence');
		            }
		            captureStart = captureEnd = state.position;
		        }
		        else if (is_EOL(ch)) {
		            captureSegment(state, captureStart, captureEnd, true);
		            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
		            captureStart = captureEnd = state.position;
		        }
		        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
		            throwError(state, 'unexpected end of the document within a double quoted scalar');
		        }
		        else {
		            state.position++;
		            captureEnd = state.position;
		        }
		    }
		    throwError(state, 'unexpected end of the stream within a double quoted scalar');
		}
		function readFlowCollection(state, nodeIndent) {
		    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, keyNode, keyTag, valueNode, ch;
		    ch = state.input.charCodeAt(state.position);
		    if (ch === 0x5B) {
		        terminator = 0x5D; /* ] */
		        isMapping = false;
		        _result = ast.newItems();
		        _result.startPosition = state.position;
		    }
		    else if (ch === 0x7B) {
		        terminator = 0x7D; /* } */
		        isMapping = true;
		        _result = ast.newMap();
		        _result.startPosition = state.position;
		    }
		    else {
		        return false;
		    }
		    if (null !== state.anchor) {
		        _result.anchorId = state.anchor;
		        state.anchorMap[state.anchor] = _result;
		    }
		    ch = state.input.charCodeAt(++state.position);
		    while (0 !== ch) {
		        skipSeparationSpace(state, true, nodeIndent);
		        ch = state.input.charCodeAt(state.position);
		        if (ch === terminator) {
		            state.position++;
		            state.tag = _tag;
		            state.anchor = _anchor;
		            state.kind = isMapping ? 'mapping' : 'sequence';
		            state.result = _result;
		            _result.endPosition = state.position;
		            return true;
		        }
		        else if (!readNext) {
		            var p = state.position;
		            throwError(state, 'missed comma between flow collection entries');
		            state.position = p + 1;
		        }
		        keyTag = keyNode = valueNode = null;
		        isPair = isExplicitPair = false;
		        if (0x3F === ch) {
		            following = state.input.charCodeAt(state.position + 1);
		            if (is_WS_OR_EOL(following)) {
		                isPair = isExplicitPair = true;
		                state.position++;
		                skipSeparationSpace(state, true, nodeIndent);
		            }
		        }
		        _line = state.line;
		        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
		        keyTag = state.tag;
		        keyNode = state.result;
		        skipSeparationSpace(state, true, nodeIndent);
		        ch = state.input.charCodeAt(state.position);
		        if ((isExplicitPair || state.line === _line) && 0x3A === ch) {
		            isPair = true;
		            ch = state.input.charCodeAt(++state.position);
		            skipSeparationSpace(state, true, nodeIndent);
		            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
		            valueNode = state.result;
		        }
		        if (isMapping) {
		            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
		        }
		        else if (isPair) {
		            var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
		            mp.parent = _result;
		            _result.items.push(mp);
		        }
		        else {
		            keyNode.parent = _result;
		            _result.items.push(keyNode);
		        }
		        _result.endPosition = state.position + 1;
		        skipSeparationSpace(state, true, nodeIndent);
		        ch = state.input.charCodeAt(state.position);
		        if (0x2C === ch) {
		            readNext = true;
		            ch = state.input.charCodeAt(++state.position);
		        }
		        else {
		            readNext = false;
		        }
		    }
		    throwError(state, 'unexpected end of the stream within a flow collection');
		}
		function readBlockScalar(state, nodeIndent) {
		    var captureStart, folding, chomping = CHOMPING_CLIP, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
		    ch = state.input.charCodeAt(state.position);
		    if (ch === 0x7C) {
		        folding = false;
		    }
		    else if (ch === 0x3E) {
		        folding = true;
		    }
		    else {
		        return false;
		    }
		    var sc = ast.newScalar();
		    state.kind = 'scalar';
		    state.result = sc;
		    sc.startPosition = state.position;
		    while (0 !== ch) {
		        ch = state.input.charCodeAt(++state.position);
		        if (0x2B === ch || 0x2D === ch) {
		            if (CHOMPING_CLIP === chomping) {
		                chomping = (0x2B === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
		            }
		            else {
		                throwError(state, 'repeat of a chomping mode identifier');
		            }
		        }
		        else if ((tmp = fromDecimalCode(ch)) >= 0) {
		            if (tmp === 0) {
		                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
		            }
		            else if (!detectedIndent) {
		                textIndent = nodeIndent + tmp - 1;
		                detectedIndent = true;
		            }
		            else {
		                throwError(state, 'repeat of an indentation width identifier');
		            }
		        }
		        else {
		            break;
		        }
		    }
		    if (is_WHITE_SPACE(ch)) {
		        do {
		            ch = state.input.charCodeAt(++state.position);
		        } while (is_WHITE_SPACE(ch));
		        if (0x23 === ch) {
		            do {
		                ch = state.input.charCodeAt(++state.position);
		            } while (!is_EOL(ch) && (0 !== ch));
		        }
		    }
		    while (0 !== ch) {
		        readLineBreak(state);
		        state.lineIndent = 0;
		        ch = state.input.charCodeAt(state.position);
		        while ((!detectedIndent || state.lineIndent < textIndent) && (0x20 === ch)) {
		            state.lineIndent++;
		            ch = state.input.charCodeAt(++state.position);
		        }
		        if (!detectedIndent && state.lineIndent > textIndent) {
		            textIndent = state.lineIndent;
		        }
		        if (is_EOL(ch)) {
		            emptyLines++;
		            continue;
		        }
		        // End of the scalar.
		        if (state.lineIndent < textIndent) {
		            // Perform the chomping.
		            if (chomping === CHOMPING_KEEP) {
		                sc.value += common.repeat('\n', emptyLines);
		            }
		            else if (chomping === CHOMPING_CLIP) {
		                if (detectedIndent) {
		                    sc.value += '\n';
		                }
		            }
		            break;
		        }
		        // Folded style: use fancy rules to handle line breaks.
		        if (folding) {
		            // Lines starting with white space characters (more-indented lines) are not folded.
		            if (is_WHITE_SPACE(ch)) {
		                atMoreIndented = true;
		                sc.value += common.repeat('\n', emptyLines + 1);
		            }
		            else if (atMoreIndented) {
		                atMoreIndented = false;
		                sc.value += common.repeat('\n', emptyLines + 1);
		            }
		            else if (0 === emptyLines) {
		                if (detectedIndent) {
		                    sc.value += ' ';
		                }
		            }
		            else {
		                sc.value += common.repeat('\n', emptyLines);
		            }
		        }
		        else if (detectedIndent) {
		            // If current line isn't the first one - count line break from the last content line.
		            sc.value += common.repeat('\n', emptyLines + 1);
		        }
		        else {
		        }
		        detectedIndent = true;
		        emptyLines = 0;
		        captureStart = state.position;
		        while (!is_EOL(ch) && (0 !== ch)) {
		            ch = state.input.charCodeAt(++state.position);
		        }
		        captureSegment(state, captureStart, state.position, false);
		    }
		    sc.endPosition = state.position;
		    var i = state.position - 1;
		    var needMinus = false;
		    while (true) {
		        var c = state.input[i];
		        if (c == '\r' || c == '\n') {
		            if (needMinus) {
		                i--;
		            }
		            break;
		        }
		        if (c != ' ' && c != '\t') {
		            break;
		        }
		        i--;
		    }
		    sc.endPosition = i;
		    return true;
		}
		function readBlockSequence(state, nodeIndent) {
		    var _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newItems(), following, detected = false, ch;
		    if (null !== state.anchor) {
		        _result.anchorId = state.anchor;
		        state.anchorMap[state.anchor] = _result;
		    }
		    _result.startPosition = state.position;
		    ch = state.input.charCodeAt(state.position);
		    while (0 !== ch) {
		        if (0x2D !== ch) {
		            break;
		        }
		        following = state.input.charCodeAt(state.position + 1);
		        if (!is_WS_OR_EOL(following)) {
		            break;
		        }
		        detected = true;
		        state.position++;
		        if (skipSeparationSpace(state, true, -1)) {
		            if (state.lineIndent <= nodeIndent) {
		                _result.items.push(null);
		                ch = state.input.charCodeAt(state.position);
		                continue;
		            }
		        }
		        _line = state.line;
		        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
		        state.result.parent = _result;
		        _result.items.push(state.result);
		        skipSeparationSpace(state, true, -1);
		        ch = state.input.charCodeAt(state.position);
		        if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
		            throwError(state, 'bad indentation of a sequence entry');
		        }
		        else if (state.lineIndent < nodeIndent) {
		            break;
		        }
		    }
		    _result.endPosition = state.position;
		    if (detected) {
		        state.tag = _tag;
		        state.anchor = _anchor;
		        state.kind = 'sequence';
		        state.result = _result;
		        _result.endPosition = state.position;
		        return true;
		    }
		    return false;
		}
		function readBlockMapping(state, nodeIndent, flowIndent) {
		    var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newMap(), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
		    _result.startPosition = state.position;
		    if (null !== state.anchor) {
		        _result.anchorId = state.anchor;
		        state.anchorMap[state.anchor] = _result;
		    }
		    ch = state.input.charCodeAt(state.position);
		    while (0 !== ch) {
		        following = state.input.charCodeAt(state.position + 1);
		        _line = state.line; // Save the current line.
		        //
		        // Explicit notation case. There are two separate blocks:
		        // first for the key (denoted by "?") and second for the value (denoted by ":")
		        //
		        if ((0x3F === ch || 0x3A === ch) && is_WS_OR_EOL(following)) {
		            if (0x3F === ch) {
		                if (atExplicitKey) {
		                    storeMappingPair(state, _result, keyTag, keyNode, null);
		                    keyTag = keyNode = valueNode = null;
		                }
		                detected = true;
		                atExplicitKey = true;
		                allowCompact = true;
		            }
		            else if (atExplicitKey) {
		                // i.e. 0x3A/* : */ === character after the explicit key.
		                atExplicitKey = false;
		                allowCompact = true;
		            }
		            else {
		                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
		            }
		            state.position += 1;
		            ch = following;
		        }
		        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
		            if (state.line === _line) {
		                ch = state.input.charCodeAt(state.position);
		                while (is_WHITE_SPACE(ch)) {
		                    ch = state.input.charCodeAt(++state.position);
		                }
		                if (0x3A === ch) {
		                    ch = state.input.charCodeAt(++state.position);
		                    if (!is_WS_OR_EOL(ch)) {
		                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
		                    }
		                    if (atExplicitKey) {
		                        storeMappingPair(state, _result, keyTag, keyNode, null);
		                        keyTag = keyNode = valueNode = null;
		                    }
		                    detected = true;
		                    atExplicitKey = false;
		                    allowCompact = false;
		                    keyTag = state.tag;
		                    keyNode = state.result;
		                }
		                else if (detected) {
		                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');
		                }
		                else {
		                    state.tag = _tag;
		                    state.anchor = _anchor;
		                    return true; // Keep the result of `composeNode`.
		                }
		            }
		            else if (detected) {
		                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
		                while (state.position > 0) {
		                    ch = state.input.charCodeAt(--state.position);
		                    if (is_EOL(ch)) {
		                        state.position++;
		                        break;
		                    }
		                }
		            }
		            else {
		                state.tag = _tag;
		                state.anchor = _anchor;
		                return true; // Keep the result of `composeNode`.
		            }
		        }
		        else {
		            break;
		        }
		        //
		        // Common reading code for both explicit and implicit notations.
		        //
		        if (state.line === _line || state.lineIndent > nodeIndent) {
		            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
		                if (atExplicitKey) {
		                    keyNode = state.result;
		                }
		                else {
		                    valueNode = state.result;
		                }
		            }
		            if (!atExplicitKey) {
		                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
		                keyTag = keyNode = valueNode = null;
		            }
		            skipSeparationSpace(state, true, -1);
		            ch = state.input.charCodeAt(state.position);
		        }
		        if (state.lineIndent > nodeIndent && (0 !== ch)) {
		            throwError(state, 'bad indentation of a mapping entry');
		        }
		        else if (state.lineIndent < nodeIndent) {
		            break;
		        }
		    }
		    //
		    // Epilogue.
		    //
		    // Special case: last mapping's node contains only the key in explicit notation.
		    if (atExplicitKey) {
		        storeMappingPair(state, _result, keyTag, keyNode, null);
		    }
		    // Expose the resulting mapping.
		    if (detected) {
		        state.tag = _tag;
		        state.anchor = _anchor;
		        state.kind = 'mapping';
		        state.result = _result;
		    }
		    return detected;
		}
		function readTagProperty(state) {
		    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
		    ch = state.input.charCodeAt(state.position);
		    if (0x21 !== ch) {
		        return false;
		    }
		    if (null !== state.tag) {
		        throwError(state, 'duplication of a tag property');
		    }
		    ch = state.input.charCodeAt(++state.position);
		    if (0x3C === ch) {
		        isVerbatim = true;
		        ch = state.input.charCodeAt(++state.position);
		    }
		    else if (0x21 === ch) {
		        isNamed = true;
		        tagHandle = '!!';
		        ch = state.input.charCodeAt(++state.position);
		    }
		    else {
		        tagHandle = '!';
		    }
		    _position = state.position;
		    if (isVerbatim) {
		        do {
		            ch = state.input.charCodeAt(++state.position);
		        } while (0 !== ch && 0x3E !== ch);
		        if (state.position < state.length) {
		            tagName = state.input.slice(_position, state.position);
		            ch = state.input.charCodeAt(++state.position);
		        }
		        else {
		            throwError(state, 'unexpected end of the stream within a verbatim tag');
		        }
		    }
		    else {
		        while (0 !== ch && !is_WS_OR_EOL(ch)) {
		            if (0x21 === ch) {
		                if (!isNamed) {
		                    tagHandle = state.input.slice(_position - 1, state.position + 1);
		                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
		                        throwError(state, 'named tag handle cannot contain such characters');
		                    }
		                    isNamed = true;
		                    _position = state.position + 1;
		                }
		                else {
		                    throwError(state, 'tag suffix cannot contain exclamation marks');
		                }
		            }
		            ch = state.input.charCodeAt(++state.position);
		        }
		        tagName = state.input.slice(_position, state.position);
		        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
		            throwError(state, 'tag suffix cannot contain flow indicator characters');
		        }
		    }
		    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
		        throwError(state, 'tag name cannot contain such characters: ' + tagName);
		    }
		    if (isVerbatim) {
		        state.tag = tagName;
		    }
		    else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
		        state.tag = state.tagMap[tagHandle] + tagName;
		    }
		    else if ('!' === tagHandle) {
		        state.tag = '!' + tagName;
		    }
		    else if ('!!' === tagHandle) {
		        state.tag = 'tag:yaml.org,2002:' + tagName;
		    }
		    else {
		        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
		    }
		    return true;
		}
		function readAnchorProperty(state) {
		    var _position, ch;
		    ch = state.input.charCodeAt(state.position);
		    if (0x26 !== ch) {
		        return false;
		    }
		    if (null !== state.anchor) {
		        throwError(state, 'duplication of an anchor property');
		    }
		    ch = state.input.charCodeAt(++state.position);
		    _position = state.position;
		    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
		        ch = state.input.charCodeAt(++state.position);
		    }
		    if (state.position === _position) {
		        throwError(state, 'name of an anchor node must contain at least one character');
		    }
		    state.anchor = state.input.slice(_position, state.position);
		    return true;
		}
		function readAlias(state) {
		    var _position, alias, len = state.length, input = state.input, ch;
		    ch = state.input.charCodeAt(state.position);
		    if (0x2A !== ch) {
		        return false;
		    }
		    ch = state.input.charCodeAt(++state.position);
		    _position = state.position;
		    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
		        ch = state.input.charCodeAt(++state.position);
		    }
		    if (state.position <= _position) {
		        throwError(state, 'name of an alias node must contain at least one character');
		        state.position = _position + 1;
		    }
		    alias = state.input.slice(_position, state.position);
		    if (!state.anchorMap.hasOwnProperty(alias)) {
		        throwError(state, 'unidentified alias "' + alias + '"');
		        if (state.position <= _position) {
		            state.position = _position + 1;
		        }
		    }
		    state.result = ast.newAnchorRef(alias, _position, state.position, state.anchorMap[alias]);
		    skipSeparationSpace(state, true, -1);
		    return true;
		}
		function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
		    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent, _result;
		    state.tag = null;
		    state.anchor = null;
		    state.kind = null;
		    state.result = null;
		    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
		    if (allowToSeek) {
		        if (skipSeparationSpace(state, true, -1)) {
		            atNewLine = true;
		            if (state.lineIndent > parentIndent) {
		                indentStatus = 1;
		            }
		            else if (state.lineIndent === parentIndent) {
		                indentStatus = 0;
		            }
		            else if (state.lineIndent < parentIndent) {
		                indentStatus = -1;
		            }
		        }
		    }
		    if (1 === indentStatus) {
		        while (readTagProperty(state) || readAnchorProperty(state)) {
		            if (skipSeparationSpace(state, true, -1)) {
		                atNewLine = true;
		                allowBlockCollections = allowBlockStyles;
		                if (state.lineIndent > parentIndent) {
		                    indentStatus = 1;
		                }
		                else if (state.lineIndent === parentIndent) {
		                    indentStatus = 0;
		                }
		                else if (state.lineIndent < parentIndent) {
		                    indentStatus = -1;
		                }
		            }
		            else {
		                allowBlockCollections = false;
		            }
		        }
		    }
		    if (allowBlockCollections) {
		        allowBlockCollections = atNewLine || allowCompact;
		    }
		    if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
		        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
		            flowIndent = parentIndent;
		        }
		        else {
		            flowIndent = parentIndent + 1;
		        }
		        blockIndent = state.position - state.lineStart;
		        if (1 === indentStatus) {
		            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
		                hasContent = true;
		            }
		            else {
		                if ((allowBlockScalars && readBlockScalar(state, flowIndent)) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
		                    hasContent = true;
		                }
		                else if (readAlias(state)) {
		                    hasContent = true;
		                    if (null !== state.tag || null !== state.anchor) {
		                        throwError(state, 'alias node should not have any properties');
		                    }
		                }
		                else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
		                    hasContent = true;
		                    if (null === state.tag) {
		                        state.tag = '?';
		                    }
		                }
		                if (null !== state.anchor) {
		                    state.anchorMap[state.anchor] = state.result;
		                    state.result.anchorId = state.anchor;
		                }
		            }
		        }
		        else if (0 === indentStatus) {
		            // Special case: block sequences are allowed to have same indentation level as the parent.
		            // http://www.yaml.org/spec/1.2/spec.html#id2799784
		            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
		        }
		    }
		    if (null !== state.tag && '!' !== state.tag) {
		        if (state.tag == "!include") {
		            if (!state.result) {
		                state.result = ast.newScalar();
		                state.result.startPosition = state.position;
		                state.result.endPosition = state.position;
		                throwError(state, "!include without value");
		            }
		            state.result.kind = 5 /* INCLUDE_REF */;
		        }
		        else if ('?' === state.tag) {
		            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
		                type = state.implicitTypes[typeIndex];
		                // Implicit resolving is not allowed for non-scalar types, and '?'
		                // non-specific tag is only assigned to plain scalars. So, it isn't
		                // needed to check for 'kind' conformity.
		                var vl = state.result['value'];
		                if (type.resolve(vl)) {
		                    state.result.valueObject = type.construct(state.result['value']);
		                    state.tag = type.tag;
		                    if (null !== state.anchor) {
		                        state.result.anchorId = state.anchor;
		                        state.anchorMap[state.anchor] = state.result;
		                    }
		                    break;
		                }
		            }
		        }
		        else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
		            type = state.typeMap[state.tag];
		            if (null !== state.result && type.kind !== state.kind) {
		                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
		            }
		            if (!type.resolve(state.result)) {
		                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
		            }
		            else {
		                state.result = type.construct(state.result);
		                if (null !== state.anchor) {
		                    state.result.anchorId = state.anchor;
		                    state.anchorMap[state.anchor] = state.result;
		                }
		            }
		        }
		        else {
		            throwWarning(state, 'unknown tag !<' + state.tag + '>');
		        }
		    }
		    return null !== state.tag || null !== state.anchor || hasContent;
		}
		function readDocument(state) {
		    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
		    state.version = null;
		    state.checkLineBreaks = state.legacy;
		    state.tagMap = {};
		    state.anchorMap = {};
		    while (0 !== (ch = state.input.charCodeAt(state.position))) {
		        skipSeparationSpace(state, true, -1);
		        ch = state.input.charCodeAt(state.position);
		        if (state.lineIndent > 0 || 0x25 !== ch) {
		            break;
		        }
		        hasDirectives = true;
		        ch = state.input.charCodeAt(++state.position);
		        _position = state.position;
		        while (0 !== ch && !is_WS_OR_EOL(ch)) {
		            ch = state.input.charCodeAt(++state.position);
		        }
		        directiveName = state.input.slice(_position, state.position);
		        directiveArgs = [];
		        if (directiveName.length < 1) {
		            throwError(state, 'directive name must not be less than one character in length');
		        }
		        while (0 !== ch) {
		            while (is_WHITE_SPACE(ch)) {
		                ch = state.input.charCodeAt(++state.position);
		            }
		            if (0x23 === ch) {
		                do {
		                    ch = state.input.charCodeAt(++state.position);
		                } while (0 !== ch && !is_EOL(ch));
		                break;
		            }
		            if (is_EOL(ch)) {
		                break;
		            }
		            _position = state.position;
		            while (0 !== ch && !is_WS_OR_EOL(ch)) {
		                ch = state.input.charCodeAt(++state.position);
		            }
		            directiveArgs.push(state.input.slice(_position, state.position));
		        }
		        if (0 !== ch) {
		            readLineBreak(state);
		        }
		        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
		            directiveHandlers[directiveName](state, directiveName, directiveArgs);
		        }
		        else {
		            throwWarning(state, 'unknown document directive "' + directiveName + '"');
		            state.position++;
		        }
		    }
		    skipSeparationSpace(state, true, -1);
		    if (0 === state.lineIndent && 0x2D === state.input.charCodeAt(state.position) && 0x2D === state.input.charCodeAt(state.position + 1) && 0x2D === state.input.charCodeAt(state.position + 2)) {
		        state.position += 3;
		        skipSeparationSpace(state, true, -1);
		    }
		    else if (hasDirectives) {
		        throwError(state, 'directives end mark is expected');
		    }
		    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
		    skipSeparationSpace(state, true, -1);
		    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
		        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
		    }
		    state.documents.push(state.result);
		    if (state.position === state.lineStart && testDocumentSeparator(state)) {
		        if (0x2E === state.input.charCodeAt(state.position)) {
		            state.position += 3;
		            skipSeparationSpace(state, true, -1);
		        }
		        return;
		    }
		    if (state.position < (state.length - 1)) {
		        throwError(state, 'end of the stream or a document separator is expected');
		    }
		    else {
		        return;
		    }
		}
		function loadDocuments(input, options) {
		    input = String(input);
		    options = options || {};
		    if (input.length !== 0) {
		        // Add tailing `\n` if not exists
		        if (0x0A !== input.charCodeAt(input.length - 1) && 0x0D !== input.charCodeAt(input.length - 1)) {
		            input += '\n';
		        }
		        // Strip BOM
		        if (input.charCodeAt(0) === 0xFEFF) {
		            input = input.slice(1);
		        }
		    }
		    var state = new State(input, options);
		    if (PATTERN_NON_PRINTABLE.test(state.input)) {
		        throwError(state, 'the stream contains non-printable characters');
		    }
		    // Use 0 as string terminator. That significantly simplifies bounds check.
		    state.input += '\0';
		    while (0x20 === state.input.charCodeAt(state.position)) {
		        state.lineIndent += 1;
		        state.position += 1;
		    }
		    while (state.position < (state.length - 1)) {
		        var q = state.position;
		        readDocument(state);
		        if (state.position <= q) {
		            for (; state.position < state.length - 1; state.position++) {
		                var c = state.input.charAt(state.position);
		                if (c == '\n') {
		                    break;
		                }
		            }
		        }
		    }
		    state.documents.forEach(function (x) { return x.errors = state.errors; });
		    return state.documents;
		}
		function loadAll(input, iterator, options) {
		    var documents = loadDocuments(input, options), index, length;
		    for (index = 0, length = documents.length; index < length; index += 1) {
		        iterator(documents[index]);
		    }
		}
		exports.loadAll = loadAll;
		function load(input, options) {
		    var documents = loadDocuments(input, options), index, length;
		    if (0 === documents.length) {
		        /*eslint-disable no-undefined*/
		        return undefined;
		    }
		    else if (1 === documents.length) {
		        //root node always takes whole file
		        documents[0].endPosition = input.length;
		        return documents[0];
		    }
		    var e = new YAMLException('expected a single document in the stream, but found more');
		    e.mark = new Mark("", "", 0, 0, 0);
		    e.mark.position = documents[0].endPosition;
		    documents[0].errors.push(e);
		    //it is an artifact which is caused by the fact that we are checking next char before stopping parse
		    return documents[0];
		}
		exports.load = load;
		function safeLoadAll(input, output, options) {
		    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
		}
		exports.safeLoadAll = safeLoadAll;
		function safeLoad(input, options) {
		    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
		}
		exports.safeLoad = safeLoad;
		module.exports.loadAll = loadAll;
		module.exports.load = load;
		module.exports.safeLoadAll = safeLoadAll;
		module.exports.safeLoad = safeLoad;


	/***/ },
	/* 20 */
	/***/ function(module, exports) {

		/// <reference path="../../../../typings/tsd.d.ts" />
		'use strict';
		function isNothing(subject) {
		    return (typeof subject === 'undefined') || (null === subject);
		}
		exports.isNothing = isNothing;
		function isObject(subject) {
		    return (typeof subject === 'object') && (null !== subject);
		}
		exports.isObject = isObject;
		function toArray(sequence) {
		    if (Array.isArray(sequence)) {
		        return sequence;
		    }
		    else if (isNothing(sequence)) {
		        return [];
		    }
		    return [sequence];
		}
		exports.toArray = toArray;
		function extend(target, source) {
		    var index, length, key, sourceKeys;
		    if (source) {
		        sourceKeys = Object.keys(source);
		        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
		            key = sourceKeys[index];
		            target[key] = source[key];
		        }
		    }
		    return target;
		}
		exports.extend = extend;
		function repeat(string, count) {
		    var result = '', cycle;
		    for (cycle = 0; cycle < count; cycle += 1) {
		        result += string;
		    }
		    return result;
		}
		exports.repeat = repeat;
		function isNegativeZero(number) {
		    return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
		}
		exports.isNegativeZero = isNegativeZero;


	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../../typings/tsd.d.ts" />
		'use strict';
		var common = __webpack_require__(20);
		var Mark = (function () {
		    function Mark(name, buffer, position, line, column) {
		        this.name = name;
		        this.buffer = buffer;
		        this.position = position;
		        this.line = line;
		        this.column = column;
		    }
		    Mark.prototype.getSnippet = function (indent, maxLength) {
		        if (indent === void 0) { indent = 0; }
		        if (maxLength === void 0) { maxLength = 75; }
		        var head, start, tail, end, snippet;
		        if (!this.buffer) {
		            return null;
		        }
		        indent = indent || 4;
		        maxLength = maxLength || 75;
		        head = '';
		        start = this.position;
		        while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
		            start -= 1;
		            if (this.position - start > (maxLength / 2 - 1)) {
		                head = ' ... ';
		                start += 5;
		                break;
		            }
		        }
		        tail = '';
		        end = this.position;
		        while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
		            end += 1;
		            if (end - this.position > (maxLength / 2 - 1)) {
		                tail = ' ... ';
		                end -= 5;
		                break;
		            }
		        }
		        snippet = this.buffer.slice(start, end);
		        return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
		    };
		    Mark.prototype.toString = function (compact) {
		        if (compact === void 0) { compact = true; }
		        var snippet, where = '';
		        if (this.name) {
		            where += 'in "' + this.name + '" ';
		        }
		        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
		        if (!compact) {
		            snippet = this.getSnippet();
		            if (snippet) {
		                where += ':\n' + snippet;
		            }
		        }
		        return where;
		    };
		    return Mark;
		})();
		module.exports = Mark;


	/***/ },
	/* 22 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../../../typings/tsd.d.ts" />
		// JS-YAML's default schema for `safeLoad` function.
		// It is not described in the YAML specification.
		//
		// This schema is based on standard YAML's Core schema and includes most of
		// extra types described at YAML tag repository. (http://yaml.org/type/)
		'use strict';
		var Schema = __webpack_require__(23);
		var schema = new Schema({
		    include: [
		        __webpack_require__(25)
		    ],
		    implicit: [
		        __webpack_require__(35),
		        __webpack_require__(36)
		    ],
		    explicit: [
		        __webpack_require__(37),
		        __webpack_require__(39),
		        __webpack_require__(40),
		        __webpack_require__(41)
		    ]
		});
		module.exports = schema;


	/***/ },
	/* 23 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../../typings/tsd.d.ts" />
		'use strict';
		/*eslint-disable max-len*/
		var common = __webpack_require__(20);
		var YAMLException = __webpack_require__(9);
		var Type = __webpack_require__(24);
		function compileList(schema, name, result) {
		    var exclude = [];
		    schema.include.forEach(function (includedSchema) {
		        result = compileList(includedSchema, name, result);
		    });
		    schema[name].forEach(function (currentType) {
		        result.forEach(function (previousType, previousIndex) {
		            if (previousType.tag === currentType.tag) {
		                exclude.push(previousIndex);
		            }
		        });
		        result.push(currentType);
		    });
		    return result.filter(function (type, index) {
		        return -1 === exclude.indexOf(index);
		    });
		}
		function compileMap() {
		    var result = {}, index, length;
		    function collectType(type) {
		        result[type.tag] = type;
		    }
		    for (index = 0, length = arguments.length; index < length; index += 1) {
		        arguments[index].forEach(collectType);
		    }
		    return result;
		}
		var Schema = (function () {
		    function Schema(definition) {
		        this.include = definition.include || [];
		        this.implicit = definition.implicit || [];
		        this.explicit = definition.explicit || [];
		        this.implicit.forEach(function (type) {
		            if (type.loadKind && 'scalar' !== type.loadKind) {
		                throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
		            }
		        });
		        this.compiledImplicit = compileList(this, 'implicit', []);
		        this.compiledExplicit = compileList(this, 'explicit', []);
		        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
		    }
		    Schema.DEFAULT = null;
		    Schema.create = function createSchema() {
		        var schemas, types;
		        switch (arguments.length) {
		            case 1:
		                schemas = Schema.DEFAULT;
		                types = arguments[0];
		                break;
		            case 2:
		                schemas = arguments[0];
		                types = arguments[1];
		                break;
		            default:
		                throw new YAMLException('Wrong number of arguments for Schema.create function');
		        }
		        schemas = common.toArray(schemas);
		        types = common.toArray(types);
		        if (!schemas.every(function (schema) {
		            return schema instanceof Schema;
		        })) {
		            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
		        }
		        if (!types.every(function (type) {
		            return type instanceof Type;
		        })) {
		            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
		        }
		        return new Schema({
		            include: schemas,
		            explicit: types
		        });
		    };
		    return Schema;
		})();
		module.exports = Schema;


	/***/ },
	/* 24 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var YAMLException = __webpack_require__(9);
		var TYPE_CONSTRUCTOR_OPTIONS = [
		    'kind',
		    'resolve',
		    'construct',
		    'instanceOf',
		    'predicate',
		    'represent',
		    'defaultStyle',
		    'styleAliases'
		];
		var YAML_NODE_KINDS = [
		    'scalar',
		    'sequence',
		    'mapping'
		];
		function compileStyleAliases(map) {
		    var result = {};
		    if (null !== map) {
		        Object.keys(map).forEach(function (style) {
		            map[style].forEach(function (alias) {
		                result[String(alias)] = style;
		            });
		        });
		    }
		    return result;
		}
		function Type(tag, options) {
		    options = options || {};
		    Object.keys(options).forEach(function (name) {
		        if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
		            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
		        }
		    });
		    // TODO: Add tag format check.
		    this.tag = tag;
		    this.kind = options['kind'] || null;
		    this.resolve = options['resolve'] || function () {
		        return true;
		    };
		    this.construct = options['construct'] || function (data) {
		        return data;
		    };
		    this.instanceOf = options['instanceOf'] || null;
		    this.predicate = options['predicate'] || null;
		    this.represent = options['represent'] || null;
		    this.defaultStyle = options['defaultStyle'] || null;
		    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
		    if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
		        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
		    }
		}
		module.exports = Type;


	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Schema = __webpack_require__(23);
		module.exports = new Schema({
		    include: [
		        __webpack_require__(26)
		    ]
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC9zY2hlbWEvY29yZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFTQSxZQUFZLENBQUM7QUFHYixJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFHbEMsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQztJQUMxQixPQUFPLEVBQUU7UUFDUCxPQUFPLENBQUMsUUFBUSxDQUFDO0tBQ2xCO0NBQ0YsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC9zY2hlbWEvY29yZS5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyIsInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi90eXBpbmdzL3RzZC5kLnRzXCIgLz5cblxuLy8gU3RhbmRhcmQgWUFNTCdzIENvcmUgc2NoZW1hLlxuLy8gaHR0cDovL3d3dy55YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjaWQyODA0OTIzXG4vL1xuLy8gTk9URTogSlMtWUFNTCBkb2VzIG5vdCBzdXBwb3J0IHNjaGVtYS1zcGVjaWZpYyB0YWcgcmVzb2x1dGlvbiByZXN0cmljdGlvbnMuXG4vLyBTbywgQ29yZSBzY2hlbWEgaGFzIG5vIGRpc3RpbmN0aW9ucyBmcm9tIEpTT04gc2NoZW1hIGlzIEpTLVlBTUwuXG5cblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTY2hlbWEoe1xuICBpbmNsdWRlOiBbXG4gICAgcmVxdWlyZSgnLi9qc29uJylcbiAgXVxufSk7XG4iXX0=


	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Schema = __webpack_require__(23);
		module.exports = new Schema({
		    include: [
		        __webpack_require__(27)
		    ],
		    implicit: [
		        __webpack_require__(31),
		        __webpack_require__(32),
		        __webpack_require__(33),
		        __webpack_require__(34)
		    ]
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC9zY2hlbWEvanNvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxZQUFZLENBQUM7QUFHYixJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFHbEMsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLE1BQU0sQ0FBQztJQUMxQixPQUFPLEVBQUU7UUFDUCxPQUFPLENBQUMsWUFBWSxDQUFDO0tBQ3RCO0lBQ0QsUUFBUSxFQUFFO1FBQ1IsT0FBTyxDQUFDLGNBQWMsQ0FBQztRQUN2QixPQUFPLENBQUMsY0FBYyxDQUFDO1FBQ3ZCLE9BQU8sQ0FBQyxhQUFhLENBQUM7UUFDdEIsT0FBTyxDQUFDLGVBQWUsQ0FBQztLQUN6QjtDQUNGLENBQUMsQ0FBQyIsImZpbGUiOiJzcmMvcmFtbDEvanN5YW1sL2pzLXlhbWwvc2NoZW1hL2pzb24uanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy90c2QuZC50c1wiIC8+XG5cbi8vIFN0YW5kYXJkIFlBTUwncyBKU09OIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMzIzMVxuLy9cbi8vIE5PVEU6IEpTLVlBTUwgZG9lcyBub3Qgc3VwcG9ydCBzY2hlbWEtc3BlY2lmaWMgdGFnIHJlc29sdXRpb24gcmVzdHJpY3Rpb25zLlxuLy8gU28sIHRoaXMgc2NoZW1hIGlzIG5vdCBzdWNoIHN0cmljdCBhcyBkZWZpbmVkIGluIHRoZSBZQU1MIHNwZWNpZmljYXRpb24uXG4vLyBJdCBhbGxvd3MgbnVtYmVycyBpbiBiaW5hcnkgbm90YWlvbiwgdXNlIGBOdWxsYCBhbmQgYE5VTExgIGFzIGBudWxsYCwgZXRjLlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgaW5jbHVkZTogW1xuICAgIHJlcXVpcmUoJy4vZmFpbHNhZmUnKVxuICBdLFxuICBpbXBsaWNpdDogW1xuICAgIHJlcXVpcmUoJy4uL3R5cGUvbnVsbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvYm9vbCcpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvaW50JyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9mbG9hdCcpXG4gIF1cbn0pO1xuIl19


	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Schema = __webpack_require__(23);
		module.exports = new Schema({
		    explicit: [
		        __webpack_require__(28),
		        __webpack_require__(29),
		        __webpack_require__(30)
		    ]
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC9zY2hlbWEvZmFpbHNhZmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBTUEsWUFBWSxDQUFDO0FBR2IsSUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBR2xDLE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUM7SUFDMUIsUUFBUSxFQUFFO1FBQ1IsT0FBTyxDQUFDLGFBQWEsQ0FBQztRQUN0QixPQUFPLENBQUMsYUFBYSxDQUFDO1FBQ3RCLE9BQU8sQ0FBQyxhQUFhLENBQUM7S0FDdkI7Q0FDRixDQUFDLENBQUMiLCJmaWxlIjoic3JjL3JhbWwxL2pzeWFtbC9qcy15YW1sL3NjaGVtYS9mYWlsc2FmZS5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyIsInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi90eXBpbmdzL3RzZC5kLnRzXCIgLz5cblxuLy8gU3RhbmRhcmQgWUFNTCdzIEZhaWxzYWZlIHNjaGVtYS5cbi8vIGh0dHA6Ly93d3cueWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2lkMjgwMjM0NlxuXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU2NoZW1hKHtcbiAgZXhwbGljaXQ6IFtcbiAgICByZXF1aXJlKCcuLi90eXBlL3N0cicpLFxuICAgIHJlcXVpcmUoJy4uL3R5cGUvc2VxJyksXG4gICAgcmVxdWlyZSgnLi4vdHlwZS9tYXAnKVxuICBdXG59KTtcbiJdfQ==


	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		module.exports = new Type('tag:yaml.org,2002:str', {
		    kind: 'scalar',
		    construct: function (data) {
		        return null !== data ? data : '';
		    }
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL3N0ci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxZQUFZLENBQUM7QUFFYixJQUFPLElBQUksV0FBVyxTQUFTLENBQUMsQ0FBQztBQUVqQyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFO0lBQ2pELElBQUksRUFBRSxRQUFRO0lBQ2QsU0FBUyxFQUFFLFVBQVUsSUFBSTtRQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7SUFBQyxDQUFDO0NBQ2pFLENBQUMsQ0FBQyIsImZpbGUiOiJzcmMvcmFtbDEvanN5YW1sL2pzLXlhbWwvdHlwZS9zdHIuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy90c2QuZC50c1wiIC8+XG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDogJyc7IH1cbn0pO1xuIl19


	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		module.exports = new Type('tag:yaml.org,2002:seq', {
		    kind: 'sequence',
		    construct: function (data) {
		        return null !== data ? data : [];
		    }
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL3NlcS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxZQUFZLENBQUM7QUFFYixJQUFPLElBQUksV0FBVyxTQUFTLENBQUMsQ0FBQztBQUVqQyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFO0lBQ2pELElBQUksRUFBRSxVQUFVO0lBQ2hCLFNBQVMsRUFBRSxVQUFVLElBQUk7UUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQUMsQ0FBQztDQUNqRSxDQUFDLENBQUMiLCJmaWxlIjoic3JjL3JhbWwxL2pzeWFtbC9qcy15YW1sL3R5cGUvc2VxLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDogW107IH1cbn0pO1xuIl19


	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		module.exports = new Type('tag:yaml.org,2002:map', {
		    kind: 'mapping',
		    construct: function (data) {
		        return null !== data ? data : {};
		    }
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL21hcC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFQSxZQUFZLENBQUM7QUFFYixJQUFPLElBQUksV0FBVyxTQUFTLENBQUMsQ0FBQztBQUVqQyxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFO0lBQ2pELElBQUksRUFBRSxTQUFTO0lBQ2YsU0FBUyxFQUFFLFVBQVUsSUFBSTtRQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssSUFBSSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7SUFBQyxDQUFDO0NBQ2pFLENBQUMsQ0FBQyIsImZpbGUiOiJzcmMvcmFtbDEvanN5YW1sL2pzLXlhbWwvdHlwZS9tYXAuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy90c2QuZC50c1wiIC8+XG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IHt9OyB9XG59KTtcbiJdfQ==


	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		function resolveYamlNull(data) {
		    if (null === data) {
		        return true;
		    }
		    var max = data.length;
		    return (max === 1 && data === '~') || (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
		}
		function constructYamlNull() {
		    return null;
		}
		function isNull(object) {
		    return null === object;
		}
		module.exports = new Type('tag:yaml.org,2002:null', {
		    kind: 'scalar',
		    resolve: resolveYamlNull,
		    construct: constructYamlNull,
		    predicate: isNull,
		    represent: {
		        canonical: function () {
		            return '~';
		        },
		        lowercase: function () {
		            return 'null';
		        },
		        uppercase: function () {
		            return 'NULL';
		        },
		        camelcase: function () {
		            return 'Null';
		        }
		    },
		    defaultStyle: 'lowercase'
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL251bGwudHMiXSwibmFtZXMiOlsicmVzb2x2ZVlhbWxOdWxsIiwiY29uc3RydWN0WWFtbE51bGwiLCJpc051bGwiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBRWpDLFNBQVMsZUFBZSxDQUFDLElBQUk7SUFDM0JBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtJQUNkQSxDQUFDQTtJQUVEQSxJQUFJQSxHQUFHQSxHQUFHQSxJQUFJQSxDQUFDQSxNQUFNQSxDQUFDQTtJQUV0QkEsTUFBTUEsQ0FBQ0EsQ0FBQ0EsR0FBR0EsS0FBS0EsQ0FBQ0EsSUFBSUEsSUFBSUEsS0FBS0EsR0FBR0EsQ0FBQ0EsSUFDM0JBLENBQUNBLEdBQUdBLEtBQUtBLENBQUNBLElBQUlBLENBQUNBLElBQUlBLEtBQUtBLE1BQU1BLElBQUlBLElBQUlBLEtBQUtBLE1BQU1BLElBQUlBLElBQUlBLEtBQUtBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBO0FBQ2hGQSxDQUFDQTtBQUVELFNBQVMsaUJBQWlCO0lBQ3hCQyxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtBQUNkQSxDQUFDQTtBQUVELFNBQVMsTUFBTSxDQUFDLE1BQU07SUFDcEJDLE1BQU1BLENBQUNBLElBQUlBLEtBQUtBLE1BQU1BLENBQUNBO0FBQ3pCQSxDQUFDQTtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsd0JBQXdCLEVBQUU7SUFDbEQsSUFBSSxFQUFFLFFBQVE7SUFDZCxPQUFPLEVBQUUsZUFBZTtJQUN4QixTQUFTLEVBQUUsaUJBQWlCO0lBQzVCLFNBQVMsRUFBRSxNQUFNO0lBQ2pCLFNBQVMsRUFBRTtRQUNULFNBQVMsRUFBRTtZQUFjLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFBSSxDQUFDO1FBQ3pDLFNBQVMsRUFBRTtZQUFjLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFBQyxDQUFDO1FBQ3pDLFNBQVMsRUFBRTtZQUFjLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFBQyxDQUFDO1FBQ3pDLFNBQVMsRUFBRTtZQUFjLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFBQyxDQUFDO0tBQzFDO0lBQ0QsWUFBWSxFQUFFLFdBQVc7Q0FDMUIsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL251bGwuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy90c2QuZC50c1wiIC8+XG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFR5cGUgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sTnVsbChkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDEgJiYgZGF0YSA9PT0gJ34nKSB8fFxuICAgICAgICAgKG1heCA9PT0gNCAmJiAoZGF0YSA9PT0gJ251bGwnIHx8IGRhdGEgPT09ICdOdWxsJyB8fCBkYXRhID09PSAnTlVMTCcpKTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0WWFtbE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwob2JqZWN0KSB7XG4gIHJldHVybiBudWxsID09PSBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE51bGwsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE51bGwsXG4gIHByZWRpY2F0ZTogaXNOdWxsLFxuICByZXByZXNlbnQ6IHtcbiAgICBjYW5vbmljYWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd+JzsgICAgfSxcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdudWxsJzsgfSxcbiAgICB1cHBlcmNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOVUxMJzsgfSxcbiAgICBjYW1lbGNhc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdOdWxsJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiJdfQ==


	/***/ },
	/* 32 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		function resolveYamlBoolean(data) {
		    if (null === data) {
		        return false;
		    }
		    var max = data.length;
		    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) || (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
		}
		function constructYamlBoolean(data) {
		    return data === 'true' || data === 'True' || data === 'TRUE';
		}
		function isBoolean(object) {
		    return '[object Boolean]' === Object.prototype.toString.call(object);
		}
		module.exports = new Type('tag:yaml.org,2002:bool', {
		    kind: 'scalar',
		    resolve: resolveYamlBoolean,
		    construct: constructYamlBoolean,
		    predicate: isBoolean,
		    represent: {
		        lowercase: function (object) {
		            return object ? 'true' : 'false';
		        },
		        uppercase: function (object) {
		            return object ? 'TRUE' : 'FALSE';
		        },
		        camelcase: function (object) {
		            return object ? 'True' : 'False';
		        }
		    },
		    defaultStyle: 'lowercase'
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2Jvb2wudHMiXSwibmFtZXMiOlsicmVzb2x2ZVlhbWxCb29sZWFuIiwiY29uc3RydWN0WWFtbEJvb2xlYW4iLCJpc0Jvb2xlYW4iXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBRWpDLFNBQVMsa0JBQWtCLENBQUMsSUFBSTtJQUM5QkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbEJBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQ2ZBLENBQUNBO0lBRURBLElBQUlBLEdBQUdBLEdBQUdBLElBQUlBLENBQUNBLE1BQU1BLENBQUNBO0lBRXRCQSxNQUFNQSxDQUFDQSxDQUFDQSxHQUFHQSxLQUFLQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxLQUFLQSxNQUFNQSxJQUFJQSxJQUFJQSxLQUFLQSxNQUFNQSxJQUFJQSxJQUFJQSxLQUFLQSxNQUFNQSxDQUFDQSxDQUFDQSxJQUN0RUEsQ0FBQ0EsR0FBR0EsS0FBS0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsSUFBSUEsS0FBS0EsT0FBT0EsSUFBSUEsSUFBSUEsS0FBS0EsT0FBT0EsSUFBSUEsSUFBSUEsS0FBS0EsT0FBT0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7QUFDbkZBLENBQUNBO0FBRUQsU0FBUyxvQkFBb0IsQ0FBQyxJQUFJO0lBQ2hDQyxNQUFNQSxDQUFDQSxJQUFJQSxLQUFLQSxNQUFNQSxJQUNmQSxJQUFJQSxLQUFLQSxNQUFNQSxJQUNmQSxJQUFJQSxLQUFLQSxNQUFNQSxDQUFDQTtBQUN6QkEsQ0FBQ0E7QUFFRCxTQUFTLFNBQVMsQ0FBQyxNQUFNO0lBQ3ZCQyxNQUFNQSxDQUFDQSxrQkFBa0JBLEtBQUtBLE1BQU1BLENBQUNBLFNBQVNBLENBQUNBLFFBQVFBLENBQUNBLElBQUlBLENBQUNBLE1BQU1BLENBQUNBLENBQUNBO0FBQ3ZFQSxDQUFDQTtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsd0JBQXdCLEVBQUU7SUFDbEQsSUFBSSxFQUFFLFFBQVE7SUFDZCxPQUFPLEVBQUUsa0JBQWtCO0lBQzNCLFNBQVMsRUFBRSxvQkFBb0I7SUFDL0IsU0FBUyxFQUFFLFNBQVM7SUFDcEIsU0FBUyxFQUFFO1FBQ1QsU0FBUyxFQUFFLFVBQVUsTUFBTTtZQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQztRQUFDLENBQUM7UUFDbEUsU0FBUyxFQUFFLFVBQVUsTUFBTTtZQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQztRQUFDLENBQUM7UUFDbEUsU0FBUyxFQUFFLFVBQVUsTUFBTTtZQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLE9BQU8sQ0FBQztRQUFDLENBQUM7S0FDbkU7SUFDRCxZQUFZLEVBQUUsV0FBVztDQUMxQixDQUFDLENBQUMiLCJmaWxlIjoic3JjL3JhbWwxL2pzeWFtbC9qcy15YW1sL3R5cGUvYm9vbC5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyIsInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi90eXBpbmdzL3RzZC5kLnRzXCIgLz5cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVHlwZSA9IHJlcXVpcmUoJy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxCb29sZWFuKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbWF4ID0gZGF0YS5sZW5ndGg7XG5cbiAgcmV0dXJuIChtYXggPT09IDQgJiYgKGRhdGEgPT09ICd0cnVlJyB8fCBkYXRhID09PSAnVHJ1ZScgfHwgZGF0YSA9PT0gJ1RSVUUnKSkgfHxcbiAgICAgICAgIChtYXggPT09IDUgJiYgKGRhdGEgPT09ICdmYWxzZScgfHwgZGF0YSA9PT0gJ0ZhbHNlJyB8fCBkYXRhID09PSAnRkFMU0UnKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCb29sZWFuKGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEgPT09ICd0cnVlJyB8fFxuICAgICAgICAgZGF0YSA9PT0gJ1RydWUnIHx8XG4gICAgICAgICBkYXRhID09PSAnVFJVRSc7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEJvb2xlYW5dJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEJvb2xlYW4sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbEJvb2xlYW4sXG4gIHByZWRpY2F0ZTogaXNCb29sZWFuLFxuICByZXByZXNlbnQ6IHtcbiAgICBsb3dlcmNhc2U6IGZ1bmN0aW9uIChvYmplY3QpIHsgcmV0dXJuIG9iamVjdCA/ICd0cnVlJyA6ICdmYWxzZSc7IH0sXG4gICAgdXBwZXJjYXNlOiBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiBvYmplY3QgPyAnVFJVRScgOiAnRkFMU0UnOyB9LFxuICAgIGNhbWVsY2FzZTogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gb2JqZWN0ID8gJ1RydWUnIDogJ0ZhbHNlJzsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdsb3dlcmNhc2UnXG59KTtcbiJdfQ==


	/***/ },
	/* 33 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var common = __webpack_require__(20);
		var Type = __webpack_require__(24);
		function isHexCode(c) {
		    return ((0x30 <= c) && (c <= 0x39)) || ((0x41 <= c) && (c <= 0x46)) || ((0x61 <= c) && (c <= 0x66));
		}
		function isOctCode(c) {
		    return ((0x30 <= c) && (c <= 0x37));
		}
		function isDecCode(c) {
		    return ((0x30 <= c) && (c <= 0x39));
		}
		function resolveYamlInteger(data) {
		    if (null === data) {
		        return false;
		    }
		    var max = data.length, index = 0, hasDigits = false, ch;
		    if (!max) {
		        return false;
		    }
		    ch = data[index];
		    if (ch === '-' || ch === '+') {
		        ch = data[++index];
		    }
		    if (ch === '0') {
		        if (index + 1 === max) {
		            return true;
		        }
		        ch = data[++index];
		        if (ch === 'b') {
		            index++;
		            for (; index < max; index++) {
		                ch = data[index];
		                if (ch === '_') {
		                    continue;
		                }
		                if (ch !== '0' && ch !== '1') {
		                    return false;
		                }
		                hasDigits = true;
		            }
		            return hasDigits;
		        }
		        if (ch === 'x') {
		            index++;
		            for (; index < max; index++) {
		                ch = data[index];
		                if (ch === '_') {
		                    continue;
		                }
		                if (!isHexCode(data.charCodeAt(index))) {
		                    return false;
		                }
		                hasDigits = true;
		            }
		            return hasDigits;
		        }
		        for (; index < max; index++) {
		            ch = data[index];
		            if (ch === '_') {
		                continue;
		            }
		            if (!isOctCode(data.charCodeAt(index))) {
		                return false;
		            }
		            hasDigits = true;
		        }
		        return hasDigits;
		    }
		    for (; index < max; index++) {
		        ch = data[index];
		        if (ch === '_') {
		            continue;
		        }
		        if (ch === ':') {
		            break;
		        }
		        if (!isDecCode(data.charCodeAt(index))) {
		            return false;
		        }
		        hasDigits = true;
		    }
		    if (!hasDigits) {
		        return false;
		    }
		    if (ch !== ':') {
		        return true;
		    }
		    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
		}
		function constructYamlInteger(data) {
		    var value = data, sign = 1, ch, base, digits = [];
		    if (value.indexOf('_') !== -1) {
		        value = value.replace(/_/g, '');
		    }
		    ch = value[0];
		    if (ch === '-' || ch === '+') {
		        if (ch === '-') {
		            sign = -1;
		        }
		        value = value.slice(1);
		        ch = value[0];
		    }
		    if ('0' === value) {
		        return 0;
		    }
		    if (ch === '0') {
		        if (value[1] === 'b') {
		            return sign * parseInt(value.slice(2), 2);
		        }
		        if (value[1] === 'x') {
		            return sign * parseInt(value, 16);
		        }
		        return sign * parseInt(value, 8);
		    }
		    if (value.indexOf(':') !== -1) {
		        value.split(':').forEach(function (v) {
		            digits.unshift(parseInt(v, 10));
		        });
		        value = 0;
		        base = 1;
		        digits.forEach(function (d) {
		            value += (d * base);
		            base *= 60;
		        });
		        return sign * value;
		    }
		    return sign * parseInt(value, 10);
		}
		function isInteger(object) {
		    return ('[object Number]' === Object.prototype.toString.call(object)) && (0 === object % 1 && !common.isNegativeZero(object));
		}
		module.exports = new Type('tag:yaml.org,2002:int', {
		    kind: 'scalar',
		    resolve: resolveYamlInteger,
		    construct: constructYamlInteger,
		    predicate: isInteger,
		    represent: {
		        binary: function (object) {
		            return '0b' + object.toString(2);
		        },
		        octal: function (object) {
		            return '0' + object.toString(8);
		        },
		        decimal: function (object) {
		            return object.toString(10);
		        },
		        hexadecimal: function (object) {
		            return '0x' + object.toString(16).toUpperCase();
		        }
		    },
		    defaultStyle: 'decimal',
		    styleAliases: {
		        binary: [2, 'bin'],
		        octal: [8, 'oct'],
		        decimal: [10, 'dec'],
		        hexadecimal: [16, 'hex']
		    }
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2ludC50cyJdLCJuYW1lcyI6WyJpc0hleENvZGUiLCJpc09jdENvZGUiLCJpc0RlY0NvZGUiLCJyZXNvbHZlWWFtbEludGVnZXIiLCJjb25zdHJ1Y3RZYW1sSW50ZWdlciIsImlzSW50ZWdlciJdLCJtYXBwaW5ncyI6IkFBRUEsWUFBWSxDQUFDO0FBRWIsSUFBTyxNQUFNLFdBQVcsV0FBVyxDQUFDLENBQUM7QUFDckMsSUFBTyxJQUFJLFdBQWEsU0FBUyxDQUFDLENBQUM7QUFFbkMsU0FBUyxTQUFTLENBQUMsQ0FBQztJQUNsQkEsTUFBTUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBV0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBSUEsQ0FBUUEsQ0FBQ0EsSUFDMUNBLENBQUNBLENBQUNBLElBQUlBLElBQVdBLENBQUNBLENBQUNBLElBQUlBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQVFBLENBQUNBLElBQzFDQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFXQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFRQSxDQUFDQSxDQUFDQTtBQUNwREEsQ0FBQ0E7QUFFRCxTQUFTLFNBQVMsQ0FBQyxDQUFDO0lBQ2xCQyxNQUFNQSxDQUFDQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFXQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFRQSxDQUFDQSxDQUFDQTtBQUNwREEsQ0FBQ0E7QUFFRCxTQUFTLFNBQVMsQ0FBQyxDQUFDO0lBQ2xCQyxNQUFNQSxDQUFDQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFXQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFRQSxDQUFDQSxDQUFDQTtBQUNwREEsQ0FBQ0E7QUFFRCxTQUFTLGtCQUFrQixDQUFDLElBQUk7SUFDOUJDLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtJQUNmQSxDQUFDQTtJQUVEQSxJQUFJQSxHQUFHQSxHQUFHQSxJQUFJQSxDQUFDQSxNQUFNQSxFQUNqQkEsS0FBS0EsR0FBR0EsQ0FBQ0EsRUFDVEEsU0FBU0EsR0FBR0EsS0FBS0EsRUFDakJBLEVBQUVBLENBQUNBO0lBRVBBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1FBQUNBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQUNBLENBQUNBO0lBRTNCQSxFQUFFQSxHQUFHQSxJQUFJQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQTtJQUdqQkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsRUFBRUEsS0FBS0EsR0FBR0EsSUFBSUEsRUFBRUEsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDN0JBLEVBQUVBLEdBQUdBLElBQUlBLENBQUNBLEVBQUVBLEtBQUtBLENBQUNBLENBQUNBO0lBQ3JCQSxDQUFDQTtJQUVEQSxFQUFFQSxDQUFDQSxDQUFDQSxFQUFFQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUVmQSxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUFDQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtRQUFDQSxDQUFDQTtRQUN2Q0EsRUFBRUEsR0FBR0EsSUFBSUEsQ0FBQ0EsRUFBRUEsS0FBS0EsQ0FBQ0EsQ0FBQ0E7UUFJbkJBLEVBQUVBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1lBRWZBLEtBQUtBLEVBQUVBLENBQUNBO1lBRVJBLEdBQUdBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLEdBQUdBLEVBQUVBLEtBQUtBLEVBQUVBLEVBQUVBLENBQUNBO2dCQUM1QkEsRUFBRUEsR0FBR0EsSUFBSUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0E7Z0JBQ2pCQSxFQUFFQSxDQUFDQSxDQUFDQSxFQUFFQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtvQkFBQ0EsUUFBUUEsQ0FBQ0E7Z0JBQUNBLENBQUNBO2dCQUM3QkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsRUFBRUEsS0FBS0EsR0FBR0EsSUFBSUEsRUFBRUEsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7b0JBQzdCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtnQkFDZkEsQ0FBQ0E7Z0JBQ0RBLFNBQVNBLEdBQUdBLElBQUlBLENBQUNBO1lBQ25CQSxDQUFDQTtZQUNEQSxNQUFNQSxDQUFDQSxTQUFTQSxDQUFDQTtRQUNuQkEsQ0FBQ0E7UUFHREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsRUFBRUEsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFFZkEsS0FBS0EsRUFBRUEsQ0FBQ0E7WUFFUkEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsRUFBRUEsS0FBS0EsR0FBR0EsR0FBR0EsRUFBRUEsS0FBS0EsRUFBRUEsRUFBRUEsQ0FBQ0E7Z0JBQzVCQSxFQUFFQSxHQUFHQSxJQUFJQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQTtnQkFDakJBLEVBQUVBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO29CQUFDQSxRQUFRQSxDQUFDQTtnQkFBQ0EsQ0FBQ0E7Z0JBQzdCQSxFQUFFQSxDQUFDQSxDQUFDQSxDQUFDQSxTQUFTQSxDQUFDQSxJQUFJQSxDQUFDQSxVQUFVQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtvQkFDdkNBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO2dCQUNmQSxDQUFDQTtnQkFDREEsU0FBU0EsR0FBR0EsSUFBSUEsQ0FBQ0E7WUFDbkJBLENBQUNBO1lBQ0RBLE1BQU1BLENBQUNBLFNBQVNBLENBQUNBO1FBQ25CQSxDQUFDQTtRQUdEQSxHQUFHQSxDQUFDQSxDQUFDQSxFQUFFQSxLQUFLQSxHQUFHQSxHQUFHQSxFQUFFQSxLQUFLQSxFQUFFQSxFQUFFQSxDQUFDQTtZQUM1QkEsRUFBRUEsR0FBR0EsSUFBSUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0E7WUFDakJBLEVBQUVBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO2dCQUFDQSxRQUFRQSxDQUFDQTtZQUFDQSxDQUFDQTtZQUM3QkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsU0FBU0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsVUFBVUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7Z0JBQ3ZDQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtZQUNmQSxDQUFDQTtZQUNEQSxTQUFTQSxHQUFHQSxJQUFJQSxDQUFDQTtRQUNuQkEsQ0FBQ0E7UUFDREEsTUFBTUEsQ0FBQ0EsU0FBU0EsQ0FBQ0E7SUFDbkJBLENBQUNBO0lBSURBLEdBQUdBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLEdBQUdBLEVBQUVBLEtBQUtBLEVBQUVBLEVBQUVBLENBQUNBO1FBQzVCQSxFQUFFQSxHQUFHQSxJQUFJQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQTtRQUNqQkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsRUFBRUEsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFBQ0EsUUFBUUEsQ0FBQ0E7UUFBQ0EsQ0FBQ0E7UUFDN0JBLEVBQUVBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1lBQUNBLEtBQUtBLENBQUNBO1FBQUNBLENBQUNBO1FBQzFCQSxFQUFFQSxDQUFDQSxDQUFDQSxDQUFDQSxTQUFTQSxDQUFDQSxJQUFJQSxDQUFDQSxVQUFVQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUN2Q0EsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7UUFDZkEsQ0FBQ0E7UUFDREEsU0FBU0EsR0FBR0EsSUFBSUEsQ0FBQ0E7SUFDbkJBLENBQUNBO0lBRURBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLFNBQVNBLENBQUNBLENBQUNBLENBQUNBO1FBQUNBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQUNBLENBQUNBO0lBR2pDQSxFQUFFQSxDQUFDQSxDQUFDQSxFQUFFQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUFDQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtJQUFDQSxDQUFDQTtJQUdoQ0EsTUFBTUEsQ0FBQ0EsbUJBQW1CQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxLQUFLQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQTtBQUNyREEsQ0FBQ0E7QUFFRCxTQUFTLG9CQUFvQixDQUFDLElBQUk7SUFDaENDLElBQUlBLEtBQUtBLEdBQUdBLElBQUlBLEVBQUVBLElBQUlBLEdBQUdBLENBQUNBLEVBQUVBLEVBQUVBLEVBQUVBLElBQUlBLEVBQUVBLE1BQU1BLEdBQUdBLEVBQUVBLENBQUNBO0lBRWxEQSxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxPQUFPQSxDQUFDQSxHQUFHQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUM5QkEsS0FBS0EsR0FBR0EsS0FBS0EsQ0FBQ0EsT0FBT0EsQ0FBQ0EsSUFBSUEsRUFBRUEsRUFBRUEsQ0FBQ0EsQ0FBQ0E7SUFDbENBLENBQUNBO0lBRURBLEVBQUVBLEdBQUdBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO0lBRWRBLEVBQUVBLENBQUNBLENBQUNBLEVBQUVBLEtBQUtBLEdBQUdBLElBQUlBLEVBQUVBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1FBQzdCQSxFQUFFQSxDQUFDQSxDQUFDQSxFQUFFQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUFDQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUFDQSxDQUFDQTtRQUM5QkEsS0FBS0EsR0FBR0EsS0FBS0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDdkJBLEVBQUVBLEdBQUdBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO0lBQ2hCQSxDQUFDQTtJQUVEQSxFQUFFQSxDQUFDQSxDQUFDQSxHQUFHQSxLQUFLQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNsQkEsTUFBTUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDWEEsQ0FBQ0E7SUFFREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsRUFBRUEsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDZkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDckJBLE1BQU1BLENBQUNBLElBQUlBLEdBQUdBLFFBQVFBLENBQUNBLEtBQUtBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBO1FBQzVDQSxDQUFDQTtRQUNEQSxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNyQkEsTUFBTUEsQ0FBQ0EsSUFBSUEsR0FBR0EsUUFBUUEsQ0FBQ0EsS0FBS0EsRUFBRUEsRUFBRUEsQ0FBQ0EsQ0FBQ0E7UUFDcENBLENBQUNBO1FBQ0RBLE1BQU1BLENBQUNBLElBQUlBLEdBQUdBLFFBQVFBLENBQUNBLEtBQUtBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBO0lBRW5DQSxDQUFDQTtJQUVEQSxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxPQUFPQSxDQUFDQSxHQUFHQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUM5QkEsS0FBS0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsT0FBT0EsQ0FBQ0EsVUFBVUEsQ0FBQ0E7WUFDbEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDQSxDQUFDQTtRQUVIQSxLQUFLQSxHQUFHQSxDQUFDQSxDQUFDQTtRQUNWQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQTtRQUVUQSxNQUFNQSxDQUFDQSxPQUFPQSxDQUFDQSxVQUFVQSxDQUFDQTtZQUN4QixLQUFLLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7WUFDcEIsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNiLENBQUMsQ0FBQ0EsQ0FBQ0E7UUFFSEEsTUFBTUEsQ0FBQ0EsSUFBSUEsR0FBR0EsS0FBS0EsQ0FBQ0E7SUFFdEJBLENBQUNBO0lBRURBLE1BQU1BLENBQUNBLElBQUlBLEdBQUdBLFFBQVFBLENBQUNBLEtBQUtBLEVBQUVBLEVBQUVBLENBQUNBLENBQUNBO0FBQ3BDQSxDQUFDQTtBQUVELFNBQVMsU0FBUyxDQUFDLE1BQU07SUFDdkJDLE1BQU1BLENBQUNBLENBQUNBLGlCQUFpQkEsS0FBS0EsTUFBTUEsQ0FBQ0EsU0FBU0EsQ0FBQ0EsUUFBUUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsTUFBTUEsQ0FBQ0EsQ0FBQ0EsSUFDOURBLENBQUNBLENBQUNBLEtBQUtBLE1BQU1BLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLE1BQU1BLENBQUNBLGNBQWNBLENBQUNBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBO0FBQzlEQSxDQUFDQTtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsdUJBQXVCLEVBQUU7SUFDakQsSUFBSSxFQUFFLFFBQVE7SUFDZCxPQUFPLEVBQUUsa0JBQWtCO0lBQzNCLFNBQVMsRUFBRSxvQkFBb0I7SUFDL0IsU0FBUyxFQUFFLFNBQVM7SUFDcEIsU0FBUyxFQUFFO1FBQ1QsTUFBTSxFQUFPLFVBQVUsTUFBTTtZQUFJLE1BQU0sQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUFDLENBQUM7UUFDcEUsS0FBSyxFQUFRLFVBQVUsTUFBTTtZQUFJLE1BQU0sQ0FBQyxHQUFHLEdBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUFDLENBQUM7UUFDcEUsT0FBTyxFQUFNLFVBQVUsTUFBTTtZQUFJLE1BQU0sQ0FBUSxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQUMsQ0FBQztRQUNyRSxXQUFXLEVBQUUsVUFBVSxNQUFNO1lBQUksTUFBTSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQUMsQ0FBQztLQUNwRjtJQUNELFlBQVksRUFBRSxTQUFTO0lBQ3ZCLFlBQVksRUFBRTtRQUNaLE1BQU0sRUFBTyxDQUFFLENBQUMsRUFBRyxLQUFLLENBQUU7UUFDMUIsS0FBSyxFQUFRLENBQUUsQ0FBQyxFQUFHLEtBQUssQ0FBRTtRQUMxQixPQUFPLEVBQU0sQ0FBRSxFQUFFLEVBQUUsS0FBSyxDQUFFO1FBQzFCLFdBQVcsRUFBRSxDQUFFLEVBQUUsRUFBRSxLQUFLLENBQUU7S0FDM0I7Q0FDRixDQUFDLENBQUMiLCJmaWxlIjoic3JjL3JhbWwxL2pzeWFtbC9qcy15YW1sL3R5cGUvaW50LmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmltcG9ydCBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbmZ1bmN0aW9uIGlzSGV4Q29kZShjKSB7XG4gIHJldHVybiAoKDB4MzAvKiAwICovIDw9IGMpICYmIChjIDw9IDB4MzkvKiA5ICovKSkgfHxcbiAgICAgICAgICgoMHg0MS8qIEEgKi8gPD0gYykgJiYgKGMgPD0gMHg0Ni8qIEYgKi8pKSB8fFxuICAgICAgICAgKCgweDYxLyogYSAqLyA8PSBjKSAmJiAoYyA8PSAweDY2LyogZiAqLykpO1xufVxuXG5mdW5jdGlvbiBpc09jdENvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM3LyogNyAqLykpO1xufVxuXG5mdW5jdGlvbiBpc0RlY0NvZGUoYykge1xuICByZXR1cm4gKCgweDMwLyogMCAqLyA8PSBjKSAmJiAoYyA8PSAweDM5LyogOSAqLykpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlWWFtbEludGVnZXIoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXggPSBkYXRhLmxlbmd0aCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIGhhc0RpZ2l0cyA9IGZhbHNlLFxuICAgICAgY2g7XG5cbiAgaWYgKCFtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggPSBkYXRhW2luZGV4XTtcblxuICAvLyBzaWduXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG4gIH1cblxuICBpZiAoY2ggPT09ICcwJykge1xuICAgIC8vIDBcbiAgICBpZiAoaW5kZXggKyAxID09PSBtYXgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICBjaCA9IGRhdGFbKytpbmRleF07XG5cbiAgICAvLyBiYXNlIDIsIGJhc2UgOCwgYmFzZSAxNlxuXG4gICAgaWYgKGNoID09PSAnYicpIHtcbiAgICAgIC8vIGJhc2UgMlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmIChjaCAhPT0gJzAnICYmIGNoICE9PSAnMScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRGlnaXRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNEaWdpdHM7XG4gICAgfVxuXG5cbiAgICBpZiAoY2ggPT09ICd4Jykge1xuICAgICAgLy8gYmFzZSAxNlxuICAgICAgaW5kZXgrKztcblxuICAgICAgZm9yICg7IGluZGV4IDwgbWF4OyBpbmRleCsrKSB7XG4gICAgICAgIGNoID0gZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIGlmICghaXNIZXhDb2RlKGRhdGEuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGhhc0RpZ2l0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzRGlnaXRzO1xuICAgIH1cblxuICAgIC8vIGJhc2UgOFxuICAgIGZvciAoOyBpbmRleCA8IG1heDsgaW5kZXgrKykge1xuICAgICAgY2ggPSBkYXRhW2luZGV4XTtcbiAgICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAoIWlzT2N0Q29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRGlnaXRzO1xuICB9XG5cbiAgLy8gYmFzZSAxMCAoZXhjZXB0IDApIG9yIGJhc2UgNjBcblxuICBmb3IgKDsgaW5kZXggPCBtYXg7IGluZGV4KyspIHtcbiAgICBjaCA9IGRhdGFbaW5kZXhdO1xuICAgIGlmIChjaCA9PT0gJ18nKSB7IGNvbnRpbnVlOyB9XG4gICAgaWYgKGNoID09PSAnOicpIHsgYnJlYWs7IH1cbiAgICBpZiAoIWlzRGVjQ29kZShkYXRhLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBoYXNEaWdpdHMgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFoYXNEaWdpdHMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgIWJhc2U2MCAtIGRvbmU7XG4gIGlmIChjaCAhPT0gJzonKSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gYmFzZTYwIGFsbW9zdCBub3QgdXNlZCwgbm8gbmVlZHMgdG8gb3B0aW1pemVcbiAgcmV0dXJuIC9eKDpbMC01XT9bMC05XSkrJC8udGVzdChkYXRhLnNsaWNlKGluZGV4KSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxJbnRlZ2VyKGRhdGEpIHtcbiAgdmFyIHZhbHVlID0gZGF0YSwgc2lnbiA9IDEsIGNoLCBiYXNlLCBkaWdpdHMgPSBbXTtcblxuICBpZiAodmFsdWUuaW5kZXhPZignXycpICE9PSAtMSkge1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXy9nLCAnJyk7XG4gIH1cblxuICBjaCA9IHZhbHVlWzBdO1xuXG4gIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICBpZiAoY2ggPT09ICctJykgeyBzaWduID0gLTE7IH1cbiAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgIGNoID0gdmFsdWVbMF07XG4gIH1cblxuICBpZiAoJzAnID09PSB2YWx1ZSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGNoID09PSAnMCcpIHtcbiAgICBpZiAodmFsdWVbMV0gPT09ICdiJykge1xuICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgMik7XG4gICAgfVxuICAgIGlmICh2YWx1ZVsxXSA9PT0gJ3gnKSB7XG4gICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDgpO1xuXG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZignOicpICE9PSAtMSkge1xuICAgIHZhbHVlLnNwbGl0KCc6JykuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgZGlnaXRzLnVuc2hpZnQocGFyc2VJbnQodiwgMTApKTtcbiAgICB9KTtcblxuICAgIHZhbHVlID0gMDtcbiAgICBiYXNlID0gMTtcblxuICAgIGRpZ2l0cy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YWx1ZSArPSAoZCAqIGJhc2UpO1xuICAgICAgYmFzZSAqPSA2MDtcbiAgICB9KTtcblxuICAgIHJldHVybiBzaWduICogdmFsdWU7XG5cbiAgfVxuXG4gIHJldHVybiBzaWduICogcGFyc2VJbnQodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gaXNJbnRlZ2VyKG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwID09PSBvYmplY3QgJSAxICYmICFjb21tb24uaXNOZWdhdGl2ZVplcm8ob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sSW50ZWdlcixcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sSW50ZWdlcixcbiAgcHJlZGljYXRlOiBpc0ludGVnZXIsXG4gIHJlcHJlc2VudDoge1xuICAgIGJpbmFyeTogICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMGInICsgb2JqZWN0LnRvU3RyaW5nKDIpOyB9LFxuICAgIG9jdGFsOiAgICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAnMCcgICsgb2JqZWN0LnRvU3RyaW5nKDgpOyB9LFxuICAgIGRlY2ltYWw6ICAgICBmdW5jdGlvbiAob2JqZWN0KSB7IHJldHVybiAgICAgICAgb2JqZWN0LnRvU3RyaW5nKDEwKTsgfSxcbiAgICBoZXhhZGVjaW1hbDogZnVuY3Rpb24gKG9iamVjdCkgeyByZXR1cm4gJzB4JyArIG9iamVjdC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuICB9LFxuICBkZWZhdWx0U3R5bGU6ICdkZWNpbWFsJyxcbiAgc3R5bGVBbGlhc2VzOiB7XG4gICAgYmluYXJ5OiAgICAgIFsgMiwgICdiaW4nIF0sXG4gICAgb2N0YWw6ICAgICAgIFsgOCwgICdvY3QnIF0sXG4gICAgZGVjaW1hbDogICAgIFsgMTAsICdkZWMnIF0sXG4gICAgaGV4YWRlY2ltYWw6IFsgMTYsICdoZXgnIF1cbiAgfVxufSk7XG4iXX0=


	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var common = __webpack_require__(20);
		var Type = __webpack_require__(24);
		var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');
		function resolveYamlFloat(data) {
		    if (null === data) {
		        return false;
		    }
		    var value, sign, base, digits;
		    if (!YAML_FLOAT_PATTERN.test(data)) {
		        return false;
		    }
		    return true;
		}
		function constructYamlFloat(data) {
		    var value, sign, base, digits;
		    value = data.replace(/_/g, '').toLowerCase();
		    sign = '-' === value[0] ? -1 : 1;
		    digits = [];
		    if (0 <= '+-'.indexOf(value[0])) {
		        value = value.slice(1);
		    }
		    if ('.inf' === value) {
		        return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
		    }
		    else if ('.nan' === value) {
		        return NaN;
		    }
		    else if (0 <= value.indexOf(':')) {
		        value.split(':').forEach(function (v) {
		            digits.unshift(parseFloat(v, 10));
		        });
		        value = 0.0;
		        base = 1;
		        digits.forEach(function (d) {
		            value += d * base;
		            base *= 60;
		        });
		        return sign * value;
		    }
		    return sign * parseFloat(value, 10);
		}
		function representYamlFloat(object, style) {
		    if (isNaN(object)) {
		        switch (style) {
		            case 'lowercase':
		                return '.nan';
		            case 'uppercase':
		                return '.NAN';
		            case 'camelcase':
		                return '.NaN';
		        }
		    }
		    else if (Number.POSITIVE_INFINITY === object) {
		        switch (style) {
		            case 'lowercase':
		                return '.inf';
		            case 'uppercase':
		                return '.INF';
		            case 'camelcase':
		                return '.Inf';
		        }
		    }
		    else if (Number.NEGATIVE_INFINITY === object) {
		        switch (style) {
		            case 'lowercase':
		                return '-.inf';
		            case 'uppercase':
		                return '-.INF';
		            case 'camelcase':
		                return '-.Inf';
		        }
		    }
		    else if (common.isNegativeZero(object)) {
		        return '-0.0';
		    }
		    return object.toString(10);
		}
		function isFloat(object) {
		    return ('[object Number]' === Object.prototype.toString.call(object)) && (0 !== object % 1 || common.isNegativeZero(object));
		}
		module.exports = new Type('tag:yaml.org,2002:float', {
		    kind: 'scalar',
		    resolve: resolveYamlFloat,
		    construct: constructYamlFloat,
		    predicate: isFloat,
		    represent: representYamlFloat,
		    defaultStyle: 'lowercase'
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2Zsb2F0LnRzIl0sIm5hbWVzIjpbInJlc29sdmVZYW1sRmxvYXQiLCJjb25zdHJ1Y3RZYW1sRmxvYXQiLCJyZXByZXNlbnRZYW1sRmxvYXQiLCJpc0Zsb2F0Il0sIm1hcHBpbmdzIjoiQUFFQSxZQUFZLENBQUM7QUFFYixJQUFPLE1BQU0sV0FBVyxXQUFXLENBQUMsQ0FBQztBQUNyQyxJQUFPLElBQUksV0FBYSxTQUFTLENBQUMsQ0FBQztBQUVuQyxJQUFJLGtCQUFrQixHQUFHLElBQUksTUFBTSxDQUNqQyx3REFBd0QsR0FDeEQsZ0NBQWdDLEdBQ2hDLCtDQUErQyxHQUMvQywwQkFBMEIsR0FDMUIsdUJBQXVCLENBQUMsQ0FBQztBQUUzQixTQUFTLGdCQUFnQixDQUFDLElBQUk7SUFDNUJBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtJQUNmQSxDQUFDQTtJQUVEQSxJQUFJQSxLQUFLQSxFQUFFQSxJQUFJQSxFQUFFQSxJQUFJQSxFQUFFQSxNQUFNQSxDQUFDQTtJQUU5QkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0Esa0JBQWtCQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNuQ0EsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7SUFDZkEsQ0FBQ0E7SUFDREEsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0E7QUFDZEEsQ0FBQ0E7QUFFRCxTQUFTLGtCQUFrQixDQUFDLElBQUk7SUFDOUJDLElBQUlBLEtBQUtBLEVBQUVBLElBQUlBLEVBQUVBLElBQUlBLEVBQUVBLE1BQU1BLENBQUNBO0lBRTlCQSxLQUFLQSxHQUFJQSxJQUFJQSxDQUFDQSxPQUFPQSxDQUFDQSxJQUFJQSxFQUFFQSxFQUFFQSxDQUFDQSxDQUFDQSxXQUFXQSxFQUFFQSxDQUFDQTtJQUM5Q0EsSUFBSUEsR0FBS0EsR0FBR0EsS0FBS0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7SUFDbkNBLE1BQU1BLEdBQUdBLEVBQUVBLENBQUNBO0lBRVpBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQUNBLE9BQU9BLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1FBQ2hDQSxLQUFLQSxHQUFHQSxLQUFLQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtJQUN6QkEsQ0FBQ0E7SUFFREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsTUFBTUEsS0FBS0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDckJBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBLEtBQUtBLElBQUlBLENBQUNBLEdBQUdBLE1BQU1BLENBQUNBLGlCQUFpQkEsR0FBR0EsTUFBTUEsQ0FBQ0EsaUJBQWlCQSxDQUFDQTtJQUU1RUEsQ0FBQ0E7SUFBQ0EsSUFBSUEsQ0FBQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsTUFBTUEsS0FBS0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDNUJBLE1BQU1BLENBQUNBLEdBQUdBLENBQUNBO0lBRWJBLENBQUNBO0lBQUNBLElBQUlBLENBQUNBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLENBQUNBLE9BQU9BLENBQUNBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1FBQ25DQSxLQUFLQSxDQUFDQSxLQUFLQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQSxPQUFPQSxDQUFDQSxVQUFVQSxDQUFDQTtZQUNsQyxNQUFNLENBQUMsT0FBTyxDQUFPLFVBQVcsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzQyxDQUFDLENBQUNBLENBQUNBO1FBRUhBLEtBQUtBLEdBQUdBLEdBQUdBLENBQUNBO1FBQ1pBLElBQUlBLEdBQUdBLENBQUNBLENBQUNBO1FBRVRBLE1BQU1BLENBQUNBLE9BQU9BLENBQUNBLFVBQVVBLENBQUNBO1lBQ3hCLEtBQUssSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQ2xCLElBQUksSUFBSSxFQUFFLENBQUM7UUFDYixDQUFDLENBQUNBLENBQUNBO1FBRUhBLE1BQU1BLENBQUNBLElBQUlBLEdBQUdBLEtBQUtBLENBQUNBO0lBRXRCQSxDQUFDQTtJQUNEQSxNQUFNQSxDQUFDQSxJQUFJQSxHQUFTQSxVQUFXQSxDQUFDQSxLQUFLQSxFQUFFQSxFQUFFQSxDQUFDQSxDQUFDQTtBQUM3Q0EsQ0FBQ0E7QUFFRCxTQUFTLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxLQUFLO0lBQ3ZDQyxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxNQUFNQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNsQkEsTUFBTUEsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDaEJBLEtBQUtBLFdBQVdBO2dCQUNkQSxNQUFNQSxDQUFDQSxNQUFNQSxDQUFDQTtZQUNoQkEsS0FBS0EsV0FBV0E7Z0JBQ2RBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBO1lBQ2hCQSxLQUFLQSxXQUFXQTtnQkFDZEEsTUFBTUEsQ0FBQ0EsTUFBTUEsQ0FBQ0E7UUFDaEJBLENBQUNBO0lBQ0hBLENBQUNBO0lBQUNBLElBQUlBLENBQUNBLEVBQUVBLENBQUNBLENBQUNBLE1BQU1BLENBQUNBLGlCQUFpQkEsS0FBS0EsTUFBTUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDL0NBLE1BQU1BLENBQUNBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBO1lBQ2hCQSxLQUFLQSxXQUFXQTtnQkFDZEEsTUFBTUEsQ0FBQ0EsTUFBTUEsQ0FBQ0E7WUFDaEJBLEtBQUtBLFdBQVdBO2dCQUNkQSxNQUFNQSxDQUFDQSxNQUFNQSxDQUFDQTtZQUNoQkEsS0FBS0EsV0FBV0E7Z0JBQ2RBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBO1FBQ2hCQSxDQUFDQTtJQUNIQSxDQUFDQTtJQUFDQSxJQUFJQSxDQUFDQSxFQUFFQSxDQUFDQSxDQUFDQSxNQUFNQSxDQUFDQSxpQkFBaUJBLEtBQUtBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBO1FBQy9DQSxNQUFNQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNoQkEsS0FBS0EsV0FBV0E7Z0JBQ2RBLE1BQU1BLENBQUNBLE9BQU9BLENBQUNBO1lBQ2pCQSxLQUFLQSxXQUFXQTtnQkFDZEEsTUFBTUEsQ0FBQ0EsT0FBT0EsQ0FBQ0E7WUFDakJBLEtBQUtBLFdBQVdBO2dCQUNkQSxNQUFNQSxDQUFDQSxPQUFPQSxDQUFDQTtRQUNqQkEsQ0FBQ0E7SUFDSEEsQ0FBQ0E7SUFBQ0EsSUFBSUEsQ0FBQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsY0FBY0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDekNBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBO0lBQ2hCQSxDQUFDQTtJQUNEQSxNQUFNQSxDQUFDQSxNQUFNQSxDQUFDQSxRQUFRQSxDQUFDQSxFQUFFQSxDQUFDQSxDQUFDQTtBQUM3QkEsQ0FBQ0E7QUFFRCxTQUFTLE9BQU8sQ0FBQyxNQUFNO0lBQ3JCQyxNQUFNQSxDQUFDQSxDQUFDQSxpQkFBaUJBLEtBQUtBLE1BQU1BLENBQUNBLFNBQVNBLENBQUNBLFFBQVFBLENBQUNBLElBQUlBLENBQUNBLE1BQU1BLENBQUNBLENBQUNBLElBQzlEQSxDQUFDQSxDQUFDQSxLQUFLQSxNQUFNQSxHQUFHQSxDQUFDQSxJQUFJQSxNQUFNQSxDQUFDQSxjQUFjQSxDQUFDQSxNQUFNQSxDQUFDQSxDQUFDQSxDQUFDQTtBQUM3REEsQ0FBQ0E7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLHlCQUF5QixFQUFFO0lBQ25ELElBQUksRUFBRSxRQUFRO0lBQ2QsT0FBTyxFQUFFLGdCQUFnQjtJQUN6QixTQUFTLEVBQUUsa0JBQWtCO0lBQzdCLFNBQVMsRUFBRSxPQUFPO0lBQ2xCLFNBQVMsRUFBRSxrQkFBa0I7SUFDN0IsWUFBWSxFQUFFLFdBQVc7Q0FDMUIsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2Zsb2F0LmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbmltcG9ydCBUeXBlICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cbnZhciBZQU1MX0ZMT0FUX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFxuICAnXig/OlstK10/KD86WzAtOV1bMC05X10qKVxcXFwuWzAtOV9dKig/OltlRV1bLStdWzAtOV0rKT8nICtcbiAgJ3xcXFxcLlswLTlfXSsoPzpbZUVdWy0rXVswLTldKyk/JyArXG4gICd8Wy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcXFwuWzAtOV9dKicgK1xuICAnfFstK10/XFxcXC4oPzppbmZ8SW5mfElORiknICtcbiAgJ3xcXFxcLig/Om5hbnxOYU58TkFOKSkkJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sRmxvYXQoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB2YWx1ZSwgc2lnbiwgYmFzZSwgZGlnaXRzO1xuXG4gIGlmICghWUFNTF9GTE9BVF9QQVRURVJOLnRlc3QoZGF0YSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxGbG9hdChkYXRhKSB7XG4gIHZhciB2YWx1ZSwgc2lnbiwgYmFzZSwgZGlnaXRzO1xuXG4gIHZhbHVlICA9IGRhdGEucmVwbGFjZSgvXy9nLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgc2lnbiAgID0gJy0nID09PSB2YWx1ZVswXSA/IC0xIDogMTtcbiAgZGlnaXRzID0gW107XG5cbiAgaWYgKDAgPD0gJystJy5pbmRleE9mKHZhbHVlWzBdKSkge1xuICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gIH1cblxuICBpZiAoJy5pbmYnID09PSB2YWx1ZSkge1xuICAgIHJldHVybiAoMSA9PT0gc2lnbikgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgfSBlbHNlIGlmICgnLm5hbicgPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIE5hTjtcblxuICB9IGVsc2UgaWYgKDAgPD0gdmFsdWUuaW5kZXhPZignOicpKSB7XG4gICAgdmFsdWUuc3BsaXQoJzonKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBkaWdpdHMudW5zaGlmdCgoPGFueT5wYXJzZUZsb2F0KSh2LCAxMCkpO1xuICAgIH0pO1xuXG4gICAgdmFsdWUgPSAwLjA7XG4gICAgYmFzZSA9IDE7XG5cbiAgICBkaWdpdHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgdmFsdWUgKz0gZCAqIGJhc2U7XG4gICAgICBiYXNlICo9IDYwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNpZ24gKiB2YWx1ZTtcblxuICB9XG4gIHJldHVybiBzaWduICogKDxhbnk+cGFyc2VGbG9hdCkodmFsdWUsIDEwKTtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEZsb2F0KG9iamVjdCwgc3R5bGUpIHtcbiAgaWYgKGlzTmFOKG9iamVjdCkpIHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgY2FzZSAnbG93ZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLm5hbic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLk5BTic7XG4gICAgY2FzZSAnY2FtZWxjYXNlJzpcbiAgICAgIHJldHVybiAnLk5hTic7XG4gICAgfVxuICB9IGVsc2UgaWYgKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA9PT0gb2JqZWN0KSB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgIGNhc2UgJ2xvd2VyY2FzZSc6XG4gICAgICByZXR1cm4gJy5pbmYnO1xuICAgIGNhc2UgJ3VwcGVyY2FzZSc6XG4gICAgICByZXR1cm4gJy5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy5JbmYnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgPT09IG9iamVjdCkge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICBjYXNlICdsb3dlcmNhc2UnOlxuICAgICAgcmV0dXJuICctLmluZic7XG4gICAgY2FzZSAndXBwZXJjYXNlJzpcbiAgICAgIHJldHVybiAnLS5JTkYnO1xuICAgIGNhc2UgJ2NhbWVsY2FzZSc6XG4gICAgICByZXR1cm4gJy0uSW5mJztcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29tbW9uLmlzTmVnYXRpdmVaZXJvKG9iamVjdCkpIHtcbiAgICByZXR1cm4gJy0wLjAnO1xuICB9XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoMTApO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0KG9iamVjdCkge1xuICByZXR1cm4gKCdbb2JqZWN0IE51bWJlcl0nID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSkgJiZcbiAgICAgICAgICgwICE9PSBvYmplY3QgJSAxIHx8IGNvbW1vbi5pc05lZ2F0aXZlWmVybyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbEZsb2F0LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxGbG9hdCxcbiAgcHJlZGljYXRlOiBpc0Zsb2F0LFxuICByZXByZXNlbnQ6IHJlcHJlc2VudFlhbWxGbG9hdCxcbiAgZGVmYXVsdFN0eWxlOiAnbG93ZXJjYXNlJ1xufSk7XG4iXX0=


	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?)?$');
		function resolveYamlTimestamp(data) {
		    if (null === data) {
		        return false;
		    }
		    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
		    match = YAML_TIMESTAMP_REGEXP.exec(data);
		    if (null === match) {
		        return false;
		    }
		    return true;
		}
		function constructYamlTimestamp(data) {
		    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
		    match = YAML_TIMESTAMP_REGEXP.exec(data);
		    if (null === match) {
		        throw new Error('Date resolve error');
		    }
		    year = +(match[1]);
		    month = +(match[2]) - 1;
		    day = +(match[3]);
		    if (!match[4]) {
		        return new Date(Date.UTC(year, month, day));
		    }
		    hour = +(match[4]);
		    minute = +(match[5]);
		    second = +(match[6]);
		    if (match[7]) {
		        fraction = match[7].slice(0, 3);
		        while (fraction.length < 3) {
		            fraction = fraction + '0';
		        }
		        fraction = +fraction;
		    }
		    if (match[9]) {
		        tz_hour = +(match[10]);
		        tz_minute = +(match[11] || 0);
		        delta = (tz_hour * 60 + tz_minute) * 60000;
		        if ('-' === match[9]) {
		            delta = -delta;
		        }
		    }
		    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
		    if (delta) {
		        date.setTime(date.getTime() - delta);
		    }
		    return date;
		}
		function representYamlTimestamp(object) {
		    return object.toISOString();
		}
		module.exports = new Type('tag:yaml.org,2002:timestamp', {
		    kind: 'scalar',
		    resolve: resolveYamlTimestamp,
		    construct: constructYamlTimestamp,
		    instanceOf: Date,
		    represent: representYamlTimestamp
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL3RpbWVzdGFtcC50cyJdLCJuYW1lcyI6WyJyZXNvbHZlWWFtbFRpbWVzdGFtcCIsImNvbnN0cnVjdFlhbWxUaW1lc3RhbXAiLCJyZXByZXNlbnRZYW1sVGltZXN0YW1wIl0sIm1hcHBpbmdzIjoiQUFFQSxZQUFZLENBQUM7QUFFYixJQUFPLElBQUksV0FBVyxTQUFTLENBQUMsQ0FBQztBQUVqQyxJQUFJLHFCQUFxQixHQUFHLElBQUksTUFBTSxDQUNwQyx5QkFBeUIsR0FDekIsZ0JBQWdCLEdBQ2hCLGdCQUFnQixHQUNoQixxQkFBcUIsR0FDckIsZUFBZSxHQUNmLGVBQWUsR0FDZixlQUFlLEdBQ2Ysa0JBQWtCLEdBQ2xCLGtDQUFrQyxHQUNsQywwQkFBMEIsQ0FBQyxDQUFDO0FBRTlCLFNBQVMsb0JBQW9CLENBQUMsSUFBSTtJQUNoQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbEJBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQ2ZBLENBQUNBO0lBRURBLElBQUlBLEtBQUtBLEVBQUVBLElBQUlBLEVBQUVBLEtBQUtBLEVBQUVBLEdBQUdBLEVBQUVBLElBQUlBLEVBQUVBLE1BQU1BLEVBQUVBLE1BQU1BLEVBQUVBLFFBQVFBLEdBQUdBLENBQUNBLEVBQzNEQSxLQUFLQSxHQUFHQSxJQUFJQSxFQUFFQSxPQUFPQSxFQUFFQSxTQUFTQSxFQUFFQSxJQUFJQSxDQUFDQTtJQUUzQ0EsS0FBS0EsR0FBR0EscUJBQXFCQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQTtJQUV6Q0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbkJBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQ2ZBLENBQUNBO0lBRURBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBO0FBQ2RBLENBQUNBO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxJQUFJO0lBQ2xDQyxJQUFJQSxLQUFLQSxFQUFFQSxJQUFJQSxFQUFFQSxLQUFLQSxFQUFFQSxHQUFHQSxFQUFFQSxJQUFJQSxFQUFFQSxNQUFNQSxFQUFFQSxNQUFNQSxFQUFFQSxRQUFRQSxHQUFpQkEsQ0FBQ0EsRUFDekVBLEtBQUtBLEdBQUdBLElBQUlBLEVBQUVBLE9BQU9BLEVBQUVBLFNBQVNBLEVBQUVBLElBQUlBLENBQUNBO0lBRTNDQSxLQUFLQSxHQUFHQSxxQkFBcUJBLENBQUNBLElBQUlBLENBQUNBLElBQUlBLENBQUNBLENBQUNBO0lBRXpDQSxFQUFFQSxDQUFDQSxDQUFDQSxJQUFJQSxLQUFLQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNuQkEsTUFBTUEsSUFBSUEsS0FBS0EsQ0FBQ0Esb0JBQW9CQSxDQUFDQSxDQUFDQTtJQUN4Q0EsQ0FBQ0E7SUFJREEsSUFBSUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDbkJBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBO0lBQ3hCQSxHQUFHQSxHQUFHQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtJQUVsQkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDZEEsTUFBTUEsQ0FBQ0EsSUFBSUEsSUFBSUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsSUFBSUEsRUFBRUEsS0FBS0EsRUFBRUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDOUNBLENBQUNBO0lBSURBLElBQUlBLEdBQUdBLENBQUNBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO0lBQ25CQSxNQUFNQSxHQUFHQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtJQUNyQkEsTUFBTUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFFckJBLEVBQUVBLENBQUNBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1FBQ2JBLFFBQVFBLEdBQUdBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBO1FBQ2hDQSxPQUFhQSxRQUFTQSxDQUFDQSxNQUFNQSxHQUFHQSxDQUFDQSxFQUFFQSxDQUFDQTtZQUNsQ0EsUUFBUUEsR0FBRUEsUUFBUUEsR0FBRUEsR0FBR0EsQ0FBQ0E7UUFDMUJBLENBQUNBO1FBQ0RBLFFBQVFBLEdBQUdBLENBQUNBLFFBQVFBLENBQUNBO0lBQ3ZCQSxDQUFDQTtJQUlEQSxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNiQSxPQUFPQSxHQUFHQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxFQUFFQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUN2QkEsU0FBU0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsRUFBRUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDOUJBLEtBQUtBLEdBQUdBLENBQUNBLE9BQU9BLEdBQUdBLEVBQUVBLEdBQUdBLFNBQVNBLENBQUNBLEdBQUdBLEtBQUtBLENBQUNBO1FBQzNDQSxFQUFFQSxDQUFDQSxDQUFDQSxHQUFHQSxLQUFLQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNyQkEsS0FBS0EsR0FBR0EsQ0FBQ0EsS0FBS0EsQ0FBQ0E7UUFDakJBLENBQUNBO0lBQ0hBLENBQUNBO0lBRURBLElBQUlBLEdBQUdBLElBQUlBLElBQUlBLENBQUNBLElBQUlBLENBQUNBLEdBQUdBLENBQUNBLElBQUlBLEVBQUVBLEtBQUtBLEVBQUVBLEdBQUdBLEVBQUVBLElBQUlBLEVBQUVBLE1BQU1BLEVBQUVBLE1BQU1BLEVBQVVBLFFBQVFBLENBQUNBLENBQUNBLENBQUNBO0lBRXBGQSxFQUFFQSxDQUFDQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNWQSxJQUFJQSxDQUFDQSxPQUFPQSxDQUFDQSxJQUFJQSxDQUFDQSxPQUFPQSxFQUFFQSxHQUFHQSxLQUFLQSxDQUFDQSxDQUFDQTtJQUN2Q0EsQ0FBQ0E7SUFFREEsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0E7QUFDZEEsQ0FBQ0E7QUFFRCxTQUFTLHNCQUFzQixDQUFDLE1BQU07SUFDcENDLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBLFdBQVdBLEVBQUVBLENBQUNBO0FBQzlCQSxDQUFDQTtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsNkJBQTZCLEVBQUU7SUFDdkQsSUFBSSxFQUFFLFFBQVE7SUFDZCxPQUFPLEVBQUUsb0JBQW9CO0lBQzdCLFNBQVMsRUFBRSxzQkFBc0I7SUFDakMsVUFBVSxFQUFFLElBQUk7SUFDaEIsU0FBUyxFQUFFLHNCQUFzQjtDQUNsQyxDQUFDLENBQUMiLCJmaWxlIjoic3JjL3JhbWwxL2pzeWFtbC9qcy15YW1sL3R5cGUvdGltZXN0YW1wLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgWUFNTF9USU1FU1RBTVBfUkVHRVhQID0gbmV3IFJlZ0V4cChcbiAgJ14oWzAtOV1bMC05XVswLTldWzAtOV0pJyAgICAgICAgICArIC8vIFsxXSB5ZWFyXG4gICctKFswLTldWzAtOV0/KScgICAgICAgICAgICAgICAgICAgKyAvLyBbMl0gbW9udGhcbiAgJy0oWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICArIC8vIFszXSBkYXlcbiAgJyg/Oig/OltUdF18WyBcXFxcdF0rKScgICAgICAgICAgICAgICsgLy8gLi4uXG4gICcoWzAtOV1bMC05XT8pJyAgICAgICAgICAgICAgICAgICAgKyAvLyBbNF0gaG91clxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzVdIG1pbnV0ZVxuICAnOihbMC05XVswLTldKScgICAgICAgICAgICAgICAgICAgICsgLy8gWzZdIHNlY29uZFxuICAnKD86XFxcXC4oWzAtOV0qKSk/JyAgICAgICAgICAgICAgICAgKyAvLyBbN10gZnJhY3Rpb25cbiAgJyg/OlsgXFxcXHRdKihafChbLStdKShbMC05XVswLTldPyknICsgLy8gWzhdIHR6IFs5XSB0el9zaWduIFsxMF0gdHpfaG91clxuICAnKD86OihbMC05XVswLTldKSk/KSk/KT8kJyk7ICAgICAgICAgLy8gWzExXSB0el9taW51dGVcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBtYXRjaCwgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZyYWN0aW9uID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAoZGF0YSkge1xuICB2YXIgbWF0Y2gsIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBmcmFjdGlvbjpudW1iZXJ8c3RyaW5nID0gMCxcbiAgICAgIGRlbHRhID0gbnVsbCwgdHpfaG91ciwgdHpfbWludXRlLCBkYXRlO1xuXG4gIG1hdGNoID0gWUFNTF9USU1FU1RBTVBfUkVHRVhQLmV4ZWMoZGF0YSk7XG5cbiAgaWYgKG51bGwgPT09IG1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEYXRlIHJlc29sdmUgZXJyb3InKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbMV0geWVhciBbMl0gbW9udGggWzNdIGRheVxuXG4gIHllYXIgPSArKG1hdGNoWzFdKTtcbiAgbW9udGggPSArKG1hdGNoWzJdKSAtIDE7IC8vIEpTIG1vbnRoIHN0YXJ0cyB3aXRoIDBcbiAgZGF5ID0gKyhtYXRjaFszXSk7XG5cbiAgaWYgKCFtYXRjaFs0XSkgeyAvLyBubyBob3VyXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXkpKTtcbiAgfVxuXG4gIC8vIG1hdGNoOiBbNF0gaG91ciBbNV0gbWludXRlIFs2XSBzZWNvbmQgWzddIGZyYWN0aW9uXG5cbiAgaG91ciA9ICsobWF0Y2hbNF0pO1xuICBtaW51dGUgPSArKG1hdGNoWzVdKTtcbiAgc2Vjb25kID0gKyhtYXRjaFs2XSk7XG5cbiAgaWYgKG1hdGNoWzddKSB7XG4gICAgZnJhY3Rpb24gPSBtYXRjaFs3XS5zbGljZSgwLCAzKTtcbiAgICB3aGlsZSAoKDxhbnk+ZnJhY3Rpb24pLmxlbmd0aCA8IDMpIHsgLy8gbWlsbGktc2Vjb25kc1xuICAgICAgZnJhY3Rpb24gPWZyYWN0aW9uKyAnMCc7XG4gICAgfVxuICAgIGZyYWN0aW9uID0gK2ZyYWN0aW9uO1xuICB9XG5cbiAgLy8gbWF0Y2g6IFs4XSB0eiBbOV0gdHpfc2lnbiBbMTBdIHR6X2hvdXIgWzExXSB0el9taW51dGVcblxuICBpZiAobWF0Y2hbOV0pIHtcbiAgICB0el9ob3VyID0gKyhtYXRjaFsxMF0pO1xuICAgIHR6X21pbnV0ZSA9ICsobWF0Y2hbMTFdIHx8IDApO1xuICAgIGRlbHRhID0gKHR6X2hvdXIgKiA2MCArIHR6X21pbnV0ZSkgKiA2MDAwMDsgLy8gZGVsdGEgaW4gbWlsaS1zZWNvbmRzXG4gICAgaWYgKCctJyA9PT0gbWF0Y2hbOV0pIHtcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIH1cbiAgfVxuXG4gIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgPG51bWJlcj5mcmFjdGlvbikpO1xuXG4gIGlmIChkZWx0YSkge1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSAtIGRlbHRhKTtcbiAgfVxuXG4gIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRZYW1sVGltZXN0YW1wKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICByZXR1cm4gb2JqZWN0LnRvSVNPU3RyaW5nKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sVGltZXN0YW1wLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxUaW1lc3RhbXAsXG4gIGluc3RhbmNlT2Y6IERhdGUsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbFRpbWVzdGFtcFxufSk7XG4iXX0=


	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		function resolveYamlMerge(data) {
		    return '<<' === data || null === data;
		}
		module.exports = new Type('tag:yaml.org,2002:merge', {
		    kind: 'scalar',
		    resolve: resolveYamlMerge
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL21lcmdlLnRzIl0sIm5hbWVzIjpbInJlc29sdmVZYW1sTWVyZ2UiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBRWpDLFNBQVMsZ0JBQWdCLENBQUMsSUFBSTtJQUM1QkEsTUFBTUEsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsSUFBSUEsSUFBSUEsS0FBS0EsSUFBSUEsQ0FBQ0E7QUFDeENBLENBQUNBO0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtJQUNuRCxJQUFJLEVBQUUsUUFBUTtJQUNkLE9BQU8sRUFBRSxnQkFBZ0I7Q0FDMUIsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL21lcmdlLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE1lcmdlKGRhdGEpIHtcbiAgcmV0dXJuICc8PCcgPT09IGRhdGEgfHwgbnVsbCA9PT0gZGF0YTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLCB7XG4gIGtpbmQ6ICdzY2FsYXInLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE1lcmdlXG59KTtcbiJdfQ==


	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var NodeBuffer = __webpack_require__(38).Buffer;
		var Type = __webpack_require__(24);
		var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
		function resolveYamlBinary(data) {
		    if (null === data) {
		        return false;
		    }
		    var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
		    for (idx = 0; idx < max; idx++) {
		        code = map.indexOf(data.charAt(idx));
		        if (code > 64) {
		            continue;
		        }
		        if (code < 0) {
		            return false;
		        }
		        bitlen += 6;
		    }
		    return (bitlen % 8) === 0;
		}
		function constructYamlBinary(data) {
		    var code, idx, tailbits, input = data.replace(/[\r\n=]/g, ''), max = input.length, map = BASE64_MAP, bits = 0, result = [];
		    for (idx = 0; idx < max; idx++) {
		        if ((idx % 4 === 0) && idx) {
		            result.push((bits >> 16) & 0xFF);
		            result.push((bits >> 8) & 0xFF);
		            result.push(bits & 0xFF);
		        }
		        bits = (bits << 6) | map.indexOf(input.charAt(idx));
		    }
		    tailbits = (max % 4) * 6;
		    if (tailbits === 0) {
		        result.push((bits >> 16) & 0xFF);
		        result.push((bits >> 8) & 0xFF);
		        result.push(bits & 0xFF);
		    }
		    else if (tailbits === 18) {
		        result.push((bits >> 10) & 0xFF);
		        result.push((bits >> 2) & 0xFF);
		    }
		    else if (tailbits === 12) {
		        result.push((bits >> 4) & 0xFF);
		    }
		    if (NodeBuffer) {
		        return new NodeBuffer(result);
		    }
		    return result;
		}
		function representYamlBinary(object) {
		    var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
		    for (idx = 0; idx < max; idx++) {
		        if ((idx % 3 === 0) && idx) {
		            result += map[(bits >> 18) & 0x3F];
		            result += map[(bits >> 12) & 0x3F];
		            result += map[(bits >> 6) & 0x3F];
		            result += map[bits & 0x3F];
		        }
		        bits = (bits << 8) + object[idx];
		    }
		    tail = max % 3;
		    if (tail === 0) {
		        result += map[(bits >> 18) & 0x3F];
		        result += map[(bits >> 12) & 0x3F];
		        result += map[(bits >> 6) & 0x3F];
		        result += map[bits & 0x3F];
		    }
		    else if (tail === 2) {
		        result += map[(bits >> 10) & 0x3F];
		        result += map[(bits >> 4) & 0x3F];
		        result += map[(bits << 2) & 0x3F];
		        result += map[64];
		    }
		    else if (tail === 1) {
		        result += map[(bits >> 2) & 0x3F];
		        result += map[(bits << 4) & 0x3F];
		        result += map[64];
		        result += map[64];
		    }
		    return result;
		}
		function isBinary(object) {
		    return NodeBuffer && NodeBuffer.isBuffer(object);
		}
		module.exports = new Type('tag:yaml.org,2002:binary', {
		    kind: 'scalar',
		    resolve: resolveYamlBinary,
		    construct: constructYamlBinary,
		    predicate: isBinary,
		    represent: representYamlBinary
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2JpbmFyeS50cyJdLCJuYW1lcyI6WyJyZXNvbHZlWWFtbEJpbmFyeSIsImNvbnN0cnVjdFlhbWxCaW5hcnkiLCJyZXByZXNlbnRZYW1sQmluYXJ5IiwiaXNCaW5hcnkiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQU1iLElBQUksVUFBVSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDMUMsSUFBTyxJQUFJLFdBQWlCLFNBQVMsQ0FBQyxDQUFDO0FBSXZDLElBQUksVUFBVSxHQUFHLHVFQUF1RSxDQUFDO0FBR3pGLFNBQVMsaUJBQWlCLENBQUMsSUFBSTtJQUM3QkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbEJBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQ2ZBLENBQUNBO0lBRURBLElBQUlBLElBQUlBLEVBQUVBLEdBQUdBLEVBQUVBLE1BQU1BLEdBQUdBLENBQUNBLEVBQUVBLEdBQUdBLEdBQUdBLENBQUNBLEVBQUVBLEdBQUdBLEdBQUdBLElBQUlBLENBQUNBLE1BQU1BLEVBQUVBLEdBQUdBLEdBQUdBLFVBQVVBLENBQUNBO0lBR3hFQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFHQSxHQUFHQSxDQUFDQSxFQUFFQSxHQUFHQSxHQUFHQSxHQUFHQSxFQUFFQSxHQUFHQSxFQUFFQSxFQUFFQSxDQUFDQTtRQUMvQkEsSUFBSUEsR0FBR0EsR0FBR0EsQ0FBQ0EsT0FBT0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsTUFBTUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFHckNBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEdBQUdBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBO1lBQUNBLFFBQVFBLENBQUNBO1FBQUNBLENBQUNBO1FBRzVCQSxFQUFFQSxDQUFDQSxDQUFDQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUFDQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtRQUFDQSxDQUFDQTtRQUUvQkEsTUFBTUEsSUFBSUEsQ0FBQ0EsQ0FBQ0E7SUFDZEEsQ0FBQ0E7SUFHREEsTUFBTUEsQ0FBQ0EsQ0FBQ0EsTUFBTUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0E7QUFDNUJBLENBQUNBO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxJQUFJO0lBQy9CQyxJQUFJQSxJQUFJQSxFQUFFQSxHQUFHQSxFQUFFQSxRQUFRQSxFQUNuQkEsS0FBS0EsR0FBR0EsSUFBSUEsQ0FBQ0EsT0FBT0EsQ0FBQ0EsVUFBVUEsRUFBRUEsRUFBRUEsQ0FBQ0EsRUFDcENBLEdBQUdBLEdBQUdBLEtBQUtBLENBQUNBLE1BQU1BLEVBQ2xCQSxHQUFHQSxHQUFHQSxVQUFVQSxFQUNoQkEsSUFBSUEsR0FBR0EsQ0FBQ0EsRUFDUkEsTUFBTUEsR0FBR0EsRUFBRUEsQ0FBQ0E7SUFJaEJBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLEdBQUdBLENBQUNBLEVBQUVBLEdBQUdBLEdBQUdBLEdBQUdBLEVBQUVBLEdBQUdBLEVBQUVBLEVBQUVBLENBQUNBO1FBQy9CQSxFQUFFQSxDQUFDQSxDQUFDQSxDQUFDQSxHQUFHQSxHQUFHQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUMzQkEsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBSUEsRUFBRUEsQ0FBQ0EsR0FBR0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7WUFDakNBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQUNBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1lBQ2hDQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtRQUMzQkEsQ0FBQ0E7UUFFREEsSUFBSUEsR0FBR0EsQ0FBQ0EsSUFBSUEsSUFBSUEsQ0FBQ0EsQ0FBQ0EsR0FBR0EsR0FBR0EsQ0FBQ0EsT0FBT0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDdERBLENBQUNBO0lBSURBLFFBQVFBLEdBQUdBLENBQUNBLEdBQUdBLEdBQUdBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBO0lBRXpCQSxFQUFFQSxDQUFDQSxDQUFDQSxRQUFRQSxLQUFLQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNuQkEsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBSUEsRUFBRUEsQ0FBQ0EsR0FBR0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7UUFDakNBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQUNBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1FBQ2hDQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtJQUMzQkEsQ0FBQ0E7SUFBQ0EsSUFBSUEsQ0FBQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsUUFBUUEsS0FBS0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDM0JBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLEVBQUVBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1FBQ2pDQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFDQSxDQUFDQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtJQUNsQ0EsQ0FBQ0E7SUFBQ0EsSUFBSUEsQ0FBQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsUUFBUUEsS0FBS0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDM0JBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQUNBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO0lBQ2xDQSxDQUFDQTtJQUdEQSxFQUFFQSxDQUFDQSxDQUFDQSxVQUFVQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNmQSxNQUFNQSxDQUFDQSxJQUFJQSxVQUFVQSxDQUFDQSxNQUFNQSxDQUFDQSxDQUFDQTtJQUNoQ0EsQ0FBQ0E7SUFFREEsTUFBTUEsQ0FBQ0EsTUFBTUEsQ0FBQ0E7QUFDaEJBLENBQUNBO0FBRUQsU0FBUyxtQkFBbUIsQ0FBQyxNQUFNO0lBQ2pDQyxJQUFJQSxNQUFNQSxHQUFHQSxFQUFFQSxFQUFFQSxJQUFJQSxHQUFHQSxDQUFDQSxFQUFFQSxHQUFHQSxFQUFFQSxJQUFJQSxFQUNoQ0EsR0FBR0EsR0FBR0EsTUFBTUEsQ0FBQ0EsTUFBTUEsRUFDbkJBLEdBQUdBLEdBQUdBLFVBQVVBLENBQUNBO0lBSXJCQSxHQUFHQSxDQUFDQSxDQUFDQSxHQUFHQSxHQUFHQSxDQUFDQSxFQUFFQSxHQUFHQSxHQUFHQSxHQUFHQSxFQUFFQSxHQUFHQSxFQUFFQSxFQUFFQSxDQUFDQTtRQUMvQkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsR0FBR0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDM0JBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLEVBQUVBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1lBQ25DQSxNQUFNQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxFQUFFQSxDQUFDQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtZQUNuQ0EsTUFBTUEsSUFBSUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBSUEsQ0FBQ0EsQ0FBQ0EsR0FBR0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7WUFDbENBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBLElBQUlBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1FBQzdCQSxDQUFDQTtRQUVEQSxJQUFJQSxHQUFHQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFDQSxDQUFDQSxHQUFHQSxNQUFNQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQTtJQUNuQ0EsQ0FBQ0E7SUFJREEsSUFBSUEsR0FBR0EsR0FBR0EsR0FBR0EsQ0FBQ0EsQ0FBQ0E7SUFFZkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDZkEsTUFBTUEsSUFBSUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBSUEsRUFBRUEsQ0FBQ0EsR0FBR0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7UUFDbkNBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLEVBQUVBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1FBQ25DQSxNQUFNQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFDQSxDQUFDQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtRQUNsQ0EsTUFBTUEsSUFBSUEsR0FBR0EsQ0FBQ0EsSUFBSUEsR0FBR0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7SUFDN0JBLENBQUNBO0lBQUNBLElBQUlBLENBQUNBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1FBQ3RCQSxNQUFNQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxFQUFFQSxDQUFDQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtRQUNuQ0EsTUFBTUEsSUFBSUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFBSUEsQ0FBQ0EsQ0FBQ0EsR0FBR0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7UUFDbENBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQUNBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1FBQ2xDQSxNQUFNQSxJQUFJQSxHQUFHQSxDQUFDQSxFQUFFQSxDQUFDQSxDQUFDQTtJQUNwQkEsQ0FBQ0E7SUFBQ0EsSUFBSUEsQ0FBQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDdEJBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBLENBQUNBLElBQUlBLElBQUlBLENBQUNBLENBQUNBLEdBQUdBLElBQUlBLENBQUNBLENBQUNBO1FBQ2xDQSxNQUFNQSxJQUFJQSxHQUFHQSxDQUFDQSxDQUFDQSxJQUFJQSxJQUFJQSxDQUFDQSxDQUFDQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQTtRQUNsQ0EsTUFBTUEsSUFBSUEsR0FBR0EsQ0FBQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0E7UUFDbEJBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBLEVBQUVBLENBQUNBLENBQUNBO0lBQ3BCQSxDQUFDQTtJQUVEQSxNQUFNQSxDQUFDQSxNQUFNQSxDQUFDQTtBQUNoQkEsQ0FBQ0E7QUFFRCxTQUFTLFFBQVEsQ0FBQyxNQUFNO0lBQ3RCQyxNQUFNQSxDQUFDQSxVQUFVQSxJQUFJQSxVQUFVQSxDQUFDQSxRQUFRQSxDQUFDQSxNQUFNQSxDQUFDQSxDQUFDQTtBQUNuREEsQ0FBQ0E7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLDBCQUEwQixFQUFFO0lBQ3BELElBQUksRUFBRSxRQUFRO0lBQ2QsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixTQUFTLEVBQUUsbUJBQW1CO0lBQzlCLFNBQVMsRUFBRSxRQUFRO0lBQ25CLFNBQVMsRUFBRSxtQkFBbUI7Q0FDL0IsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2JpbmFyeS5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyIsInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi90eXBpbmdzL3RzZC5kLnRzXCIgLz5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UqL1xuXG4vLyBBIHRyaWNrIGZvciBicm93c2VyaWZpZWQgdmVyc2lvbi5cbi8vIFNpbmNlIHdlIG1ha2UgYnJvd3NlcmlmaWVyIHRvIGlnbm9yZSBgYnVmZmVyYCBtb2R1bGUsIE5vZGVCdWZmZXIgd2lsbCBiZSB1bmRlZmluZWRcbnZhciBOb2RlQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuaW1wb3J0IFR5cGUgICAgICAgPSByZXF1aXJlKCcuLi90eXBlJyk7XG5cblxuLy8gWyA2NCwgNjUsIDY2IF0gLT4gWyBwYWRkaW5nLCBDUiwgTEYgXVxudmFyIEJBU0U2NF9NQVAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cXG5cXHInO1xuXG5cbmZ1bmN0aW9uIHJlc29sdmVZYW1sQmluYXJ5KGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY29kZSwgaWR4LCBiaXRsZW4gPSAwLCBsZW4gPSAwLCBtYXggPSBkYXRhLmxlbmd0aCwgbWFwID0gQkFTRTY0X01BUDtcblxuICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbWF4OyBpZHgrKykge1xuICAgIGNvZGUgPSBtYXAuaW5kZXhPZihkYXRhLmNoYXJBdChpZHgpKTtcblxuICAgIC8vIFNraXAgQ1IvTEZcbiAgICBpZiAoY29kZSA+IDY0KSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBGYWlsIG9uIGlsbGVnYWwgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGJpdGxlbiArPSA2O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHNvdXJjZSB3YXMgY29ycnVwdGVkXG4gIHJldHVybiAoYml0bGVuICUgOCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxCaW5hcnkoZGF0YSkge1xuICB2YXIgY29kZSwgaWR4LCB0YWlsYml0cyxcbiAgICAgIGlucHV0ID0gZGF0YS5yZXBsYWNlKC9bXFxyXFxuPV0vZywgJycpLCAvLyByZW1vdmUgQ1IvTEYgJiBwYWRkaW5nIHRvIHNpbXBsaWZ5IHNjYW5cbiAgICAgIG1heCA9IGlucHV0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVAsXG4gICAgICBiaXRzID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIC8vIENvbGxlY3QgYnkgNio0IGJpdHMgKDMgYnl0ZXMpXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSA0ID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChiaXRzID4+IDE2KSAmIDB4RkYpO1xuICAgICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICAgIHJlc3VsdC5wdXNoKGJpdHMgJiAweEZGKTtcbiAgICB9XG5cbiAgICBiaXRzID0gKGJpdHMgPDwgNikgfCBtYXAuaW5kZXhPZihpbnB1dC5jaGFyQXQoaWR4KSk7XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsYml0cyA9IChtYXggJSA0KSAqIDY7XG5cbiAgaWYgKHRhaWxiaXRzID09PSAwKSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTYpICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gOCkgJiAweEZGKTtcbiAgICByZXN1bHQucHVzaChiaXRzICYgMHhGRik7XG4gIH0gZWxzZSBpZiAodGFpbGJpdHMgPT09IDE4KSB7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMTApICYgMHhGRik7XG4gICAgcmVzdWx0LnB1c2goKGJpdHMgPj4gMikgJiAweEZGKTtcbiAgfSBlbHNlIGlmICh0YWlsYml0cyA9PT0gMTIpIHtcbiAgICByZXN1bHQucHVzaCgoYml0cyA+PiA0KSAmIDB4RkYpO1xuICB9XG5cbiAgLy8gV3JhcCBpbnRvIEJ1ZmZlciBmb3IgTm9kZUpTIGFuZCBsZWF2ZSBBcnJheSBmb3IgYnJvd3NlclxuICBpZiAoTm9kZUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgTm9kZUJ1ZmZlcihyZXN1bHQpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVwcmVzZW50WWFtbEJpbmFyeShvYmplY3QgLyosIHN0eWxlKi8pIHtcbiAgdmFyIHJlc3VsdCA9ICcnLCBiaXRzID0gMCwgaWR4LCB0YWlsLFxuICAgICAgbWF4ID0gb2JqZWN0Lmxlbmd0aCxcbiAgICAgIG1hcCA9IEJBU0U2NF9NQVA7XG5cbiAgLy8gQ29udmVydCBldmVyeSB0aHJlZSBieXRlcyB0byA0IEFTQ0lJIGNoYXJhY3RlcnMuXG5cbiAgZm9yIChpZHggPSAwOyBpZHggPCBtYXg7IGlkeCsrKSB7XG4gICAgaWYgKChpZHggJSAzID09PSAwKSAmJiBpZHgpIHtcbiAgICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDEyKSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA2KSAmIDB4M0ZdO1xuICAgICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gICAgfVxuXG4gICAgYml0cyA9IChiaXRzIDw8IDgpICsgb2JqZWN0W2lkeF07XG4gIH1cblxuICAvLyBEdW1wIHRhaWxcblxuICB0YWlsID0gbWF4ICUgMztcblxuICBpZiAodGFpbCA9PT0gMCkge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTgpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAxMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWyhiaXRzID4+IDYpICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFtiaXRzICYgMHgzRl07XG4gIH0gZWxzZSBpZiAodGFpbCA9PT0gMikge1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPj4gMTApICYgMHgzRl07XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiA0KSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgMikgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfSBlbHNlIGlmICh0YWlsID09PSAxKSB7XG4gICAgcmVzdWx0ICs9IG1hcFsoYml0cyA+PiAyKSAmIDB4M0ZdO1xuICAgIHJlc3VsdCArPSBtYXBbKGJpdHMgPDwgNCkgJiAweDNGXTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgICByZXN1bHQgKz0gbWFwWzY0XTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iamVjdCkge1xuICByZXR1cm4gTm9kZUJ1ZmZlciAmJiBOb2RlQnVmZmVyLmlzQnVmZmVyKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sQmluYXJ5LFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdFlhbWxCaW5hcnksXG4gIHByZWRpY2F0ZTogaXNCaW5hcnksXG4gIHJlcHJlc2VudDogcmVwcmVzZW50WWFtbEJpbmFyeVxufSk7XG4iXX0=


	/***/ },
	/* 38 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(6);

	/***/ },
	/* 39 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		var _toString = Object.prototype.toString;
		function resolveYamlOmap(data) {
		    if (null === data) {
		        return true;
		    }
		    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
		    for (index = 0, length = object.length; index < length; index += 1) {
		        pair = object[index];
		        pairHasKey = false;
		        if ('[object Object]' !== _toString.call(pair)) {
		            return false;
		        }
		        for (pairKey in pair) {
		            if (_hasOwnProperty.call(pair, pairKey)) {
		                if (!pairHasKey) {
		                    pairHasKey = true;
		                }
		                else {
		                    return false;
		                }
		            }
		        }
		        if (!pairHasKey) {
		            return false;
		        }
		        if (-1 === objectKeys.indexOf(pairKey)) {
		            objectKeys.push(pairKey);
		        }
		        else {
		            return false;
		        }
		    }
		    return true;
		}
		function constructYamlOmap(data) {
		    return null !== data ? data : [];
		}
		module.exports = new Type('tag:yaml.org,2002:omap', {
		    kind: 'sequence',
		    resolve: resolveYamlOmap,
		    construct: constructYamlOmap
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL29tYXAudHMiXSwibmFtZXMiOlsicmVzb2x2ZVlhbWxPbWFwIiwiY29uc3RydWN0WWFtbE9tYXAiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBRWpDLElBQUksZUFBZSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO0FBQ3RELElBQUksU0FBUyxHQUFTLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBRWhELFNBQVMsZUFBZSxDQUFDLElBQUk7SUFDM0JBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtJQUNkQSxDQUFDQTtJQUVEQSxJQUFJQSxVQUFVQSxHQUFHQSxFQUFFQSxFQUFFQSxLQUFLQSxFQUFFQSxNQUFNQSxFQUFFQSxJQUFJQSxFQUFFQSxPQUFPQSxFQUFFQSxVQUFVQSxFQUN6REEsTUFBTUEsR0FBR0EsSUFBSUEsQ0FBQ0E7SUFFbEJBLEdBQUdBLENBQUNBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLEVBQUVBLE1BQU1BLEdBQUdBLE1BQU1BLENBQUNBLE1BQU1BLEVBQUVBLEtBQUtBLEdBQUdBLE1BQU1BLEVBQUVBLEtBQUtBLElBQUlBLENBQUNBLEVBQUVBLENBQUNBO1FBQ25FQSxJQUFJQSxHQUFHQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQTtRQUNyQkEsVUFBVUEsR0FBR0EsS0FBS0EsQ0FBQ0E7UUFFbkJBLEVBQUVBLENBQUNBLENBQUNBLGlCQUFpQkEsS0FBS0EsU0FBU0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDL0NBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO1FBQ2ZBLENBQUNBO1FBRURBLEdBQUdBLENBQUNBLENBQUNBLE9BQU9BLElBQUlBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1lBQ3JCQSxFQUFFQSxDQUFDQSxDQUFDQSxlQUFlQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxFQUFFQSxPQUFPQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtnQkFDeENBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLFVBQVVBLENBQUNBLENBQUNBLENBQUNBO29CQUNoQkEsVUFBVUEsR0FBR0EsSUFBSUEsQ0FBQ0E7Z0JBQ3BCQSxDQUFDQTtnQkFBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7b0JBQ05BLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO2dCQUNmQSxDQUFDQTtZQUNIQSxDQUFDQTtRQUNIQSxDQUFDQTtRQUVEQSxFQUFFQSxDQUFDQSxDQUFDQSxDQUFDQSxVQUFVQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNoQkEsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7UUFDZkEsQ0FBQ0E7UUFFREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsS0FBS0EsVUFBVUEsQ0FBQ0EsT0FBT0EsQ0FBQ0EsT0FBT0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFDdkNBLFVBQVVBLENBQUNBLElBQUlBLENBQUNBLE9BQU9BLENBQUNBLENBQUNBO1FBQzNCQSxDQUFDQTtRQUFDQSxJQUFJQSxDQUFDQSxDQUFDQTtZQUNOQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtRQUNmQSxDQUFDQTtJQUNIQSxDQUFDQTtJQUVEQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtBQUNkQSxDQUFDQTtBQUVELFNBQVMsaUJBQWlCLENBQUMsSUFBSTtJQUM3QkMsTUFBTUEsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsR0FBR0EsSUFBSUEsR0FBR0EsRUFBRUEsQ0FBQ0E7QUFDbkNBLENBQUNBO0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyx3QkFBd0IsRUFBRTtJQUNsRCxJQUFJLEVBQUUsVUFBVTtJQUNoQixPQUFPLEVBQUUsZUFBZTtJQUN4QixTQUFTLEVBQUUsaUJBQWlCO0NBQzdCLENBQUMsQ0FBQyIsImZpbGUiOiJzcmMvcmFtbDEvanN5YW1sL2pzLXlhbWwvdHlwZS9vbWFwLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfdG9TdHJpbmcgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiByZXNvbHZlWWFtbE9tYXAoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG9iamVjdEtleXMgPSBbXSwgaW5kZXgsIGxlbmd0aCwgcGFpciwgcGFpcktleSwgcGFpckhhc0tleSxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG4gICAgcGFpckhhc0tleSA9IGZhbHNlO1xuXG4gICAgaWYgKCdbb2JqZWN0IE9iamVjdF0nICE9PSBfdG9TdHJpbmcuY2FsbChwYWlyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAocGFpcktleSBpbiBwYWlyKSB7XG4gICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwocGFpciwgcGFpcktleSkpIHtcbiAgICAgICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICAgICAgcGFpckhhc0tleSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYWlySGFzS2V5KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC0xID09PSBvYmplY3RLZXlzLmluZGV4T2YocGFpcktleSkpIHtcbiAgICAgIG9iamVjdEtleXMucHVzaChwYWlyS2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sT21hcChkYXRhKSB7XG4gIHJldHVybiBudWxsICE9PSBkYXRhID8gZGF0YSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJywge1xuICBraW5kOiAnc2VxdWVuY2UnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbE9tYXAsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbE9tYXBcbn0pO1xuIl19


	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		var _toString = Object.prototype.toString;
		function resolveYamlPairs(data) {
		    if (null === data) {
		        return true;
		    }
		    var index, length, pair, keys, result, object = data;
		    result = new Array(object.length);
		    for (index = 0, length = object.length; index < length; index += 1) {
		        pair = object[index];
		        if ('[object Object]' !== _toString.call(pair)) {
		            return false;
		        }
		        keys = Object.keys(pair);
		        if (1 !== keys.length) {
		            return false;
		        }
		        result[index] = [keys[0], pair[keys[0]]];
		    }
		    return true;
		}
		function constructYamlPairs(data) {
		    if (null === data) {
		        return [];
		    }
		    var index, length, pair, keys, result, object = data;
		    result = new Array(object.length);
		    for (index = 0, length = object.length; index < length; index += 1) {
		        pair = object[index];
		        keys = Object.keys(pair);
		        result[index] = [keys[0], pair[keys[0]]];
		    }
		    return result;
		}
		module.exports = new Type('tag:yaml.org,2002:pairs', {
		    kind: 'sequence',
		    resolve: resolveYamlPairs,
		    construct: constructYamlPairs
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL3BhaXJzLnRzIl0sIm5hbWVzIjpbInJlc29sdmVZYW1sUGFpcnMiLCJjb25zdHJ1Y3RZYW1sUGFpcnMiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBRWpDLElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBRTFDLFNBQVMsZ0JBQWdCLENBQUMsSUFBSTtJQUM1QkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbEJBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBO0lBQ2RBLENBQUNBO0lBRURBLElBQUlBLEtBQUtBLEVBQUVBLE1BQU1BLEVBQUVBLElBQUlBLEVBQUVBLElBQUlBLEVBQUVBLE1BQU1BLEVBQ2pDQSxNQUFNQSxHQUFHQSxJQUFJQSxDQUFDQTtJQUVsQkEsTUFBTUEsR0FBR0EsSUFBSUEsS0FBS0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsTUFBTUEsQ0FBQ0EsQ0FBQ0E7SUFFbENBLEdBQUdBLENBQUNBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLEVBQUVBLE1BQU1BLEdBQUdBLE1BQU1BLENBQUNBLE1BQU1BLEVBQUVBLEtBQUtBLEdBQUdBLE1BQU1BLEVBQUVBLEtBQUtBLElBQUlBLENBQUNBLEVBQUVBLENBQUNBO1FBQ25FQSxJQUFJQSxHQUFHQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQTtRQUVyQkEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsaUJBQWlCQSxLQUFLQSxTQUFTQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUMvQ0EsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7UUFDZkEsQ0FBQ0E7UUFFREEsSUFBSUEsR0FBR0EsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0E7UUFFekJBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLEtBQUtBLElBQUlBLENBQUNBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBO1lBQ3RCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtRQUNmQSxDQUFDQTtRQUVEQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQSxHQUFHQSxDQUFFQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxFQUFFQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFFQSxDQUFDQTtJQUM3Q0EsQ0FBQ0E7SUFFREEsTUFBTUEsQ0FBQ0EsSUFBSUEsQ0FBQ0E7QUFDZEEsQ0FBQ0E7QUFFRCxTQUFTLGtCQUFrQixDQUFDLElBQUk7SUFDOUJDLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxFQUFFQSxDQUFDQTtJQUNaQSxDQUFDQTtJQUVEQSxJQUFJQSxLQUFLQSxFQUFFQSxNQUFNQSxFQUFFQSxJQUFJQSxFQUFFQSxJQUFJQSxFQUFFQSxNQUFNQSxFQUNqQ0EsTUFBTUEsR0FBR0EsSUFBSUEsQ0FBQ0E7SUFFbEJBLE1BQU1BLEdBQUdBLElBQUlBLEtBQUtBLENBQUNBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBLENBQUNBO0lBRWxDQSxHQUFHQSxDQUFDQSxDQUFDQSxLQUFLQSxHQUFHQSxDQUFDQSxFQUFFQSxNQUFNQSxHQUFHQSxNQUFNQSxDQUFDQSxNQUFNQSxFQUFFQSxLQUFLQSxHQUFHQSxNQUFNQSxFQUFFQSxLQUFLQSxJQUFJQSxDQUFDQSxFQUFFQSxDQUFDQTtRQUNuRUEsSUFBSUEsR0FBR0EsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0E7UUFFckJBLElBQUlBLEdBQUdBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBLElBQUlBLENBQUNBLENBQUNBO1FBRXpCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQSxHQUFHQSxDQUFFQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxFQUFFQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFFQSxDQUFDQTtJQUM3Q0EsQ0FBQ0E7SUFFREEsTUFBTUEsQ0FBQ0EsTUFBTUEsQ0FBQ0E7QUFDaEJBLENBQUNBO0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyx5QkFBeUIsRUFBRTtJQUNuRCxJQUFJLEVBQUUsVUFBVTtJQUNoQixPQUFPLEVBQUUsZ0JBQWdCO0lBQ3pCLFNBQVMsRUFBRSxrQkFBa0I7Q0FDOUIsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL3BhaXJzLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaW5kZXgsIGxlbmd0aCwgcGFpciwga2V5cywgcmVzdWx0LFxuICAgICAgb2JqZWN0ID0gZGF0YTtcblxuICByZXN1bHQgPSBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCk7XG5cbiAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IG9iamVjdC5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgcGFpciA9IG9iamVjdFtpbmRleF07XG5cbiAgICBpZiAoJ1tvYmplY3QgT2JqZWN0XScgIT09IF90b1N0cmluZy5jYWxsKHBhaXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgaWYgKDEgIT09IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFlhbWxQYWlycyhkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGluZGV4LCBsZW5ndGgsIHBhaXIsIGtleXMsIHJlc3VsdCxcbiAgICAgIG9iamVjdCA9IGRhdGE7XG5cbiAgcmVzdWx0ID0gbmV3IEFycmF5KG9iamVjdC5sZW5ndGgpO1xuXG4gIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBvYmplY3QubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgIHBhaXIgPSBvYmplY3RbaW5kZXhdO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHBhaXIpO1xuXG4gICAgcmVzdWx0W2luZGV4XSA9IFsga2V5c1swXSwgcGFpcltrZXlzWzBdXSBdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnLCB7XG4gIGtpbmQ6ICdzZXF1ZW5jZScsXG4gIHJlc29sdmU6IHJlc29sdmVZYW1sUGFpcnMsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0WWFtbFBhaXJzXG59KTtcbiJdfQ==


	/***/ },
	/* 41 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		function resolveYamlSet(data) {
		    if (null === data) {
		        return true;
		    }
		    var key, object = data;
		    for (key in object) {
		        if (_hasOwnProperty.call(object, key)) {
		            if (null !== object[key]) {
		                return false;
		            }
		        }
		    }
		    return true;
		}
		function constructYamlSet(data) {
		    return null !== data ? data : {};
		}
		module.exports = new Type('tag:yaml.org,2002:set', {
		    kind: 'mapping',
		    resolve: resolveYamlSet,
		    construct: constructYamlSet
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL3NldC50cyJdLCJuYW1lcyI6WyJyZXNvbHZlWWFtbFNldCIsImNvbnN0cnVjdFlhbWxTZXQiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFNBQVMsQ0FBQyxDQUFDO0FBRWpDLElBQUksZUFBZSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDO0FBRXRELFNBQVMsY0FBYyxDQUFDLElBQUk7SUFDMUJBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtJQUNkQSxDQUFDQTtJQUVEQSxJQUFJQSxHQUFHQSxFQUFFQSxNQUFNQSxHQUFHQSxJQUFJQSxDQUFDQTtJQUV2QkEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsR0FBR0EsSUFBSUEsTUFBTUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbkJBLEVBQUVBLENBQUNBLENBQUNBLGVBQWVBLENBQUNBLElBQUlBLENBQUNBLE1BQU1BLEVBQUVBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1lBQ3RDQSxFQUFFQSxDQUFDQSxDQUFDQSxJQUFJQSxLQUFLQSxNQUFNQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtnQkFDekJBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO1lBQ2ZBLENBQUNBO1FBQ0hBLENBQUNBO0lBQ0hBLENBQUNBO0lBRURBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBO0FBQ2RBLENBQUNBO0FBRUQsU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJO0lBQzVCQyxNQUFNQSxDQUFDQSxJQUFJQSxLQUFLQSxJQUFJQSxHQUFHQSxJQUFJQSxHQUFHQSxFQUFFQSxDQUFDQTtBQUNuQ0EsQ0FBQ0E7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFO0lBQ2pELElBQUksRUFBRSxTQUFTO0lBQ2YsT0FBTyxFQUFFLGNBQWM7SUFDdkIsU0FBUyxFQUFFLGdCQUFnQjtDQUM1QixDQUFDLENBQUMiLCJmaWxlIjoic3JjL3JhbWwxL2pzeWFtbC9qcy15YW1sL3R5cGUvc2V0LmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBUeXBlID0gcmVxdWlyZSgnLi4vdHlwZScpO1xuXG52YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gcmVzb2x2ZVlhbWxTZXQoZGF0YSkge1xuICBpZiAobnVsbCA9PT0gZGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGtleSwgb2JqZWN0ID0gZGF0YTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICBpZiAobnVsbCAhPT0gb2JqZWN0W2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RZYW1sU2V0KGRhdGEpIHtcbiAgcmV0dXJuIG51bGwgIT09IGRhdGEgPyBkYXRhIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsIHtcbiAga2luZDogJ21hcHBpbmcnLFxuICByZXNvbHZlOiByZXNvbHZlWWFtbFNldCxcbiAgY29uc3RydWN0OiBjb25zdHJ1Y3RZYW1sU2V0XG59KTtcbiJdfQ==


	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../../../typings/tsd.d.ts" />
		// JS-YAML's default schema for `load` function.
		// It is not described in the YAML specification.
		//
		// This schema is based on JS-YAML's default safe schema and includes
		// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
		//
		// Also this schema is used as default base schema at `Schema.create` function.
		'use strict';
		var Schema = __webpack_require__(23);
		var schema = new Schema({
		    include: [
		        __webpack_require__(22)
		    ],
		    explicit: [
		        __webpack_require__(43),
		        __webpack_require__(44),
		        __webpack_require__(45)
		    ]
		});
		Schema.DEFAULT = schema;
		module.exports = schema;


	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		function resolveJavascriptUndefined() {
		    return true;
		}
		function constructJavascriptUndefined() {
		    return undefined;
		}
		function representJavascriptUndefined() {
		    return '';
		}
		function isUndefined(object) {
		    return 'undefined' === typeof object;
		}
		module.exports = new Type('tag:yaml.org,2002:js/undefined', {
		    kind: 'scalar',
		    resolve: resolveJavascriptUndefined,
		    construct: constructJavascriptUndefined,
		    predicate: isUndefined,
		    represent: representJavascriptUndefined
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2pzL3VuZGVmaW5lZC50cyJdLCJuYW1lcyI6WyJyZXNvbHZlSmF2YXNjcmlwdFVuZGVmaW5lZCIsImNvbnN0cnVjdEphdmFzY3JpcHRVbmRlZmluZWQiLCJyZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkIiwiaXNVbmRlZmluZWQiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFlBQVksQ0FBQyxDQUFDO0FBRXBDLFNBQVMsMEJBQTBCO0lBQ2pDQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtBQUNkQSxDQUFDQTtBQUVELFNBQVMsNEJBQTRCO0lBRW5DQyxNQUFNQSxDQUFDQSxTQUFTQSxDQUFDQTtBQUNuQkEsQ0FBQ0E7QUFFRCxTQUFTLDRCQUE0QjtJQUNuQ0MsTUFBTUEsQ0FBQ0EsRUFBRUEsQ0FBQ0E7QUFDWkEsQ0FBQ0E7QUFFRCxTQUFTLFdBQVcsQ0FBQyxNQUFNO0lBQ3pCQyxNQUFNQSxDQUFDQSxXQUFXQSxLQUFLQSxPQUFPQSxNQUFNQSxDQUFDQTtBQUN2Q0EsQ0FBQ0E7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLGdDQUFnQyxFQUFFO0lBQzFELElBQUksRUFBRSxRQUFRO0lBQ2QsT0FBTyxFQUFFLDBCQUEwQjtJQUNuQyxTQUFTLEVBQUUsNEJBQTRCO0lBQ3ZDLFNBQVMsRUFBRSxXQUFXO0lBQ3RCLFNBQVMsRUFBRSw0QkFBNEI7Q0FDeEMsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2pzL3VuZGVmaW5lZC5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyIsInNvdXJjZXNDb250ZW50IjpbIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi8uLi8uLi90eXBpbmdzL3RzZC5kLnRzXCIgLz5cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0VW5kZWZpbmVkKCkge1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXVuZGVmaW5lZCovXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlcHJlc2VudEphdmFzY3JpcHRVbmRlZmluZWQoKSB7XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqZWN0KSB7XG4gIHJldHVybiAndW5kZWZpbmVkJyA9PT0gdHlwZW9mIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHlwZSgndGFnOnlhbWwub3JnLDIwMDI6anMvdW5kZWZpbmVkJywge1xuICBraW5kOiAnc2NhbGFyJyxcbiAgcmVzb2x2ZTogcmVzb2x2ZUphdmFzY3JpcHRVbmRlZmluZWQsXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdFVuZGVmaW5lZCxcbiAgcHJlZGljYXRlOiBpc1VuZGVmaW5lZCxcbiAgcmVwcmVzZW50OiByZXByZXNlbnRKYXZhc2NyaXB0VW5kZWZpbmVkXG59KTtcbiJdfQ==


	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var Type = __webpack_require__(24);
		function resolveJavascriptRegExp(data) {
		    if (null === data) {
		        return false;
		    }
		    if (0 === data.length) {
		        return false;
		    }
		    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
		    if ('/' === regexp[0]) {
		        if (tail) {
		            modifiers = tail[1];
		        }
		        if (modifiers.length > 3) {
		            return false;
		        }
		        if (regexp[regexp.length - modifiers.length - 1] !== '/') {
		            return false;
		        }
		        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
		    }
		    try {
		        var dummy = new RegExp(regexp, modifiers);
		        return true;
		    }
		    catch (error) {
		        return false;
		    }
		}
		function constructJavascriptRegExp(data) {
		    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
		    if ('/' === regexp[0]) {
		        if (tail) {
		            modifiers = tail[1];
		        }
		        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
		    }
		    return new RegExp(regexp, modifiers);
		}
		function representJavascriptRegExp(object) {
		    var result = '/' + object.source + '/';
		    if (object.global) {
		        result += 'g';
		    }
		    if (object.multiline) {
		        result += 'm';
		    }
		    if (object.ignoreCase) {
		        result += 'i';
		    }
		    return result;
		}
		function isRegExp(object) {
		    return '[object RegExp]' === Object.prototype.toString.call(object);
		}
		module.exports = new Type('tag:yaml.org,2002:js/regexp', {
		    kind: 'scalar',
		    resolve: resolveJavascriptRegExp,
		    construct: constructJavascriptRegExp,
		    predicate: isRegExp,
		    represent: representJavascriptRegExp
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2pzL3JlZ2V4cC50cyJdLCJuYW1lcyI6WyJyZXNvbHZlSmF2YXNjcmlwdFJlZ0V4cCIsImNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAiLCJyZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwIiwiaXNSZWdFeHAiXSwibWFwcGluZ3MiOiJBQUVBLFlBQVksQ0FBQztBQUViLElBQU8sSUFBSSxXQUFXLFlBQVksQ0FBQyxDQUFDO0FBRXBDLFNBQVMsdUJBQXVCLENBQUMsSUFBSTtJQUNuQ0EsRUFBRUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsS0FBS0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDbEJBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQ2ZBLENBQUNBO0lBRURBLEVBQUVBLENBQUNBLENBQUNBLENBQUNBLEtBQUtBLElBQUlBLENBQUNBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBO1FBQ3RCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtJQUNmQSxDQUFDQTtJQUVEQSxJQUFJQSxNQUFNQSxHQUFHQSxJQUFJQSxFQUNiQSxJQUFJQSxHQUFLQSxhQUFhQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxFQUNqQ0EsU0FBU0EsR0FBR0EsRUFBRUEsQ0FBQ0E7SUFJbkJBLEVBQUVBLENBQUNBLENBQUNBLEdBQUdBLEtBQUtBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1FBQ3RCQSxFQUFFQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNUQSxTQUFTQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUN0QkEsQ0FBQ0E7UUFFREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsU0FBU0EsQ0FBQ0EsTUFBTUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7WUFBQ0EsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7UUFBQ0EsQ0FBQ0E7UUFFM0NBLEVBQUVBLENBQUNBLENBQUNBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBLE1BQU1BLEdBQUdBLFNBQVNBLENBQUNBLE1BQU1BLEdBQUdBLENBQUNBLENBQUNBLEtBQUtBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBO1lBQUNBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO1FBQUNBLENBQUNBO1FBRTNFQSxNQUFNQSxHQUFHQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQSxDQUFDQSxFQUFFQSxNQUFNQSxDQUFDQSxNQUFNQSxHQUFHQSxTQUFTQSxDQUFDQSxNQUFNQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtJQUNqRUEsQ0FBQ0E7SUFFREEsSUFBQUEsQ0FBQ0E7UUFDQ0EsSUFBSUEsS0FBS0EsR0FBR0EsSUFBSUEsTUFBTUEsQ0FBQ0EsTUFBTUEsRUFBRUEsU0FBU0EsQ0FBQ0EsQ0FBQ0E7UUFDMUNBLE1BQU1BLENBQUNBLElBQUlBLENBQUNBO0lBQ2RBLENBQUVBO0lBQUFBLEtBQUtBLENBQUNBLENBQUNBLEtBQUtBLENBQUNBLENBQUNBLENBQUNBO1FBQ2ZBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBO0lBQ2ZBLENBQUNBO0FBQ0hBLENBQUNBO0FBRUQsU0FBUyx5QkFBeUIsQ0FBQyxJQUFJO0lBQ3JDQyxJQUFJQSxNQUFNQSxHQUFHQSxJQUFJQSxFQUNiQSxJQUFJQSxHQUFLQSxhQUFhQSxDQUFDQSxJQUFJQSxDQUFDQSxJQUFJQSxDQUFDQSxFQUNqQ0EsU0FBU0EsR0FBR0EsRUFBRUEsQ0FBQ0E7SUFHbkJBLEVBQUVBLENBQUNBLENBQUNBLEdBQUdBLEtBQUtBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO1FBQ3RCQSxFQUFFQSxDQUFDQSxDQUFDQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQTtZQUNUQSxTQUFTQSxHQUFHQSxJQUFJQSxDQUFDQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUN0QkEsQ0FBQ0E7UUFDREEsTUFBTUEsR0FBR0EsTUFBTUEsQ0FBQ0EsS0FBS0EsQ0FBQ0EsQ0FBQ0EsRUFBRUEsTUFBTUEsQ0FBQ0EsTUFBTUEsR0FBR0EsU0FBU0EsQ0FBQ0EsTUFBTUEsR0FBR0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7SUFDakVBLENBQUNBO0lBRURBLE1BQU1BLENBQUNBLElBQUlBLE1BQU1BLENBQUNBLE1BQU1BLEVBQUVBLFNBQVNBLENBQUNBLENBQUNBO0FBQ3ZDQSxDQUFDQTtBQUVELFNBQVMseUJBQXlCLENBQUMsTUFBTTtJQUN2Q0MsSUFBSUEsTUFBTUEsR0FBR0EsR0FBR0EsR0FBR0EsTUFBTUEsQ0FBQ0EsTUFBTUEsR0FBR0EsR0FBR0EsQ0FBQ0E7SUFFdkNBLEVBQUVBLENBQUNBLENBQUNBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxJQUFJQSxHQUFHQSxDQUFDQTtJQUNoQkEsQ0FBQ0E7SUFFREEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsTUFBTUEsQ0FBQ0EsU0FBU0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDckJBLE1BQU1BLElBQUlBLEdBQUdBLENBQUNBO0lBQ2hCQSxDQUFDQTtJQUVEQSxFQUFFQSxDQUFDQSxDQUFDQSxNQUFNQSxDQUFDQSxVQUFVQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUN0QkEsTUFBTUEsSUFBSUEsR0FBR0EsQ0FBQ0E7SUFDaEJBLENBQUNBO0lBRURBLE1BQU1BLENBQUNBLE1BQU1BLENBQUNBO0FBQ2hCQSxDQUFDQTtBQUVELFNBQVMsUUFBUSxDQUFDLE1BQU07SUFDdEJDLE1BQU1BLENBQUNBLGlCQUFpQkEsS0FBS0EsTUFBTUEsQ0FBQ0EsU0FBU0EsQ0FBQ0EsUUFBUUEsQ0FBQ0EsSUFBSUEsQ0FBQ0EsTUFBTUEsQ0FBQ0EsQ0FBQ0E7QUFDdEVBLENBQUNBO0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLElBQUksQ0FBQyw2QkFBNkIsRUFBRTtJQUN2RCxJQUFJLEVBQUUsUUFBUTtJQUNkLE9BQU8sRUFBRSx1QkFBdUI7SUFDaEMsU0FBUyxFQUFFLHlCQUF5QjtJQUNwQyxTQUFTLEVBQUUsUUFBUTtJQUNuQixTQUFTLEVBQUUseUJBQXlCO0NBQ3JDLENBQUMsQ0FBQyIsImZpbGUiOiJzcmMvcmFtbDEvanN5YW1sL2pzLXlhbWwvdHlwZS9qcy9yZWdleHAuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8iLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vLi4vLi4vdHlwaW5ncy90c2QuZC50c1wiIC8+XG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFR5cGUgPSByZXF1aXJlKCcuLi8uLi90eXBlJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwKGRhdGEpIHtcbiAgaWYgKG51bGwgPT09IGRhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoMCA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gZGF0YSxcbiAgICAgIHRhaWwgICA9IC9cXC8oW2dpbV0qKSQvLmV4ZWMoZGF0YSksXG4gICAgICBtb2RpZmllcnMgPSAnJztcblxuICAvLyBpZiByZWdleHAgc3RhcnRzIHdpdGggJy8nIGl0IGNhbiBoYXZlIG1vZGlmaWVycyBhbmQgbXVzdCBiZSBwcm9wZXJseSBjbG9zZWRcbiAgLy8gYC9mb28vZ2ltYCAtIG1vZGlmaWVycyB0YWlsIGNhbiBiZSBtYXhpbXVtIDMgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuXG4gICAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAzKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIGlmIGV4cHJlc3Npb24gc3RhcnRzIHdpdGggLywgaXMgc2hvdWxkIGJlIHByb3Blcmx5IHRlcm1pbmF0ZWRcbiAgICBpZiAocmVnZXhwW3JlZ2V4cC5sZW5ndGggLSBtb2RpZmllcnMubGVuZ3RoIC0gMV0gIT09ICcvJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgZHVtbXkgPSBuZXcgUmVnRXhwKHJlZ2V4cCwgbW9kaWZpZXJzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SmF2YXNjcmlwdFJlZ0V4cChkYXRhKSB7XG4gIHZhciByZWdleHAgPSBkYXRhLFxuICAgICAgdGFpbCAgID0gL1xcLyhbZ2ltXSopJC8uZXhlYyhkYXRhKSxcbiAgICAgIG1vZGlmaWVycyA9ICcnO1xuXG4gIC8vIGAvZm9vL2dpbWAgLSB0YWlsIGNhbiBiZSBtYXhpbXVtIDQgY2hhcnNcbiAgaWYgKCcvJyA9PT0gcmVnZXhwWzBdKSB7XG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIG1vZGlmaWVycyA9IHRhaWxbMV07XG4gICAgfVxuICAgIHJlZ2V4cCA9IHJlZ2V4cC5zbGljZSgxLCByZWdleHAubGVuZ3RoIC0gbW9kaWZpZXJzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXhwLCBtb2RpZmllcnMpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0UmVnRXhwKG9iamVjdCAvKiwgc3R5bGUqLykge1xuICB2YXIgcmVzdWx0ID0gJy8nICsgb2JqZWN0LnNvdXJjZSArICcvJztcblxuICBpZiAob2JqZWN0Lmdsb2JhbCkge1xuICAgIHJlc3VsdCArPSAnZyc7XG4gIH1cblxuICBpZiAob2JqZWN0Lm11bHRpbGluZSkge1xuICAgIHJlc3VsdCArPSAnbSc7XG4gIH1cblxuICBpZiAob2JqZWN0Lmlnbm9yZUNhc2UpIHtcbiAgICByZXN1bHQgKz0gJ2knO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAob2JqZWN0KSB7XG4gIHJldHVybiAnW29iamVjdCBSZWdFeHBdJyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFR5cGUoJ3RhZzp5YW1sLm9yZywyMDAyOmpzL3JlZ2V4cCcsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0UmVnRXhwLFxuICBjb25zdHJ1Y3Q6IGNvbnN0cnVjdEphdmFzY3JpcHRSZWdFeHAsXG4gIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdFJlZ0V4cFxufSk7XG4iXX0=


	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		var esprima = __webpack_require__(46);
		var Type = __webpack_require__(24);
		function resolveJavascriptFunction(data) {
		    if (null === data) {
		        return false;
		    }
		    try {
		        var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
		        if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0]['expression'].type) {
		            return false;
		        }
		        return true;
		    }
		    catch (err) {
		        return false;
		    }
		}
		function constructJavascriptFunction(data) {
		    var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
		    if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0]['expression'].type) {
		        throw new Error('Failed to resolve function');
		    }
		    ast.body[0]['expression'].params.forEach(function (param) {
		        params.push(param.name);
		    });
		    body = ast.body[0]['expression'].body.range;
		    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
		}
		function representJavascriptFunction(object) {
		    return object.toString();
		}
		function isFunction(object) {
		    return '[object Function]' === Object.prototype.toString.call(object);
		}
		module.exports = new Type('tag:yaml.org,2002:js/function', {
		    kind: 'scalar',
		    resolve: resolveJavascriptFunction,
		    construct: constructJavascriptFunction,
		    predicate: isFunction,
		    represent: representJavascriptFunction
		});

		//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2pzL2Z1bmN0aW9uLnRzIl0sIm5hbWVzIjpbInJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24iLCJjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24iLCJyZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24iLCJpc0Z1bmN0aW9uIl0sIm1hcHBpbmdzIjoiQUFFQSxZQUFZLENBQUM7QUFFYixJQUFPLE9BQU8sV0FBUyxTQUFTLENBQUMsQ0FBQztBQVVsQyxJQUFPLElBQUksV0FBVyxZQUFZLENBQUMsQ0FBQztBQUVwQyxTQUFTLHlCQUF5QixDQUFDLElBQUk7SUFDckNBLEVBQUVBLENBQUNBLENBQUNBLElBQUlBLEtBQUtBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1FBQ2xCQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtJQUNmQSxDQUFDQTtJQUVEQSxJQUFBQSxDQUFDQTtRQUNDQSxJQUFJQSxNQUFNQSxHQUFHQSxHQUFHQSxHQUFHQSxJQUFJQSxHQUFHQSxHQUFHQSxFQUN6QkEsR0FBR0EsR0FBTUEsT0FBT0EsQ0FBQ0EsS0FBS0EsQ0FBQ0EsTUFBTUEsRUFBRUEsRUFBRUEsS0FBS0EsRUFBRUEsSUFBSUEsRUFBRUEsQ0FBQ0EsRUFDL0NBLE1BQU1BLEdBQUdBLEVBQUVBLEVBQ1hBLElBQUlBLENBQUNBO1FBRVRBLEVBQUVBLENBQUNBLENBQUNBLFNBQVNBLEtBQWlCQSxHQUFHQSxDQUFDQSxJQUFJQSxJQUNsQ0EsQ0FBQ0EsS0FBeUJBLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLE1BQU1BLElBQ3pDQSxxQkFBcUJBLEtBQUtBLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLElBQUlBLElBQzFDQSxvQkFBb0JBLEtBQU1BLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLFlBQVlBLENBQUNBLENBQUNBLElBQUlBLENBQUNBLENBQUNBLENBQUNBO1lBQzdEQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtRQUNmQSxDQUFDQTtRQUVEQSxNQUFNQSxDQUFDQSxJQUFJQSxDQUFDQTtJQUNkQSxDQUFFQTtJQUFBQSxLQUFLQSxDQUFDQSxDQUFDQSxHQUFHQSxDQUFDQSxDQUFDQSxDQUFDQTtRQUNiQSxNQUFNQSxDQUFDQSxLQUFLQSxDQUFDQTtJQUNmQSxDQUFDQTtBQUNIQSxDQUFDQTtBQUVELFNBQVMsMkJBQTJCLENBQUMsSUFBSTtJQUd2Q0MsSUFBSUEsTUFBTUEsR0FBR0EsR0FBR0EsR0FBR0EsSUFBSUEsR0FBR0EsR0FBR0EsRUFDekJBLEdBQUdBLEdBQU1BLE9BQU9BLENBQUNBLEtBQUtBLENBQUNBLE1BQU1BLEVBQUVBLEVBQUVBLEtBQUtBLEVBQUVBLElBQUlBLEVBQUVBLENBQUNBLEVBQy9DQSxNQUFNQSxHQUFZQSxFQUFFQSxFQUNwQkEsSUFBSUEsQ0FBQ0E7SUFFVEEsRUFBRUEsQ0FBQ0EsQ0FBQ0EsU0FBU0EsS0FBaUJBLEdBQUdBLENBQUNBLElBQUlBLElBQ2xDQSxDQUFDQSxLQUF5QkEsR0FBR0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsTUFBTUEsSUFDekNBLHFCQUFxQkEsS0FBS0EsR0FBR0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsSUFBSUEsSUFDMUNBLG9CQUFvQkEsS0FBTUEsR0FBR0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsWUFBWUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0E7UUFDN0RBLE1BQU1BLElBQUlBLEtBQUtBLENBQUNBLDRCQUE0QkEsQ0FBQ0EsQ0FBQ0E7SUFDaERBLENBQUNBO0lBRURBLEdBQUdBLENBQUNBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLENBQUNBLFlBQVlBLENBQUNBLENBQUNBLE1BQU1BLENBQUNBLE9BQU9BLENBQUNBLFVBQVVBLEtBQUtBO1FBQ3RELE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUMsQ0FBQ0EsQ0FBQ0E7SUFFSEEsSUFBSUEsR0FBR0EsR0FBR0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsQ0FBQ0EsWUFBWUEsQ0FBQ0EsQ0FBQ0EsSUFBSUEsQ0FBQ0EsS0FBS0EsQ0FBQ0E7SUFLNUNBLE1BQU1BLENBQUNBLElBQVVBLFFBQVNBLENBQUNBLE1BQU1BLEVBQUVBLE1BQU1BLENBQUNBLEtBQUtBLENBQUNBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLEVBQUVBLElBQUlBLENBQUNBLENBQUNBLENBQUNBLEdBQUdBLENBQUNBLENBQUNBLENBQUNBLENBQUNBO0FBQzdFQSxDQUFDQTtBQUVELFNBQVMsMkJBQTJCLENBQUMsTUFBTTtJQUN6Q0MsTUFBTUEsQ0FBQ0EsTUFBTUEsQ0FBQ0EsUUFBUUEsRUFBRUEsQ0FBQ0E7QUFDM0JBLENBQUNBO0FBRUQsU0FBUyxVQUFVLENBQUMsTUFBTTtJQUN4QkMsTUFBTUEsQ0FBQ0EsbUJBQW1CQSxLQUFLQSxNQUFNQSxDQUFDQSxTQUFTQSxDQUFDQSxRQUFRQSxDQUFDQSxJQUFJQSxDQUFDQSxNQUFNQSxDQUFDQSxDQUFDQTtBQUN4RUEsQ0FBQ0E7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksSUFBSSxDQUFDLCtCQUErQixFQUFFO0lBQ3pELElBQUksRUFBRSxRQUFRO0lBQ2QsT0FBTyxFQUFFLHlCQUF5QjtJQUNsQyxTQUFTLEVBQUUsMkJBQTJCO0lBQ3RDLFNBQVMsRUFBRSxVQUFVO0lBQ3JCLFNBQVMsRUFBRSwyQkFBMkI7Q0FDdkMsQ0FBQyxDQUFDIiwiZmlsZSI6InNyYy9yYW1sMS9qc3lhbWwvanMteWFtbC90eXBlL2pzL2Z1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uLy4uLy4uL3R5cGluZ3MvdHNkLmQudHNcIiAvPlxuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBlc3ByaW1hPXJlcXVpcmUoXCJlc3ByaW1hXCIpO1xuXG4vLyBCcm93c2VyaWZpZWQgdmVyc2lvbiBkb2VzIG5vdCBoYXZlIGVzcHJpbWFcbi8vXG4vLyAxLiBGb3Igbm9kZS5qcyBqdXN0IHJlcXVpcmUgbW9kdWxlIGFzIGRlcHNcbi8vIDIuIEZvciBicm93c2VyIHRyeSB0byByZXF1aXJlIG11ZHVsZSB2aWEgZXh0ZXJuYWwgQU1EIHN5c3RlbS5cbi8vICAgIElmIG5vdCBmb3VuZCAtIHRyeSB0byBmYWxsYmFjayB0byB3aW5kb3cuZXNwcmltYS4gSWYgbm90XG4vLyAgICBmb3VuZCB0b28gLSB0aGVuIGZhaWwgdG8gcGFyc2UuXG4vL1xuXG5pbXBvcnQgVHlwZSA9IHJlcXVpcmUoJy4uLy4uL3R5cGUnKTtcblxuZnVuY3Rpb24gcmVzb2x2ZUphdmFzY3JpcHRGdW5jdGlvbihkYXRhKSB7XG4gIGlmIChudWxsID09PSBkYXRhKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgc291cmNlID0gJygnICsgZGF0YSArICcpJyxcbiAgICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICAgIHBhcmFtcyA9IFtdLFxuICAgICAgICBib2R5O1xuXG4gICAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxuICAgICAgICAxICAgICAgICAgICAgICAgICAgICAgIT09IGFzdC5ib2R5Lmxlbmd0aCAgfHxcbiAgICAgICAgJ0V4cHJlc3Npb25TdGF0ZW1lbnQnICE9PSBhc3QuYm9keVswXS50eXBlIHx8XG4gICAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF1bJ2V4cHJlc3Npb24nXS50eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RKYXZhc2NyaXB0RnVuY3Rpb24oZGF0YSkge1xuICAvKmpzbGludCBldmlsOnRydWUqL1xuXG4gIHZhciBzb3VyY2UgPSAnKCcgKyBkYXRhICsgJyknLFxuICAgICAgYXN0ICAgID0gZXNwcmltYS5wYXJzZShzb3VyY2UsIHsgcmFuZ2U6IHRydWUgfSksXG4gICAgICBwYXJhbXM6c3RyaW5nW10gPSBbXSxcbiAgICAgIGJvZHk7XG5cbiAgaWYgKCdQcm9ncmFtJyAgICAgICAgICAgICAhPT0gYXN0LnR5cGUgICAgICAgICB8fFxuICAgICAgMSAgICAgICAgICAgICAgICAgICAgICE9PSBhc3QuYm9keS5sZW5ndGggIHx8XG4gICAgICAnRXhwcmVzc2lvblN0YXRlbWVudCcgIT09IGFzdC5ib2R5WzBdLnR5cGUgfHxcbiAgICAgICdGdW5jdGlvbkV4cHJlc3Npb24nICAhPT0gYXN0LmJvZHlbMF1bJ2V4cHJlc3Npb24nXS50eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSBmdW5jdGlvbicpO1xuICB9XG5cbiAgYXN0LmJvZHlbMF1bJ2V4cHJlc3Npb24nXS5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICBwYXJhbXMucHVzaChwYXJhbS5uYW1lKTtcbiAgfSk7XG5cbiAgYm9keSA9IGFzdC5ib2R5WzBdWydleHByZXNzaW9uJ10uYm9keS5yYW5nZTtcblxuICAvLyBFc3ByaW1hJ3MgcmFuZ2VzIGluY2x1ZGUgdGhlIGZpcnN0ICd7JyBhbmQgdGhlIGxhc3QgJ30nIGNoYXJhY3RlcnMgb25cbiAgLy8gZnVuY3Rpb24gZXhwcmVzc2lvbnMuIFNvIGN1dCB0aGVtIG91dC5cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYyovXG4gIHJldHVybiBuZXcgKDxhbnk+RnVuY3Rpb24pKHBhcmFtcywgc291cmNlLnNsaWNlKGJvZHlbMF0gKyAxLCBib2R5WzFdIC0gMSkpO1xufVxuXG5mdW5jdGlvbiByZXByZXNlbnRKYXZhc2NyaXB0RnVuY3Rpb24ob2JqZWN0IC8qLCBzdHlsZSovKSB7XG4gIHJldHVybiBvYmplY3QudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuICdbb2JqZWN0IEZ1bmN0aW9uXScgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBUeXBlKCd0YWc6eWFtbC5vcmcsMjAwMjpqcy9mdW5jdGlvbicsIHtcbiAga2luZDogJ3NjYWxhcicsXG4gIHJlc29sdmU6IHJlc29sdmVKYXZhc2NyaXB0RnVuY3Rpb24sXG4gIGNvbnN0cnVjdDogY29uc3RydWN0SmF2YXNjcmlwdEZ1bmN0aW9uLFxuICBwcmVkaWNhdGU6IGlzRnVuY3Rpb24sXG4gIHJlcHJlc2VudDogcmVwcmVzZW50SmF2YXNjcmlwdEZ1bmN0aW9uXG59KTtcbiJdfQ==


	/***/ },
	/* 46 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(10);

	/***/ },
	/* 47 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../../typings/tsd.d.ts" />
		'use strict';
		/*eslint-disable no-use-before-define*/
		var common = __webpack_require__(20);
		var YAMLException = __webpack_require__(9);
		var DEFAULT_FULL_SCHEMA = __webpack_require__(42);
		var DEFAULT_SAFE_SCHEMA = __webpack_require__(22);
		var _toString = Object.prototype.toString;
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		var CHAR_TAB = 0x09; /* Tab */
		var CHAR_LINE_FEED = 0x0A; /* LF */
		var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */
		var CHAR_SPACE = 0x20; /* Space */
		var CHAR_EXCLAMATION = 0x21; /* ! */
		var CHAR_DOUBLE_QUOTE = 0x22; /* " */
		var CHAR_SHARP = 0x23; /* # */
		var CHAR_PERCENT = 0x25; /* % */
		var CHAR_AMPERSAND = 0x26; /* & */
		var CHAR_SINGLE_QUOTE = 0x27; /* ' */
		var CHAR_ASTERISK = 0x2A; /* * */
		var CHAR_COMMA = 0x2C; /* , */
		var CHAR_MINUS = 0x2D; /* - */
		var CHAR_COLON = 0x3A; /* : */
		var CHAR_GREATER_THAN = 0x3E; /* > */
		var CHAR_QUESTION = 0x3F; /* ? */
		var CHAR_COMMERCIAL_AT = 0x40; /* @ */
		var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
		var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
		var CHAR_GRAVE_ACCENT = 0x60; /* ` */
		var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
		var CHAR_VERTICAL_LINE = 0x7C; /* | */
		var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */
		var ESCAPE_SEQUENCES = {};
		ESCAPE_SEQUENCES[0x00] = '\\0';
		ESCAPE_SEQUENCES[0x07] = '\\a';
		ESCAPE_SEQUENCES[0x08] = '\\b';
		ESCAPE_SEQUENCES[0x09] = '\\t';
		ESCAPE_SEQUENCES[0x0A] = '\\n';
		ESCAPE_SEQUENCES[0x0B] = '\\v';
		ESCAPE_SEQUENCES[0x0C] = '\\f';
		ESCAPE_SEQUENCES[0x0D] = '\\r';
		ESCAPE_SEQUENCES[0x1B] = '\\e';
		ESCAPE_SEQUENCES[0x22] = '\\"';
		ESCAPE_SEQUENCES[0x5C] = '\\\\';
		ESCAPE_SEQUENCES[0x85] = '\\N';
		ESCAPE_SEQUENCES[0xA0] = '\\_';
		ESCAPE_SEQUENCES[0x2028] = '\\L';
		ESCAPE_SEQUENCES[0x2029] = '\\P';
		var DEPRECATED_BOOLEANS_SYNTAX = [
		    'y',
		    'Y',
		    'yes',
		    'Yes',
		    'YES',
		    'on',
		    'On',
		    'ON',
		    'n',
		    'N',
		    'no',
		    'No',
		    'NO',
		    'off',
		    'Off',
		    'OFF'
		];
		function compileStyleMap(schema, map) {
		    var result, keys, index, length, tag, style, type;
		    if (null === map) {
		        return {};
		    }
		    result = {};
		    keys = Object.keys(map);
		    for (index = 0, length = keys.length; index < length; index += 1) {
		        tag = keys[index];
		        style = String(map[tag]);
		        if ('!!' === tag.slice(0, 2)) {
		            tag = 'tag:yaml.org,2002:' + tag.slice(2);
		        }
		        type = schema.compiledTypeMap[tag];
		        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
		            style = type.styleAliases[style];
		        }
		        result[tag] = style;
		    }
		    return result;
		}
		function encodeHex(character) {
		    var string, handle, length;
		    string = character.toString(16).toUpperCase();
		    if (character <= 0xFF) {
		        handle = 'x';
		        length = 2;
		    }
		    else if (character <= 0xFFFF) {
		        handle = 'u';
		        length = 4;
		    }
		    else if (character <= 0xFFFFFFFF) {
		        handle = 'U';
		        length = 8;
		    }
		    else {
		        throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
		    }
		    return '\\' + handle + common.repeat('0', length - string.length) + string;
		}
		function State(options) {
		    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
		    this.indent = Math.max(1, (options['indent'] || 2));
		    this.skipInvalid = options['skipInvalid'] || false;
		    this.flowLevel = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
		    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
		    this.implicitTypes = this.schema.compiledImplicit;
		    this.explicitTypes = this.schema.compiledExplicit;
		    this.tag = null;
		    this.result = '';
		    this.duplicates = [];
		    this.usedDuplicates = null;
		}
		function indentString(string, spaces) {
		    var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
		    while (position < length) {
		        next = string.indexOf('\n', position);
		        if (next === -1) {
		            line = string.slice(position);
		            position = length;
		        }
		        else {
		            line = string.slice(position, next + 1);
		            position = next + 1;
		        }
		        if (line.length && line !== '\n') {
		            result += ind;
		        }
		        result += line;
		    }
		    return result;
		}
		function generateNextLine(state, level) {
		    return '\n' + common.repeat(' ', state.indent * level);
		}
		function testImplicitResolving(state, str) {
		    var index, length, type;
		    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
		        type = state.implicitTypes[index];
		        if (type.resolve(str)) {
		            return true;
		        }
		    }
		    return false;
		}
		function StringBuilder(source) {
		    this.source = source;
		    this.result = '';
		    this.checkpoint = 0;
		}
		StringBuilder.prototype.takeUpTo = function (position) {
		    var er;
		    if (position < this.checkpoint) {
		        er = new Error('position should be > checkpoint');
		        er.position = position;
		        er.checkpoint = this.checkpoint;
		        throw er;
		    }
		    this.result += this.source.slice(this.checkpoint, position);
		    this.checkpoint = position;
		    return this;
		};
		StringBuilder.prototype.escapeChar = function () {
		    var character, esc;
		    character = this.source.charCodeAt(this.checkpoint);
		    esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
		    this.result += esc;
		    this.checkpoint += 1;
		    return this;
		};
		StringBuilder.prototype.finish = function () {
		    if (this.source.length > this.checkpoint) {
		        this.takeUpTo(this.source.length);
		    }
		};
		function writeScalar(state, object, level) {
		    var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;
		    if (0 === object.length) {
		        state.dump = "''";
		        return;
		    }
		    if (object.indexOf("!include") == 0) {
		        state.dump = "" + object; //FIXME
		        return;
		    }
		    if (object.indexOf("!$$$novalue") == 0) {
		        state.dump = ""; //FIXME
		        return;
		    }
		    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
		        state.dump = "'" + object + "'";
		        return;
		    }
		    simple = true;
		    first = object.length ? object.charCodeAt(0) : 0;
		    spaceWrap = (CHAR_SPACE === first || CHAR_SPACE === object.charCodeAt(object.length - 1));
		    // Simplified check for restricted first characters
		    // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
		    if (CHAR_MINUS === first || CHAR_QUESTION === first || CHAR_COMMERCIAL_AT === first || CHAR_GRAVE_ACCENT === first) {
		        simple = false;
		    }
		    // can only use > and | if not wrapped in spaces.
		    if (spaceWrap) {
		        simple = false;
		        folded = false;
		        literal = false;
		    }
		    else {
		        folded = true;
		        literal = true;
		    }
		    single = true;
		    double = new StringBuilder(object);
		    sawLineFeed = false;
		    linePosition = 0;
		    longestLine = 0;
		    indent = state.indent * level;
		    max = 80;
		    if (indent < 40) {
		        max -= indent;
		    }
		    else {
		        max = 40;
		    }
		    for (position = 0; position < object.length; position++) {
		        character = object.charCodeAt(position);
		        if (simple) {
		            // Characters that can never appear in the simple scalar
		            if (!simpleChar(character)) {
		                simple = false;
		            }
		            else {
		                continue;
		            }
		        }
		        if (single && character === CHAR_SINGLE_QUOTE) {
		            single = false;
		        }
		        escapeSeq = ESCAPE_SEQUENCES[character];
		        hexEsc = needsHexEscape(character);
		        if (!escapeSeq && !hexEsc) {
		            continue;
		        }
		        if (character !== CHAR_LINE_FEED && character !== CHAR_DOUBLE_QUOTE && character !== CHAR_SINGLE_QUOTE) {
		            folded = false;
		            literal = false;
		        }
		        else if (character === CHAR_LINE_FEED) {
		            sawLineFeed = true;
		            single = false;
		            if (position > 0) {
		                previous = object.charCodeAt(position - 1);
		                if (previous === CHAR_SPACE) {
		                    literal = false;
		                    folded = false;
		                }
		            }
		            if (folded) {
		                lineLength = position - linePosition;
		                linePosition = position;
		                if (lineLength > longestLine) {
		                    longestLine = lineLength;
		                }
		            }
		        }
		        if (character !== CHAR_DOUBLE_QUOTE) {
		            single = false;
		        }
		        double.takeUpTo(position);
		        double.escapeChar();
		    }
		    if (simple && testImplicitResolving(state, object)) {
		        simple = false;
		    }
		    modifier = '';
		    if (folded || literal) {
		        trailingLineBreaks = 0;
		        if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
		            trailingLineBreaks += 1;
		            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
		                trailingLineBreaks += 1;
		            }
		        }
		        if (trailingLineBreaks === 0) {
		            modifier = '-';
		        }
		        else if (trailingLineBreaks === 2) {
		            modifier = '+';
		        }
		    }
		    if (literal && longestLine < max) {
		        folded = false;
		    }
		    // If it's literally one line, then don't bother with the literal.
		    // We may still want to do a fold, though, if it's a super long line.
		    if (!sawLineFeed) {
		        literal = false;
		    }
		    if (simple) {
		        state.dump = object;
		    }
		    else if (single) {
		        state.dump = '\'' + object + '\'';
		    }
		    else if (folded) {
		        result = fold(object, max);
		        state.dump = '>' + modifier + '\n' + indentString(result, indent);
		    }
		    else if (literal) {
		        if (!modifier) {
		            object = object.replace(/\n$/, '');
		        }
		        state.dump = '|' + modifier + '\n' + indentString(object, indent);
		    }
		    else if (double) {
		        double.finish();
		        state.dump = '"' + double.result + '"';
		    }
		    else {
		        throw new Error('Failed to dump scalar value');
		    }
		    return;
		}
		// The `trailing` var is a regexp match of any trailing `\n` characters.
		//
		// There are three cases we care about:
		//
		// 1. One trailing `\n` on the string.  Just use `|` or `>`.
		//    This is the assumed default. (trailing = null)
		// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
		// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
		//
		// In the case of `>+`, these line breaks are *not* doubled (like the line
		// breaks within the string), so it's important to only end with the exact
		// same number as we started.
		function fold(object, max) {
		    var result = '', position = 0, length = object.length, trailing = /\n+$/.exec(object), newLine;
		    if (trailing) {
		        length = trailing.index + 1;
		    }
		    while (position < length) {
		        newLine = object.indexOf('\n', position);
		        if (newLine > length || newLine === -1) {
		            if (result) {
		                result += '\n\n';
		            }
		            result += foldLine(object.slice(position, length), max);
		            position = length;
		        }
		        else {
		            if (result) {
		                result += '\n\n';
		            }
		            result += foldLine(object.slice(position, newLine), max);
		            position = newLine + 1;
		        }
		    }
		    if (trailing && trailing[0] !== '\n') {
		        result += trailing[0];
		    }
		    return result;
		}
		function foldLine(line, max) {
		    if (line === '') {
		        return line;
		    }
		    var foldRe = /[^\s] [^\s]/g, result = '', prevMatch = 0, foldStart = 0, match = foldRe.exec(line), index, foldEnd, folded;
		    while (match) {
		        index = match.index;
		        // when we cross the max len, if the previous match would've
		        // been ok, use that one, and carry on.  If there was no previous
		        // match on this fold section, then just have a long line.
		        if (index - foldStart > max) {
		            if (prevMatch !== foldStart) {
		                foldEnd = prevMatch;
		            }
		            else {
		                foldEnd = index;
		            }
		            if (result) {
		                result += '\n';
		            }
		            folded = line.slice(foldStart, foldEnd);
		            result += folded;
		            foldStart = foldEnd + 1;
		        }
		        prevMatch = index + 1;
		        match = foldRe.exec(line);
		    }
		    if (result) {
		        result += '\n';
		    }
		    // if we end up with one last word at the end, then the last bit might
		    // be slightly bigger than we wanted, because we exited out of the loop.
		    if (foldStart !== prevMatch && line.length - foldStart > max) {
		        result += line.slice(foldStart, prevMatch) + '\n' + line.slice(prevMatch + 1);
		    }
		    else {
		        result += line.slice(foldStart);
		    }
		    return result;
		}
		// Returns true if character can be found in a simple scalar
		function simpleChar(character) {
		    return CHAR_TAB !== character && CHAR_LINE_FEED !== character && CHAR_CARRIAGE_RETURN !== character && CHAR_COMMA !== character && CHAR_LEFT_SQUARE_BRACKET !== character && CHAR_RIGHT_SQUARE_BRACKET !== character && CHAR_LEFT_CURLY_BRACKET !== character && CHAR_RIGHT_CURLY_BRACKET !== character && CHAR_SHARP !== character && CHAR_AMPERSAND !== character && CHAR_ASTERISK !== character && CHAR_EXCLAMATION !== character && CHAR_VERTICAL_LINE !== character && CHAR_GREATER_THAN !== character && CHAR_SINGLE_QUOTE !== character && CHAR_DOUBLE_QUOTE !== character && CHAR_PERCENT !== character && CHAR_COLON !== character && !ESCAPE_SEQUENCES[character] && !needsHexEscape(character);
		}
		// Returns true if the character code needs to be escaped.
		function needsHexEscape(character) {
		    return !((0x00020 <= character && character <= 0x00007E) || (0x00085 === character) || (0x000A0 <= character && character <= 0x00D7FF) || (0x0E000 <= character && character <= 0x00FFFD) || (0x10000 <= character && character <= 0x10FFFF));
		}
		function writeFlowSequence(state, level, object) {
		    var _result = '', _tag = state.tag, index, length;
		    for (index = 0, length = object.length; index < length; index += 1) {
		        // Write only valid elements.
		        if (writeNode(state, level, object[index], false, false)) {
		            if (0 !== index) {
		                _result += ', ';
		            }
		            _result += state.dump;
		        }
		    }
		    state.tag = _tag;
		    state.dump = '[' + _result + ']';
		}
		function writeBlockSequence(state, level, object, compact) {
		    var _result = '', _tag = state.tag, index, length;
		    for (index = 0, length = object.length; index < length; index += 1) {
		        // Write only valid elements.
		        if (writeNode(state, level + 1, object[index], true, true)) {
		            if (!compact || 0 !== index) {
		                _result += generateNextLine(state, level);
		            }
		            _result += '- ' + state.dump;
		        }
		    }
		    state.tag = _tag;
		    state.dump = _result || '[]'; // Empty sequence if no valid values.
		}
		function writeFlowMapping(state, level, object) {
		    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
		    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
		        pairBuffer = '';
		        if (0 !== index) {
		            pairBuffer += ', ';
		        }
		        objectKey = objectKeyList[index];
		        objectValue = object[objectKey];
		        if (!writeNode(state, level, objectKey, false, false)) {
		            continue;
		        }
		        if (state.dump.length > 1024) {
		            pairBuffer += '? ';
		        }
		        pairBuffer += state.dump + ': ';
		        if (!writeNode(state, level, objectValue, false, false)) {
		            continue;
		        }
		        pairBuffer += state.dump;
		        // Both key and value are valid.
		        _result += pairBuffer;
		    }
		    state.tag = _tag;
		    state.dump = '{' + _result + '}';
		}
		function writeBlockMapping(state, level, object, compact) {
		    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
		    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
		        pairBuffer = '';
		        if (!compact || 0 !== index) {
		            pairBuffer += generateNextLine(state, level);
		        }
		        objectKey = objectKeyList[index];
		        objectValue = object[objectKey];
		        if (!writeNode(state, level + 1, objectKey, true, true)) {
		            continue;
		        }
		        explicitPair = (null !== state.tag && '?' !== state.tag) || (state.dump && state.dump.length > 1024);
		        if (explicitPair) {
		            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
		                pairBuffer += '?';
		            }
		            else {
		                pairBuffer += '? ';
		            }
		        }
		        pairBuffer += state.dump;
		        if (explicitPair) {
		            pairBuffer += generateNextLine(state, level);
		        }
		        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
		            continue;
		        }
		        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
		            pairBuffer += ':';
		        }
		        else {
		            pairBuffer += ': ';
		        }
		        pairBuffer += state.dump;
		        // Both key and value are valid.
		        _result += pairBuffer;
		    }
		    state.tag = _tag;
		    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
		}
		function detectType(state, object, explicit) {
		    var _result, typeList, index, length, type, style;
		    typeList = explicit ? state.explicitTypes : state.implicitTypes;
		    for (index = 0, length = typeList.length; index < length; index += 1) {
		        type = typeList[index];
		        if ((type.instanceOf || type.predicate) && (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) && (!type.predicate || type.predicate(object))) {
		            state.tag = explicit ? type.tag : '?';
		            if (type.represent) {
		                style = state.styleMap[type.tag] || type.defaultStyle;
		                if ('[object Function]' === _toString.call(type.represent)) {
		                    _result = type.represent(object, style);
		                }
		                else if (_hasOwnProperty.call(type.represent, style)) {
		                    _result = type.represent[style](object, style);
		                }
		                else {
		                    throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
		                }
		                state.dump = _result;
		            }
		            return true;
		        }
		    }
		    return false;
		}
		// Serializes `object` and writes it to global `result`.
		// Returns true on success, or false on invalid object.
		//
		function writeNode(state, level, object, block, compact) {
		    state.tag = null;
		    state.dump = object;
		    if (!detectType(state, object, false)) {
		        detectType(state, object, true);
		    }
		    var type = _toString.call(state.dump);
		    if (block) {
		        block = (0 > state.flowLevel || state.flowLevel > level);
		    }
		    if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
		        compact = false;
		    }
		    var objectOrArray = '[object Object]' === type || '[object Array]' === type, duplicateIndex, duplicate;
		    if (objectOrArray) {
		        duplicateIndex = state.duplicates.indexOf(object);
		        duplicate = duplicateIndex !== -1;
		    }
		    if (duplicate && state.usedDuplicates[duplicateIndex]) {
		        state.dump = '*ref_' + duplicateIndex;
		    }
		    else {
		        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
		            state.usedDuplicates[duplicateIndex] = true;
		        }
		        if ('[object Object]' === type) {
		            if (block && (0 !== Object.keys(state.dump).length)) {
		                writeBlockMapping(state, level, state.dump, compact);
		                if (duplicate) {
		                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
		                }
		            }
		            else {
		                writeFlowMapping(state, level, state.dump);
		                if (duplicate) {
		                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
		                }
		            }
		        }
		        else if ('[object Array]' === type) {
		            if (block && (0 !== state.dump.length)) {
		                writeBlockSequence(state, level, state.dump, compact);
		                if (duplicate) {
		                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
		                }
		            }
		            else {
		                writeFlowSequence(state, level, state.dump);
		                if (duplicate) {
		                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
		                }
		            }
		        }
		        else if ('[object String]' === type) {
		            if ('?' !== state.tag) {
		                writeScalar(state, state.dump, level);
		            }
		        }
		        else {
		            if (state.skipInvalid) {
		                return false;
		            }
		            throw new YAMLException('unacceptable kind of an object to dump ' + type);
		        }
		        if (null !== state.tag && '?' !== state.tag) {
		            state.dump = '!<' + state.tag + '> ' + state.dump;
		        }
		    }
		    return true;
		}
		function getDuplicateReferences(object, state) {
		    var objects = [], duplicatesIndexes = [], index, length;
		    inspectNode(object, objects, duplicatesIndexes);
		    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
		        state.duplicates.push(objects[duplicatesIndexes[index]]);
		    }
		    state.usedDuplicates = new Array(length);
		}
		function inspectNode(object, objects, duplicatesIndexes) {
		    var type = _toString.call(object), objectKeyList, index, length;
		    if (null !== object && 'object' === typeof object) {
		        index = objects.indexOf(object);
		        if (-1 !== index) {
		            if (-1 === duplicatesIndexes.indexOf(index)) {
		                duplicatesIndexes.push(index);
		            }
		        }
		        else {
		            objects.push(object);
		            if (Array.isArray(object)) {
		                for (index = 0, length = object.length; index < length; index += 1) {
		                    inspectNode(object[index], objects, duplicatesIndexes);
		                }
		            }
		            else {
		                objectKeyList = Object.keys(object);
		                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
		                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
		                }
		            }
		        }
		    }
		}
		function dump(input, options) {
		    options = options || {};
		    var state = new State(options);
		    getDuplicateReferences(input, state);
		    if (writeNode(state, 0, input, true, true)) {
		        return state.dump + '\n';
		    }
		    return '';
		}
		exports.dump = dump;
		function safeDump(input, options) {
		    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
		}
		exports.safeDump = safeDump;


	/***/ },
	/* 48 */
	/***/ function(module, exports) {

		/// <reference path="../../typings/tsd.d.ts" />
		function isMultiLine(s) {
		    return s && s.indexOf('\n') >= 0;
		}
		exports.isMultiLine = isMultiLine;
		function isMultiLineValue(s) {
		    return isMultiLine(s) && s.length > 2 && s[0] == '|' && (s[1] == '\n' || s[1] == '\r' || s[2] == '\n');
		}
		exports.isMultiLineValue = isMultiLineValue;
		function makeMutiLine(s, lev) {
		    var xbuf = '';
		    if (isMultiLine(s)) {
		        xbuf += '|\n';
		        var lines = splitOnLines(s);
		        for (var i = 0; i < lines.length; i++) {
		            xbuf += indent(lev, lines[i]);
		        }
		    }
		    else {
		        xbuf += s;
		    }
		    return xbuf;
		}
		exports.makeMutiLine = makeMutiLine;
		function fromMutiLine(s) {
		    if (!isMultiLineValue(s))
		        return s;
		    var res = null;
		    var lines = splitOnLines(s);
		    for (var i = 1; i < lines.length; i++) {
		        var line = lines[i];
		        var str = line.substring(2);
		        if (!res)
		            res = str;
		        else
		            res += str;
		    }
		    return res;
		}
		exports.fromMutiLine = fromMutiLine;
		function trimStart(s) {
		    if (!s)
		        return s;
		    var pos = 0;
		    while (pos < s.length) {
		        var ch = s[pos];
		        if (ch != '\r' && ch != '\n' && ch != ' ' && ch != '\t')
		            break;
		        pos++;
		    }
		    return s.substring(pos, s.length);
		}
		exports.trimStart = trimStart;
		function indent(lev, str) {
		    if (str === void 0) { str = ''; }
		    var leading = '';
		    for (var i = 0; i < lev; i++)
		        leading += '  ';
		    return leading + str;
		}
		exports.indent = indent;
		function print(lev, str) {
		    if (str === void 0) { str = ''; }
		    console.log(indent(lev, str));
		}
		exports.print = print;
		function replaceNewlines(s, rep) {
		    if (rep === void 0) { rep = null; }
		    var res = '';
		    for (var i = 0; i < s.length; i++) {
		        var ch = s[i];
		        if (ch == '\r')
		            ch = rep == null ? '\\r' : rep;
		        if (ch == '\n')
		            ch = rep == null ? '\\n' : rep;
		        res += ch;
		    }
		    return res;
		}
		exports.replaceNewlines = replaceNewlines;
		function trimEnd(s) {
		    var pos = s.length;
		    while (pos > 0) {
		        var ch = s[pos - 1];
		        if (ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n')
		            break;
		        pos--;
		    }
		    return s.substring(0, pos);
		}
		exports.trimEnd = trimEnd;
		function splitOnLines(text) {
		    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
		    return lines;
		}
		exports.splitOnLines = splitOnLines;
		function startsWith(s, suffix) {
		    if (!s || !suffix || s.length < suffix.length)
		        return false;
		    for (var i = 0; i < suffix.length; i++) {
		        if (s[i] != suffix[i])
		            return false;
		    }
		    return true;
		}
		exports.startsWith = startsWith;
		function endsWith(s, suffix) {
		    if (!s || !suffix || s.length < suffix.length)
		        return false;
		    for (var i = 0; i < suffix.length; i++) {
		        if (s[s.length - 1 - i] != suffix[suffix.length - 1 - i])
		            return false;
		    }
		    return true;
		}
		exports.endsWith = endsWith;
		var TextRange = (function () {
		    function TextRange(contents, start, end) {
		        this.contents = contents;
		        this.start = start;
		        this.end = end;
		    }
		    TextRange.prototype.text = function () {
		        return this.contents.substring(this.start, this.end);
		    };
		    TextRange.prototype.startpos = function () {
		        return this.start;
		    };
		    TextRange.prototype.endpos = function () {
		        return this.end;
		    };
		    TextRange.prototype.len = function () {
		        return this.end - this.start;
		    };
		    TextRange.prototype.unitText = function () {
		        return this.contents;
		    };
		    TextRange.prototype.withStart = function (start) {
		        return new TextRange(this.contents, start, this.end);
		    };
		    TextRange.prototype.withEnd = function (end) {
		        return new TextRange(this.contents, this.start, end);
		    };
		    TextRange.prototype.sub = function (start, end) {
		        return this.contents.substring(start, end);
		    };
		    TextRange.prototype.trimStart = function () {
		        var pos = this.start;
		        while (pos < this.contents.length - 1) {
		            var ch = this.contents[pos];
		            if (ch != ' ' && ch != '\t')
		                break;
		            pos++;
		        }
		        return new TextRange(this.contents, pos, this.end);
		    };
		    TextRange.prototype.trimEnd = function () {
		        var pos = this.end;
		        while (pos > 0) {
		            var ch = this.contents[pos - 1];
		            if (ch != ' ' && ch != '\t')
		                break;
		            pos--;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.extendToStartOfLine = function () {
		        var pos = this.start;
		        while (pos > 0) {
		            var prevchar = this.contents[pos - 1];
		            if (prevchar == '\r' || prevchar == '\n')
		                break;
		            pos--;
		        }
		        return new TextRange(this.contents, pos, this.end);
		    };
		    TextRange.prototype.extendAnyUntilNewLines = function () {
		        var pos = this.end;
		        if (pos > 0) {
		            var last = this.contents[pos - 1];
		            if (last == '\n')
		                return this;
		        }
		        while (pos < this.contents.length - 1) {
		            var nextchar = this.contents[pos];
		            if (nextchar == '\r' || nextchar == '\n')
		                break;
		            pos++;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.extendSpacesUntilNewLines = function () {
		        var pos = this.end;
		        if (pos > 0) {
		            var last = this.contents[pos - 1];
		            if (last == '\n')
		                return this;
		        }
		        while (pos < this.contents.length - 1) {
		            var nextchar = this.contents[pos];
		            if (nextchar != ' ' || nextchar == '\r' || nextchar == '\n')
		                break;
		            pos++;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.extendSpaces = function () {
		        var pos = this.end;
		        while (pos < this.contents.length - 1) {
		            var nextchar = this.contents[pos];
		            if (nextchar != ' ')
		                break;
		            pos++;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.extendSpacesBack = function () {
		        var pos = this.start;
		        while (pos > 0) {
		            var nextchar = this.contents[pos - 1];
		            if (nextchar != ' ')
		                break;
		            pos--;
		        }
		        return new TextRange(this.contents, pos, this.end);
		    };
		    TextRange.prototype.extendCharIfAny = function (ch) {
		        var pos = this.end;
		        if (pos < this.contents.length - 1 && this.contents[pos] == ch) {
		            pos++;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.extendCharIfAnyBack = function (ch) {
		        var pos = this.start;
		        if (pos > 0 && this.contents[pos - 1] == ch) {
		            pos--;
		        }
		        return new TextRange(this.contents, pos, this.end);
		    };
		    TextRange.prototype.extendToNewlines = function () {
		        var pos = this.end;
		        if (pos > 0) {
		            var last = this.contents[pos - 1];
		            if (last == '\n')
		                return this;
		        }
		        while (pos < this.contents.length - 1) {
		            var nextchar = this.contents[pos];
		            if (nextchar != '\r' && nextchar != '\n')
		                break;
		            pos++;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.extendUntilNewlinesBack = function () {
		        var pos = this.start;
		        while (pos > 0) {
		            var nextchar = this.contents[pos - 1];
		            if (nextchar == '\r' || nextchar == '\n')
		                break;
		            pos--;
		        }
		        return new TextRange(this.contents, pos, this.end);
		    };
		    TextRange.prototype.reduceNewlinesEnd = function () {
		        var pos = this.end;
		        while (pos > this.start) {
		            var last = this.contents[pos - 1];
		            if (last != '\r' && last != '\n')
		                break;
		            pos--;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.reduceSpaces = function () {
		        var pos = this.end;
		        while (pos > this.start) {
		            var last = this.contents[pos - 1];
		            if (last != ' ')
		                break;
		            pos--;
		        }
		        return new TextRange(this.contents, this.start, pos);
		    };
		    TextRange.prototype.replace = function (text) {
		        return this.sub(0, this.start) + text + this.sub(this.end, this.unitText().length);
		    };
		    TextRange.prototype.remove = function () {
		        return this.sub(0, this.start) + this.sub(this.end, this.unitText().length);
		    };
		    return TextRange;
		})();
		exports.TextRange = TextRange;


	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/underscore/underscore.d.ts" />
		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var _ = __webpack_require__(4);
		var hlImpl = __webpack_require__(5);
		var jsyaml = __webpack_require__(15);
		var typeBuilder = __webpack_require__(50);
		var search = __webpack_require__(53);
		var def = __webpack_require__(3);
		var universes = __webpack_require__(54);
		var su = __webpack_require__(56);
		var RAMLPropertyDocumentationService = (function () {
		    function RAMLPropertyDocumentationService() {
		    }
		    RAMLPropertyDocumentationService.prototype.setDocTableName = function (val) {
		        this._documentationTableName = val;
		    };
		    RAMLPropertyDocumentationService.prototype.docTableName = function () {
		        return this._documentationTableName;
		    };
		    RAMLPropertyDocumentationService.prototype.setHidden = function (val) {
		        this._isHidden = val;
		    };
		    RAMLPropertyDocumentationService.prototype.isHidden = function () {
		        return this._isHidden;
		    };
		    RAMLPropertyDocumentationService.prototype.setMarkdownDescription = function (val) {
		        this._markdownDescription = val;
		    };
		    RAMLPropertyDocumentationService.prototype.markdownDescription = function () {
		        return this._markdownDescription;
		    };
		    RAMLPropertyDocumentationService.prototype.setValueDescription = function (val) {
		        this._valueDescription = val;
		    };
		    RAMLPropertyDocumentationService.prototype.valueDescription = function () {
		        return this._valueDescription;
		    };
		    return RAMLPropertyDocumentationService;
		})();
		exports.RAMLPropertyDocumentationService = RAMLPropertyDocumentationService;
		var RAMLPropertyParserService = (function (_super) {
		    __extends(RAMLPropertyParserService, _super);
		    function RAMLPropertyParserService() {
		        _super.apply(this, arguments);
		    }
		    RAMLPropertyParserService.prototype.isSystem = function () {
		        return this._isSystemProperty;
		    };
		    RAMLPropertyParserService.prototype.withSystem = function (s) {
		        this._isSystemProperty = s;
		        return this;
		    };
		    RAMLPropertyParserService.prototype.isEmbedMap = function () {
		        return this._isEmbededMap;
		    };
		    RAMLPropertyParserService.prototype.withEmbedMap = function () {
		        this._isEmbededMap = true;
		        return this;
		    };
		    return RAMLPropertyParserService;
		})(RAMLPropertyDocumentationService);
		exports.RAMLPropertyParserService = RAMLPropertyParserService;
		var RAMLPropertyService = (function (_super) {
		    __extends(RAMLPropertyService, _super);
		    function RAMLPropertyService(_property) {
		        _super.call(this);
		        this._property = _property;
		        if (!_property) {
		            throw new Error();
		        }
		        _super.call(this);
		    }
		    RAMLPropertyService.prototype.valueDocProvider = function () {
		        return this._property.valueDocProvider();
		    };
		    RAMLPropertyService.prototype.withPropertyGrammarType = function (pt) {
		        this._propertyGrammarType = pt;
		    };
		    RAMLPropertyService.prototype.getPropertyGrammarType = function () {
		        return this._propertyGrammarType;
		    };
		    RAMLPropertyService.prototype.id = function () {
		        return this._property.nameId();
		    };
		    RAMLPropertyService.prototype.range = function () {
		        return this._property.range();
		    };
		    RAMLPropertyService.prototype.domain = function () {
		        return this._property.domain();
		    };
		    RAMLPropertyService.prototype.createAttr = function (val) {
		        var lowLevel = jsyaml.createMapping(this._property.nameId(), val);
		        var nm = new hlImpl.ASTPropImpl(lowLevel, null, this.range(), this._property);
		        return nm;
		    };
		    RAMLPropertyService.prototype.isValidValue = function (vl, c) {
		        var node = search.declRoot(c);
		        if (!node._cach) {
		            node._cach = {};
		        }
		        var id = this.id();
		        if (this.domain()) {
		            id += this.domain().nameId();
		        }
		        if (id) {
		            var cached = node._cach[id];
		            if (cached) {
		                return cached[vl] != null;
		            }
		        }
		        var vls = this.enumValues(c);
		        var mm = {};
		        vls.forEach(function (x) { return mm[x] = 1; });
		        if (this.id()) {
		            node._cach[id] = mm;
		        }
		        return mm[vl] != null;
		    };
		    RAMLPropertyService.prototype.enumValues = function (c) {
		        if (c) {
		            var rs = [];
		            //TODO FIXME it is very very weird idea but I need to get it working right now
		            if (this.isTypeExpr()) {
		                var definitionNodes = search.globalDeclarations(c).filter(function (node) {
		                    var nc = node.definition().key();
		                    if (nc === universes.Universe08.GlobalSchema || nc === universes.Universe10.GlobalSchema) {
		                        return true;
		                    }
		                    return (node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name));
		                    //return true;
		                });
		                rs = definitionNodes.map(function (x) { return hlImpl.qName(x, c); });
		                var de = c.definition().universe().type(universes.Universe10.TypeDeclaration.name);
		                if (de) {
		                    var subTypes = de.allSubTypes();
		                    rs = rs.concat(subTypes.map(function (x) { return (x).getAdapter(RAMLService).descriminatorValue(); }));
		                }
		                return rs;
		            }
		            else {
		                if (this.range().key() == universes.Universe08.SchemaString || this.range().key() == universes.Universe10.SchemaString) {
		                    if (this.range().universe().version() == "RAML10") {
		                        if (this.range().isValueType()) {
		                            var definitionNodes = search.globalDeclarations(c).filter(function (node) {
		                                if (node.definition().key() == universes.Universe10.GlobalSchema) {
		                                    return true;
		                                }
		                                return node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
		                            });
		                            rs = definitionNodes.map(function (x) { return hlImpl.qName(x, c); });
		                        }
		                    }
		                }
		            }
		            if (this.isDescriminating()) {
		                var subTypes = search.subTypesWithLocals(this.domain(), c);
		                rs = rs.concat(subTypes.map(function (x) { return (x).getAdapter(RAMLService).descriminatorValue(); }));
		            }
		            else if (this.isReference()) {
		                rs = search.nodesDeclaringType(this.referencesTo(), c).map(function (x) { return hlImpl.qName(x, c); });
		            }
		            else if (this.range().isValueType() && this.range().isValueType()) {
		                var vt = this.range().getAdapter(RAMLService);
		                if (vt.globallyDeclaredBy().length > 0) {
		                    var definitionNodes = search.globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
		                    rs = rs.concat(definitionNodes.map(function (x) { return hlImpl.qName(x, c); }));
		                }
		            }
		            if (this.isAllowNull()) {
		                rs.push("null");
		            }
		            if (this._property.enumOptions()) {
		                rs = rs.concat(this._property.enumOptions());
		            }
		            return rs;
		        }
		        if (this._property.enumOptions() && typeof this._property.enumOptions() == 'string') {
		            return [this._property.enumOptions() + ""];
		        }
		        return this._property.enumOptions();
		    };
		    RAMLPropertyService.prototype.isAllowNull = function () {
		        return this._property.isAllowNull();
		    };
		    RAMLPropertyService.prototype.referencesTo = function () {
		        return this._property.referencesTo();
		    };
		    RAMLPropertyService.prototype.isReference = function () {
		        return this._property.isReference();
		    };
		    RAMLPropertyService.prototype.nameId = function () {
		        return this._property.nameId();
		    };
		    RAMLPropertyService.prototype.priority = function () {
		        if (this.isKey())
		            return 128;
		        else if (this.isReference())
		            return 64;
		        else if (this.isTypeExpr())
		            return 32;
		        else if (this.nameId() == 'example')
		            return 0;
		        else
		            return -1024;
		    };
		    RAMLPropertyService.prototype.isKey = function () {
		        if (this._property instanceof def.Property) {
		            return this._property.isKey();
		        }
		        return false;
		    };
		    RAMLPropertyService.prototype.isMerged = function () {
		        if (this._property instanceof def.Property) {
		            return this._property.isMerged();
		        }
		        return false;
		    };
		    RAMLPropertyService.prototype.isTypeExpr = function () {
		        if (this.teDef && false) {
		            return this.texpr;
		        }
		        if (this.domain()) {
		            var dc = this.domain().key();
		            this.texpr = ((this.nameId() == universes.Universe10.TypeDeclaration.properties.type.name || this.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name) && dc == universes.Universe10.TypeDeclaration) || (this.nameId() == universes.Universe08.BodyLike.properties.schema.name && dc === universes.Universe08.BodyLike);
		        }
		        if (!this.texpr) {
		            if (this.range().key() === universes.Universe08.SchemaString || this.range().key() === universes.Universe10.SchemaString) {
		                if (this.range().universe().version() == "RAML10") {
		                    if (this.range() instanceof def.ValueType) {
		                        this.texpr = true;
		                    }
		                }
		            }
		        }
		        this.teDef = true;
		        return this.texpr;
		    };
		    RAMLPropertyService.prototype.isExampleProperty = function () {
		        return this.domain() && (!this.domain().getAdapter(RAMLService).isUserDefined()) && ((this.nameId() == universes.Universe10.TypeDeclaration.properties.example.name) || (this.nameId() == universes.Universe10.ExampleSpec.properties.content.name));
		    };
		    RAMLPropertyService.prototype.isDescriminating = function () {
		        return this._property.isDescriminator();
		    };
		    RAMLPropertyService.prototype.referenceTargets = function (c) {
		        if (this.isTypeExpr()) {
		            var definitionNodes = search.globalDeclarations(c).filter(function (node) {
		                var nc = node.definition().key();
		                if (nc === universes.Universe08.GlobalSchema || nc === universes.Universe10.GlobalSchema) {
		                    return true;
		                }
		                return node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
		            });
		            return definitionNodes;
		        }
		        if (this.isDescriminating()) {
		            var subTypes = search.nodesDeclaringType(this.range(), c);
		            return subTypes;
		        }
		        if (this.isReference()) {
		            var rt = this.referencesTo();
		            var subTypes = search.nodesDeclaringType(rt, c);
		            return subTypes;
		        }
		        if (this.range().isValueType()) {
		            var vt = this.range().getAdapter(RAMLService);
		            if (vt.globallyDeclaredBy().length > 0) {
		                var definitionNodes = search.globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
		                return definitionNodes;
		            }
		        }
		        return [];
		    };
		    return RAMLPropertyService;
		})(RAMLPropertyParserService);
		exports.RAMLPropertyService = RAMLPropertyService;
		var RAMLService = (function () {
		    function RAMLService(d) {
		        this._runtime = null;
		        //!!!
		        this._allowsOptionalProperties = false;
		        //!!!
		        this._canInherit = [];
		        this._declaredBy = [];
		        //!!!
		        this._aliases = [];
		        //!!!???
		        this._defining = [];
		        this._runtimeExtenders = [];
		        //!!!???
		        this._declaresType = null;
		        //!!!
		        this._isTemplate = false;
		        //!!!
		        this._contextRequirements = [];
		        this._type = d;
		    }
		    RAMLService.prototype.withAllowQuestion = function () {
		        this._allowsOptionalProperties = true;
		    };
		    RAMLService.prototype.getAllowQuestion = function () {
		        return this._allowsOptionalProperties;
		    };
		    RAMLService.prototype.withCanInherit = function (clazz) {
		        this._canInherit.push(clazz);
		    };
		    RAMLService.prototype.getReferenceIs = function () {
		        return this._referenceIs;
		    };
		    RAMLService.prototype.withReferenceIs = function (fname) {
		        this._referenceIs = fname;
		    };
		    RAMLService.prototype.descriminatorValue = function () {
		        if (this.valueRequirements().length == 0) {
		            return this.nameId();
		        }
		        return this.valueRequirements()[0].value;
		    };
		    RAMLService.prototype.getCanInherit = function () {
		        return this._canInherit;
		    };
		    RAMLService.prototype.withAllowAny = function () {
		        this._allowsAnyChildren = true;
		    };
		    RAMLService.prototype.getAllowAny = function () {
		        return this._allowsAnyChildren;
		    };
		    RAMLService.prototype.globallyDeclaredBy = function () {
		        return this._declaredBy;
		    };
		    RAMLService.prototype.setGloballyDeclaredBy = function (c) {
		        this._declaredBy.push(c);
		    };
		    RAMLService.prototype.setDeclaringNode = function (n) {
		        this._node = n;
		    };
		    RAMLService.prototype.isRuntime = function () {
		        return this._isRuntime;
		    };
		    RAMLService.prototype.nameId = function () {
		        return this._type.nameId();
		    };
		    RAMLService.prototype.universe = function () {
		        return this._type.universe();
		    };
		    RAMLService.prototype.toRuntimeArray = function () {
		        //    var rs= new def.Array(this.nameId(),this.universe(),"");
		        //    rs._af={};
		        //    var fs=this.getFixedFacets();
		        //    for (var i in fs){
		        //        rs._af[i]=fs[i];
		        //    }
		        //    rs._representationOf=this._type;
		        //    rs.component=this.component?this.component.toRuntime():this.component;
		        //    rs.dimensions=this.dimensions;
		        //    return rs;
		    };
		    RAMLService.prototype.isAssignableFrom = function (name) {
		        return this._type.isAssignableFrom(name);
		    };
		    RAMLService.prototype.isValid = function (h, value, p) {
		        if (this._type.isArray()) {
		            return this.isValidArray(h, value, p);
		        }
		        else if (this._type.isValueType()) {
		            return this.isValidValueType(h, value, p);
		        }
		        return true;
		    };
		    RAMLService.prototype.setConsumesRefs = function (b) {
		        this._consumesRef = b;
		    };
		    RAMLService.prototype.definingPropertyIsEnough = function (v) {
		        this._defining.push(v);
		    };
		    RAMLService.prototype.getDefining = function () {
		        return this._defining;
		    };
		    RAMLService.prototype.getConsumesRefs = function () {
		        return this._consumesRef;
		    };
		    RAMLService.prototype.addAlias = function (al) {
		        this._aliases.push(al);
		    };
		    RAMLService.prototype.getAliases = function () {
		        return this._aliases;
		    };
		    RAMLService.prototype.valueRequirements = function () {
		        return this._type.valueRequirements();
		    };
		    RAMLService.prototype.isAnnotation = function () {
		        if (this._annotationChecked) {
		            return this._isAnnotation;
		        }
		        this._annotationChecked = true;
		        this._isAnnotation = (_.find(this._type.allSuperTypes(), function (x) { return x.key() == universes.Universe10.Annotation; }) != null);
		        return this._isAnnotation;
		    };
		    RAMLService.prototype.allowValue = function () {
		        if (this._allowsValueSet) {
		            return this._allowsValue;
		        }
		        if (_.find(this._type.allProperties(), function (x) { return x.isFromParentValue() || x.canBeValue(); })) {
		            this._allowsValue = true;
		            this._allowsValueSet = true;
		            return true;
		        }
		        this._allowsValueSet = true;
		        return false;
		    };
		    RAMLService.prototype.match = function (r, alreadyFound) {
		        var _this = this;
		        //this.vReqInitied=true;
		        if (r.isAttr() || r.isUnknown()) {
		            return false;
		        }
		        var el = r;
		        //if (this.name()=="ObjectField"){
		        //   var tp= el.attr("type");
		        //    if (tp&&tp.value()) {
		        //        //FIXME
		        //        if (!_.find(["string","boolean","file","number","integer","date","pointer","script"], x=>x==tp.value())) {
		        //            return true;
		        //        }
		        //    }
		        //}
		        var hasSuperType = _.find(this._type.superTypes(), function (x) {
		            var dp = _.find(x.allProperties(), function (x) { return (x).isDescriminator(); });
		            if (dp) {
		                var a = el.attr(dp.nameId());
		                if (a) {
		                    if (a.value() == _this.nameId()) {
		                        return true;
		                    }
		                }
		            }
		            return false;
		        });
		        if (hasSuperType) {
		            return true;
		        }
		        if (this.valueRequirements().length == 0) {
		            return false;
		        }
		        var matches = true;
		        //descriminating constraint
		        this.valueRequirements().forEach(function (x) {
		            var a = el.attr(x.name);
		            if (a) {
		                if (a.value() == x.value) {
		                }
		                else {
		                    if (_this.getConsumesRefs()) {
		                        var vl = a.value();
		                        var allSubs = [];
		                        _this._type.superTypes().forEach(function (x) { return x.allSubTypes().forEach(function (y) {
		                            allSubs.push(y);
		                        }); });
		                        var allSubNames = [];
		                        _.unique(allSubs).forEach(function (x) {
		                            allSubNames.push(x.nameId());
		                            x.valueRequirements().forEach(function (y) {
		                                allSubNames.push(y.value);
		                            });
		                            x.getAdapter(RAMLService).getAliases().forEach(function (y) { return allSubNames.push(y); });
		                        });
		                        if (_.find(allSubNames, function (x) { return x == vl; })) {
		                            matches = false;
		                        }
		                    }
		                    else {
		                        matches = false;
		                    }
		                }
		            }
		            else {
		                var m = _this.getDefining();
		                var ms = false;
		                m.forEach(function (x) {
		                    el.lowLevel().children().forEach(function (y) {
		                        if (y.key() == x) {
		                            ms = true;
		                        }
		                    });
		                });
		                if (ms) {
		                    matches = true;
		                    return;
		                }
		                if (!alreadyFound) {
		                    var pr = _this._type.property(x.name);
		                    if (pr && pr.defaultValue() == x.value) {
		                    }
		                    else {
		                        matches = false;
		                    }
		                }
		            }
		        });
		        return matches;
		    };
		    RAMLService.prototype.createStubNode = function (p, key) {
		        if (key === void 0) { key = null; }
		        var lowLevel = jsyaml.createNode(key ? key : "key");
		        var nm = new hlImpl.ASTNodeImpl(lowLevel, null, this._type, p);
		        this._type.allProperties().forEach(function (x) {
		            if (x.range().isValueType() && !x.getAdapter(RAMLPropertyParserService).isSystem()) {
		                var a = nm.attr(x.nameId());
		                if (!a) {
		                }
		            }
		        });
		        nm.children();
		        return nm;
		    };
		    RAMLService.prototype.key = function () {
		        return this._type.key();
		    };
		    RAMLService.prototype.isValidArray = function (h, v, p) {
		        if (this._type.array().componentType()) {
		            return this._type.array().componentType().getAdapter(RAMLService).isValid(h, v, p);
		        }
		        return true;
		    };
		    RAMLService.prototype.isValidValueType = function (h, v, p) {
		        try {
		            if (this.key() == universes.Universe10.AnnotationRef) {
		                var targets = p.getAdapter(RAMLPropertyService).referenceTargets(h);
		                var actualAnnotation = _.find(targets, function (x) { return hlImpl.qName(x, h) == v; });
		                if (actualAnnotation != null) {
		                    var attrs = actualAnnotation.attributes("allowedTargets");
		                    if (attrs) {
		                        var aVals = attrs.map(function (x) { return x.value(); });
		                        if (aVals.length > 0) {
		                            var found = false;
		                            //no we should actually check that we are applying annotation properly
		                            var tps = h.definition().allSuperTypes();
		                            tps = tps.concat([h.definition()]);
		                            var tpNames = tps.map(function (x) { return x.nameId(); });
		                            aVals.forEach(function (x) {
		                                //FIXME this is deeply wrong code
		                                if (x == "API") {
		                                    x = "Api";
		                                }
		                                if (x == "NamedExample") {
		                                    x = "ExampleSpec";
		                                }
		                                if (x == "SecurityScheme") {
		                                    x = "AbstractSecurityScheme";
		                                }
		                                if (x == "SecuritySchemeSettings") {
		                                    x = "SecuritySchemeSettings";
		                                }
		                                if (_.find(tpNames, function (y) { return y == x; })) {
		                                    found = true;
		                                }
		                                else {
		                                    if (x == "Parameter") {
		                                        if (h.computedValue("location")) {
		                                            found = true;
		                                        }
		                                    }
		                                    if (x == "Field") {
		                                        if (h.computedValue("field")) {
		                                            found = true;
		                                        }
		                                    }
		                                }
		                            });
		                            if (!found) {
		                                return new Error("annotation " + v + " can not be placed at this location, allowed targets are:" + aVals);
		                            }
		                        }
		                    }
		                }
		                return tm;
		            }
		            if (this.key() == universes.Universe08.SchemaString || this.key() == universes.Universe10.SchemaString) {
		                var tm = su.createSchema(v);
		                if (tm instanceof Error) {
		                    tm.canBeRef = true;
		                }
		                return tm;
		            }
		            if (this.key() == universes.Universe08.StatusCodeString || this.key() == universes.Universe10.StatusCodeString) {
		                if (v.length != 3) {
		                    return new Error("Status code should be 3 digits number with optional 'x' as wildcards");
		                }
		                for (var i = 0; i < v.length; i++) {
		                    var c = v[i];
		                    if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x', 'X'], function (x) { return x == c; })) {
		                        return new Error("Status code should be 3 digits number with optional 'x' as wildcards");
		                    }
		                }
		            }
		            if (this.key() == universes.Universe08.JSonSchemaString || this.key() == universes.Universe10.JSonSchemaString) {
		                var jsshema = su.getJSONSchema(v);
		                if (jsshema instanceof Error) {
		                    jsshema.canBeRef = true;
		                }
		                return jsshema;
		            }
		            if (this.key() == universes.Universe08.XMLSchemaString || this.key() == universes.Universe10.XMLSchemaString) {
		                var xmlschema = su.getXMLSchema(v);
		                if (xmlschema instanceof Error) {
		                    xmlschema.canBeRef = true;
		                }
		                return xmlschema;
		            }
		            if (this.key() == universes.Universe08.BooleanType || this.isAssignableFrom(universes.Universe10.BooleanType.name)) {
		                if (!(v == 'true' || v == 'false')) {
		                    return new Error("'true' or 'false' is expected here");
		                }
		            }
		            if (this.key() == universes.Universe08.NumberType || this.isAssignableFrom(universes.Universe10.NumberType.name)) {
		                var q = parseFloat(v);
		                if (isNaN(q)) {
		                    return new Error("number is expected here");
		                }
		            }
		            //if (this.name()=='ramlexpression'){
		            //    try {
		            //        if (p.name()=='condition'){
		            //            if (h.computedValue("response")) {
		            //                h = h.parent().parent().parent();
		            //            }
		            //            else{
		            //                h=h.parent().parent();
		            //            }
		            //        }
		            //        if (p.name()=='validWhen'||p.name()=='requiredWhen'){
		            //            h=h.parent();
		            //        }
		            //        ramlexp.validate(v, h);
		            //    } catch (e){
		            //        return e;
		            //    }
		            //}
		            //if (this.name()=="pointer") {
		            //    var pointer = search.resolveRamlPointer(h, v);
		            //    if (!pointer) {
		            //        return new Error("Unable to resolve raml pointer:" + v);
		            //    }
		            //    else{
		            //        var dp=<defs.Property>p;
		            //        var sl=dp.getSelector(h);
		            //        if (sl){
		            //            var pp=h;
		            //            if (pp.definition().isAnnotation()){
		            //                pp=pp.parent();
		            //            }
		            //            var options=sl.apply(pp);
		            //            if (!_.find(options,x=>x==pointer)){
		            //                return new Error("Pointer does not fits to scope " + v);
		            //            }
		            //        }
		            //    }
		            //}
		            //if (this.name()=="RAMLSelector") {
		            //    try {
		            //        var sl = selector.parse(h,v);
		            //        return sl;
		            //    } catch(e){
		            //        return new Error("Unable to parse RAML selector :"+e.message);
		            //    }
		            //}
		            return true;
		        }
		        catch (e) {
		            e.canBeRef = true; //FIXME
		            return e;
		        }
		    };
		    RAMLService.prototype.getRepresentationOf = function () {
		        return this._representationOf;
		    };
		    RAMLService.prototype.addRuntimeProperty = function (p) {
		        this._runtimeProperties.push(p);
		    };
		    RAMLService.prototype.initRuntime = function () {
		        var _this = this;
		        this._runtimeProperties = [];
		        var node = this.getDeclaringNode();
		        if (node) {
		            var el = node.elementsOfKind("properties");
		            el.forEach(function (x) {
		                var prop = typeBuilder.elementToProp(x, true);
		                _this.addRuntimeProperty(prop);
		            });
		        }
		    };
		    RAMLService.prototype.allRuntimeProperties = function (ps) {
		        if (ps === void 0) { ps = {}; }
		        if (!this._runtimeProperties) {
		            this.initRuntime();
		            this._rprops = null;
		        }
		        if (this._rprops) {
		            return this._rprops;
		        }
		        if (ps[this.nameId()]) {
		            return [];
		        }
		        ps[this.nameId()] = this._type;
		        var n = {};
		        if (this._type.superTypes().length > 0) {
		            this._type.superTypes().forEach(function (x) {
		                if (x instanceof def.NodeClass) {
		                    x.getAdapter(RAMLService).allRuntimeProperties(ps).forEach(function (y) { return n[y.nameId()] = y; });
		                }
		            });
		        }
		        this._runtimeProperties.forEach(function (x) { return n[x.nameId()] = x; });
		        this._rprops = Object.keys(n).map(function (x) { return n[x]; });
		        return this._rprops;
		    };
		    RAMLService.prototype.getRuntimeProperties = function () {
		        if (!this._runtimeProperties) {
		            this.initRuntime();
		        }
		        return this._runtimeProperties;
		    };
		    RAMLService.prototype.getPath = function () {
		        return "";
		    };
		    RAMLService.prototype.isDeclaration = function () {
		        if (this._isTemplate) {
		            return true;
		        }
		        if (this._convertsToGlobal) {
		            return true;
		        }
		        if (this._declaresType) {
		            return true;
		        }
		        if (this.key() === universes.Universe10.Library) {
		            return true;
		        }
		        return false;
		    };
		    RAMLService.prototype.isGlobalDeclaration = function () {
		        if (this._actuallyExports) {
		            return true;
		        }
		        if (this._isTemplate) {
		            return true;
		        }
		        if (this._declaresType) {
		            return true;
		        }
		        return false;
		    };
		    RAMLService.prototype.isTypeSystemMember = function () {
		        return this._declaresType != null;
		    };
		    RAMLService.prototype.getExtendedType = function () {
		        return this.universe().type(this._declaresType);
		    };
		    RAMLService.prototype.setInlinedTemplates = function (b) {
		        this._isTemplate = b;
		        return this;
		    };
		    RAMLService.prototype.getRuntimeExtenders = function () {
		        return this._runtimeExtenders;
		    };
		    RAMLService.prototype.isInlinedTemplates = function () {
		        return this._isTemplate;
		    };
		    RAMLService.prototype.setExtendedTypeName = function (name) {
		        this._declaresType = name;
		        var tp = this.universe().type(name);
		        if (tp instanceof def.NodeClass) {
		            var nc = tp;
		            nc.getAdapter(RAMLService)._runtimeExtenders.push(this._type);
		        }
		    };
		    RAMLService.prototype.getKeyProp = function () {
		        return _.find(this._type.allProperties(), function (x) { return x.getAdapter(RAMLPropertyService).isKey(); });
		    };
		    RAMLService.prototype.withActuallyExports = function (pname) {
		        this._actuallyExports = pname;
		    };
		    RAMLService.prototype.withConvertsToGlobal = function (pname) {
		        this._convertsToGlobal = pname;
		    };
		    RAMLService.prototype.getConvertsToGlobal = function () {
		        return this._convertsToGlobal;
		    };
		    RAMLService.prototype.getActuallyExports = function () {
		        return this._actuallyExports;
		    };
		    RAMLService.prototype.isUserDefined = function () {
		        if (this._type instanceof def.NodeClass) {
		            return this._type.isUserDefined();
		        }
		        if (this._type instanceof def.Array) {
		            return this._type.isUserDefined();
		        }
		        if (this._type instanceof def.Union) {
		            return this._type.isUserDefined();
		        }
		        return false;
		    };
		    RAMLService.prototype.withContextRequirement = function (name, value) {
		        this._contextRequirements.push({ name: name, value: value });
		    };
		    RAMLService.prototype.getContextRequirements = function () {
		        return this._contextRequirements;
		    };
		    RAMLService.prototype.findMembersDeterminer = function () {
		        return _.find(this._type.allProperties(), function (x) { return x.isThisPropertyDeclaresTypeFields(); });
		    };
		    RAMLService.prototype.nameAtRuntime = function () {
		        if (this._type.valueRequirements().length > 0) {
		            return this.valueRequirements()[0].value;
		        }
		        if (this._type instanceof def.ValueType) {
		            var nr = this._type.getNameAtRuntime();
		            if (nr) {
		                return nr;
		            }
		        }
		        return this._type.nameId();
		    };
		    RAMLService.prototype.toRuntime = function () {
		        if (this._runtime) {
		            return this._runtime;
		        }
		        if (this.key() == universes.Universe10.NumberTypeDeclaration) {
		            return this.universe().type(universes.Universe10.NumberType.name);
		        }
		        if (this.key() == universes.Universe10.StringTypeDeclaration) {
		            return this.universe().type(universes.Universe10.StringType.name);
		        }
		        if (this.key() == universes.Universe10.BooleanTypeDeclaration) {
		            return this.universe().type(universes.Universe10.BooleanType.name);
		        }
		        if (this.key() == universes.Universe10.IntegerTypeDeclaration) {
		            return this.universe().type(universes.Universe10.NumberType.name);
		        }
		        if (this._isRuntime) {
		            return this._type;
		        }
		        if (!this._type.getAdapter(RAMLService).isUserDefined()) {
		            return this._type;
		        }
		        var c = new def.UserDefinedClass(this.nameId(), this.universe(), null, this.getPath(), "");
		        this._runtime = c;
		        c.getAdapter(RAMLService)._isRuntime = true;
		        c.getAdapter(RAMLService)._representationOf = this._type;
		        var foundRuntimeProperties = this.allRuntimeProperties();
		        if (foundRuntimeProperties) {
		            foundRuntimeProperties.forEach(function (runtimeProperty) { return runtimeProperty.withDomain(c); });
		            c._properties = foundRuntimeProperties;
		        }
		        else {
		            c._properties = [];
		        }
		        c.getAdapter(RAMLService).setDeclaringNode(this.getDeclaringNode());
		        if (this.isAssignableFrom("ObjectTypeDeclaration")) {
		            c._value = false;
		            if (c._properties.length == 0) {
		                c.getAdapter(RAMLService).withAllowAny();
		            }
		        }
		        else {
		            c._value = true;
		            var sm = this._type.superTypes();
		            c._superTypes = sm.map(function (x) { return x.getAdapter(RAMLService).toRuntime(); }).filter(function (x) { return x && x.isValueType(); });
		        }
		        if (this._type.isUnion()) {
		            var ut = new def.Union(this.nameId(), this.universe(), this.getPath());
		            ut.getAdapter(RAMLService)._representationOf = this._type;
		            ut._isRuntime = true;
		            ut.getAdapter(RAMLService).setDeclaringNode(this.getDeclaringNode());
		            var cm = this._type.union();
		            if (cm) {
		                if (cm.leftType()) {
		                    ut.left = cm.leftType().getAdapter(RAMLService).toRuntime();
		                }
		                if (cm.rightType()) {
		                    ut.right = cm.rightType().getAdapter(RAMLService).toRuntime();
		                }
		                this._runtime = ut;
		                return ut;
		            }
		            this._runtime = ut;
		            //at.component=this.component.toRuntime();
		            return ut;
		        }
		        if (this._type.isArray()) {
		            var at = new def.Array(this.nameId(), this.universe(), this.getPath());
		            this._runtime = at;
		            at._af = {};
		            var fs = this._type.getFixedFacets();
		            for (var i in fs) {
		                at._af[i] = fs[i];
		            }
		            at.getAdapter(RAMLService)._representationOf = this._type;
		            at.getAdapter(RAMLService).setDeclaringNode(this.getDeclaringNode());
		            var at1 = this._type.array();
		            if (at1) {
		                var comp = at1.componentType();
		                if (comp) {
		                    at.component = comp.getAdapter(RAMLService).toRuntime();
		                }
		            }
		            //at.component=this.component.toRuntime();
		            return at;
		        }
		        return c;
		    };
		    RAMLService.prototype.toRuntimeWithInheritance = function () {
		        if (this._runtime) {
		            return this._runtime;
		        }
		        if (!this._type.getAdapter(RAMLService).isUserDefined()) {
		            return new def.NodeClass(this.nameAtRuntime(), this.universe(), "", "");
		        }
		        var c = new def.UserDefinedClass(this.nameId(), this.universe(), null, this.getPath(), "");
		        this._runtime = c;
		        c.getAdapter(RAMLService)._isRuntime = true;
		        c.getAdapter(RAMLService)._representationOf = this._type;
		        var foundRuntimeProperties = this.getRuntimeProperties();
		        if (foundRuntimeProperties) {
		            foundRuntimeProperties.forEach(function (runtimeProperty) { return runtimeProperty.withDomain(c); });
		            c._properties = foundRuntimeProperties;
		        }
		        else {
		            c._properties = [];
		        }
		        c.getAdapter(RAMLService).setDeclaringNode(this.getDeclaringNode());
		        this._type.allSuperTypes().forEach(function (t) {
		            var s = t.getAdapter(RAMLService).toRuntimeWithInheritance();
		            if (t.key() == universes.Universe10.TypeDeclaration) {
		                return;
		            }
		            if (t.key() == universes.Universe10.RAMLLanguageElement) {
		                return;
		            }
		            c._superTypes.push(s);
		        });
		        if (this.isAssignableFrom("ObjectTypeDeclaration")) {
		            c._value = false;
		            if (c._properties.length == 0) {
		                c.getAdapter(RAMLService).withAllowAny();
		            }
		        }
		        else {
		            c._value = true;
		        }
		        if (this._type.isUnion()) {
		            var ut = new def.Union(this.nameId(), this.universe(), this.getPath());
		            ut.getAdapter(RAMLService)._representationOf = this._type;
		            ut._isRuntime = true;
		            ut.getAdapter(RAMLService).setDeclaringNode(this.getDeclaringNode());
		            var cm = this._type.union();
		            if (cm) {
		                if (cm.leftType()) {
		                    ut.left = cm.leftType().getAdapter(RAMLService).toRuntime();
		                }
		                if (cm.rightType()) {
		                    ut.right = cm.rightType().getAdapter(RAMLService).toRuntime();
		                }
		                return ut;
		            }
		            this._runtime = ut;
		            var union = new def.NodeClass("union", this.universe(), "", "");
		            union._superTypes.push(arr);
		            //at.component=this.component.toRuntime();
		            return ut;
		        }
		        if (this._type.isArray()) {
		            var at = new def.Array(this.nameId(), this.universe(), this.getPath());
		            this._runtime = at;
		            at._af = {};
		            var fs = this._type.getFixedFacets();
		            for (var i in fs) {
		                at._af[i] = fs[i];
		            }
		            at.getAdapter(RAMLService)._representationOf = this._type;
		            at.getAdapter(RAMLService).setDeclaringNode(this.getDeclaringNode());
		            var at1 = this._type.array();
		            if (at1) {
		                var comp = at1.componentType();
		                if (comp) {
		                    at.component = comp.getAdapter(RAMLService).toRuntime();
		                }
		            }
		            var arr = new def.NodeClass("array", this.universe(), "", "");
		            at._superTypes.push(arr);
		            //at.component=this.component.toRuntime();
		            return at;
		        }
		        return c;
		    };
		    RAMLService.prototype.getDeclaringNode = function () {
		        return this._node;
		    };
		    return RAMLService;
		})();
		exports.RAMLService = RAMLService;


	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var defs = __webpack_require__(3);
		var _ = __webpack_require__(4);
		var typeExpression = __webpack_require__(51);
		var universes = __webpack_require__(54);
		var hlimpl = __webpack_require__(5);
		var annotationHandlers = __webpack_require__(83);
		var services = __webpack_require__(49);
		var linter = __webpack_require__(55);
		function templateFields(node, d) {
		    var u = node.root().definition().universe();
		    node.children().forEach(function (x) { return templateFields(x, d); });
		    if (node instanceof hlimpl.ASTPropImpl) {
		        var prop = node;
		        //TODO RECURSIVE PARAMETERS
		        var v = prop.value();
		        if (typeof v == 'string') {
		            var strV = v;
		            handleValue(strV, d, prop, false, u);
		        }
		        else {
		            node.lowLevel().visit(function (x) {
		                if (x.value()) {
		                    var strV = x.value() + "";
		                    handleValue(strV, d, prop, true, u);
		                }
		                return true;
		            });
		        }
		    }
		    else if (node instanceof hlimpl.BasicASTNode) {
		        var v = node.lowLevel().value();
		        if (typeof v == 'string') {
		            var strV = v;
		            handleValue(strV, d, null, false, u);
		        }
		        else {
		            node.lowLevel().visit(function (x) {
		                if (x.value()) {
		                    var strV = x.value() + "";
		                    handleValue(strV, d, null, true, u);
		                }
		                return true;
		            });
		        }
		    }
		}
		var handleValue = function (strV, d, prop, allwaysString, u) {
		    var ps = 0;
		    while (true) {
		        var pos = strV.indexOf("<<", ps);
		        if (pos != -1) {
		            var end = strV.indexOf(">>", pos);
		            var isFull = pos == 0 && end == strV.length - 2;
		            var parameterUsage = strV.substring(pos + 2, end);
		            ps = pos + 2;
		            var directiveIndex = parameterUsage.indexOf("|");
		            if (directiveIndex != -1) {
		                parameterUsage = parameterUsage.substring(0, directiveIndex);
		            }
		            parameterUsage = parameterUsage.trim();
		            if (parameterUsage == "resourcePathName" || parameterUsage == "methodName" || parameterUsage == "resourcePath") {
		                continue;
		            }
		            var q = d[parameterUsage];
		            var r = (prop) ? prop.property().range() : null;
		            if (prop) {
		                if (prop.property().nameId() == universes.Universe10.TypeDeclaration.properties.type.name || prop.property().nameId() == universes.Universe10.TypeDeclaration.properties.schema.name) {
		                    if (prop.property().domain().key() == universes.Universe10.TypeDeclaration) {
		                        r = u.type(universes.Universe10.SchemaString.name);
		                    }
		                }
		            }
		            if (!isFull || allwaysString) {
		                r = u.type(universes.Universe10.StringType.name);
		            }
		            //FIX ME NOT WHOLE TEMPLATES
		            if (q) {
		                q.push({
		                    tp: r,
		                    attr: prop
		                });
		            }
		            else {
		                d[parameterUsage] = [{
		                    tp: r,
		                    attr: prop
		                }];
		            }
		        }
		        else
		            break;
		    }
		};
		function ObjectTypeDeclaration(node) {
		    var de = node.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
		    return de;
		}
		var ann = 0;
		function typeFromNode(node) {
		    if (!node) {
		        return null;
		    }
		    if (node.associatedType()) {
		        return node.associatedType();
		    }
		    var u = node.lowLevel().unit();
		    var upath = u ? u.path() : "";
		    if (node.property() && node.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name) {
		        var st = node.definition().getAdapter(services.RAMLService).toRuntime();
		        var result = new defs.AnnotationType(node.name(), node.definition().universe(), node, upath, "");
		        result._superTypes.push(st);
		        return result;
		    }
		    else {
		        var result = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, upath, "");
		    }
		    node.setAssociatedType(result);
		    //result.setDeclaringNode(node);
		    var def = node.definition();
		    if (def.getAdapter(services.RAMLService).isInlinedTemplates()) {
		        var usages = {};
		        templateFields(node, usages);
		        Object.keys(usages).forEach(function (x) {
		            var prop = new defs.UserDefinedProp(x);
		            //prop._node=node;
		            prop.withDomain(result);
		            var tp = _.unique(usages[x]).map(function (x) { return x.tp; }).filter(function (x) { return x && x.nameId() != universes.Universe08.StringType.name; });
		            prop.withRange(tp.length == 1 ? tp[0] : node.definition().universe().type(universes.Universe08.StringType.name));
		            prop.withRequired(true);
		            if (usages[x].length > 0) {
		                prop._node = usages[x][0].attr;
		            }
		            prop.unmerge();
		        });
		        var keyProp = new defs.UserDefinedProp("key");
		        //prop._node=node;
		        keyProp.withDomain(result);
		        keyProp.withKey(true);
		        keyProp._node = node;
		        keyProp.withFromParentKey(true);
		        keyProp.withRange(node.definition().universe().type(universes.Universe08.StringType.name));
		    }
		    else if (def.getAdapter(services.RAMLService).getReferenceIs()) {
		        if (def.universe().version() == "RAML08") {
		            result.getAdapter(services.RAMLService).withAllowAny();
		        }
		        var p = def.property(def.getAdapter(services.RAMLService).getReferenceIs());
		        if (p) {
		            p.range().properties().forEach(function (x) {
		                var prop = new defs.Property(x.nameId());
		                prop.unmerge();
		                prop.withDomain(result);
		                prop.withRange(x.range());
		                prop.withMultiValue(x.isMultiValue());
		            });
		        }
		    }
		    else {
		        var rp = def.getAdapter(services.RAMLService).findMembersDeterminer();
		        if (rp) {
		            var elements = node.elementsOfKind(rp.nameId());
		            elements.forEach(function (x) {
		                var prop = elementToProp(x);
		                prop.withDomain(result);
		            });
		        }
		        //here we should found correct inheritance chain
		        var types = node.attributes("type");
		        var schema = node.attributes("schema");
		        types = types.concat(schema);
		        if (node.definition().key() === universes.Universe08.GlobalSchema || node.definition().key() === universes.Universe10.GlobalSchema) {
		            var vl = node.attributes("value");
		            types = types.concat(vl);
		        }
		        var tp = types.length != 0;
		        types.forEach(function (tp) {
		            var vl = tp.value();
		            if (typeof vl == 'string' && vl) {
		                vl = vl.trim();
		                if (vl.charAt(0) == '{') {
		                    var et = new defs.ExternalType(node.name(), node.definition().universe(), upath, "");
		                    et.schemaString = vl;
		                    et.node = node;
		                    var de = ObjectTypeDeclaration(node);
		                    if (de) {
		                        result._superTypes.push(de);
		                    }
		                    result._superTypes.push(et);
		                }
		                if (vl.charAt(0) == '<') {
		                    var et = new defs.ExternalType(node.name(), node.definition().universe(), upath, "");
		                    et.schemaString = vl;
		                    et.node = node;
		                    var de = ObjectTypeDeclaration(node);
		                    if (de) {
		                        result._superTypes.push(de);
		                    }
		                    result._superTypes.push(et);
		                }
		            }
		            var types = {};
		            types[result.nameId()] = result;
		            var at = null;
		            if (vl != result.nameId()) {
		                at = typeExpression.getType(node.parent(), vl, types);
		            }
		            else {
		            }
		            if (at) {
		                result._superTypes.push(at);
		            }
		        });
		        result.addRequirement("type", node.name());
		        var extType = def.getAdapter(services.RAMLService).getExtendedType();
		        if (extType) {
		            result._superTypes.push(extType);
		        }
		        {
		            //Adding runtime properties for object types TODO it should be done in more elegant way
		            var prop = _.find(node.lowLevel().children(), function (x) { return x.key() == "properties"; });
		            if (prop) {
		                var de = ObjectTypeDeclaration(node);
		                if (de) {
		                    result._superTypes.push(de);
		                }
		            }
		            else {
		                if (node.property() && node.property().nameId() == universes.Universe10.Method.properties.body.name) {
		                    var de = ObjectTypeDeclaration(node);
		                    if (de) {
		                        result._superTypes.push(de);
		                    }
		                }
		                else if (!tp) {
		                    var de = node.definition().universe().type(universes.Universe10.StringTypeDeclaration.name);
		                    if (de && node.definition().key() != universes.Universe08.BodyLike && node.definition().key() != universes.Universe10.AnnotationTypeDeclaration) {
		                        result._superTypes.push(de);
		                    }
		                }
		                if (result._superTypes.length == 0) {
		                    var de = node.definition().universe().type(universes.Universe10.TypeDeclaration.name);
		                    if (de) {
		                        result._superTypes.push(de);
		                    }
		                }
		            }
		            var pn = ObjectTypeDeclaration(node);
		            if (pn) {
		                node.lowLevel().children().forEach(function (x) {
		                    if (x.key() == "facets") {
		                        return;
		                    }
		                    if (x.key() == "annotations") {
		                        return;
		                    }
		                    if (x.key() == "parameters") {
		                        return;
		                    }
		                    if (!pn.property(x.key())) {
		                        result.fixFacet(x.key(), x);
		                    }
		                });
		            }
		        }
		    }
		    return result;
		}
		exports.typeFromNode = typeFromNode;
		function parsePropertyName(name) {
		    var v = { name: "", regexp: null };
		    if (name.length > 2) {
		        name = name.substr(1, name.length - 2);
		        var pos = name.lastIndexOf("#");
		        if (pos != -1) {
		            v.name = name.substr(pos + 1);
		            v.regexp = name.substr(0, pos);
		        }
		        else {
		            v.regexp = name;
		        }
		    }
		    return v;
		}
		exports.parsePropertyName = parsePropertyName;
		function libraryLocation(definition) {
		    var node = definition.getAdapter(services.RAMLService).getDeclaringNode();
		    var result = null;
		    if (node != null) {
		        var library = node.parent();
		        if (library) {
		            var libraryAnnotations = library.attributes("annotations");
		            libraryAnnotations.forEach(function (x) {
		                var value = x.value();
		                if (value instanceof hlimpl.StructuredValue) {
		                    if (value.lowLevel().key() == "(LibraryLocation)") {
		                        var hlv = value.toHighlevel(library);
		                        if (hlv) {
		                            result = valueOf(hlv);
		                        }
		                    }
		                }
		            });
		        }
		    }
		    return result;
		}
		exports.libraryLocation = libraryLocation;
		function valueOf(hl) {
		    if (hl) {
		        var vl = hl.attr("value");
		        if (vl) {
		            return vl.value();
		        }
		    }
		    return null;
		}
		exports.valueOf = valueOf;
		var scriptToValidator = {};
		var loophole = __webpack_require__(110);
		function evalInSandbox(code, thisArg, args) {
		    return new loophole.Function(code).call(thisArg, args);
		}
		var ValidatorHolder = (function () {
		    function ValidatorHolder() {
		    }
		    ValidatorHolder.prototype.register = function (mm) {
		        this._result = mm;
		    };
		    return ValidatorHolder;
		})();
		function aquireValidator(value) {
		    if (value) {
		        var nm = scriptToValidator[value];
		        if (nm) {
		            if (nm == aquireValidator) {
		                return null;
		            }
		            return nm;
		        }
		        try {
		            var holder = new ValidatorHolder();
		            evalInSandbox(value, holder, []);
		            if (holder._result) {
		                scriptToValidator[value] = holder._result;
		                return holder._result;
		            }
		            else {
		                scriptToValidator[value] = aquireValidator;
		            }
		        }
		        catch (e) {
		            scriptToValidator[value] = aquireValidator;
		        }
		    }
		    return null;
		}
		exports.aquireValidator = aquireValidator;
		function elementToProp(e, toRuntime) {
		    if (toRuntime === void 0) { toRuntime = false; }
		    var nm = e.name();
		    var optional = false;
		    if (nm && nm.length > 0 && nm.charAt(nm.length - 1) == '?') {
		        nm = nm.substr(0, nm.length - 1);
		        optional = true;
		    }
		    var result = new defs.UserDefinedProp(nm);
		    result._node = e;
		    try {
		        var description = e.attr("description");
		        if (description) {
		            var dsv = "" + description.value();
		            result.withDescription(dsv);
		        }
		        var dn = e.attr("displayName");
		        if (dn) {
		            var dsv = "" + dn.value();
		            result.withDisplayName(dsv);
		        }
		        var example = e.attr("example");
		        if (example) {
		            var obj = new linter.ExampleValidator().parseObject(example, {
		                begin: function () {
		                },
		                end: function () {
		                },
		                accept: function (f) {
		                }
		            }, false);
		            result.setDefaultVal(obj);
		        }
		        else {
		            var exampleElements = e.elementsOfKind("examples");
		            exampleElements.forEach(function (x) {
		                var cnt = x.attr("content");
		                if (cnt) {
		                    var obj = new linter.ExampleValidator().parseObject(cnt, {
		                        begin: function () {
		                        },
		                        end: function () {
		                        },
		                        accept: function (f) {
		                        }
		                    }, false);
		                    result.setDefaultVal(obj);
		                }
		            });
		        }
		    }
		    catch (e) {
		        console.log(e); //TODO remove me
		    }
		    var annotations = e.attributes("annotations");
		    annotations.forEach(function (annotation) {
		        var value = annotation.value();
		        if (value instanceof hlimpl.StructuredValue) {
		            var highLevel = value.toHighlevel(e);
		            if (highLevel) {
		                var definition = highLevel.definition();
		                if (definition.nameId() == "FacetInstanceValidator") {
		                    var node = definition.getAdapter(services.RAMLService).getDeclaringNode();
		                    var ll = libraryLocation(definition);
		                    if (ll == "http://raml.org/library/common.raml") {
		                        var value = valueOf(highLevel);
		                        var facetValidator = aquireValidator(value);
		                        if (facetValidator) {
		                            result.setFacetValidator(facetValidator);
		                        }
		                    }
		                }
		            }
		        }
		    });
		    if (nm.length > 0) {
		        if (nm[0] == '[') {
		            optional = true;
		            var info = parsePropertyName(nm);
		            if (info.regexp) {
		                result.withKeyRegexp(info.regexp);
		            }
		            else {
		                result.withKeyRestriction("");
		            }
		            if (info.name) {
		                result.withDescription(info.name);
		            }
		            result.withMultiValue();
		        }
		        else {
		            result.unmerge();
		        }
		    }
		    var props = e.definition().properties();
		    var tp = e.attr("type");
		    if (tp) {
		        var typeName = tp.value();
		        if (typeName == "any") {
		            result.withMultiValue(true);
		            var rm = new defs.NodeClass("ObjectTypeDeclaration", e.definition().universe(), "", "");
		            rm.getAdapter(services.RAMLService).withAllowAny();
		            result.withRange(rm);
		        }
		        else {
		            var tpv = typeExpression.getType(e, typeName, {}, true);
		            if (tpv) {
		                tpv = tpv.getAdapter(services.RAMLService).toRuntime();
		                if (tpv instanceof defs.Array) {
		                    var at = tpv;
		                    //FIXME
		                    at._af = {};
		                    //var fs=tpv.getFixedFacets();
		                    //for (var i in fs){
		                    //    at._af[i]=fs[i];
		                    //}
		                    at.findFacets(e, at._af);
		                }
		            }
		            result.withRange(tpv);
		        }
		    }
		    //FIXME Literals
		    if (nm == "value" && e.parent() && e.parent().definition().isAssignableFrom(universes.Universe10.AnnotationTypeDeclaration.name)) {
		        result.withCanBeValue();
		    }
		    e.definition().allProperties().forEach(function (p) {
		        if (p.nameId() != universes.Universe10.TypeDeclaration.properties.type.name) {
		            if (p.describesAnnotation()) {
		                var annotationName = p.describedAnnotation();
		                var args = [];
		                var vl = e.attributes(p.nameId()).map(function (a) { return a.value(); });
		                if (vl.length == 1) {
		                    args.push(vl[0]);
		                }
		                else {
		                    args.push(vl);
		                }
		                //TODO ANNOTATIONS WITH MULTIPLE ARGUMENTS
		                var an = {
		                    name: annotationName,
		                    arguments: args
		                };
		                annotationHandlers.recordAnnotation(result, an);
		            }
		        }
		    });
		    if (optional) {
		        result.withRequired(false);
		    }
		    var vn = _.find(e.lowLevel().children(), function (x) { return x.key() == "properties"; });
		    if (vn) {
		        var of = e.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
		        var node = new hlimpl.ASTNodeImpl(e.lowLevel(), e.parent(), of, result);
		        var epath = e.lowLevel().unit();
		        var nc = new defs.UserDefinedClass("", of.universe(), node, epath ? epath.path() : "", "");
		        nc._superTypes.push(of);
		        result.withRange(nc.getAdapter(services.RAMLService).toRuntime());
		    }
		    if (result.range() == null) {
		        result.withRange(new defs.ValueType("string", e.definition().universe(), ""));
		    }
		    if (result.range().key() == universes.Universe10.ObjectTypeDeclaration) {
		        var rm = new defs.NodeClass(universes.Universe10.ObjectTypeDeclaration.name, result.range().universe(), "", "");
		        rm.getAdapter(services.RAMLService).withAllowAny();
		        result.withRange(rm);
		    }
		    return result;
		}
		exports.elementToProp = elementToProp;


	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var defs = __webpack_require__(3);
		var hl = __webpack_require__(2);
		var _ = __webpack_require__(4);
		var typeExpression = __webpack_require__(52);
		var search = __webpack_require__(53);
		var linter = __webpack_require__(55);
		var schema = __webpack_require__(56);
		var services = __webpack_require__(49);
		function validate(str, node, cb) {
		    var x = str.trim();
		    if (x.length > 0) {
		        try {
		            if (x.charAt(0) == "{") {
		                schema.getJSONSchema(str);
		                //this is json schema
		                return;
		            }
		            if (x.charAt(0) == "<") {
		                schema.getXMLSchema(str);
		                //this is xsd schema
		                return;
		            }
		        }
		        catch (e) {
		            cb.accept(linter.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node));
		        }
		    }
		    var result = typeExpression.parse(str);
		    validateNode(result, node, cb);
		}
		exports.validate = validate;
		function getType(node, expression, defined, toRuntime) {
		    if (toRuntime === void 0) { toRuntime = false; }
		    if (!expression) {
		        return node.definition().universe().type("StringTypeDeclaration");
		    }
		    if (toRuntime) {
		        if (buildInsRuntime[expression]) {
		            var sm = node.definition().universe().type(buildInsRuntime[expression]);
		            return sm;
		        }
		    }
		    if (buildIns[expression]) {
		        var qm = node.definition().universe().type(buildIns[expression]);
		        return qm;
		    }
		    try {
		        var vl = expression;
		        vl = vl.trim();
		        if (vl.charAt(0) == '{') {
		            return null;
		        }
		        if (vl.charAt(0) == '<') {
		            return null;
		        }
		        var result = typeExpression.parse(expression);
		    }
		    catch (e) {
		        return null;
		    }
		    return deriveType(node, result, toRuntime, defined);
		}
		exports.getType = getType;
		/**
		 * Only use it for example validaation at this point, lets think about it after release.
		 * @param node
		 * @param expression
		 * @param defined
		 * @param toRuntime
		 * @returns {any}
		 */
		function getType2(node, expression, defined, toRuntime) {
		    if (toRuntime === void 0) { toRuntime = false; }
		    if (!expression) {
		        return node.definition().universe().type("StringTypeDeclaration");
		    }
		    if (toRuntime) {
		        if (buildInsRuntime[expression]) {
		            var sm = node.definition().universe().type(buildInsRuntime[expression]);
		            if (sm) {
		                var ret = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, "", "");
		                ret._superTypes.push(sm);
		                return ret;
		            }
		        }
		    }
		    if (buildIns[expression]) {
		        var qm = node.definition().universe().type(buildIns[expression]);
		        if (qm) {
		            var ret = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, "", "");
		            ret._superTypes.push(qm);
		            return ret;
		        }
		    }
		    try {
		        var vl = expression;
		        vl = vl.trim();
		        if (vl.charAt(0) == '{') {
		            return null;
		        }
		        if (vl.charAt(0) == '<') {
		            return null;
		        }
		        var result = typeExpression.parse(expression);
		    }
		    catch (e) {
		        return null;
		    }
		    return deriveType(node, result, toRuntime, defined);
		}
		exports.getType2 = getType2;
		var buildIns = {
		    string: "StringTypeDeclaration",
		    number: "NumberTypeDeclaration",
		    integer: "IntegerTypeDeclaration",
		    date: "DateTypeDeclaration",
		    object: "ObjectTypeDeclaration",
		    boolean: "BooleanTypeDeclaration",
		    value: "ValueTypeDeclaration",
		    file: "FileTypeDeclaration"
		};
		var buildInsRuntime = {
		    string: "string",
		    number: "number",
		    integer: "integer",
		    date: "date",
		    object: "ObjectTypeDeclaration",
		    boolean: "boolean",
		    value: "string",
		    file: "file"
		};
		var counter = 0;
		function deriveType(node, r, toRuntime, defining) {
		    if (toRuntime === void 0) { toRuntime = false; }
		    if (defining === void 0) { defining = {}; }
		    if (r.type == "union") {
		        var u = r;
		        var left = deriveType(node, u.first, toRuntime, defining);
		        var right = deriveType(node, u.rest, toRuntime, defining);
		        var ut = node.definition().universe().type("UnionTypeDeclaration");
		        var union = new defs.Union("Union" + (counter++), node.definition().universe(), "");
		        union._superTypes.push(ut);
		        union.left = left;
		        union.right = right;
		        return union;
		    }
		    if (r.type == 'responses') {
		        var res = r;
		        var result = null;
		        res.codes.forEach(function (t) {
		            var tp = deriveType(node, t.expr, toRuntime, defining);
		            if (tp) {
		                if (!result) {
		                    result = tp;
		                }
		                else {
		                    var union = new defs.Union("Union" + (counter++), node.definition().universe(), "");
		                    union.left = result;
		                    union.right = tp;
		                    result = tp;
		                }
		            }
		        });
		        return result;
		    }
		    if (r.type == 'parens') {
		        var ex = r;
		        return deriveType(node, ex.expr, toRuntime, defining);
		    }
		    if (r.type == 'name') {
		        var l = r;
		        var val = l.value;
		        var ind = val.lastIndexOf("[]");
		        if (ind != -1 && ind == val.length - 2) {
		            val = val.substr(0, val.length - 2); //FIXME Should be in PEG
		        }
		        if (l.arr > 0) {
		            var types = search.subTypesWithLocals(node.definition().universe().type("TypeDeclaration"), node);
		            var tp = _.find(types, function (x) {
		                var c = x.nameId() == val;
		                if (!c) {
		                    if (x instanceof defs.AbstractType) {
		                        var at = x;
		                        at.getAdapter(services.RAMLService).getAliases().forEach(function (y) {
		                            if (y == val) {
		                                c = true;
		                            }
		                        });
		                    }
		                }
		                return c;
		            });
		            if (!tp) {
		                //TOD make it simpler
		                if (toRuntime || true) {
		                    //it is always runtime model when we are here
		                    if (buildInsRuntime[val]) {
		                        tp = node.definition().universe().type(buildInsRuntime[val]);
		                    }
		                }
		                else if (buildIns[val]) {
		                    tp = node.definition().universe().type(buildIns[val]);
		                }
		            }
		            if (!tp) {
		                tp = new defs.ValueType("String", node.definition().universe(), "");
		            }
		            var at = node.definition().universe().type("ArrayTypeDeclaration");
		            var arr = new defs.Array(tp.nameId() + "[]", node.definition().universe(), "");
		            arr._superTypes.push(at);
		            arr.component = tp;
		            arr.dimensions = l.arr;
		            return arr;
		        }
		        if (toRuntime) {
		            if (buildInsRuntime[val]) {
		                return node.definition().universe().type(buildInsRuntime[val]);
		            }
		        }
		        if (buildIns[val]) {
		            return node.definition().universe().type(buildIns[val]);
		        }
		        var de = node.definition().universe().type("TypeDeclaration");
		        if (!de) {
		            de = node.definition().universe().type("GlobalSchema");
		        }
		        //if (defining[val]){
		        //    return defining[val];
		        //}
		        var qm = search.subTypesWithName(val, node, defining);
		        if (qm) {
		            return qm;
		        }
		        //return null;
		        de = node.definition().universe().type("GlobalSchema");
		        return search.schemasWithName(val, node, defining);
		    }
		    return null;
		}
		exports.deriveType = deriveType;
		function nodeToString(r) {
		    if (r.type == "union") {
		        var u = r;
		        return nodeToString(u.first) + "|" + nodeToString(u.rest);
		    }
		    if (r.type == "responses") {
		        var res = r;
		        var rs = "{";
		        for (var i = 0; i < res.codes.length; i++) {
		            rs += res.codes[i].code;
		            rs += ":";
		            rs += nodeToString(res.codes[i].expr);
		            if (i != res.codes.length - 1) {
		                rs += ",";
		            }
		        }
		        rs += '}';
		        return rs;
		    }
		    if (r.type == 'parens') {
		        var ex = r;
		        var pr = "(" + nodeToString(ex.expr) + ")";
		        if (ex.arr) {
		            pr += "[]";
		        }
		        return pr;
		    }
		    if (r.type == 'name') {
		        var l = r;
		        var val = l.value;
		        var pr = val;
		        if (l.arr) {
		            pr += "[]";
		        }
		        return pr;
		    }
		}
		exports.nodeToString = nodeToString;
		function validateNode(r, node, cb) {
		    if (r.type == "union") {
		        var u = r;
		        validateNode(u.first, node, cb);
		        validateNode(u.rest, node, cb);
		    }
		    if (r.type == "responses") {
		        var res = r;
		        res.codes.forEach(function (x) {
		            var v = x.code;
		            for (var i = 0; i < v.length; i++) {
		                var c = v[i];
		                if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x', 'X'], function (x) { return x == c; })) {
		                    cb.accept(linter.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Status code should be 3 digits number with optional 'x' as wildcards", node));
		                    return;
		                }
		            }
		            validateNode(x.expr, node, cb);
		        });
		    }
		    if (r.type == 'parens') {
		        var ex = r;
		        validateNode(ex.expr, node, cb);
		    }
		    if (r.type == 'name') {
		        var l = r;
		        var val = l.value;
		        if (val.lastIndexOf("[]") != -1) {
		            val = val.substr(0, val.length - 2); //FIXME Should be in PEG
		        }
		        var pr = node.property();
		        if (pr.getAdapter(services.RAMLPropertyService).isValidValue(val, node.parent())) {
		            return;
		        }
		        var values = pr.getAdapter(services.RAMLPropertyService).enumValues(node.parent());
		        values = values.map(function (x) {
		            var tp = x.indexOf("<");
		            if (tp != -1) {
		                return x.substring(0, tp);
		            }
		            return x;
		        });
		        if (l.params) {
		            l.params.forEach(function (x) {
		                validateNode(x, node, cb);
		            });
		        }
		        values.push("number");
		        values.push("integer");
		        values.push("file");
		        values.push("boolean");
		        values.push("any");
		        values.push("date");
		        values.push("void");
		        values.push("string");
		        values.push("value");
		        if (!_.find(values, function (x) { return x == val; })) {
		            var message = "Unrecognized type '" + val + "'.";
		            cb.accept(linter.createIssue(0 /* UNRESOLVED_REFERENCE */, message, node));
		            return true;
		        }
		    }
		}
		exports.validateNode = validateNode;


	/***/ },
	/* 52 */
	/***/ function(module, exports) {

		var parser = (function () {
		    "use strict";
		    /*
		     * Generated by PEG.js 0.9.0.
		     *
		     * http://pegjs.org/
		     */
		    function peg$subclass(child, parent) {
		        function ctor() {
		            this.constructor = child;
		        }
		        ctor.prototype = parent.prototype;
		        child.prototype = new ctor();
		    }
		    function peg$SyntaxError(message, expected, found, location) {
		        this.message = message;
		        this.expected = expected;
		        this.found = found;
		        this.location = location;
		        this.name = "SyntaxError";
		        if (typeof Error.captureStackTrace === "function") {
		            Error.captureStackTrace(this, peg$SyntaxError);
		        }
		    }
		    peg$subclass(peg$SyntaxError, Error);
		    function peg$parse(input) {
		        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { Term: peg$parseTerm }, peg$startRuleFunction = peg$parseTerm, peg$c0 = "|", peg$c1 = { type: "literal", value: "|", description: "\"|\"" }, peg$c2 = function (first, rest) {
		            return rest ? { "type": "union", "first": first, "rest": rest[3] } : first;
		        }, peg$c3 = "(", peg$c4 = { type: "literal", value: "(", description: "\"(\"" }, peg$c5 = ")", peg$c6 = { type: "literal", value: ")", description: "\")\"" }, peg$c7 = "[]", peg$c8 = { type: "literal", value: "[]", description: "\"[]\"" }, peg$c9 = function (expr, arr) {
		            return { "type": "parens", "expr": expr, "arr": arr.length };
		        }, peg$c10 = "<", peg$c11 = { type: "literal", value: "<", description: "\"<\"" }, peg$c12 = ">", peg$c13 = { type: "literal", value: ">", description: "\">\"" }, peg$c14 = function (first, other) {
		            return [first].concat(other);
		        }, peg$c15 = ",", peg$c16 = { type: "literal", value: ",", description: "\",\"" }, peg$c17 = function (r) {
		            return r;
		        }, peg$c18 = { type: "other", description: "name" }, peg$c19 = function (r, tp, c) {
		            return { "type": "name", "params": tp, "value": r.join(""), "arr": (c.length) };
		        }, peg$c20 = { type: "other", description: "whitespace" }, peg$c21 = /^[ \t\n\r]/, peg$c22 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, peg$c23 = /^[A-Z]/, peg$c24 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c25 = "_", peg$c26 = { type: "literal", value: "_", description: "\"_\"" }, peg$c27 = "-", peg$c28 = { type: "literal", value: "-", description: "\"-\"" }, peg$c29 = ".", peg$c30 = { type: "literal", value: ".", description: "\".\"" }, peg$c31 = /^[a-z]/, peg$c32 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c33 = /^[0-9]/, peg$c34 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
		        if ("startRule" in options) {
		            if (!(options.startRule in peg$startRuleFunctions)) {
		                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
		            }
		            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		        }
		        function text() {
		            return input.substring(peg$savedPos, peg$currPos);
		        }
		        function location() {
		            return peg$computeLocation(peg$savedPos, peg$currPos);
		        }
		        function expected(description) {
		            throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
		        }
		        function error(message) {
		            throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
		        }
		        function peg$computePosDetails(pos) {
		            var details = peg$posDetailsCache[pos], p, ch;
		            if (details) {
		                return details;
		            }
		            else {
		                p = pos - 1;
		                while (!peg$posDetailsCache[p]) {
		                    p--;
		                }
		                details = peg$posDetailsCache[p];
		                details = {
		                    line: details.line,
		                    column: details.column,
		                    seenCR: details.seenCR
		                };
		                while (p < pos) {
		                    ch = input.charAt(p);
		                    if (ch === "\n") {
		                        if (!details.seenCR) {
		                            details.line++;
		                        }
		                        details.column = 1;
		                        details.seenCR = false;
		                    }
		                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
		                        details.line++;
		                        details.column = 1;
		                        details.seenCR = true;
		                    }
		                    else {
		                        details.column++;
		                        details.seenCR = false;
		                    }
		                    p++;
		                }
		                peg$posDetailsCache[pos] = details;
		                return details;
		            }
		        }
		        function peg$computeLocation(startPos, endPos) {
		            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
		            return {
		                start: {
		                    offset: startPos,
		                    line: startPosDetails.line,
		                    column: startPosDetails.column
		                },
		                end: {
		                    offset: endPos,
		                    line: endPosDetails.line,
		                    column: endPosDetails.column
		                }
		            };
		        }
		        function peg$fail(expected) {
		            if (peg$currPos < peg$maxFailPos) {
		                return;
		            }
		            if (peg$currPos > peg$maxFailPos) {
		                peg$maxFailPos = peg$currPos;
		                peg$maxFailExpected = [];
		            }
		            peg$maxFailExpected.push(expected);
		        }
		        function peg$buildException(message, expected, found, location) {
		            function cleanupExpected(expected) {
		                var i = 1;
		                expected.sort(function (a, b) {
		                    if (a.description < b.description) {
		                        return -1;
		                    }
		                    else if (a.description > b.description) {
		                        return 1;
		                    }
		                    else {
		                        return 0;
		                    }
		                });
		                while (i < expected.length) {
		                    if (expected[i - 1] === expected[i]) {
		                        expected.splice(i, 1);
		                    }
		                    else {
		                        i++;
		                    }
		                }
		            }
		            function buildMessage(expected, found) {
		                function stringEscape(s) {
		                    function hex(ch) {
		                        return ch.charCodeAt(0).toString(16).toUpperCase();
		                    }
		                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
		                        return '\\x0' + hex(ch);
		                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
		                        return '\\x' + hex(ch);
		                    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
		                        return '\\u0' + hex(ch);
		                    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
		                        return '\\u' + hex(ch);
		                    });
		                }
		                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
		                for (i = 0; i < expected.length; i++) {
		                    expectedDescs[i] = expected[i].description;
		                }
		                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
		                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
		                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
		            }
		            if (expected !== null) {
		                cleanupExpected(expected);
		            }
		            return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
		        }
		        function peg$parseTerm() {
		            var s0, s1, s2, s3, s4, s5, s6, s7;
		            s0 = peg$currPos;
		            s1 = peg$parse_();
		            if (s1 !== peg$FAILED) {
		                s2 = peg$parseFactor();
		                if (s2 !== peg$FAILED) {
		                    s3 = peg$currPos;
		                    s4 = peg$parse_();
		                    if (s4 !== peg$FAILED) {
		                        if (input.charCodeAt(peg$currPos) === 124) {
		                            s5 = peg$c0;
		                            peg$currPos++;
		                        }
		                        else {
		                            s5 = peg$FAILED;
		                            if (peg$silentFails === 0) {
		                                peg$fail(peg$c1);
		                            }
		                        }
		                        if (s5 !== peg$FAILED) {
		                            s6 = peg$parse_();
		                            if (s6 !== peg$FAILED) {
		                                s7 = peg$parseTerm();
		                                if (s7 !== peg$FAILED) {
		                                    s4 = [s4, s5, s6, s7];
		                                    s3 = s4;
		                                }
		                                else {
		                                    peg$currPos = s3;
		                                    s3 = peg$FAILED;
		                                }
		                            }
		                            else {
		                                peg$currPos = s3;
		                                s3 = peg$FAILED;
		                            }
		                        }
		                        else {
		                            peg$currPos = s3;
		                            s3 = peg$FAILED;
		                        }
		                    }
		                    else {
		                        peg$currPos = s3;
		                        s3 = peg$FAILED;
		                    }
		                    if (s3 === peg$FAILED) {
		                        s3 = null;
		                    }
		                    if (s3 !== peg$FAILED) {
		                        peg$savedPos = s0;
		                        s1 = peg$c2(s2, s3);
		                        s0 = s1;
		                    }
		                    else {
		                        peg$currPos = s0;
		                        s0 = peg$FAILED;
		                    }
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$FAILED;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$FAILED;
		            }
		            return s0;
		        }
		        function peg$parseFactor() {
		            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
		            s0 = peg$currPos;
		            if (input.charCodeAt(peg$currPos) === 40) {
		                s1 = peg$c3;
		                peg$currPos++;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c4);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                s2 = peg$parse_();
		                if (s2 !== peg$FAILED) {
		                    s3 = peg$parseTerm();
		                    if (s3 !== peg$FAILED) {
		                        s4 = peg$parse_();
		                        if (s4 !== peg$FAILED) {
		                            if (input.charCodeAt(peg$currPos) === 41) {
		                                s5 = peg$c5;
		                                peg$currPos++;
		                            }
		                            else {
		                                s5 = peg$FAILED;
		                                if (peg$silentFails === 0) {
		                                    peg$fail(peg$c6);
		                                }
		                            }
		                            if (s5 !== peg$FAILED) {
		                                s6 = [];
		                                s7 = peg$currPos;
		                                s8 = peg$parse_();
		                                if (s8 !== peg$FAILED) {
		                                    if (input.substr(peg$currPos, 2) === peg$c7) {
		                                        s9 = peg$c7;
		                                        peg$currPos += 2;
		                                    }
		                                    else {
		                                        s9 = peg$FAILED;
		                                        if (peg$silentFails === 0) {
		                                            peg$fail(peg$c8);
		                                        }
		                                    }
		                                    if (s9 !== peg$FAILED) {
		                                        s8 = [s8, s9];
		                                        s7 = s8;
		                                    }
		                                    else {
		                                        peg$currPos = s7;
		                                        s7 = peg$FAILED;
		                                    }
		                                }
		                                else {
		                                    peg$currPos = s7;
		                                    s7 = peg$FAILED;
		                                }
		                                while (s7 !== peg$FAILED) {
		                                    s6.push(s7);
		                                    s7 = peg$currPos;
		                                    s8 = peg$parse_();
		                                    if (s8 !== peg$FAILED) {
		                                        if (input.substr(peg$currPos, 2) === peg$c7) {
		                                            s9 = peg$c7;
		                                            peg$currPos += 2;
		                                        }
		                                        else {
		                                            s9 = peg$FAILED;
		                                            if (peg$silentFails === 0) {
		                                                peg$fail(peg$c8);
		                                            }
		                                        }
		                                        if (s9 !== peg$FAILED) {
		                                            s8 = [s8, s9];
		                                            s7 = s8;
		                                        }
		                                        else {
		                                            peg$currPos = s7;
		                                            s7 = peg$FAILED;
		                                        }
		                                    }
		                                    else {
		                                        peg$currPos = s7;
		                                        s7 = peg$FAILED;
		                                    }
		                                }
		                                if (s6 !== peg$FAILED) {
		                                    peg$savedPos = s0;
		                                    s1 = peg$c9(s3, s6);
		                                    s0 = s1;
		                                }
		                                else {
		                                    peg$currPos = s0;
		                                    s0 = peg$FAILED;
		                                }
		                            }
		                            else {
		                                peg$currPos = s0;
		                                s0 = peg$FAILED;
		                            }
		                        }
		                        else {
		                            peg$currPos = s0;
		                            s0 = peg$FAILED;
		                        }
		                    }
		                    else {
		                        peg$currPos = s0;
		                        s0 = peg$FAILED;
		                    }
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$FAILED;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$FAILED;
		            }
		            if (s0 === peg$FAILED) {
		                s0 = peg$parseLiteral();
		            }
		            return s0;
		        }
		        function peg$parseTypeParams() {
		            var s0, s1, s2, s3, s4;
		            s0 = peg$currPos;
		            if (input.charCodeAt(peg$currPos) === 60) {
		                s1 = peg$c10;
		                peg$currPos++;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c11);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                s2 = peg$parseTerm();
		                if (s2 !== peg$FAILED) {
		                    s3 = [];
		                    s4 = peg$parseExtraParam();
		                    while (s4 !== peg$FAILED) {
		                        s3.push(s4);
		                        s4 = peg$parseExtraParam();
		                    }
		                    if (s3 !== peg$FAILED) {
		                        if (input.charCodeAt(peg$currPos) === 62) {
		                            s4 = peg$c12;
		                            peg$currPos++;
		                        }
		                        else {
		                            s4 = peg$FAILED;
		                            if (peg$silentFails === 0) {
		                                peg$fail(peg$c13);
		                            }
		                        }
		                        if (s4 !== peg$FAILED) {
		                            peg$savedPos = s0;
		                            s1 = peg$c14(s2, s3);
		                            s0 = s1;
		                        }
		                        else {
		                            peg$currPos = s0;
		                            s0 = peg$FAILED;
		                        }
		                    }
		                    else {
		                        peg$currPos = s0;
		                        s0 = peg$FAILED;
		                    }
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$FAILED;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$FAILED;
		            }
		            return s0;
		        }
		        function peg$parseExtraParam() {
		            var s0, s1, s2;
		            s0 = peg$currPos;
		            if (input.charCodeAt(peg$currPos) === 44) {
		                s1 = peg$c15;
		                peg$currPos++;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c16);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                s2 = peg$parseTerm();
		                if (s2 !== peg$FAILED) {
		                    peg$savedPos = s0;
		                    s1 = peg$c17(s2);
		                    s0 = s1;
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$FAILED;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$FAILED;
		            }
		            return s0;
		        }
		        function peg$parseLiteral() {
		            var s0, s1, s2, s3, s4, s5, s6;
		            peg$silentFails++;
		            s0 = peg$currPos;
		            s1 = [];
		            s2 = peg$parsechar();
		            if (s2 !== peg$FAILED) {
		                while (s2 !== peg$FAILED) {
		                    s1.push(s2);
		                    s2 = peg$parsechar();
		                }
		            }
		            else {
		                s1 = peg$FAILED;
		            }
		            if (s1 !== peg$FAILED) {
		                s2 = peg$parseTypeParams();
		                if (s2 === peg$FAILED) {
		                    s2 = null;
		                }
		                if (s2 !== peg$FAILED) {
		                    s3 = [];
		                    s4 = peg$currPos;
		                    s5 = peg$parse_();
		                    if (s5 !== peg$FAILED) {
		                        if (input.substr(peg$currPos, 2) === peg$c7) {
		                            s6 = peg$c7;
		                            peg$currPos += 2;
		                        }
		                        else {
		                            s6 = peg$FAILED;
		                            if (peg$silentFails === 0) {
		                                peg$fail(peg$c8);
		                            }
		                        }
		                        if (s6 !== peg$FAILED) {
		                            s5 = [s5, s6];
		                            s4 = s5;
		                        }
		                        else {
		                            peg$currPos = s4;
		                            s4 = peg$FAILED;
		                        }
		                    }
		                    else {
		                        peg$currPos = s4;
		                        s4 = peg$FAILED;
		                    }
		                    while (s4 !== peg$FAILED) {
		                        s3.push(s4);
		                        s4 = peg$currPos;
		                        s5 = peg$parse_();
		                        if (s5 !== peg$FAILED) {
		                            if (input.substr(peg$currPos, 2) === peg$c7) {
		                                s6 = peg$c7;
		                                peg$currPos += 2;
		                            }
		                            else {
		                                s6 = peg$FAILED;
		                                if (peg$silentFails === 0) {
		                                    peg$fail(peg$c8);
		                                }
		                            }
		                            if (s6 !== peg$FAILED) {
		                                s5 = [s5, s6];
		                                s4 = s5;
		                            }
		                            else {
		                                peg$currPos = s4;
		                                s4 = peg$FAILED;
		                            }
		                        }
		                        else {
		                            peg$currPos = s4;
		                            s4 = peg$FAILED;
		                        }
		                    }
		                    if (s3 !== peg$FAILED) {
		                        peg$savedPos = s0;
		                        s1 = peg$c19(s1, s2, s3);
		                        s0 = s1;
		                    }
		                    else {
		                        peg$currPos = s0;
		                        s0 = peg$FAILED;
		                    }
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$FAILED;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$FAILED;
		            }
		            peg$silentFails--;
		            if (s0 === peg$FAILED) {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c18);
		                }
		            }
		            return s0;
		        }
		        function peg$parse_() {
		            var s0, s1;
		            peg$silentFails++;
		            s0 = [];
		            if (peg$c21.test(input.charAt(peg$currPos))) {
		                s1 = input.charAt(peg$currPos);
		                peg$currPos++;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c22);
		                }
		            }
		            while (s1 !== peg$FAILED) {
		                s0.push(s1);
		                if (peg$c21.test(input.charAt(peg$currPos))) {
		                    s1 = input.charAt(peg$currPos);
		                    peg$currPos++;
		                }
		                else {
		                    s1 = peg$FAILED;
		                    if (peg$silentFails === 0) {
		                        peg$fail(peg$c22);
		                    }
		                }
		            }
		            peg$silentFails--;
		            if (s0 === peg$FAILED) {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c20);
		                }
		            }
		            return s0;
		        }
		        function peg$parsechar() {
		            var s0;
		            if (peg$c23.test(input.charAt(peg$currPos))) {
		                s0 = input.charAt(peg$currPos);
		                peg$currPos++;
		            }
		            else {
		                s0 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c24);
		                }
		            }
		            if (s0 === peg$FAILED) {
		                if (input.charCodeAt(peg$currPos) === 95) {
		                    s0 = peg$c25;
		                    peg$currPos++;
		                }
		                else {
		                    s0 = peg$FAILED;
		                    if (peg$silentFails === 0) {
		                        peg$fail(peg$c26);
		                    }
		                }
		                if (s0 === peg$FAILED) {
		                    if (input.charCodeAt(peg$currPos) === 45) {
		                        s0 = peg$c27;
		                        peg$currPos++;
		                    }
		                    else {
		                        s0 = peg$FAILED;
		                        if (peg$silentFails === 0) {
		                            peg$fail(peg$c28);
		                        }
		                    }
		                    if (s0 === peg$FAILED) {
		                        if (input.charCodeAt(peg$currPos) === 46) {
		                            s0 = peg$c29;
		                            peg$currPos++;
		                        }
		                        else {
		                            s0 = peg$FAILED;
		                            if (peg$silentFails === 0) {
		                                peg$fail(peg$c30);
		                            }
		                        }
		                        if (s0 === peg$FAILED) {
		                            if (peg$c31.test(input.charAt(peg$currPos))) {
		                                s0 = input.charAt(peg$currPos);
		                                peg$currPos++;
		                            }
		                            else {
		                                s0 = peg$FAILED;
		                                if (peg$silentFails === 0) {
		                                    peg$fail(peg$c32);
		                                }
		                            }
		                            if (s0 === peg$FAILED) {
		                                if (peg$c33.test(input.charAt(peg$currPos))) {
		                                    s0 = input.charAt(peg$currPos);
		                                    peg$currPos++;
		                                }
		                                else {
		                                    s0 = peg$FAILED;
		                                    if (peg$silentFails === 0) {
		                                        peg$fail(peg$c34);
		                                    }
		                                }
		                            }
		                        }
		                    }
		                }
		            }
		            return s0;
		        }
		        peg$result = peg$startRuleFunction();
		        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		            return peg$result;
		        }
		        else {
		            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
		                peg$fail({ type: "end", description: "end of input" });
		            }
		            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
		        }
		    }
		    return {
		        SyntaxError: peg$SyntaxError,
		        parse: peg$parse
		    };
		})();
		module.exports = parser;


	/***/ },
	/* 53 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var defs = __webpack_require__(3);
		var hl = __webpack_require__(2);
		var _ = __webpack_require__(4);
		var typeExpression = __webpack_require__(51);
		var hlimpl = __webpack_require__(5);
		var universes = __webpack_require__(54);
		var typeBuilder = __webpack_require__(50);
		var ramlServices = __webpack_require__(49);
		//FIXME CORRECTLY STRUCTURE IT
		function resolveRamlPointer(point, path) {
		    var components = path.split(".");
		    var currentNode = point;
		    if (currentNode.definition().getAdapter(ramlServices.RAMLService).isAnnotation()) {
		        currentNode = currentNode.parent();
		    }
		    components.forEach(function (x) {
		        if (currentNode == null) {
		            return;
		        }
		        if (x == '$parent') {
		            currentNode = currentNode.parent();
		            return;
		        }
		        if (x == '$root') {
		            currentNode = currentNode.root();
		            return;
		        }
		        if (x == '$top') {
		            currentNode = exports.declRoot(currentNode);
		            return;
		        }
		        var newEl = _.find(currentNode.elements(), function (y) { return y.name() == x; });
		        currentNode = newEl;
		    });
		    return currentNode;
		}
		exports.resolveRamlPointer = resolveRamlPointer;
		exports.declRoot = function (h) {
		    var declRoot = h;
		    while (true) {
		        if (declRoot.definition().key() == universes.Universe10.Library) {
		            break;
		        }
		        var np = declRoot.parent();
		        if (!np) {
		            break;
		        }
		        declRoot = np;
		    }
		    return declRoot;
		};
		function globalDeclarations(h) {
		    var decl = exports.declRoot(h);
		    return findDeclarations(decl);
		}
		exports.globalDeclarations = globalDeclarations;
		function mark(h, rs) {
		    var n = h.lowLevel();
		    n = n._node ? n._node : n;
		    if (n['mark']) {
		        return rs;
		    }
		    n['mark'] = rs;
		    return null;
		}
		function unmark(h) {
		    var n = h.lowLevel();
		    n = n._node ? n._node : n;
		    delete n['mark'];
		}
		function findDeclarations(h) {
		    var rs = [];
		    var q = mark(h, rs);
		    if (q) {
		    }
		    try {
		        h.elements().forEach(function (x) {
		            if (x.definition().key() == universes.Universe10.Library) {
		                rs = rs.concat(findDeclarations(x));
		            }
		            rs.push(x);
		        });
		        return rs;
		    }
		    finally {
		        unmark(h);
		    }
		}
		exports.findDeclarations = findDeclarations;
		function getIndent2(offset, text) {
		    var spaces = "";
		    for (var i = offset - 1; i >= 0; i--) {
		        var c = text.charAt(i);
		        if (c == ' ' || c == '\t') {
		            if (spaces) {
		                spaces += c;
		            }
		            else {
		                spaces = c;
		            }
		        }
		        else if (c == '\r' || c == '\n') {
		            return spaces;
		        }
		    }
		}
		function deepFindNode(n, offset, end, goToOtherUnits) {
		    if (goToOtherUnits === void 0) { goToOtherUnits = true; }
		    if (n == null) {
		        return null;
		    }
		    if (n.lowLevel()) {
		        //var node:ASTNode=<ASTNode>n;
		        if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
		            if (n instanceof hlimpl.ASTNodeImpl) {
		                var hn = n;
		                var all = goToOtherUnits ? hn.children() : hn.directChildren();
		                for (var i = 0; i < all.length; i++) {
		                    if (!goToOtherUnits && all[i].lowLevel().unit() != n.lowLevel().unit()) {
		                        continue;
		                    }
		                    var node = deepFindNode(all[i], offset, end, goToOtherUnits);
		                    if (node) {
		                        return node;
		                    }
		                }
		                return n;
		            }
		            if (n instanceof hlimpl.ASTPropImpl) {
		                var attr = n;
		                if (!attr.property().isKey()) {
		                    var vl = attr.value();
		                    if (vl instanceof hlimpl.StructuredValue) {
		                        var st = vl;
		                        var hl = st.toHighlevel();
		                        if (hl) {
		                            if (!goToOtherUnits && hl.lowLevel().unit() != n.lowLevel().unit()) {
		                                return null;
		                            }
		                        }
		                        var node = deepFindNode(hl, offset, end, goToOtherUnits);
		                        if (node) {
		                            return node;
		                        }
		                    }
		                    return attr;
		                }
		                return null;
		            }
		            return n;
		        }
		    }
		    return null;
		}
		function getValueAt(text, offset) {
		    var sp = -1;
		    for (var i = offset - 1; i >= 0; i--) {
		        var c = text.charAt(i);
		        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
		            sp = i + 1;
		            break;
		        }
		    }
		    var ep = -1;
		    for (var i = offset; i < text.length; i++) {
		        var c = text.charAt(i);
		        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
		            ep = i;
		            break;
		        }
		    }
		    if (sp != -1 && ep != -1) {
		        return text.substring(sp, ep);
		    }
		    return "";
		}
		function extractName(cleaned, offset) {
		    var txt = "";
		    for (var i = offset; i >= 0; i--) {
		        var c = cleaned[i];
		        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
		            break;
		        }
		        txt = c + txt;
		    }
		    for (var i = offset + 1; i < cleaned.length; i++) {
		        var c = cleaned[i];
		        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
		            break;
		        }
		        txt = txt + c;
		    }
		    return txt;
		}
		exports.extractName = extractName;
		var searchInTheValue = function (offset, content, attr, hlnode, p) {
		    if (p === void 0) { p = attr.property(); }
		    var targets = p.getAdapter(ramlServices.RAMLPropertyService).referenceTargets(hlnode);
		    var txt = extractName(content, offset);
		    var t = _.find(targets, function (x) { return hlimpl.qName(x, hlnode) == txt; });
		    if (t) {
		        //TODO EXTRACT COMMON OPEN NODE FUNC
		        return t;
		    }
		    if (attr.property() instanceof defs.UserDefinedProp) {
		        var up = attr.property();
		        return up._node;
		    }
		    return null;
		};
		function findUsages(unit, offset) {
		    var decl = findDeclaration(unit, offset);
		    if (decl) {
		        if (decl instanceof hlimpl.ASTNodeImpl) {
		            var hnode = decl;
		            return { node: hnode, results: hnode.findReferences() };
		        }
		        if (decl instanceof hlimpl.ASTPropImpl) {
		        }
		    }
		    var node = deepFindNode(hl.fromUnit(unit), offset, offset, false);
		    if (node instanceof hlimpl.ASTNodeImpl) {
		        return { node: node, results: node.findReferences() };
		    }
		    if (node instanceof hlimpl.ASTPropImpl) {
		        var prop = node;
		        if (prop.property().canBeValue()) {
		            return { node: prop.parent(), results: prop.parent().findReferences() };
		        }
		    }
		    return { node: null, results: [] };
		}
		exports.findUsages = findUsages;
		function findDeclaration(unit, offset) {
		    var node = deepFindNode(hl.fromUnit(unit), offset, offset, false);
		    var kind = determineCompletionKind(unit.contents(), offset);
		    if (kind == 0 /* VALUE_COMPLETION */) {
		        var hlnode = node;
		        if (node instanceof hlimpl.ASTPropImpl) {
		            var attr = node;
		            if (attr) {
		                if (attr.value()) {
		                    if (attr.value() instanceof hlimpl.StructuredValue) {
		                        var sval = attr.value();
		                        var hlvalue = sval.toHighlevel();
		                        if (hlvalue) {
		                            var newAttr = _.find(hlvalue.attrs(), function (x) { return x.lowLevel().start() < offset && x.lowLevel().end() >= offset; });
		                            if (newAttr) {
		                                return searchInTheValue(offset, unit.contents(), newAttr, hlvalue, attr.property());
		                            }
		                        }
		                    }
		                    else {
		                        return searchInTheValue(offset, unit.contents(), attr, hlnode);
		                    }
		                }
		            }
		        }
		    }
		    if (kind == 1 /* KEY_COMPLETION */ || kind == 6 /* SEQUENCE_KEY_COPLETION */) {
		        var hlnode = node;
		        var pp = node.property();
		        if (pp instanceof defs.UserDefinedProp) {
		            var up = pp;
		            return up.node();
		        }
		        if (node instanceof hlimpl.ASTNodeImpl) {
		            if (hlnode.definition() instanceof defs.UserDefinedClass) {
		                var uc = hlnode.definition();
		                if (uc.isAssignableFrom("TypeDeclaration")) {
		                    return node;
		                }
		                return uc.getAdapter(ramlServices.RAMLService).getDeclaringNode();
		            }
		        }
		        if (node instanceof hlimpl.ASTPropImpl) {
		            var pr = node;
		            if (isExampleNodeContent(pr)) {
		                var contentType = findExampleContentType(pr);
		                if (contentType) {
		                    var documentationRoot = parseDocumentationContent(pr, contentType.getAdapter(ramlServices.RAMLService).toRuntime());
		                    if (documentationRoot) {
		                        var node = deepFindNode(documentationRoot, offset, offset);
		                        pp = node.property();
		                        if (pp instanceof defs.UserDefinedProp) {
		                            var up = pp;
		                            return up.node();
		                        }
		                        if (node instanceof hlimpl.ASTNodeImpl) {
		                            if (hlnode.definition() instanceof defs.UserDefinedClass) {
		                                var uc = hlnode.definition();
		                                return uc.getAdapter(ramlServices.RAMLService).getDeclaringNode();
		                            }
		                        }
		                    }
		                }
		            }
		        }
		    }
		    if (kind == 2 /* PATH_COMPLETION */) {
		        var inclpath = getValueAt(unit.contents(), offset);
		        if (inclpath) {
		            var ap = unit.resolve(inclpath);
		            return ap;
		        }
		    }
		}
		exports.findDeclaration = findDeclaration;
		function findExampleContentType(node) {
		    var p = node.parent();
		    if (node.property().nameId() == universes.Universe10.ExampleSpec.properties.content.name) {
		        p = p.parent();
		    }
		    return typeBuilder.typeFromNode(p);
		}
		exports.findExampleContentType = findExampleContentType;
		function parseDocumentationContent(attribute, type) {
		    if (!(attribute.value() instanceof hlimpl.StructuredValue)) {
		        return null;
		    }
		    return new hlimpl.ASTNodeImpl(attribute.value().lowLevel(), attribute.parent(), type, attribute.property());
		}
		exports.parseDocumentationContent = parseDocumentationContent;
		function isExampleNodeContent(node) {
		    if (!(node instanceof hlimpl.ASTPropImpl)) {
		        return false;
		    }
		    var property = node;
		    if (universes.Universe10.ExampleSpec.properties.content.name == property.name() && property.isString()) {
		        if (property.parent() instanceof hlimpl.ASTNodeImpl && (universes.Universe10.TypeDeclaration.properties.examples.name == property.parent().property().nameId() || universes.Universe10.TypeDeclaration.properties.example.name == property.parent().property().nameId())) {
		            if (property.parent().parent() instanceof hlimpl.ASTNodeImpl && property.parent().parent().definition().isAssignableFrom(universes.Universe10.ObjectTypeDeclaration.name)) {
		                return true;
		            }
		        }
		    }
		    else if (universes.Universe10.TypeDeclaration.properties.example.name == property.name() && property.isString()) {
		        if (property.parent() instanceof hlimpl.ASTNodeImpl && property.parent().definition().isAssignableFrom(universes.Universe10.ObjectTypeDeclaration.name)) {
		            return true;
		        }
		    }
		    return false;
		}
		exports.isExampleNodeContent = isExampleNodeContent;
		function determineCompletionKind(text, offset) {
		    var hasIn = false;
		    var hasSeq = false;
		    var canBeInComment = false;
		    var canBeAnnotation = false;
		    for (var i = offset - 1; i >= 0; i--) {
		        var c = text.charAt(i);
		        if (c == '(') {
		            canBeAnnotation = true;
		        }
		        else if (canBeAnnotation) {
		            if (c == '\r' || c == '\n') {
		                var hasClosing = false;
		                for (var j = offset - 1; j < text.length; j++) {
		                    var ch = text[j];
		                    if (ch == ')') {
		                        hasClosing = true;
		                    }
		                    if (ch == '\r' || ch == "\n") {
		                        break;
		                    }
		                    if (ch == ':') {
		                        canBeAnnotation = false;
		                        break;
		                    }
		                }
		                if (canBeAnnotation && hasClosing) {
		                    return 5 /* ANNOTATION_COMPLETION */;
		                }
		                else {
		                    break;
		                }
		            }
		            if (c == ' ' || c == '\t') {
		                continue;
		            }
		            else {
		                break;
		            }
		        }
		        else {
		            if (c == '\r' || c == '\n') {
		                break;
		            }
		            if (c == ':') {
		                break;
		            }
		        }
		    }
		    for (var i = offset - 1; i >= 0; i--) {
		        var c = text.charAt(i);
		        if (c == '#') {
		            if (i == 0) {
		                return 4 /* VERSION_COMPLETION */;
		            }
		            return 7 /* INCOMMENT */;
		        }
		        if (c == ':') {
		            if (hasIn) {
		                return 3 /* DIRECTIVE_COMPLETION */;
		            }
		            return 0 /* VALUE_COMPLETION */;
		        }
		        if (c == '\r' || c == '\n') {
		            //check for multiline literal
		            var insideOfMultiline = false;
		            var ind = getIndent2(offset, text);
		            for (var a = i; a > 0; a--) {
		                c = text.charAt(a);
		                //TODO this can be further improved
		                if (c == ':') {
		                    if (insideOfMultiline) {
		                        var ll = getIndent2(a, text);
		                        if (ll.length < ind.length) {
		                            return 0 /* VALUE_COMPLETION */;
		                        }
		                    }
		                    break;
		                }
		                if (c == '|') {
		                    insideOfMultiline = true;
		                    continue;
		                }
		                if (c == '\r' || c == '\n') {
		                    insideOfMultiline = false;
		                }
		                if (c != ' ' && c != '\t') {
		                    insideOfMultiline = false;
		                }
		            }
		            if (hasSeq) {
		                return 6 /* SEQUENCE_KEY_COPLETION */;
		            }
		            return 1 /* KEY_COMPLETION */;
		        }
		        if (c == '-') {
		            hasSeq = true;
		        }
		        if (c == '!') {
		            if (text.indexOf("!include", i) == i) {
		                return 2 /* PATH_COMPLETION */;
		            }
		            if (text.indexOf("!i", i) == i) {
		                hasIn = true;
		            }
		        }
		    }
		}
		exports.determineCompletionKind = determineCompletionKind;
		(function (LocationKind) {
		    LocationKind[LocationKind["VALUE_COMPLETION"] = 0] = "VALUE_COMPLETION";
		    LocationKind[LocationKind["KEY_COMPLETION"] = 1] = "KEY_COMPLETION";
		    LocationKind[LocationKind["PATH_COMPLETION"] = 2] = "PATH_COMPLETION";
		    LocationKind[LocationKind["DIRECTIVE_COMPLETION"] = 3] = "DIRECTIVE_COMPLETION";
		    LocationKind[LocationKind["VERSION_COMPLETION"] = 4] = "VERSION_COMPLETION";
		    LocationKind[LocationKind["ANNOTATION_COMPLETION"] = 5] = "ANNOTATION_COMPLETION";
		    LocationKind[LocationKind["SEQUENCE_KEY_COPLETION"] = 6] = "SEQUENCE_KEY_COPLETION";
		    LocationKind[LocationKind["INCOMMENT"] = 7] = "INCOMMENT";
		})(exports.LocationKind || (exports.LocationKind = {}));
		var LocationKind = exports.LocationKind;
		function resolveReference(point, path) {
		    if (!path) {
		        return null;
		    }
		    var sp = path.split("/");
		    var result = point;
		    for (var i = 0; i < sp.length; i++) {
		        if (sp[i] == '#') {
		            result = point.unit().ast();
		            continue;
		        }
		        result = _.find(result.children(), function (x) { return x.key() == sp[i]; });
		        if (!result) {
		            return null;
		        }
		    }
		    return result;
		}
		exports.resolveReference = resolveReference;
		/**
		 * return all sub types of given type visible from parent node
		 * @param range
		 * @param parentNode
		 * @returns ITypeDefinition[]
		 */
		exports.subTypesWithLocals = function (range, parentNode) {
		    if (range == null) {
		        return [];
		    }
		    var name = range.nameId();
		    parentNode = exports.declRoot(parentNode);
		    var actual = parentNode;
		    if (actual._subTypesCache) {
		        var cached = actual._subTypesCache[name];
		        if (cached) {
		            return cached;
		        }
		    }
		    else {
		        actual._subTypesCache = {};
		    }
		    var result = range.allSubTypes();
		    if (range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders().length > 0 && parentNode) {
		        var decls = globalDeclarations(parentNode);
		        var extenders = range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders();
		        var root = parentNode.root();
		        extenders.forEach(function (x) {
		            var definitionNodes = decls.filter(function (z) {
		                var def = z.definition().allSuperTypes();
		                def.push(z.definition());
		                var rr = (z.definition() == x) || (_.find(def, function (d) { return d == x; }) != null) || (_.find(def, function (d) { return d == range; }) != null);
		                return rr;
		            });
		            result = result.concat(definitionNodes.map(function (x) { return typeBuilder.typeFromNode(x); }));
		        });
		    }
		    result = _.unique(result);
		    actual._subTypesCache[name] = result;
		    return result;
		};
		exports.subTypesWithName = function (tname, parentNode, backup) {
		    parentNode = exports.declRoot(parentNode);
		    var decls = globalDeclarations(parentNode);
		    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() && (x.property().nameId() == universes.Universe10.LibraryBase.properties.types.name); });
		    var result = typeBuilder.typeFromNode(declNode);
		    return result;
		};
		exports.schemasWithName = function (tname, parentNode, backup) {
		    parentNode = exports.declRoot(parentNode);
		    var decls = globalDeclarations(parentNode);
		    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() && (x.property().nameId() == universes.Universe10.LibraryBase.properties.schemas.name); });
		    var result = typeBuilder.typeFromNode(declNode);
		    return result;
		};
		exports.nodesDeclaringType = function (range, n) {
		    var result = [];
		    var extenders = range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders();
		    if (extenders.length > 0 && n) {
		        var root = n;
		        extenders.forEach(function (x) {
		            var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition().isAssignableFrom(x.nameId()); });
		            result = result.concat(definitionNodes);
		        });
		    }
		    var isElementType = !range.isValueType();
		    if (isElementType && range.getAdapter(ramlServices.RAMLService).isInlinedTemplates() && n) {
		        var root = n;
		        //TODO I did not like it it might be written much better
		        var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition() == range; });
		        result = result.concat(definitionNodes);
		    }
		    else {
		        var root = n;
		        var q = {};
		        range.allSubTypes().forEach(function (x) { return q[x.nameId()] = true; });
		        q[range.nameId()] = true;
		        var definitionNodes = globalDeclarations(root).filter(function (z) { return q[z.definition().nameId()]; });
		        result = result.concat(definitionNodes);
		    }
		    return result;
		};
		function findAllSubTypes(p, n) {
		    var range = p.range();
		    return exports.subTypesWithLocals(range, n);
		}
		exports.findAllSubTypes = findAllSubTypes;
		;
		function possibleNodes(p, c) {
		    if (c) {
		        if (p.isDescriminator()) {
		            var range = p.range();
		            var extenders = range.getAdapter(ramlServices.RAMLService).getRuntimeExtenders();
		            if (extenders.length > 0 && c) {
		                var result = [];
		                extenders.forEach(function (x) {
		                    var definitionNodes = globalDeclarations(c).filter(function (z) { return z.definition() == x; });
		                    result = result.concat(definitionNodes);
		                });
		                return result;
		            }
		            return [];
		        }
		        if (p.isReference()) {
		            return exports.nodesDeclaringType(p.referencesTo(), c);
		        }
		        if (p.range().isValueType()) {
		            var vt = p.range().getAdapter(ramlServices.RAMLService);
		            if (vt.globallyDeclaredBy && vt.globallyDeclaredBy().length > 0) {
		                var definitionNodes = globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
		                return definitionNodes;
		            }
		        }
		    }
		    return this._enumOptions;
		}
		function allChildren(node) {
		    var res = [];
		    gather(node, res);
		    return res;
		}
		exports.allChildren = allChildren;
		function gather(node, result) {
		    node.children().forEach(function (x) {
		        result.push(x);
		        gather(x, result);
		    });
		}
		var testUsage = function (ck, x, node, result) {
		    if (ck instanceof defs.UserDefinedClass) {
		        var ud = ck;
		        if (node.isSameNode(ud.getAdapter(ramlServices.RAMLService).getDeclaringNode())) {
		            result.push(x);
		        }
		    }
		    if (ck instanceof defs.Array) {
		        var cmp = ck;
		        testUsage(cmp.component, x, node, result);
		    }
		    if (ck instanceof defs.Union) {
		        var uni = ck;
		        testUsage(uni.left, x, node, result);
		        testUsage(uni.right, x, node, result);
		    }
		};
		function refFinder(root, node, result) {
		    root.elements().forEach(function (x) {
		        refFinder(x, node, result);
		        //console.log(x.name())
		        var ck = x.definition();
		        //testUsage(ck, x, node, result);
		    });
		    root.attrs().forEach(function (a) {
		        var pr = a.property();
		        var vl = a.value();
		        //if (pr.isTypeExpr()){
		        //    typeExpression.
		        //}
		        if (pr instanceof defs.UserDefinedProp) {
		            var up = pr.node();
		            if (up == node) {
		                result.push(a);
		            }
		            else if (up.lowLevel().start() == node.lowLevel().start()) {
		                if (up.lowLevel().unit() == node.lowLevel().unit()) {
		                    result.push(a);
		                }
		            }
		        }
		        if (isExampleNodeContent(a)) {
		            var contentType = findExampleContentType(a);
		            if (contentType) {
		                var documentationRoot = parseDocumentationContent(a, contentType.getAdapter(ramlServices.RAMLService).toRuntime());
		                if (documentationRoot) {
		                    refFinder(documentationRoot, node, result);
		                }
		            }
		        }
		        else if (pr.getAdapter(ramlServices.RAMLPropertyService).isTypeExpr() && typeof vl == "string") {
		            var tpa = typeExpression.getType(root, "" + vl, {});
		            testUsage(tpa, a, node, result);
		            var libraryName = hl.getLibraryName(node);
		            if (libraryName && vl.indexOf(libraryName) != -1) {
		                var referencingLibrary = getLibraryDefiningNode(a);
		                if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
		                    result.push(a);
		                }
		            }
		        }
		        if (pr.isReference() || pr.isDescriminator()) {
		            if (typeof vl == 'string') {
		                var pn = possibleNodes(pr, root);
		                if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
		                    result.push(a);
		                }
		                var libraryName = hl.getLibraryName(node);
		                if (libraryName && vl.indexOf(libraryName) != -1) {
		                    var referencingLibrary = getLibraryDefiningNode(a);
		                    if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
		                        result.push(a);
		                    }
		                }
		            }
		            else {
		                var st = vl;
		                if (st) {
		                    var vn = st.valueName();
		                    var pn = possibleNodes(pr, root);
		                    if (_.find(pn, function (x) { return x.name() == vn && x == node; })) {
		                        result.push(a);
		                    }
		                    var hnode = st.toHighlevel();
		                    if (hnode) {
		                        refFinder(hnode, node, result);
		                    }
		                    var libraryName = hl.getLibraryName(node);
		                    if (libraryName && vn.indexOf(libraryName) != -1) {
		                        var referencingLibrary = getLibraryDefiningNode(vl);
		                        if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
		                            result.push(a);
		                        }
		                    }
		                }
		            }
		        }
		        else {
		            var pn = possibleNodes(pr, root);
		            if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
		                result.push(a);
		            }
		        }
		    });
		}
		exports.refFinder = refFinder;
		/**
		 * Returns library node that definition of the current node is located in, or null
		 * if current node is not defined in a library.
		 */
		function getLibraryDefiningNode(nodeToCheck) {
		    if (!nodeToCheck.lowLevel) {
		        return null;
		    }
		    var lowLevelNode = nodeToCheck.lowLevel();
		    if (!lowLevelNode) {
		        return null;
		    }
		    if (lowLevelNode.key()) {
		        var offset = Math.floor((lowLevelNode.keyEnd() + lowLevelNode.keyStart()) / 2);
		        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
		        if (result)
		            return result;
		    }
		    if (lowLevelNode.value()) {
		        var offset = Math.floor((lowLevelNode.valueEnd() + lowLevelNode.valueStart()) / 2);
		        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
		        if (result)
		            return result;
		    }
		    return null;
		}
		function getLibraryDefiningNodeByOffset(unit, offset) {
		    var declaration = findDeclaration(unit, offset);
		    if (declaration && hl.asNode(declaration)) {
		        var declarationNode = hl.asNode(declaration);
		        var parent = declarationNode;
		        while (parent) {
		            if (parent.definition().key() == universes.Universe10.Library) {
		                return parent;
		            }
		            parent = parent.parent();
		        }
		    }
		    return null;
		}


	/***/ },
	/* 54 */
	/***/ function(module, exports) {

		var Universes = {
		    "Universe08": {
		        "GlobalSchema": {
		            "name": "GlobalSchema",
		            "properties": {
		                "key": {
		                    "name": "key"
		                },
		                "value": {
		                    "name": "value"
		                }
		            }
		        },
		        "Api": {
		            "name": "Api",
		            "properties": {
		                "title": {
		                    "name": "title"
		                },
		                "version": {
		                    "name": "version"
		                },
		                "baseUri": {
		                    "name": "baseUri"
		                },
		                "baseUriParameters": {
		                    "name": "baseUriParameters"
		                },
		                "uriParameters": {
		                    "name": "uriParameters"
		                },
		                "protocols": {
		                    "name": "protocols"
		                },
		                "mediaType": {
		                    "name": "mediaType"
		                },
		                "schemas": {
		                    "name": "schemas"
		                },
		                "traits": {
		                    "name": "traits"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                },
		                "securitySchemes": {
		                    "name": "securitySchemes"
		                },
		                "resourceTypes": {
		                    "name": "resourceTypes"
		                },
		                "resources": {
		                    "name": "resources"
		                },
		                "documentation": {
		                    "name": "documentation"
		                }
		            }
		        },
		        "DocumentationItem": {
		            "name": "DocumentationItem",
		            "properties": {
		                "title": {
		                    "name": "title"
		                },
		                "content": {
		                    "name": "content"
		                }
		            }
		        },
		        "ValueType": {
		            "name": "ValueType",
		            "properties": {}
		        },
		        "StringType": {
		            "name": "StringType",
		            "properties": {}
		        },
		        "NumberType": {
		            "name": "NumberType",
		            "properties": {}
		        },
		        "BooleanType": {
		            "name": "BooleanType",
		            "properties": {}
		        },
		        "Referencable": {
		            "name": "Referencable",
		            "properties": {}
		        },
		        "Reference": {
		            "name": "Reference",
		            "properties": {}
		        },
		        "DeclaresDynamicType": {
		            "name": "DeclaresDynamicType",
		            "properties": {}
		        },
		        "UriTemplate": {
		            "name": "UriTemplate",
		            "properties": {}
		        },
		        "RelativeUriString": {
		            "name": "RelativeUriString",
		            "properties": {}
		        },
		        "FullUriTemplateString": {
		            "name": "FullUriTemplateString",
		            "properties": {}
		        },
		        "FixedUri": {
		            "name": "FixedUri",
		            "properties": {}
		        },
		        "MarkdownString": {
		            "name": "MarkdownString",
		            "properties": {}
		        },
		        "SchemaString": {
		            "name": "SchemaString",
		            "properties": {}
		        },
		        "JSonSchemaString": {
		            "name": "JSonSchemaString",
		            "properties": {}
		        },
		        "XMLSchemaString": {
		            "name": "XMLSchemaString",
		            "properties": {}
		        },
		        "ExampleString": {
		            "name": "ExampleString",
		            "properties": {}
		        },
		        "StatusCodeString": {
		            "name": "StatusCodeString",
		            "properties": {}
		        },
		        "JSONExample": {
		            "name": "JSONExample",
		            "properties": {}
		        },
		        "XMLExample": {
		            "name": "XMLExample",
		            "properties": {}
		        },
		        "ResourceTypeRef": {
		            "name": "ResourceTypeRef",
		            "properties": {}
		        },
		        "TraitRef": {
		            "name": "TraitRef",
		            "properties": {}
		        },
		        "SecuritySchemaPart": {
		            "name": "SecuritySchemaPart",
		            "properties": {}
		        },
		        "SecuritySchemaSettings": {
		            "name": "SecuritySchemaSettings",
		            "properties": {}
		        },
		        "OAuth1SecuritySchemeSettings": {
		            "name": "OAuth1SecuritySchemeSettings",
		            "properties": {
		                "requestTokenUri": {
		                    "name": "requestTokenUri"
		                },
		                "authorizationUri": {
		                    "name": "authorizationUri"
		                },
		                "tokenCredentialsUri": {
		                    "name": "tokenCredentialsUri"
		                }
		            }
		        },
		        "OAuth2SecuritySchemeSettings": {
		            "name": "OAuth2SecuritySchemeSettings",
		            "properties": {
		                "accessTokenUri": {
		                    "name": "accessTokenUri"
		                },
		                "authorizationUri": {
		                    "name": "authorizationUri"
		                },
		                "authorizationGrants": {
		                    "name": "authorizationGrants"
		                },
		                "scopes": {
		                    "name": "scopes"
		                }
		            }
		        },
		        "SecuritySchemaRef": {
		            "name": "SecuritySchemaRef",
		            "properties": {}
		        },
		        "SecuritySchema": {
		            "name": "SecuritySchema",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "describedBy": {
		                    "name": "describedBy"
		                },
		                "settings": {
		                    "name": "settings"
		                }
		            }
		        },
		        "MethodBase": {
		            "name": "MethodBase",
		            "properties": {
		                "responses": {
		                    "name": "responses"
		                },
		                "body": {
		                    "name": "body"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                }
		            }
		        },
		        "Trait": {
		            "name": "Trait",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "usage": {
		                    "name": "usage"
		                }
		            }
		        },
		        "ResourceType": {
		            "name": "ResourceType",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "usage": {
		                    "name": "usage"
		                },
		                "methods": {
		                    "name": "methods"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                },
		                "uriParameters": {
		                    "name": "uriParameters"
		                }
		            }
		        },
		        "Method": {
		            "name": "Method",
		            "properties": {
		                "method": {
		                    "name": "method"
		                },
		                "protocols": {
		                    "name": "protocols"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                }
		            }
		        },
		        "Resource": {
		            "name": "Resource",
		            "properties": {
		                "relativeUri": {
		                    "name": "relativeUri"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                },
		                "uriParameters": {
		                    "name": "uriParameters"
		                },
		                "methods": {
		                    "name": "methods"
		                },
		                "resources": {
		                    "name": "resources"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "baseUriParameters": {
		                    "name": "baseUriParameters"
		                }
		            }
		        },
		        "Parameter": {
		            "name": "Parameter",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "location": {
		                    "name": "location"
		                },
		                "required": {
		                    "name": "required"
		                },
		                "default": {
		                    "name": "default"
		                },
		                "example": {
		                    "name": "example"
		                },
		                "repeat": {
		                    "name": "repeat"
		                }
		            }
		        },
		        "StringTypeDeclaration": {
		            "name": "StringTypeDeclaration",
		            "properties": {
		                "pattern": {
		                    "name": "pattern"
		                },
		                "enum": {
		                    "name": "enum"
		                },
		                "minLength": {
		                    "name": "minLength"
		                },
		                "maxLength": {
		                    "name": "maxLength"
		                }
		            }
		        },
		        "BooleanTypeDeclaration": {
		            "name": "BooleanTypeDeclaration",
		            "properties": {}
		        },
		        "NumberTypeDeclaration": {
		            "name": "NumberTypeDeclaration",
		            "properties": {
		                "minimum": {
		                    "name": "minimum"
		                },
		                "maximum": {
		                    "name": "maximum"
		                }
		            }
		        },
		        "IntegerTypeDeclaration": {
		            "name": "IntegerTypeDeclaration",
		            "properties": {}
		        },
		        "DateTypeDeclaration": {
		            "name": "DateTypeDeclaration",
		            "properties": {}
		        },
		        "FileTypeDeclaration": {
		            "name": "FileTypeDeclaration",
		            "properties": {}
		        },
		        "HasNormalParameters": {
		            "name": "HasNormalParameters",
		            "properties": {
		                "queryParameters": {
		                    "name": "queryParameters"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "headers": {
		                    "name": "headers"
		                }
		            }
		        },
		        "ParameterLocation": {
		            "name": "ParameterLocation",
		            "properties": {}
		        },
		        "RAMLLanguageElement": {
		            "name": "RAMLLanguageElement",
		            "properties": {
		                "description": {
		                    "name": "description"
		                }
		            }
		        },
		        "RAMLSimpleElement": {
		            "name": "RAMLSimpleElement",
		            "properties": {}
		        },
		        "MimeTypeModel": {
		            "name": "MimeTypeModel",
		            "properties": {
		                "type": {
		                    "name": "type"
		                },
		                "tree": {
		                    "name": "tree"
		                },
		                "subtype": {
		                    "name": "subtype"
		                },
		                "suffix": {
		                    "name": "suffix"
		                },
		                "parameters": {
		                    "name": "parameters"
		                }
		            }
		        },
		        "MimeType": {
		            "name": "MimeType",
		            "properties": {}
		        },
		        "BodyLike": {
		            "name": "BodyLike",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "schema": {
		                    "name": "schema"
		                },
		                "example": {
		                    "name": "example"
		                },
		                "formParameters": {
		                    "name": "formParameters"
		                }
		            }
		        },
		        "XMLBody": {
		            "name": "XMLBody",
		            "properties": {
		                "schema": {
		                    "name": "schema"
		                }
		            }
		        },
		        "JSONBody": {
		            "name": "JSONBody",
		            "properties": {
		                "schema": {
		                    "name": "schema"
		                }
		            }
		        },
		        "Response": {
		            "name": "Response",
		            "properties": {
		                "code": {
		                    "name": "code"
		                },
		                "headers": {
		                    "name": "headers"
		                },
		                "body": {
		                    "name": "body"
		                }
		            }
		        }
		    },
		    "Universe10": {
		        "GlobalSchema": {
		            "name": "GlobalSchema",
		            "properties": {
		                "key": {
		                    "name": "key"
		                },
		                "value": {
		                    "name": "value"
		                }
		            }
		        },
		        "ImportDeclaration": {
		            "name": "ImportDeclaration",
		            "properties": {
		                "key": {
		                    "name": "key"
		                },
		                "value": {
		                    "name": "value"
		                }
		            }
		        },
		        "Library": {
		            "name": "Library",
		            "properties": {
		                "usage": {
		                    "name": "usage"
		                }
		            }
		        },
		        "LibraryBase": {
		            "name": "LibraryBase",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "schemas": {
		                    "name": "schemas"
		                },
		                "types": {
		                    "name": "types"
		                },
		                "traits": {
		                    "name": "traits"
		                },
		                "resourceTypes": {
		                    "name": "resourceTypes"
		                },
		                "annotationTypes": {
		                    "name": "annotationTypes"
		                },
		                "securitySchemaTypes": {
		                    "name": "securitySchemaTypes"
		                },
		                "securitySchemes": {
		                    "name": "securitySchemes"
		                },
		                "uses": {
		                    "name": "uses"
		                }
		            }
		        },
		        "Overlay": {
		            "name": "Overlay",
		            "properties": {
		                "usage": {
		                    "name": "usage"
		                },
		                "masterRef": {
		                    "name": "masterRef"
		                },
		                "title": {
		                    "name": "title"
		                }
		            }
		        },
		        "Extension": {
		            "name": "Extension",
		            "properties": {
		                "usage": {
		                    "name": "usage"
		                },
		                "masterRef": {
		                    "name": "masterRef"
		                },
		                "title": {
		                    "name": "title"
		                }
		            }
		        },
		        "Api": {
		            "name": "Api",
		            "properties": {
		                "title": {
		                    "name": "title"
		                },
		                "version": {
		                    "name": "version"
		                },
		                "baseUri": {
		                    "name": "baseUri"
		                },
		                "baseUriParameters": {
		                    "name": "baseUriParameters"
		                },
		                "protocols": {
		                    "name": "protocols"
		                },
		                "mediaType": {
		                    "name": "mediaType"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                },
		                "resources": {
		                    "name": "resources"
		                },
		                "documentation": {
		                    "name": "documentation"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "name": {
		                    "name": "name"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                },
		                "securitySchemaTypes": {
		                    "name": "securitySchemaTypes"
		                }
		            }
		        },
		        "DocumentationItem": {
		            "name": "DocumentationItem",
		            "properties": {
		                "title": {
		                    "name": "title"
		                },
		                "content": {
		                    "name": "content"
		                }
		            }
		        },
		        "ScriptSpec": {
		            "name": "ScriptSpec",
		            "properties": {
		                "language": {
		                    "name": "language"
		                },
		                "content": {
		                    "name": "content"
		                }
		            }
		        },
		        "ApiDescription": {
		            "name": "ApiDescription",
		            "properties": {
		                "apiFiles": {
		                    "name": "apiFiles"
		                },
		                "script": {
		                    "name": "script"
		                },
		                "type": {
		                    "name": "type"
		                }
		            }
		        },
		        "CallbackAPIDescription": {
		            "name": "CallbackAPIDescription",
		            "properties": {
		                "callbackFor": {
		                    "name": "callbackFor"
		                }
		            }
		        },
		        "RAMLProject": {
		            "name": "RAMLProject",
		            "properties": {
		                "relatedProjects": {
		                    "name": "relatedProjects"
		                },
		                "declaredApis": {
		                    "name": "declaredApis"
		                },
		                "license": {
		                    "name": "license"
		                },
		                "overview": {
		                    "name": "overview"
		                },
		                "url": {
		                    "name": "url"
		                }
		            }
		        },
		        "ValueType": {
		            "name": "ValueType",
		            "properties": {}
		        },
		        "StringType": {
		            "name": "StringType",
		            "properties": {}
		        },
		        "NumberType": {
		            "name": "NumberType",
		            "properties": {}
		        },
		        "BooleanType": {
		            "name": "BooleanType",
		            "properties": {}
		        },
		        "Referencable": {
		            "name": "Referencable",
		            "properties": {}
		        },
		        "Reference": {
		            "name": "Reference",
		            "properties": {}
		        },
		        "DeclaresDynamicType": {
		            "name": "DeclaresDynamicType",
		            "properties": {}
		        },
		        "UriTemplate": {
		            "name": "UriTemplate",
		            "properties": {}
		        },
		        "StatusCodeString": {
		            "name": "StatusCodeString",
		            "properties": {}
		        },
		        "RelativeUriString": {
		            "name": "RelativeUriString",
		            "properties": {}
		        },
		        "FullUriTemplateString": {
		            "name": "FullUriTemplateString",
		            "properties": {}
		        },
		        "FixedUriString": {
		            "name": "FixedUriString",
		            "properties": {}
		        },
		        "ContentType": {
		            "name": "ContentType",
		            "properties": {}
		        },
		        "ValidityExpression": {
		            "name": "ValidityExpression",
		            "properties": {}
		        },
		        "MarkdownString": {
		            "name": "MarkdownString",
		            "properties": {}
		        },
		        "DateFormatSpec": {
		            "name": "DateFormatSpec",
		            "properties": {}
		        },
		        "FunctionalInterface": {
		            "name": "FunctionalInterface",
		            "properties": {}
		        },
		        "SchemaString": {
		            "name": "SchemaString",
		            "properties": {}
		        },
		        "ExampleString": {
		            "name": "ExampleString",
		            "properties": {}
		        },
		        "JSonSchemaString": {
		            "name": "JSonSchemaString",
		            "properties": {}
		        },
		        "XMLSchemaString": {
		            "name": "XMLSchemaString",
		            "properties": {}
		        },
		        "RAMLPointer": {
		            "name": "RAMLPointer",
		            "properties": {}
		        },
		        "RAMLSelector": {
		            "name": "RAMLSelector",
		            "properties": {}
		        },
		        "ResourceTypeRef": {
		            "name": "ResourceTypeRef",
		            "properties": {}
		        },
		        "TraitRef": {
		            "name": "TraitRef",
		            "properties": {}
		        },
		        "SecuritySchemePart": {
		            "name": "SecuritySchemePart",
		            "properties": {
		                "headers": {
		                    "name": "headers"
		                },
		                "queryParameters": {
		                    "name": "queryParameters"
		                },
		                "queryString": {
		                    "name": "queryString"
		                },
		                "responses": {
		                    "name": "responses"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                }
		            }
		        },
		        "SecuritySchemaType": {
		            "name": "SecuritySchemaType",
		            "properties": {
		                "requiredSettings": {
		                    "name": "requiredSettings"
		                },
		                "describedBy": {
		                    "name": "describedBy"
		                }
		            }
		        },
		        "SecuritySchemeSettings": {
		            "name": "SecuritySchemeSettings",
		            "properties": {}
		        },
		        "OAuth1SecuritySchemeSettings": {
		            "name": "OAuth1SecuritySchemeSettings",
		            "properties": {
		                "requestTokenUri": {
		                    "name": "requestTokenUri"
		                },
		                "authorizationUri": {
		                    "name": "authorizationUri"
		                },
		                "tokenCredentialsUri": {
		                    "name": "tokenCredentialsUri"
		                },
		                "signatures": {
		                    "name": "signatures"
		                }
		            }
		        },
		        "OAuth2SecuritySchemeSettings": {
		            "name": "OAuth2SecuritySchemeSettings",
		            "properties": {
		                "accessTokenUri": {
		                    "name": "accessTokenUri"
		                },
		                "authorizationUri": {
		                    "name": "authorizationUri"
		                },
		                "authorizationGrants": {
		                    "name": "authorizationGrants"
		                },
		                "scopes": {
		                    "name": "scopes"
		                }
		            }
		        },
		        "PassThroughSecuritySchemeSettings": {
		            "name": "PassThroughSecuritySchemeSettings",
		            "properties": {
		                "queryParameterName": {
		                    "name": "queryParameterName"
		                },
		                "headerName": {
		                    "name": "headerName"
		                }
		            }
		        },
		        "SecuritySchemeRef": {
		            "name": "SecuritySchemeRef",
		            "properties": {}
		        },
		        "AbstractSecurityScheme": {
		            "name": "AbstractSecurityScheme",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "describedBy": {
		                    "name": "describedBy"
		                },
		                "settings": {
		                    "name": "settings"
		                }
		            }
		        },
		        "OAuth2SecurityScheme": {
		            "name": "OAuth2SecurityScheme",
		            "properties": {
		                "settings": {
		                    "name": "settings"
		                }
		            }
		        },
		        "OAuth1SecurityScheme": {
		            "name": "OAuth1SecurityScheme",
		            "properties": {
		                "settings": {
		                    "name": "settings"
		                }
		            }
		        },
		        "PassThroughSecurityScheme": {
		            "name": "PassThroughSecurityScheme",
		            "properties": {
		                "settings": {
		                    "name": "settings"
		                }
		            }
		        },
		        "BasicSecurityScheme": {
		            "name": "BasicSecurityScheme",
		            "properties": {}
		        },
		        "DigestSecurityScheme": {
		            "name": "DigestSecurityScheme",
		            "properties": {}
		        },
		        "CustomSecurityScheme": {
		            "name": "CustomSecurityScheme",
		            "properties": {}
		        },
		        "MethodBase": {
		            "name": "MethodBase",
		            "properties": {
		                "responses": {
		                    "name": "responses"
		                },
		                "body": {
		                    "name": "body"
		                },
		                "protocols": {
		                    "name": "protocols"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                }
		            }
		        },
		        "Trait": {
		            "name": "Trait",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "usage": {
		                    "name": "usage"
		                },
		                "uses": {
		                    "name": "uses"
		                }
		            }
		        },
		        "ResourceBase": {
		            "name": "ResourceBase",
		            "properties": {
		                "methods": {
		                    "name": "methods"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                },
		                "uriParameters": {
		                    "name": "uriParameters"
		                }
		            }
		        },
		        "ResourceType": {
		            "name": "ResourceType",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "usage": {
		                    "name": "usage"
		                },
		                "uses": {
		                    "name": "uses"
		                }
		            }
		        },
		        "ResourceTypeOrTrait": {
		            "name": "ResourceTypeOrTrait",
		            "properties": {
		                "usage": {
		                    "name": "usage"
		                },
		                "uses": {
		                    "name": "uses"
		                },
		                "parameters": {
		                    "name": "parameters"
		                }
		            }
		        },
		        "Method": {
		            "name": "Method",
		            "properties": {
		                "signature": {
		                    "name": "signature"
		                },
		                "method": {
		                    "name": "method"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "queryString": {
		                    "name": "queryString"
		                },
		                "queryParameters": {
		                    "name": "queryParameters"
		                },
		                "headers": {
		                    "name": "headers"
		                },
		                "body": {
		                    "name": "body"
		                },
		                "is": {
		                    "name": "is"
		                },
		                "annotations": {
		                    "name": "annotations"
		                },
		                "securedBy": {
		                    "name": "securedBy"
		                }
		            }
		        },
		        "Resource": {
		            "name": "Resource",
		            "properties": {
		                "signature": {
		                    "name": "signature"
		                },
		                "relativeUri": {
		                    "name": "relativeUri"
		                },
		                "resources": {
		                    "name": "resources"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                }
		            }
		        },
		        "FileTypeDeclaration": {
		            "name": "FileTypeDeclaration",
		            "properties": {
		                "fileTypes": {
		                    "name": "fileTypes"
		                },
		                "minLength": {
		                    "name": "minLength"
		                },
		                "maxLength": {
		                    "name": "maxLength"
		                }
		            }
		        },
		        "HasNormalParameters": {
		            "name": "HasNormalParameters",
		            "properties": {
		                "queryParameters": {
		                    "name": "queryParameters"
		                },
		                "headers": {
		                    "name": "headers"
		                },
		                "queryString": {
		                    "name": "queryString"
		                }
		            }
		        },
		        "RAMLLanguageElement": {
		            "name": "RAMLLanguageElement",
		            "properties": {
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                }
		            }
		        },
		        "RAMLSimpleElement": {
		            "name": "RAMLSimpleElement",
		            "properties": {}
		        },
		        "AnnotationTypeDeclaration": {
		            "name": "AnnotationTypeDeclaration",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "usage": {
		                    "name": "usage"
		                },
		                "parameters": {
		                    "name": "parameters"
		                },
		                "allowMultiple": {
		                    "name": "allowMultiple"
		                },
		                "allowedTargets": {
		                    "name": "allowedTargets"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                }
		            }
		        },
		        "AnnotationRef": {
		            "name": "AnnotationRef",
		            "properties": {}
		        },
		        "AnnotationTarget": {
		            "name": "AnnotationTarget",
		            "properties": {}
		        },
		        "Annotation": {
		            "name": "Annotation",
		            "properties": {
		                "name": {
		                    "name": "name"
		                }
		            }
		        },
		        "ExampleSpec": {
		            "name": "ExampleSpec",
		            "properties": {
		                "content": {
		                    "name": "content"
		                },
		                "strict": {
		                    "name": "strict"
		                },
		                "name": {
		                    "name": "name"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                }
		            }
		        },
		        "DataElementProperty": {
		            "name": "DataElementProperty",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "location": {
		                    "name": "location"
		                },
		                "locationKind": {
		                    "name": "locationKind"
		                },
		                "default": {
		                    "name": "default"
		                },
		                "required": {
		                    "name": "required"
		                }
		            }
		        },
		        "TypeDeclaration": {
		            "name": "TypeDeclaration",
		            "properties": {
		                "name": {
		                    "name": "name"
		                },
		                "facets": {
		                    "name": "facets"
		                },
		                "schema": {
		                    "name": "schema"
		                },
		                "usage": {
		                    "name": "usage"
		                },
		                "type": {
		                    "name": "type"
		                },
		                "location": {
		                    "name": "location"
		                },
		                "locationKind": {
		                    "name": "locationKind"
		                },
		                "default": {
		                    "name": "default"
		                },
		                "example": {
		                    "name": "example"
		                },
		                "examples": {
		                    "name": "examples"
		                },
		                "repeat": {
		                    "name": "repeat"
		                },
		                "required": {
		                    "name": "required"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                }
		            }
		        },
		        "ScalarElement": {
		            "name": "ScalarElement",
		            "properties": {
		                "facets": {
		                    "name": "facets"
		                },
		                "enum": {
		                    "name": "enum"
		                }
		            }
		        },
		        "ArrayTypeDeclaration": {
		            "name": "ArrayTypeDeclaration",
		            "properties": {
		                "uniqueItems": {
		                    "name": "uniqueItems"
		                },
		                "items": {
		                    "name": "items"
		                },
		                "minItems": {
		                    "name": "minItems"
		                },
		                "maxItems": {
		                    "name": "maxItems"
		                }
		            }
		        },
		        "UnionTypeDeclaration": {
		            "name": "UnionTypeDeclaration",
		            "properties": {
		                "discriminator": {
		                    "name": "discriminator"
		                }
		            }
		        },
		        "DataElementRef": {
		            "name": "DataElementRef",
		            "properties": {}
		        },
		        "ObjectTypeDeclaration": {
		            "name": "ObjectTypeDeclaration",
		            "properties": {
		                "properties": {
		                    "name": "properties"
		                },
		                "minProperties": {
		                    "name": "minProperties"
		                },
		                "maxProperties": {
		                    "name": "maxProperties"
		                },
		                "additionalProperties": {
		                    "name": "additionalProperties"
		                },
		                "patternProperties": {
		                    "name": "patternProperties"
		                },
		                "discriminator": {
		                    "name": "discriminator"
		                },
		                "discriminatorValue": {
		                    "name": "discriminatorValue"
		                }
		            }
		        },
		        "StringTypeDeclaration": {
		            "name": "StringTypeDeclaration",
		            "properties": {
		                "pattern": {
		                    "name": "pattern"
		                },
		                "minLength": {
		                    "name": "minLength"
		                },
		                "maxLength": {
		                    "name": "maxLength"
		                },
		                "enum": {
		                    "name": "enum"
		                }
		            }
		        },
		        "BooleanTypeDeclaration": {
		            "name": "BooleanTypeDeclaration",
		            "properties": {}
		        },
		        "ValueTypeDeclaration": {
		            "name": "ValueTypeDeclaration",
		            "properties": {}
		        },
		        "NumberTypeDeclaration": {
		            "name": "NumberTypeDeclaration",
		            "properties": {
		                "minimum": {
		                    "name": "minimum"
		                },
		                "maximum": {
		                    "name": "maximum"
		                },
		                "enum": {
		                    "name": "enum"
		                },
		                "format": {
		                    "name": "format"
		                },
		                "multipleOf": {
		                    "name": "multipleOf"
		                }
		            }
		        },
		        "IntegerTypeDeclaration": {
		            "name": "IntegerTypeDeclaration",
		            "properties": {
		                "format": {
		                    "name": "format"
		                }
		            }
		        },
		        "RAMLPointerElement": {
		            "name": "RAMLPointerElement",
		            "properties": {
		                "target": {
		                    "name": "target"
		                }
		            }
		        },
		        "pointer": {
		            "name": "pointer",
		            "properties": {}
		        },
		        "RAMLExpression": {
		            "name": "RAMLExpression",
		            "properties": {}
		        },
		        "ScriptHookElement": {
		            "name": "ScriptHookElement",
		            "properties": {
		                "declaredIn": {
		                    "name": "declaredIn"
		                },
		                "interfaceName": {
		                    "name": "interfaceName"
		                }
		            }
		        },
		        "SchemaElement": {
		            "name": "SchemaElement",
		            "properties": {}
		        },
		        "DateTypeDeclaration": {
		            "name": "DateTypeDeclaration",
		            "properties": {
		                "dateFormat": {
		                    "name": "dateFormat"
		                }
		            }
		        },
		        "ModelLocation": {
		            "name": "ModelLocation",
		            "properties": {}
		        },
		        "LocationKind": {
		            "name": "LocationKind",
		            "properties": {}
		        },
		        "MimeTypeModel": {
		            "name": "MimeTypeModel",
		            "properties": {
		                "type": {
		                    "name": "type"
		                },
		                "tree": {
		                    "name": "tree"
		                },
		                "subtype": {
		                    "name": "subtype"
		                },
		                "suffix": {
		                    "name": "suffix"
		                },
		                "parameters": {
		                    "name": "parameters"
		                }
		            }
		        },
		        "MimeType": {
		            "name": "MimeType",
		            "properties": {}
		        },
		        "Response": {
		            "name": "Response",
		            "properties": {
		                "code": {
		                    "name": "code"
		                },
		                "headers": {
		                    "name": "headers"
		                },
		                "body": {
		                    "name": "body"
		                },
		                "displayName": {
		                    "name": "displayName"
		                },
		                "description": {
		                    "name": "description"
		                },
		                "annotations": {
		                    "name": "annotations"
		                }
		            }
		        },
		        "Status": {
		            "name": "Status",
		            "properties": {
		                "code": {
		                    "name": "code"
		                },
		                "message": {
		                    "name": "message"
		                }
		            }
		        },
		        "AuthentificationState": {
		            "name": "AuthentificationState",
		            "properties": {}
		        },
		        "AuthentificationParameters": {
		            "name": "AuthentificationParameters",
		            "properties": {}
		        },
		        "AuthData": {
		            "name": "AuthData",
		            "properties": {
		                "authentificationParameters": {
		                    "name": "authentificationParameters"
		                }
		            }
		        },
		        "ParameterSpec": {
		            "name": "ParameterSpec",
		            "properties": {}
		        },
		        "PromptSpec": {
		            "name": "PromptSpec",
		            "properties": {}
		        },
		        "UserResponse": {
		            "name": "UserResponse",
		            "properties": {}
		        },
		        "QueryListener": {
		            "name": "QueryListener",
		            "properties": {}
		        },
		        "EndPoint": {
		            "name": "EndPoint",
		            "properties": {}
		        },
		        "EndPointSpec": {
		            "name": "EndPointSpec",
		            "properties": {
		                "url": {
		                    "name": "url"
		                },
		                "needToSendResponse": {
		                    "name": "needToSendResponse"
		                }
		            }
		        },
		        "SecurityEnvironment": {
		            "name": "SecurityEnvironment",
		            "properties": {}
		        },
		        "AuthentificationManager": {
		            "name": "AuthentificationManager",
		            "properties": {}
		        },
		        "SchemeInfo": {
		            "name": "SchemeInfo",
		            "properties": {
		                "parameterSpec": {
		                    "name": "parameterSpec"
		                }
		            }
		        },
		        "SecurityScheme": {
		            "name": "SecurityScheme",
		            "properties": {}
		        },
		        "SecurityAwareApiClient": {
		            "name": "SecurityAwareApiClient",
		            "properties": {}
		        },
		        "SecuritySchemeHook": {
		            "name": "SecuritySchemeHook",
		            "properties": {}
		        },
		        "StatusCode": {
		            "name": "StatusCode",
		            "properties": {}
		        }
		    }
		};
		module.exports = Universes;


	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var jsyaml = __webpack_require__(15);
		var defs = __webpack_require__(3);
		var hl = __webpack_require__(2);
		var _ = __webpack_require__(4);
		var typeExpression = __webpack_require__(51);
		var def = __webpack_require__(3);
		var hlimpl = __webpack_require__(5);
		var su = __webpack_require__(56);
		var path = __webpack_require__(16);
		var fs = __webpack_require__(17);
		var universes = __webpack_require__(54);
		var universeHelpers = __webpack_require__(62);
		var services = __webpack_require__(49);
		var typeSystem = __webpack_require__(63);
		var typeBuilder = __webpack_require__(50);
		var OverloadingValidator = __webpack_require__(64);
		var util = __webpack_require__(48);
		var mediaTypeParser = __webpack_require__(87);
		var xmlutil = __webpack_require__(57);
		var LinterSettings = (function () {
		    function LinterSettings() {
		        this.validateNotStrictExamples = true;
		    }
		    return LinterSettings;
		})();
		var settings = new LinterSettings();
		var loophole = __webpack_require__(110);
		function evalInSandbox(code, thisArg, args) {
		    return new loophole.Function(code).call(thisArg, args);
		}
		var MAX_RECURSION_LEVEL = 400;
		var lintWithFile = function (customLinter, acceptor, astNode) {
		    if (fs.existsSync(customLinter)) {
		        try {
		            var content = fs.readFileSync(customLinter).toString();
		            var factr = new LinterExtensionsImpl(acceptor);
		            evalInSandbox(content, factr, null);
		            factr.visit(astNode);
		        }
		        catch (e) {
		            console.log("Error in custom linter");
		            console.log(e);
		        }
		    }
		};
		function checkPropertyQuard(n, v) {
		    var pr = n.property();
		    if (pr) {
		        pr.getContextRequirements().forEach(function (x) {
		            if (!n.checkContextValue(x.name, x.value, x.value)) {
		                v.accept(createIssue(8 /* MISSED_CONTEXT_REQUIREMENT */, x.name + " should be " + x.value + " to use property " + pr.nameId(), n));
		            }
		        });
		    }
		    return pr;
		}
		;
		function lintNode(astNode, acceptor) {
		    var ps = astNode.lowLevel().unit().absolutePath();
		    var dr = path.dirname(ps);
		    var customLinter = path.resolve(dr, "raml-lint.js");
		    lintWithFile(customLinter, acceptor, astNode);
		    var dir = path.resolve(dr, ".raml");
		    if (fs.existsSync(dir)) {
		        var st = fs.statSync(dir);
		        if (st.isDirectory()) {
		            var files = fs.readdirSync(dir);
		            files.forEach(function (x) {
		                if (x.indexOf("-lint.js") != -1) {
		                    lintWithFile(path.resolve(dir, x), acceptor, astNode);
		                }
		                //console.log(x);
		            });
		        }
		    }
		}
		;
		var LinterExtensionsImpl = (function () {
		    function LinterExtensionsImpl(acceptor) {
		        this.acceptor = acceptor;
		        this.nodes = {};
		    }
		    LinterExtensionsImpl.prototype.error = function (w, message) {
		        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, w.highLevel()));
		    };
		    LinterExtensionsImpl.prototype.errorOnProperty = function (w, property, message) {
		        var pr = w.highLevel().attr(property);
		        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, pr));
		    };
		    LinterExtensionsImpl.prototype.warningOnProperty = function (w, property, message) {
		        var pr = w.highLevel().attr(property);
		        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, pr, true));
		    };
		    LinterExtensionsImpl.prototype.warning = function (w, message) {
		        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, w.highLevel(), true));
		    };
		    LinterExtensionsImpl.prototype.registerRule = function (nodeType, rule) {
		        var q = this.nodes[nodeType];
		        if (!q) {
		            q = [];
		            this.nodes[nodeType] = q;
		        }
		        q.push(rule);
		    };
		    LinterExtensionsImpl.prototype.visit = function (h) {
		        var _this = this;
		        var nd = h.definition();
		        this.process(nd, h);
		        nd.allSuperTypes().forEach(function (x) { return _this.process(x, h); });
		        h.elements().forEach(function (y) { return _this.visit(y); });
		    };
		    LinterExtensionsImpl.prototype.process = function (d, h) {
		        var _this = this;
		        if (d instanceof def.NodeClass) {
		            if (!d.getAdapter(services.RAMLService).getDeclaringNode()) {
		                var rules = this.nodes[d.nameId()];
		                if (rules) {
		                    rules.forEach(function (x) { return x(h.wrapperNode(), _this); });
		                }
		            }
		        }
		    };
		    return LinterExtensionsImpl;
		})();
		var StackNode = (function () {
		    function StackNode() {
		    }
		    StackNode.prototype.toString = function () {
		        if (this.prev) {
		            return this.value + "." + this.prev.toString();
		        }
		        return this.value;
		    };
		    StackNode.prototype.last = function () {
		        if (this.prev) {
		            return this.prev.last();
		        }
		        return this;
		    };
		    return StackNode;
		})();
		var TypeValidator = (function () {
		    function TypeValidator(node) {
		        this.node = node;
		    }
		    TypeValidator.prototype.validate = function (obj, t, cb, strict, recursionLevel) {
		        if (recursionLevel === void 0) { recursionLevel = 0; }
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        if (t instanceof typeSystem.Array) {
		            this.validateArray(obj, t, cb, strict, recursionLevel);
		        }
		        else if (t instanceof typeSystem.Union) {
		            this.validateUnion(obj, t, cb, strict, recursionLevel);
		        }
		        else if (t instanceof typeSystem.StructuredType) {
		            this.validateClass(obj, t, cb, strict, recursionLevel);
		        }
		        else if (t instanceof typeSystem.ValueType) {
		            this.validateValue(obj, t, cb, strict, recursionLevel);
		        }
		        else {
		            throw new Error("Not supported case");
		        }
		    };
		    TypeValidator.prototype.createIssue = function (c, message, node, w) {
		        if (w === void 0) { w = false; }
		        var result = createIssue(c, message, node, w);
		        if (this.stack) {
		            var ll = this.findNode(this.stack.last(), this.node.lowLevel());
		            if (ll && ll != node.lowLevel()) {
		                if (ll.unit() == node.root().lowLevel().unit()) {
		                    if (ll.keyStart() > 0 && ll.keyEnd() > 0) {
		                        result.start = ll.keyStart();
		                        result.end = ll.keyEnd();
		                    }
		                }
		            }
		        }
		        return result;
		    };
		    TypeValidator.prototype.findNode = function (c, q) {
		        var key = "" + c.value;
		        if (typeof c.value == 'number') {
		            var m = q.children();
		            if (m[c.value]) {
		                var node = m[c.value];
		                if (c.next) {
		                    return this.findNode(c.next, node);
		                }
		            }
		            return q;
		        }
		        var node = _.find(q.children(), function (x) { return x.key() == key; });
		        if (node) {
		            if (c.next) {
		                return this.findNode(c.next, node);
		            }
		            return node;
		        }
		        else {
		            return q;
		        }
		    };
		    TypeValidator.prototype.validateClass = function (obj, t, cb, strict, recursionLevel) {
		        var _this = this;
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        var supers = t.allSuperTypes();
		        supers.push(t);
		        this.validateFacets(t.getAdapter(services.RAMLService).isRuntime() ? t : t.getAdapter(services.RAMLService).toRuntime(), obj, cb, strict, recursionLevel);
		        supers.forEach(function (s) {
		            if (s.key() == universes.Universe10.StringTypeDeclaration || s.key() == universes.Universe08.StringTypeDeclaration) {
		                if (typeof obj != 'string' && typeof obj != 'number' && typeof obj != 'boolean') {
		                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "String is expected", _this.node, !strict));
		                }
		            }
		            if (s.key() == universes.Universe10.NumberTypeDeclaration || s.key() == universes.Universe08.NumberTypeDeclaration) {
		                if (typeof obj != 'number') {
		                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Number is expected", _this.node, !strict));
		                }
		            }
		            if (s.key() == universes.Universe10.BooleanTypeDeclaration || s.key() == universes.Universe08.BooleanTypeDeclaration) {
		                var isOk = obj == true || obj == false;
		                if (!isOk) {
		                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "boolean is expected", _this.node, !strict));
		                }
		            }
		            if (s instanceof def.Array) {
		                _this.validate(obj, s, cb, strict, recursionLevel + 1);
		            }
		            if (s instanceof def.Union) {
		                _this.validate(obj, s, cb, strict, recursionLevel + 1);
		            }
		        });
		        var props = t.getAdapter(services.RAMLService).isRuntime() ? t.allProperties() : t.getAdapter(services.RAMLService).toRuntime().allProperties();
		        if (!obj) {
		            obj = {};
		        }
		        var handled = {};
		        props.forEach(function (p) {
		            if (!p.getAdapter(services.RAMLPropertyService).isMerged()) {
		                var value = obj[p.nameId()];
		                handled[p.nameId()] = 1;
		                if (value == null) {
		                    if (p.isRequired()) {
		                        cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Required property:" + p.nameId() + " is missed", _this.node, !strict));
		                    }
		                }
		                else {
		                    _this.validatePropValue(value, p, cb, strict, p.nameId(), recursionLevel + 1);
		                }
		            }
		        });
		        props.forEach(function (p) {
		            if (p.getAdapter(services.RAMLPropertyService).isMerged()) {
		                if (p.getKeyRegexp() != null) {
		                    Object.keys(obj).forEach(function (x) {
		                        if (!handled[x]) {
		                            try {
		                                var re = new RegExp(p.getKeyRegexp());
		                                if (re.test(x)) {
		                                    var n = _this.node;
		                                    _this.validatePropValue(obj[x], p, cb, strict, x, recursionLevel + 1);
		                                    handled[x] = 1;
		                                }
		                            }
		                            catch (e) {
		                            }
		                        }
		                    });
		                }
		            }
		        });
		        props.forEach(function (p) {
		            if (p.getAdapter(services.RAMLPropertyService).isMerged()) {
		                if (p.keyPrefix() != null) {
		                    Object.keys(obj).forEach(function (x) {
		                        if (!handled[x]) {
		                            _this.validatePropValue(obj[x], p, cb, strict, x, recursionLevel + 1);
		                            handled[x] = 1;
		                        }
		                    });
		                }
		            }
		        });
		        if (typeof obj == 'object' && props.length > 0) {
		            Object.keys(obj).forEach(function (x) {
		                if (!handled[x]) {
		                    try {
		                        _this.pushStack(x);
		                        cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unknown property:" + x, _this.node, !strict));
		                    }
		                    finally {
		                        if (_this.stack) {
		                            _this.stack = _this.stack.prev;
		                        }
		                    }
		                }
		            });
		        }
		    };
		    TypeValidator.prototype.validateFacets = function (t, obj, cb, strict, recursionLevel) {
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        var rof = t.getAdapter(services.RAMLService).getRepresentationOf();
		        var fixedFacets = t.getFixedFacets();
		        if (rof) {
		            t = rof;
		            if (t instanceof def.UserDefinedClass) {
		                fixedFacets = t.getFixedFacets();
		            }
		        }
		        for (var facetKey in fixedFacets) {
		            var facet = t.facet(facetKey);
		            if (facet) {
		                var facetValue = fixedFacets[facetKey];
		                var facetValidator = facet.getFacetValidator();
		                if (facetValidator) {
		                    try {
		                        var result = facetValidator(obj, facetValue);
		                        if (typeof result == "string") {
		                            cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + result, this.node, !strict));
		                        }
		                    }
		                    catch (e) {
		                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, this.node, !strict));
		                    }
		                }
		            }
		        }
		    };
		    TypeValidator.prototype.validatePropValue = function (value, p, cb, strict, key, recursionLevel) {
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        this.pushStack(key);
		        try {
		            this.validate(value, p.range(), cb, strict, recursionLevel);
		            var enumValues = p.getAdapter(services.RAMLPropertyService).enumValues(null);
		            if (enumValues) {
		                if (typeof enumValues == 'string') {
		                    if (enumValues != value) {
		                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + p.nameId() + " should be one of " + enumValues, this.node, !strict));
		                    }
		                }
		                else if (enumValues.length > 0) {
		                    if (!_.find(enumValues, function (x) { return x == value; })) {
		                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + p.nameId() + " should be one of " + enumValues, this.node, !strict));
		                    }
		                }
		            }
		        }
		        finally {
		            if (this.stack) {
		                this.stack = this.stack.prev;
		            }
		        }
		    };
		    TypeValidator.prototype.pushStack = function (key) {
		        if (!this.stack) {
		            this.stack = new StackNode();
		            this.stack.value = key;
		        }
		        else {
		            var pn = new StackNode();
		            pn.prev = this.stack;
		            this.stack.next = pn;
		            this.stack = pn;
		            this.stack.value = key;
		        }
		    };
		    TypeValidator.prototype.validateArray = function (obj, t, cb, strict, recursionLevel) {
		        var _this = this;
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        if (!(obj instanceof Array)) {
		            obj = [obj];
		        }
		        if (obj instanceof Array) {
		            var arr = obj;
		            this.validateFacets(t, obj, cb, strict, recursionLevel);
		            var num = 0;
		            arr.forEach(function (x) {
		                try {
		                    _this.pushStack(num++);
		                    _this.validate(x, t.component, cb, strict, recursionLevel + 1);
		                }
		                finally {
		                    if (_this.stack) {
		                        _this.stack = _this.stack.prev;
		                    }
		                }
		            });
		        }
		    };
		    TypeValidator.prototype.validateUnion = function (obj, t, cb, strict, recursionLevel) {
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        //FIXME
		    };
		    TypeValidator.prototype.validateValue = function (obj, t, cb, strict, recursionLevel) {
		        if (recursionLevel >= MAX_RECURSION_LEVEL) {
		            return;
		        }
		        //FIXME
		        if (t.key() == universes.Universe08.NumberType || t.key() == universes.Universe10.NumberType) {
		            if (typeof obj != 'number') {
		                var qqq = parseFloat(obj);
		                if (!qqq) {
		                    if (isNaN(qqq)) {
		                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Number is expected", this.node, !strict));
		                    }
		                }
		            }
		        }
		        if (t.key() == universes.Universe08.BooleanType || t.key() == universes.Universe10.BooleanType) {
		            if (typeof obj != 'boolean') {
		                if (obj != 'true' && obj != 'false') {
		                    cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "boolean is expected", this.node, !strict));
		                }
		            }
		        }
		    };
		    return TypeValidator;
		})();
		exports.TypeValidator = TypeValidator;
		function isTypeOrSchema(d) {
		    return d.nameId() == universes.Universe10.TypeDeclaration.properties.type.name || d.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name;
		}
		function isExampleProp(d) {
		    if (!d.domain()) {
		        return;
		    }
		    if (d.domain().getAdapter(services.RAMLService).isUserDefined()) {
		        return false;
		    }
		    return d.nameId() == universes.Universe10.TypeDeclaration.properties.example.name || d.nameId() == universes.Universe10.ExampleSpec.properties.content.name;
		}
		function insideResourceTypeOrTrait(h) {
		    var declRoot = h;
		    while (true) {
		        if (declRoot.definition().getAdapter(services.RAMLService).isInlinedTemplates()) {
		            return true;
		        }
		        var np = declRoot.parent();
		        if (!np) {
		            break;
		        }
		        else {
		            declRoot = np;
		        }
		    }
		    return false;
		}
		function validateBasic(node, v) {
		    if (node.lowLevel() && node.parent() == null) {
		        node.lowLevel().errors().forEach(function (x) {
		            var em = {
		                code: 1 /* YAML_ERROR */,
		                message: x.message,
		                node: null,
		                start: x.mark.position,
		                end: x.mark.position + 1,
		                isWarning: false,
		                path: node.lowLevel().unit() == node.root().lowLevel().unit() ? null : node.lowLevel().unit().path(),
		                unit: node.lowLevel().unit()
		            };
		            v.accept(em);
		        });
		    }
		    validateIncludes(node, v);
		    if (node.isUnknown()) {
		        if (node.needSequence) {
		            v.accept(createIssue(2 /* UNKNOWN_NODE */, "node: " + node.name() + " should be wrapped in sequence", node));
		        }
		        if (node.unresolvedRef) {
		            v.accept(createIssue(2 /* UNKNOWN_NODE */, "reference: " + node.lowLevel().value() + " can not be resolved", node));
		        }
		        if (node.knownProperty && node.lowLevel().value()) {
		            v.accept(createIssue(2 /* UNKNOWN_NODE */, "property " + node.name() + " can not have scalar value", node));
		        }
		        else {
		            v.accept(createIssue(2 /* UNKNOWN_NODE */, "Unknown node: " + node.name(), node));
		        }
		    }
		    if (node.markCh() && !node.allowRecursive()) {
		        v.accept(createIssue(2 /* UNKNOWN_NODE */, "Recursive definition: " + node.name(), node));
		        return;
		    }
		    try {
		        node.directChildren().forEach(function (x) { return x.validate(v); });
		    }
		    finally {
		        node.unmarkCh();
		    }
		}
		exports.validateBasic = validateBasic;
		function validate(node, v) {
		    if (node.isAttr()) {
		        new CompositePropertyValidator().validate(node, v);
		    }
		    else if (node.isElement()) {
		        if (!node.definition().getAdapter(services.RAMLService).getAllowAny()) {
		            validateBasic(node, v);
		        }
		        else {
		            validateIncludes(node, v);
		        }
		        ;
		        new CompositeNodeValidator().validate(node, v);
		    }
		    else {
		        validateBasic(node, v);
		    }
		}
		exports.validate = validate;
		function validateIncludes(node, v) {
		    if (node.lowLevel()) {
		        node.lowLevel().includeErrors().forEach(function (x) {
		            var em = createIssue(6 /* UNABLE_TO_RESOLVE_INCLUDE_FILE */, x, node);
		            v.accept(em);
		        });
		    }
		}
		var validateRegexp = function (cleanedValue, v, node) {
		    try {
		        new RegExp(cleanedValue);
		    }
		    catch (Error) {
		        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Illegal pattern " + cleanedValue, node));
		    }
		};
		var CompositePropertyValidator = (function () {
		    function CompositePropertyValidator() {
		    }
		    CompositePropertyValidator.prototype.validate = function (node, v) {
		        var pr = checkPropertyQuard(node, v);
		        var vl = node.value();
		        if (!node.property().range().hasStructure()) {
		            if (vl instanceof hlimpl.StructuredValue && !node.property().isSelfNode()) {
		                //TODO THIS SHOULD BE MOVED TO TYPESYSTEM FOR STS AT SOME MOMENT
		                if (isTypeOrSchema(node.property())) {
		                    if (node.property().domain().key() == universes.Universe08.BodyLike) {
		                        var structValue = vl;
		                        var newNode = new hlimpl.ASTNodeImpl(node.lowLevel(), node.parent(), node.parent().definition().universe().type("ObjectTypeDeclaration"), node.property());
		                        newNode.validate(v);
		                        return;
		                    }
		                }
		                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Scalar is expected here", node));
		            }
		        }
		        if (node.parent().allowsQuestion() && node.property().getAdapter(services.RAMLPropertyService).isKey()) {
		            if (vl != null && vl.length > 0 && vl.charAt(vl.length - 1) == '?') {
		                vl = vl.substr(0, vl.length - 1);
		            }
		        }
		        if (typeof vl == 'string' && vl.indexOf("<<") != -1) {
		            if (vl.indexOf(">>") > vl.indexOf("<<")) {
		                if (insideResourceTypeOrTrait(node.parent())) {
		                    return;
		                }
		            }
		        }
		        validateIncludes(node, v);
		        if ((node.property().range().key() == universes.Universe08.MimeType || node.property().range().key() == universes.Universe10.MimeType) || (node.property().nameId() == universes.Universe10.TypeDeclaration.properties.name.name && node.parent().property().nameId() == universes.Universe10.Method.properties.body.name)) {
		            new MediaTypeValidator().validate(node, v);
		            return;
		        }
		        if (node.property().getAdapter(services.RAMLPropertyService).isKey()) {
		            if (vl.indexOf(" ") != -1) {
		                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Keys should not have spaces '" + node.value() + "'", node));
		            }
		        }
		        if (isExampleProp(node.property())) {
		            new ExampleValidator().validate(node, v);
		        }
		        if (node.property().nameId() == universes.Universe10.TypeDeclaration.properties.name.name) {
		            //TODO MOVE TO DEF SYSTEM
		            var nameId = node.parent().property() && node.parent().property().nameId();
		            if (nameId == universes.Universe08.Resource.properties.uriParameters.name || nameId == universes.Universe08.Resource.properties.baseUriParameters.name) {
		                new UrlParameterNameValidator().validate(node, v);
		                return;
		            }
		        }
		        var range = node.property().range().key();
		        if (range == universes.Universe08.RelativeUriString || range == universes.Universe10.RelativeUriString) {
		            new UriValidator().validate(node, v);
		            return;
		        }
		        if (range == universes.Universe08.FullUriTemplateString || range == universes.Universe10.FullUriTemplateString) {
		            new UriValidator().validate(node, v);
		            return;
		        }
		        if ("pattern" == node.name() && universes.Universe10.StringType == node.definition().key() && node.parent().definition().isAssignableFrom("StringTypeDeclaration")) {
		            validateRegexp(node.value(), v, node);
		        }
		        if ("name" == node.name() && universes.Universe10.StringType == node.definition().key() && (typeof node.value() == "string") && node.value().indexOf("[") == 0 && node.value().lastIndexOf("]") == node.value().length - 1) {
		            if (node.parent() instanceof hlimpl.ASTNodeImpl && universes.Universe10.ObjectTypeDeclaration.properties.properties.name == node.parent().property().nameId()) {
		                if (node.parent().parent() instanceof hlimpl.ASTNodeImpl && universes.Universe10.ObjectTypeDeclaration == node.parent().parent().definition().key()) {
		                    var cleanedValue = node.value().substr(1, node.value().length - 2);
		                    validateRegexp(cleanedValue, v, node);
		                }
		            }
		        }
		        if (pr.getAdapter(services.RAMLPropertyService).isTypeExpr()) {
		            new SchemaOrTypeValidator().validate(node, v);
		            return;
		        }
		        if (pr.isReference() || pr.isDescriminator()) {
		            new DescriminatorOrReferenceValidator().validate(node, v);
		        }
		        else {
		            new NormalValidator().validate(node, v);
		        }
		    };
		    return CompositePropertyValidator;
		})();
		var NormalValidator = (function () {
		    function NormalValidator() {
		    }
		    NormalValidator.prototype.validate = function (node, cb) {
		        var vl = node.value();
		        if (node.parent().allowsQuestion() && node.property().getAdapter(services.RAMLPropertyService).isKey()) {
		            if (vl != null && vl.length > 0 && vl.charAt(vl.length - 1) == '?') {
		                vl = vl.substr(0, vl.length - 1);
		            }
		        }
		        var pr = node.property();
		        var range = pr.range();
		        if (range instanceof typeSystem.AbstractType) {
		            var nc = range;
		            var rof = nc.getAdapter(services.RAMLService).getRepresentationOf();
		            if (rof) {
		                nc = rof;
		            }
		            var ff = nc.getFixedFacets();
		            for (var fc in ff) {
		                var facet = nc.facet(fc);
		                if (facet) {
		                    var val = facet.getFacetValidator();
		                    if (val) {
		                        try {
		                            var qq = vl;
		                            if (pr.range().isArray()) {
		                                try {
		                                    qq = node.parent().lowLevel().dumpToObject()[node.parent().name()][pr.nameId()];
		                                }
		                                catch (e) {
		                                }
		                            }
		                            var res = val(qq, ff[fc]);
		                            if (typeof res == 'string') {
		                                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + res, node));
		                            }
		                        }
		                        catch (e) {
		                            cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node));
		                        }
		                    }
		                }
		            }
		        }
		        var v = cb;
		        var validation = pr.range().getAdapter(services.RAMLService).isValid(node.parent(), vl, pr);
		        if (validation instanceof Error) {
		            if (!validation.canBeRef) {
		                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
		                validation = null;
		                return;
		            }
		        }
		        if (!validation || validation instanceof Error) {
		            if (pr.nameId() != 'value') {
		                if (!checkReference(pr, node, vl, v)) {
		                    if (pr.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name || universes.Universe10.TypeDeclaration.properties.type.name) {
		                        if (vl && vl.trim() && (pr.domain().key() == universes.Universe08.BodyLike || pr.domain().key() == universes.Universe10.TypeDeclaration)) {
		                            var testSchema = vl.trim().charAt(0); //FIXME
		                            if (testSchema != '{' && testSchema != '<') {
		                                return;
		                            }
		                        }
		                    }
		                    var decl = node.findReferencedValue();
		                    if (decl instanceof Error) {
		                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, decl.message, node));
		                    }
		                    if (!decl) {
		                        if (vl) {
		                            if (pr.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name) {
		                                var z = vl.trim();
		                                if (z.charAt(0) != '{' && z.charAt(0) != '<') {
		                                    if (vl.indexOf('|') != -1 || vl.indexOf('[]') != -1 || vl.indexOf("(") != -1) {
		                                        return;
		                                    }
		                                }
		                            }
		                        }
		                        if (validation instanceof Error && vl) {
		                            v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
		                            validation = null;
		                            return;
		                        }
		                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Empty value is not allowed here", node));
		                    }
		                }
		            }
		            else {
		                var vl = node.value();
		                var message = "Invalid value schema:" + vl;
		                if (validation instanceof Error) {
		                    message = validation.message;
		                }
		                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, node));
		            }
		        }
		        var values = pr.enumOptions();
		        if (values) {
		            if (typeof values == 'string') {
		                if (values != vl) {
		                    if (vl && (vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe08.SecuritySchema.properties.type.name) {
		                    }
		                    else {
		                        v.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Invalid value:" + vl + " allowed values are:" + values, node));
		                    }
		                }
		            }
		            else if (values.length > 0) {
		                if (!_.find(values, function (x) { return x == vl; })) {
		                    if (vl && (vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe08.SecuritySchema.properties.type.name) {
		                    }
		                    else {
		                        v.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Invalid value:" + vl + " allowed values are:" + values.join(","), node));
		                    }
		                }
		            }
		        }
		    };
		    return NormalValidator;
		})();
		var UriValidator = (function () {
		    function UriValidator() {
		    }
		    UriValidator.prototype.validate = function (node, cb) {
		        try {
		            new UrlParameterNameValidator().parseUrl(node.value());
		        }
		        catch (e) {
		            cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node, false));
		        }
		    };
		    return UriValidator;
		})();
		var MediaTypeValidator = (function () {
		    function MediaTypeValidator() {
		    }
		    MediaTypeValidator.prototype.validate = function (node, cb) {
		        try {
		            var v = node.value();
		            if (!v) {
		                return;
		            }
		            if (v == "*/*") {
		                return;
		            }
		            if (v.indexOf("/*") == v.length - 2) {
		                v = v.substring(0, v.length - 2) + "/xxx";
		            }
		            if (v == "body") {
		                if (node.parent().parent()) {
		                    var ppc = node.parent().parent().definition().key();
		                    if (ppc === universes.Universe08.Response || ppc === universes.Universe10.Response || node.parent().parent().definition().isAssignableFrom(universes.Universe10.MethodBase.name)) {
		                        v = node.parent().computedValue("mediaType");
		                    }
		                }
		            }
		            var res = mediaTypeParser.parse(v);
		            var types = {
		                application: 1,
		                audio: 1,
		                example: 1,
		                image: 1,
		                message: 1,
		                model: 1,
		                multipart: 1,
		                text: 1,
		                video: 1
		            };
		            if (!types[res.type]) {
		                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unknown media type 'type'", node));
		            }
		        }
		        catch (e) {
		            cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + e.message, node));
		        }
		        if (node.value() && node.value() == ("multipart/form-data") || node.value() == ("application/x-www-form-urlencoded")) {
		            if (node.parent() && node.parent().parent() && node.parent().parent().property()) {
		                if (node.parent().parent().property().nameId() == universes.Universe10.MethodBase.properties.responses.name) {
		                    cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Form related media types can not be used in responses", node));
		                }
		            }
		        }
		        return;
		    };
		    return MediaTypeValidator;
		})();
		//class SignatureValidator implements PropertyValidator{
		//    validate(node:hl.IAttribute,cb:hl.ValidationAcceptor){
		//        var vl=node.value();
		//        var q = vl?vl.trim():"";
		//        if (q.length > 0 ) {
		//            try {
		//                //ramlSignature.validate(vl, node, cb);
		//            }catch (e){
		//                cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA,"Error during signature parse:"+e.message,node))
		//            }
		//            return;
		//        }
		//        return;
		//    }
		//}
		var UrlParameterNameValidator = (function () {
		    function UrlParameterNameValidator() {
		    }
		    UrlParameterNameValidator.prototype.checkBaseUri = function (node, c, vl, v) {
		        var bu = c.root().attr("baseUri");
		        if (bu) {
		            var tnv = bu.value();
		            try {
		                var pNames = this.parseUrl(tnv);
		                if (!_.find(pNames, function (x) { return x == vl; })) {
		                    v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter", node));
		                }
		            }
		            catch (e) {
		            }
		        }
		        else {
		            v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter", node));
		        }
		    };
		    UrlParameterNameValidator.prototype.parseUrl = function (value) {
		        var result = [];
		        var temp = "";
		        var inPar = false;
		        var count = 0;
		        for (var a = 0; a < value.length; a++) {
		            var c = value[a];
		            if (c == '{') {
		                count++;
		                inPar = true;
		                continue;
		            }
		            if (c == '}') {
		                count--;
		                inPar = false;
		                result.push(temp);
		                temp = "";
		                continue;
		            }
		            if (inPar) {
		                temp += c;
		            }
		        }
		        if (count > 0) {
		            throw new Error("Unmatched '{'");
		        }
		        if (count < 0) {
		            throw new Error("Unmatched '}'");
		        }
		        return result;
		    };
		    UrlParameterNameValidator.prototype.validate = function (node, cb) {
		        var vl = node.value();
		        if (node.parent().property().nameId() == universes.Universe10.Api.properties.baseUri.name) {
		            var c = node.parent().parent();
		            this.checkBaseUri(node, c, vl, cb);
		            return;
		        }
		        var c = node.parent().parent();
		        var tn = c.name();
		        if (c.definition().key() === universes.Universe10.Api || c.definition().key() === universes.Universe08.Api) {
		            this.checkBaseUri(node, c, vl, cb);
		            return;
		        }
		        if (c.definition().key() == universes.Universe10.ResourceType || c.definition().key() == universes.Universe08.ResourceType) {
		            return;
		        }
		        try {
		            var pNames = this.parseUrl(tn);
		            if (!_.find(pNames, function (x) { return x == vl; })) {
		                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter '" + vl + "'", node));
		            }
		        }
		        catch (e) {
		        }
		    };
		    return UrlParameterNameValidator;
		})();
		exports.UrlParameterNameValidator = UrlParameterNameValidator;
		exports.typeToName = {};
		exports.typeToName[universes.Universe08.Trait.name] = "trait";
		exports.typeToName[universes.Universe08.ResourceType.name] = "resource type";
		exports.typeToName[universes.Universe10.Trait.name] = "trait";
		exports.typeToName[universes.Universe10.AnnotationTypeDeclaration.name] = "annotation type";
		exports.typeToName[universes.Universe10.ResourceType.name] = "resource type";
		exports.typeToName[universes.Universe10.AbstractSecurityScheme.name] = "security scheme";
		function checkReference(pr, astNode, vl, cb) {
		    if (!vl) {
		        return;
		    }
		    if (vl == 'null') {
		        if (pr.isAllowNull()) {
		            return;
		        }
		    }
		    try {
		        if (typeof vl == 'string') {
		            if (pr.domain().key() == universes.Universe10.TypeDeclaration) {
		                if (pr.nameId() == universes.Universe10.TypeDeclaration.properties.type.name || pr.nameId() == universes.Universe10.ArrayTypeDeclaration.properties.items.name) {
		                    typeExpression.validate(vl, astNode, cb);
		                    return false;
		                }
		            }
		            if (pr.range().key() == universes.Universe08.SchemaString || pr.range().key() == universes.Universe10.SchemaString) {
		                if (pr.range().universe().version() == "RAML10") {
		                    if (pr.range() instanceof defs.ValueType) {
		                        typeExpression.validate(vl, astNode, cb);
		                        return false;
		                    }
		                }
		            }
		            if (pr.nameId() == universes.Universe10.TypeDeclaration.properties.schema.name || pr.nameId() == universes.Universe10.TypeDeclaration.properties.type.name) {
		                if (pr.domain().key() == universes.Universe08.BodyLike || pr.domain().key() == universes.Universe10.TypeDeclaration) {
		                    var q = vl.trim();
		                    if (q.length > 0 && q.charAt(0) != '{' && q.charAt(0) != '<') {
		                        typeExpression.validate(vl, astNode, cb);
		                        return false;
		                    }
		                    return;
		                }
		            }
		        }
		    }
		    catch (e) {
		        cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Syntax error:" + e.message, astNode));
		    }
		    var adapter = pr.getAdapter(services.RAMLPropertyService);
		    var valid = adapter.isValidValue(vl, astNode.parent());
		    if (!valid) {
		        if (typeof vl == 'string') {
		            if ((vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe10.TypeDeclaration.properties.type.name) {
		                return true;
		            }
		        }
		        var expected = (adapter.isReference && adapter.isReference() && adapter.referencesTo && adapter.referencesTo() && adapter.referencesTo().nameId && adapter.referencesTo().nameId());
		        var referencedToName = exports.typeToName[expected] || nameForNonReference(astNode);
		        var message = referencedToName ? ("Unrecognized " + referencedToName + " '" + vl + "'.") : ("Unresolved reference: " + vl);
		        cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, message, astNode));
		        return true;
		    }
		    return false;
		}
		function nameForNonReference(astNode) {
		    var propertyName = astNode && astNode.lowLevel() && astNode.lowLevel().key();
		    if (propertyName === universes.Universe10.AbstractSecurityScheme.properties.type.name) {
		        var domain = astNode.parent() && astNode.parent().definition() && astNode.parent().definition().nameId();
		        if (domain === universes.Universe10.AbstractSecurityScheme.name) {
		            return "security scheme type";
		        }
		    }
		}
		var SchemaOrTypeValidator = (function () {
		    function SchemaOrTypeValidator() {
		    }
		    SchemaOrTypeValidator.prototype.validate = function (node, cb) {
		        var vl = node.value();
		        if (vl instanceof hlimpl.StructuredValue) {
		            //already validated in scalar
		            //cb.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE,"Type expression is expected here",node));
		            return;
		        }
		        if (!vl) {
		            vl = "";
		        }
		        try {
		            typeExpression.validate(vl, node, cb);
		        }
		        catch (e) {
		            cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Syntax error:" + e.message, node));
		        }
		    };
		    return SchemaOrTypeValidator;
		})();
		var DescriminatorOrReferenceValidator = (function () {
		    function DescriminatorOrReferenceValidator() {
		    }
		    DescriminatorOrReferenceValidator.prototype.validate = function (node, cb) {
		        var vl = node.value();
		        var valueKey = vl;
		        var pr = node.property();
		        if (typeof vl == 'string') {
		            checkReference(pr, node, vl, cb);
		            if (pr.range() instanceof defs.ReferenceType) {
		                var t = pr.range();
		                if (true) {
		                    var mockNode = jsyaml.createNode("" + vl);
		                    mockNode._actualNode().startPosition = node.lowLevel().valueStart();
		                    mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
		                    var stv = new hlimpl.StructuredValue(mockNode, node.parent(), node.property());
		                    var hn = stv.toHighlevel();
		                    if (hn) {
		                        hn.validate(cb);
		                    }
		                }
		            }
		        }
		        else {
		            var st = vl;
		            if (st) {
		                valueKey = st.valueName();
		                var vn = st.valueName();
		                if (!checkReference(pr, node, vn, cb)) {
		                    var hnode = st.toHighlevel();
		                    if (hnode)
		                        hnode.validate(cb);
		                }
		            }
		            else {
		                valueKey = null;
		            }
		        }
		        if (valueKey) {
		            var validation = pr.range().getAdapter(services.RAMLService).isValid(node.parent(), valueKey, pr);
		            if (validation instanceof Error) {
		                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
		                validation = null;
		            }
		        }
		    };
		    return DescriminatorOrReferenceValidator;
		})();
		var allowOverride = { resources: 1, queryParameters: 1, headers: 1, body: 1, methods: 1, responses: 1 };
		var RAMLVersionAndFragmentValidator = (function () {
		    function RAMLVersionAndFragmentValidator() {
		    }
		    RAMLVersionAndFragmentValidator.prototype.validate = function (node, v) {
		        var u = node.universe();
		        var tv = u.getTypedVersion();
		        if (tv) {
		            if (util.startsWith(tv, "#%")) {
		                if (tv !== "#%RAML 0.8" && tv !== "#%RAML 1.0") {
		                    var i = createIssue(9 /* NODE_HAS_VALUE */, "Unknown version of RAML expected to see one of '#%RAML 0.8' or '#%RAML 1.0'", node);
		                    v.accept(i);
		                }
		                var tl = u.getTopLevel();
		                if (tl) {
		                    if (tl != node.definition().nameId()) {
		                        if (node.definition().nameId() == "Api") {
		                            var i = createIssue(9 /* NODE_HAS_VALUE */, "Unknown top level type:" + tl, node);
		                            v.accept(i);
		                        }
		                    }
		                }
		            }
		        }
		    };
		    return RAMLVersionAndFragmentValidator;
		})();
		var RequiredPropertiesAndContextRequirementsValidator = (function () {
		    function RequiredPropertiesAndContextRequirementsValidator() {
		    }
		    RequiredPropertiesAndContextRequirementsValidator.prototype.validate = function (node, v) {
		        (node.definition()).getAdapter(services.RAMLService).getContextRequirements().forEach(function (x) {
		            if (!node.checkContextValue(x.name, x.value, x.value)) {
		                v.accept(createIssue(8 /* MISSED_CONTEXT_REQUIREMENT */, x.name + (" should be " + x.value + " to use type " + node.definition().nameId()), node));
		            }
		        });
		        node.definition().requiredProperties().forEach(function (x) {
		            var r = x.range();
		            if (r.isArray()) {
		                r = r.array().componentType();
		            }
		            if (r.isValueType()) {
		                var nm = node.attr(x.nameId());
		                if (!nm) {
		                    var i = createIssue(3 /* MISSING_REQUIRED_PROPERTY */, "Missing required property " + x.nameId(), node);
		                    v.accept(i);
		                }
		            }
		            else {
		                var el = node.elementsOfKind(x.nameId());
		                if (!el || el.length == 0) {
		                    var i = createIssue(3 /* MISSING_REQUIRED_PROPERTY */, "Missing required property " + x.nameId(), node);
		                    v.accept(i);
		                }
		            }
		        });
		    };
		    return RequiredPropertiesAndContextRequirementsValidator;
		})();
		var ScalarQuoteValidator = (function () {
		    function ScalarQuoteValidator() {
		    }
		    ScalarQuoteValidator.prototype.validate = function (node, v) {
		        var r = node.lowLevel().unit();
		        node.lowLevel().visit(function (x) {
		            if (x.unit() != r) {
		                return false;
		            }
		            if (x.value() && x._node && x._node.value) {
		                if (x._node.value.doubleQuoted) {
		                    var ind = (x.value() + "").indexOf(":");
		                    var nl = (x.value() + "").indexOf("\n");
		                    if (ind != -1 && nl != -1 && (!x.includePath() || x.includePath().length == 0)) {
		                        var i = createIssue(9 /* NODE_HAS_VALUE */, "Suspicious double quoted multiline scalar, it is likely that you forgot closing \" " + x.value(), node, true);
		                        i.start = x._node.value.startPosition;
		                        i.end = x._node.value.endPosition;
		                        if (i.start == i.end) {
		                            i.end++;
		                        }
		                        v.accept(i);
		                    }
		                }
		            }
		            return true;
		        });
		    };
		    return ScalarQuoteValidator;
		})();
		//TODO to typesystem
		var FixedFacetsValidator = (function () {
		    function FixedFacetsValidator() {
		    }
		    FixedFacetsValidator.prototype.validate = function (node, v) {
		        var nc = node.definition();
		        var facets = nc.getFixedFacets();
		        Object.keys(facets).forEach(function (fk) {
		            var facet = nc.getAdapter(services.RAMLService).getRepresentationOf().facet(fk);
		            if (facet) {
		                var facetValidator = facet.getFacetValidator();
		                if (facetValidator) {
		                    var obj = node.lowLevel().dumpToObject();
		                    obj = obj[node.lowLevel().key()];
		                    try {
		                        var message = facetValidator(obj, facets[fk]);
		                        if (typeof message == 'string') {
		                            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + message, node);
		                            v.accept(i);
		                        }
		                    }
		                    catch (e) {
		                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node);
		                        v.accept(i);
		                    }
		                }
		            }
		        });
		    };
		    return FixedFacetsValidator;
		})();
		var OverridePropertyValidator = (function () {
		    function OverridePropertyValidator() {
		    }
		    OverridePropertyValidator.prototype.validate = function (node, v) {
		        var props = node.elementsOfKind("properties");
		        this.checkOverride(props, node, v, false);
		        var faceted = node.elementsOfKind("facets");
		        this.checkOverride(faceted, node, v, true);
		    };
		    OverridePropertyValidator.prototype.checkOverride = function (props, node, v, facets) {
		        var name = facets ? "facet" : "property";
		        if (props.length > 0) {
		            var types = node.attributes("type");
		            types.forEach(function (t) {
		                var tp = typeExpression.getType(node, t.value(), {});
		                if (tp instanceof def.NodeClass) {
		                    var xnc = tp;
		                    var serv = xnc.getAdapter(services.RAMLService);
		                    var rps = facets ? xnc.allFacets() : serv.allRuntimeProperties();
		                    rps.forEach(function (rp) {
		                        var override = _.find(props, function (x) { return x.name() == rp.nameId(); });
		                        if (override) {
		                            var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, ("overriding " + name + " " + override.name() + " inherited from ") + t.value(), override);
		                            v.accept(i);
		                        }
		                    });
		                }
		            });
		        }
		    };
		    return OverridePropertyValidator;
		})();
		var CompositeNodeValidator = (function () {
		    function CompositeNodeValidator() {
		    }
		    CompositeNodeValidator.prototype.validate = function (node, v) {
		        if (!node.parent()) {
		            new RAMLVersionAndFragmentValidator().validate(node, v);
		            if (node.definition().key() == universes.Universe08.Api || node.definition().key() == universes.Universe10.Api) {
		                if (node.definition().universe().version() != "RAML08") {
		                    new OverloadingValidator().validateApi(node.wrapperNode(), v);
		                }
		            }
		            new ScalarQuoteValidator().validate(node, v);
		            lintNode(node, v);
		        }
		        new OverlayNodesValidator().validate(node, v);
		        var nc = node.definition();
		        if (nc instanceof typeSystem.AbstractType) {
		            var anc = nc;
		            if (nc.isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
		                //var tpes=anc.allSuperTypes();
		                new OverridePropertyValidator().validate(node, v);
		            }
		            if (anc.getAdapter(services.RAMLService).isRuntime()) {
		                new FixedFacetsValidator().validate(node, v);
		            }
		        }
		        checkPropertyQuard(node, v);
		        if (typeof node.value() == 'string' && !node.definition().getAdapter(services.RAMLService).allowValue()) {
		            if (node.parent()) {
		                var i = createIssue(9 /* NODE_HAS_VALUE */, "node " + node.name() + " can not be a scalar", node);
		                v.accept(i);
		            }
		        }
		        new RequiredPropertiesAndContextRequirementsValidator().validate(node, v);
		        new ValidateChildrenKeys().validate(node, v);
		        if (node.definition() && node.property() && node.property().nameId() == "types") {
		            new TypeExressionHierarchyValidator().validate(node, v);
		            new InheritanceRulesValidator().validate(node, v);
		        }
		    };
		    return CompositeNodeValidator;
		})();
		var OverlayNodesValidator = (function () {
		    function OverlayNodesValidator() {
		    }
		    OverlayNodesValidator.prototype.insideOfDeclaration = function (node) {
		        return node && (node.definition().getAdapter(services.RAMLService).isDeclaration() || this.insideOfDeclaration(node.parent()));
		    };
		    OverlayNodesValidator.prototype.isAllowedId = function (node) {
		        var r = node.root();
		        if (node.id() == "") {
		            return true;
		        }
		        if (r.definition().key() == universes.Universe10.Extension) {
		            return true;
		        }
		        if (r.isAuxilary()) {
		            if (node.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name && node.definition().key() == universes.Universe10.AnnotationTypeDeclaration) {
		                return true;
		            }
		            if (node.property().nameId() == universes.Universe10.LibraryBase.properties.types.name && node.definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name)) {
		                return true;
		            }
		            if (this.insideOfDeclaration(node)) {
		                var vl = node.computedValue("decls");
		                if (vl == "true") {
		                    return true;
		                }
		            }
		            if (r.knownIds()) {
		                var m = r.knownIds().hasOwnProperty(node.id());
		                if (!m) {
		                    if (node.parent() && node.parent().parent()) {
		                        if (this.isAllowedId(node.parent())) {
		                            return true;
		                        }
		                    }
		                }
		                return m;
		            }
		            if (node.parent() && node.parent().parent()) {
		                if (this.isAllowedId(node.parent())) {
		                    return true;
		                }
		            }
		            return false;
		        }
		        return true;
		    };
		    OverlayNodesValidator.prototype.validate = function (node, v) {
		        if (!this.isAllowedId(node)) {
		            if ((!node.property()) || node.property().nameId() != universes.Universe10.RAMLLanguageElement.properties.annotations.name) {
		                if (node.definition().key() != universes.Universe08.GlobalSchema && node.definition().key() != universes.Universe10.GlobalSchema) {
		                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "This node does not override any node from master api:" + node.id(), node);
		                    v.accept(i);
		                }
		            }
		        }
		    };
		    return OverlayNodesValidator;
		})();
		var ValidateChildrenKeys = (function () {
		    function ValidateChildrenKeys() {
		    }
		    ValidateChildrenKeys.prototype.validate = function (node, v) {
		        if (node.definition().universe().version() == "RAML08") {
		            var m = {};
		            var els = node.directChildren().filter(function (x) { return x.isElement(); });
		            els.forEach(function (x) {
		                if (x["_computed"]) {
		                    return;
		                }
		                if (!x.name()) {
		                    return; //handling nodes with no key (documentation)
		                }
		                var rm = x.lowLevel().parent() ? x.lowLevel().parent().end() : "";
		                var k = x.name() + rm;
		                if (m.hasOwnProperty(k)) {
		                    var i = createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, x.name() + " already exists in this context", x);
		                    v.accept(i);
		                }
		                else {
		                    m[k] = 1;
		                }
		            });
		        }
		        else {
		            var m = {};
		            var els = node.directChildren().filter(function (x) { return x.isElement(); });
		            els.forEach(function (x) {
		                if (x["_computed"]) {
		                    return;
		                }
		                if (!x.name()) {
		                    return; //handling nodes with no key (documentation)
		                }
		                if (allowOverride[x.property().nameId()]) {
		                    return;
		                }
		                var k = x.name() + x.property().nameId();
		                if (m.hasOwnProperty(k)) {
		                    var i = createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, x.name() + " already exists in this context", x);
		                    v.accept(i);
		                }
		                else {
		                    m[k] = 1;
		                }
		            });
		        }
		        var allLowlevel = node.lowLevel().children();
		        var mm = _.groupBy(allLowlevel, function (x) { return x.key(); });
		        var pr = node.directChildren().filter(function (x) { return x.isAttr(); });
		        var gr = _.groupBy(pr, function (x) { return x.name(); });
		        var all = node.directChildren();
		        var allG = _.groupBy(all, function (x) { return x.name(); });
		        var computedAnnotationsMultiplValues = false;
		        Object.keys(mm).forEach(function (x) {
		            if (x.charAt(0) !== '(' || mm[x].length < 2) {
		                return;
		            }
		            if (!computedAnnotationsMultiplValues) {
		                computedAnnotationsMultiplValues = true;
		                pr.forEach(function (z) {
		                    if (z.property().isAnnotation()) {
		                        var annotationRange = z.property().range();
		                        var attr = z;
		                        var refsTo = attr.findReferenceDeclaration();
		                        if (refsTo != null) {
		                            var refNode = refsTo;
		                            var multiple = refNode.attr("allowMultiple");
		                            if (multiple) {
		                                var mv = multiple.value();
		                                if (mv == 'true') {
		                                    delete mm[attr.lowLevel().key()];
		                                }
		                            }
		                        }
		                    }
		                });
		            }
		        });
		        Object.keys(mm).forEach(function (x) {
		            if (x) {
		                if (mm[x].length > 1 && !allG[x]) {
		                    var i = createIssue(4 /* PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE */, x + " should have a single value", node);
		                    i.start = mm[x][0].keyStart();
		                    i.end = mm[x][0].keyEnd();
		                    v.accept(i);
		                }
		            }
		        });
		        Object.keys(gr).forEach(function (x) {
		            if (gr[x].length > 1 && !gr[x][0].property().isMultiValue()) {
		                gr[x].forEach(function (y) {
		                    var i = createIssue(4 /* PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE */, y.property().nameId() + " should have a single value", y);
		                    v.accept(i);
		                });
		            }
		        });
		    };
		    return ValidateChildrenKeys;
		})();
		var InheritanceRulesValidator = (function () {
		    function InheritanceRulesValidator() {
		    }
		    InheritanceRulesValidator.prototype.isPrimitive = function (q) {
		        return !q.isArray() && !this.isObject(q) && !q.isUnion() && q.key() != universes.Universe10.TypeDeclaration;
		    };
		    InheritanceRulesValidator.prototype.isObject = function (q) {
		        return q.isAssignableFrom(universes.Universe10.ObjectTypeDeclaration.name);
		    };
		    InheritanceRulesValidator.prototype.validate = function (node, v) {
		        var _this = this;
		        var associatedType = node.associatedType();
		        if (!associatedType) {
		            if (_.find(node.definition().allSuperTypes(), function (x) { return x.key() == universes.Universe10.TypeDeclaration; })) {
		                associatedType = typeBuilder.typeFromNode(node);
		            }
		        }
		        if (associatedType) {
		            var st = associatedType.superTypes();
		            var nameMap = {};
		            st.forEach(function (x) {
		                nameMap[x.nameId()] = x;
		            });
		            var newSt = [];
		            for (var nm in nameMap) {
		                newSt.push(nameMap[nm]);
		            }
		            st = newSt;
		            if (st.length > 1) {
		                if (_.find(st, function (x) { return _this.isPrimitive(x); })) {
		                    if (_.find(st, function (x) { return _this.isObject(x); })) {
		                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit both from types of different kind", node.attr("type") ? node.attr("type") : node);
		                        v.accept(i);
		                        return;
		                    }
		                }
		                if (_.find(st, function (x) { return x.isArray(); })) {
		                    if (_.find(st, function (x) { return !x.isArray(); })) {
		                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit both from types of different kind", node.attr("type") ? node.attr("type") : node);
		                        v.accept(i);
		                        return;
		                    }
		                }
		                if (_.filter(st, function (x) { return _this.isPrimitive(x); }).length > 1) {
		                    var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit from two primitive types", node.attr("type") ? node.attr("type") : node);
		                    v.accept(i);
		                    return;
		                }
		            }
		        }
		    };
		    return InheritanceRulesValidator;
		})();
		//TODO REMOVE IT
		var buildIns = {
		    string: 1,
		    date: 1,
		    boolean: 1,
		    number: 1,
		    integer: 1,
		    object: 1,
		    array: 1,
		    union: 1,
		    file: 1,
		    value: 1,
		    any: 1,
		    scalar: 1
		};
		var TypeExressionHierarchyValidator = (function () {
		    function TypeExressionHierarchyValidator() {
		    }
		    TypeExressionHierarchyValidator.prototype.validate = function (node, cb) {
		        this._node = node;
		        try {
		            if (buildIns[node.name()]) {
		                var issue = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not redeclare build in types", node);
		                cb.accept(issue);
		            }
		            var at = node.attributes("type");
		            if (at) {
		                var found = false;
		                at.forEach(function (x) {
		                    if (x.value() == node.name()) {
		                        var issue = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", node.attr("type") ? node.attr("type") : node);
		                        cb.accept(issue);
		                        found = true;
		                    }
		                });
		                if (found) {
		                    return;
		                }
		            }
		            var cc = {};
		            cc[this._node.name()] = this.definition();
		            this.traverseDec(this.definition(), cb, 0, cc);
		        }
		        catch (e) {
		        }
		    };
		    TypeExressionHierarchyValidator.prototype.attr = function (name) {
		        return this._node.attr(name);
		    };
		    TypeExressionHierarchyValidator.prototype.definition = function () {
		        return this._node.definition();
		    };
		    /**
		     * !!!You cannot inherit from types of different kind at the same moment ( kinds are: union types, array types, object types, scalar types )
		     * !!!You cannot inherit from types extending union types ( ex: you cannot extend from Pet if Pet = Dog | Cat )
		     * You cannot inherit from multiple primitive types
		     * !!! You cannot inherit from a type that extends Array type
		     * Facets are always inherited
		     * You can fix a previously defined facet to a value if the facet is defined on a superclass
		     * Properties are only allowed on object types
		     * You cannot create cyclic dependencies when inheriting
		     * @param d
		     * @param v
		     * @param level
		     * @param visited
		     */
		    TypeExressionHierarchyValidator.prototype.traverseDec = function (d, v, level, visited) {
		        var _this = this;
		        if (visited === void 0) { visited = {}; }
		        if (!d) {
		            return;
		        }
		        if (d instanceof def.Array && level > 0) {
		            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Extending from types extending array types is not allowed", this.attr("type") ? this.attr("type") : this._node);
		            v.accept(i);
		            return;
		        }
		        if (d instanceof def.Union && level > 0) {
		            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Extending from types extending union types is not allowed", this.attr("type") ? this.attr("type") : this._node);
		            v.accept(i);
		            return;
		        }
		        if (visited[d.nameId()]) {
		            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", this.attr("type") ? this.attr("type") : this._node);
		            v.accept(i);
		            throw new Error();
		        }
		        visited[d.nameId()] = this.definition();
		        try {
		            if (d.nameId() == this._node.name() && level > 0) {
		                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", this.attr("type") ? this.attr("type") : this._node);
		                v.accept(i);
		                throw new Error();
		            }
		            if (d.isArray()) {
		                this.traverseDec(d.array().componentType(), v, level + 1, visited);
		                return;
		            }
		            if (d.isUnion()) {
		                var lleft = level + 1;
		                var lright = level + 1;
		                var union = d.union();
		                if (union.leftType()) {
		                    if (union.leftType().isUnion()) {
		                        var ul = union.leftType().union();
		                        if (union.getAdapter(services.RAMLService).getDeclaringNode() == ul.getAdapter(services.RAMLService).getDeclaringNode()) {
		                        }
		                    }
		                }
		                if (union.rightType()) {
		                    if (union.rightType().isUnion()) {
		                        var ul = union.rightType().union();
		                        if (union.getAdapter(services.RAMLService).getDeclaringNode() == ul.getAdapter(services.RAMLService).getDeclaringNode()) {
		                            lright = level;
		                        }
		                    }
		                }
		                if (lleft == level + 1) {
		                    this.traverseDec(union.leftType(), v, lleft, visited);
		                }
		                if (lright == level + 1) {
		                    this.traverseDec(union.rightType(), v, lright, visited);
		                }
		                return;
		            }
		            var mn = d.allSuperTypes();
		            mn.forEach(function (yy) {
		                if (yy instanceof defs.AbstractType) {
		                    var node = yy.getDeclaringNode();
		                    if (node || yy instanceof defs.Array || yy instanceof defs.Union) {
		                        _this.traverseDec(yy, v, level + 1, visited);
		                    }
		                }
		            });
		        }
		        finally {
		            delete visited[d.nameId()];
		        }
		    };
		    return TypeExressionHierarchyValidator;
		})();
		/**
		 * validates examples
		 */
		var ExampleValidator = (function () {
		    function ExampleValidator() {
		    }
		    ExampleValidator.prototype.validate = function (node, cb) {
		        //check if we expect to do strict validation
		        var strictValidation = this.isStrict(node);
		        if (!strictValidation) {
		            if (!settings.validateNotStrictExamples) {
		                return;
		            }
		        }
		        var pObj = this.parseObject(node, cb, strictValidation);
		        if (!pObj) {
		            return;
		        }
		        var schema = this.aquireSchema(node);
		        if (schema) {
		            schema.validate(pObj, cb, strictValidation);
		        }
		    };
		    ExampleValidator.prototype.isExampleNode = function (node) {
		        return this.isSingleExampleNode(node) || this.isExampleNodeInMultipleDecl(node);
		    };
		    ExampleValidator.prototype.isSingleExampleNode = function (node) {
		        return node.name() == universes.Universe10.TypeDeclaration.properties.example.name;
		    };
		    ExampleValidator.prototype.isExampleNodeInMultipleDecl = function (node) {
		        var parent = node.parent();
		        if (parent) {
		            return universeHelpers.isExampleSpecType(parent.definition());
		        }
		        return false;
		    };
		    ExampleValidator.prototype.findParentSchemaOrTypeAttribute = function (node) {
		        var attribute = node.parent().attr(universes.Universe10.TypeDeclaration.properties.schema.name);
		        if (attribute) {
		            return attribute;
		        }
		        attribute = node.parent().attr(universes.Universe10.TypeDeclaration.properties.type.name);
		        if (attribute) {
		            return attribute;
		        }
		        if (!node.parent()) {
		            return null;
		        }
		        attribute = node.parent().parent().attr(universes.Universe10.TypeDeclaration.properties.schema.name);
		        if (attribute) {
		            return attribute;
		        }
		        attribute = node.parent().parent().attr(universes.Universe10.TypeDeclaration.properties.type.name);
		        if (attribute) {
		            return attribute;
		        }
		        return null;
		    };
		    ExampleValidator.prototype.aquireSchema = function (node) {
		        var sp = node.parent().definition().isAssignableFrom(universes.Universe10.TypeDeclaration.name);
		        if (this.isExampleNode(node)) {
		            var sampleRoot = node;
		            if (this.isExampleNodeInMultipleDecl(node)) {
		                sampleRoot = node.parent();
		            }
		            if (sampleRoot.parent().property().nameId() == universes.Universe10.LibraryBase.properties.types.name) {
		                sp = false;
		            }
		            if (sampleRoot.parent().parent()) {
		                var ppc = sampleRoot.parent().parent().definition().key();
		                if (ppc == universes.Universe08.Method || ppc == universes.Universe10.Method) {
		                    if (sampleRoot.parent().property().nameId() == universes.Universe10.Method.properties.queryParameters.name) {
		                    }
		                    else {
		                        sp = true;
		                    }
		                }
		                if (ppc == universes.Universe08.Response || ppc == universes.Universe10.Response) {
		                    sp = true;
		                }
		            }
		        }
		        if (node.parent().definition().key() == universes.Universe08.BodyLike || sp) {
		            //FIXME MULTIPLE INHERITANCE
		            var sa = this.findParentSchemaOrTypeAttribute(node);
		            if (sa) {
		                var val = sa.value();
		                if (val instanceof hlimpl.StructuredValue) {
		                    return null;
		                }
		                var strVal = ("" + val).trim();
		                var so = null;
		                if (strVal.charAt(0) == "{") {
		                    try {
		                        so = su.getJSONSchema(strVal);
		                    }
		                    catch (e) {
		                        return null;
		                    }
		                }
		                if (strVal.charAt(0) == "<") {
		                    try {
		                        so = su.getXMLSchema(strVal);
		                    }
		                    catch (e) {
		                        return null;
		                    }
		                }
		                if (so) {
		                    return {
		                        validate: function (pObje, cb, strict) {
		                            try {
		                                so.validateObject(pObje);
		                            }
		                            catch (e) {
		                                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Example does not conforms to schema:" + e.message, node, !strict));
		                                return;
		                            }
		                            //validate using classical schema;
		                        }
		                    };
		                }
		                else {
		                    //lets try to get schema from type
		                    if (strVal.length > 0) {
		                        var tp = typeExpression.getType2(node.parent(), strVal, {});
		                        if (tp) {
		                            return {
		                                validate: function (pObje, cb, strict) {
		                                    new TypeValidator(node).validate(pObje, tp, cb, strict);
		                                    //validate using typeExpression;
		                                }
		                            };
		                        }
		                    }
		                }
		            }
		        }
		        return this.getSchemaFromModel(node);
		    };
		    ExampleValidator.prototype.getSchemaFromModel = function (node) {
		        var p = node.parent();
		        if (node.property().nameId() == universes.Universe10.ExampleSpec.properties.content.name) {
		            p = p.parent();
		        }
		        var tp = typeBuilder.typeFromNode(p);
		        if (tp) {
		            return {
		                validate: function (pObje, cb, strict) {
		                    new TypeValidator(node).validate(pObje, tp, cb, strict);
		                    //validate using typeExpression;
		                }
		            };
		        }
		        return null;
		    };
		    ExampleValidator.prototype.toObject = function (h, v, cb) {
		        var res = v.lowLevel().dumpToObject(true);
		        this.testDublication(h, v.lowLevel(), cb);
		        if (res["example"]) {
		            return res["example"];
		        }
		        if (res["content"]) {
		            return res["content"];
		        }
		    };
		    ExampleValidator.prototype.testDublication = function (h, v, cb) {
		        var _this = this;
		        var map = {};
		        v.children().forEach(function (x) {
		            if (x.key()) {
		                if (map[x.key()]) {
		                    cb.accept(createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "Keys should be unique", new hlimpl.BasicASTNode(x, h.parent())));
		                }
		                map[x.key()] = x;
		            }
		            _this.testDublication(h, x, cb);
		        });
		    };
		    ExampleValidator.prototype.parseObject = function (node, cb, strictValidation) {
		        var pObj = null;
		        var vl = node.value();
		        var mediaType = getMediaType(node);
		        if (vl instanceof hlimpl.StructuredValue) {
		            //validate in context of type/schema
		            pObj = this.toObject(node, vl, cb);
		        }
		        else {
		            if (mediaType) {
		                if (isJson(mediaType)) {
		                    try {
		                        pObj = JSON.parse(vl);
		                    }
		                    catch (e) {
		                        cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse JSON:" + e.message, node, !strictValidation));
		                        return;
		                    }
		                }
		                if (isXML(mediaType)) {
		                    try {
		                        pObj = xmlutil(vl);
		                    }
		                    catch (e) {
		                        cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse XML:" + e.message, node, !strictValidation));
		                        return;
		                    }
		                }
		            }
		            else {
		                try {
		                    pObj = JSON.parse(vl);
		                }
		                catch (e) {
		                    if (vl.trim().indexOf("<") == 0) {
		                        try {
		                            pObj = xmlutil(vl);
		                        }
		                        catch (e) {
		                            cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse XML:" + e.message, node, !strictValidation));
		                            return;
		                        }
		                    }
		                    else {
		                        //cb.accept(createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse JSON:" + e.message, node, !strictValidation));
		                        return vl;
		                    }
		                }
		            }
		        }
		        return pObj;
		    };
		    ExampleValidator.prototype.isStrict = function (node) {
		        var strictValidation = false;
		        var strict = node.parent().attr("strict");
		        if (strict) {
		            if (strict.value() == 'true') {
		                strictValidation = true;
		            }
		        }
		        return strictValidation;
		    };
		    return ExampleValidator;
		})();
		exports.ExampleValidator = ExampleValidator;
		function isJson(s) {
		    return s.indexOf("json") != -1;
		}
		function isXML(s) {
		    return s.indexOf("xml") != -1;
		}
		function getMediaType(node) {
		    var vl = getMediaType2(node);
		    if (vl == 'body') {
		        var rootMedia = node.root().attr("mediaType");
		        if (rootMedia) {
		            return rootMedia.value();
		        }
		        return null;
		    }
		    return vl;
		}
		function getMediaType2(node) {
		    if (node.parent()) {
		        var pc = node.parent().definition();
		        if (pc.key() == universes.Universe08.BodyLike) {
		            return node.parent().name();
		        }
		        if (node.parent().parent()) {
		            var ppc = node.parent().parent().definition().key();
		            if (ppc == universes.Universe08.Response || ppc == universes.Universe10.Response) {
		                if (node.parent().property().nameId() == universes.Universe08.Response.properties.headers.name) {
		                    return null;
		                }
		                return node.parent().name();
		            }
		            if (ppc == universes.Universe08.Method || ppc == universes.Universe10.Method) {
		                if (node.parent().property().nameId() == universes.Universe10.Method.properties.queryParameters.name || node.parent().property().nameId() == universes.Universe10.Method.properties.headers.name) {
		                    return null;
		                }
		                return node.parent().name();
		            }
		        }
		    }
		    return null;
		}
		var localError = function (node, c, w, message, p, prop) {
		    var st = node.lowLevel().start();
		    var et = node.lowLevel().end();
		    if (node.lowLevel().key() && node.lowLevel().keyStart()) {
		        var ks = node.lowLevel().keyStart();
		        if (ks > 0) {
		            st = ks;
		        }
		        var ke = node.lowLevel().keyEnd();
		        if (ke > 0) {
		            et = ke;
		        }
		    }
		    if (et < st) {
		        et = st + 1; //FIXME
		    }
		    if (prop && !prop.getAdapter(services.RAMLPropertyService).isMerged() && node.parent() == null) {
		        var nm = _.find(node.lowLevel().children(), function (x) { return x.key() == prop.nameId(); });
		        if (nm) {
		            var ks = nm.keyStart();
		            var ke = nm.keyEnd();
		            if (ks > 0 && ke > ks) {
		                st = ks;
		                et = ke;
		            }
		        }
		    }
		    return {
		        code: c,
		        isWarning: w,
		        message: message,
		        node: node,
		        start: st,
		        end: et,
		        path: p ? (node.lowLevel().unit() ? node.lowLevel().unit().path() : "") : null,
		        extras: [],
		        unit: node ? node.lowLevel().unit() : null
		    };
		};
		function createIssue(c, message, node, w) {
		    if (w === void 0) { w = false; }
		    //console.log(node.name()+node.lowLevel().start()+":"+node.id());
		    var original = null;
		    var pr = null;
		    if (node) {
		        pr = node.property();
		        if (node.lowLevel().unit() != node.root().lowLevel().unit()) {
		            original = localError(node, c, w, message, true, pr);
		            var v = node.lowLevel().unit();
		            if (v) {
		                message = message + " " + v.path();
		            }
		            while (node.lowLevel().unit() != node.root().lowLevel().unit()) {
		                pr = node.property();
		                node = node.parent();
		            }
		        }
		    }
		    if (original) {
		        if (node.property() && node.property().nameId() == universes.Universe10.LibraryBase.properties.uses.name && node.parent() != null) {
		            pr = node.property(); //FIXME there should be other cases
		            node = node.parent();
		        }
		    }
		    var error = localError(node, c, w, message, false, pr);
		    if (original) {
		        error.extras.push(original);
		    }
		    //console.log(error.start+":"+error.end)
		    return error;
		}
		exports.createIssue = createIssue;


	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var xmlutil = __webpack_require__(57);
		var lru = __webpack_require__(59);
		var ZSchema = __webpack_require__(60);
		var ValidationResult = (function () {
		    function ValidationResult() {
		    }
		    return ValidationResult;
		})();
		exports.ValidationResult = ValidationResult;
		var globalCache = lru(400);
		var useLint = true;
		var JSONSchemaObject = (function () {
		    function JSONSchemaObject(schema) {
		        this.schema = schema;
		        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
		            throw new Error("Invalid JSON schema content");
		        }
		        var jsonSchemaObject;
		        try {
		            var jsonSchemaObject = JSON.parse(schema);
		        }
		        catch (err) {
		            throw new Error("It is not JSON schema");
		        }
		        if (!jsonSchemaObject) {
		            return;
		        }
		        try {
		            var api = __webpack_require__(61);
		            jsonSchemaObject = api.v4(jsonSchemaObject);
		        }
		        catch (e) {
		            throw new Error('Can not parse schema' + schema);
		        }
		        delete jsonSchemaObject['$schema'];
		        delete jsonSchemaObject['required'];
		        this.jsonSchema = jsonSchemaObject;
		    }
		    JSONSchemaObject.prototype.getType = function () {
		        return "source.json";
		    };
		    JSONSchemaObject.prototype.validateObject = function (object) {
		        //TODO Validation of objects
		        //xmlutil(content);
		        this.validate(JSON.stringify(object));
		    };
		    JSONSchemaObject.prototype.validate = function (content) {
		        var key = content + this.schema;
		        var c = globalCache.get(key);
		        if (c) {
		            if (c instanceof Error) {
		                throw c;
		            }
		            return;
		        }
		        var validator = new ZSchema();
		        var valid = validator.validate(JSON.parse(content), this.jsonSchema);
		        var errors = validator.getLastErrors();
		        if (errors && errors.length > 0) {
		            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message + " " + x.params; }).join(", "));
		            res.errors = errors;
		            globalCache.set(key, res);
		            throw res;
		        }
		        globalCache.set(key, 1);
		    };
		    return JSONSchemaObject;
		})();
		exports.JSONSchemaObject = JSONSchemaObject;
		var XMLSchemaObject = (function () {
		    function XMLSchemaObject(schema) {
		        this.schema = schema;
		        if (schema.charAt(0) != '<') {
		            throw new Error("Invalid JSON schema");
		        }
		        xmlutil(schema);
		    }
		    XMLSchemaObject.prototype.getType = function () {
		        return "text.xml";
		    };
		    XMLSchemaObject.prototype.validate = function (content) {
		        xmlutil(content);
		    };
		    XMLSchemaObject.prototype.validateObject = function (object) {
		        //TODO Validation of objects
		        //xmlutil(content);
		    };
		    return XMLSchemaObject;
		})();
		exports.XMLSchemaObject = XMLSchemaObject;
		function getJSONSchema(content) {
		    var rs = useLint ? globalCache.get(content) : false;
		    if (rs) {
		        return rs;
		    }
		    var res = new JSONSchemaObject(content);
		    globalCache.set(content, res);
		    return res;
		}
		exports.getJSONSchema = getJSONSchema;
		function getXMLSchema(content) {
		    var rs = useLint ? globalCache.get(content) : false;
		    if (rs) {
		        return rs;
		    }
		    var res = new XMLSchemaObject(content);
		    if (useLint) {
		        globalCache.set(content, res);
		    }
		}
		exports.getXMLSchema = getXMLSchema;
		function createSchema(content) {
		    var rs = useLint ? globalCache.get(content) : false;
		    if (rs) {
		        return rs;
		    }
		    try {
		        var res = new JSONSchemaObject(content);
		        if (useLint) {
		            globalCache.set(content, res);
		        }
		        return res;
		    }
		    catch (e) {
		        try {
		            var res = new XMLSchemaObject(content);
		            if (useLint) {
		                globalCache.set(content, res);
		            }
		            return res;
		        }
		        catch (e) {
		            if (useLint) {
		                globalCache.set(content, new Error("Can not parse schema"));
		            }
		            return null;
		        }
		    }
		}
		exports.createSchema = createSchema;


	/***/ },
	/* 57 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var DomParser = __webpack_require__(58);
		function xmlToJson(xml) {
		    // Create the return object
		    var obj = {};
		    if (xml.nodeType == 1) {
		        // do attributes
		        if (xml.attributes.length > 0) {
		            for (var j = 0; j < xml.attributes.length; j++) {
		                var attribute = xml.attributes.item(j);
		                obj["@" + attribute.nodeName] = attribute.nodeValue;
		            }
		        }
		    }
		    else if (xml.nodeType == 3) {
		        obj = xml.nodeValue;
		    }
		    // do children
		    if (xml.hasChildNodes()) {
		        for (var i = 0; i < xml.childNodes.length; i++) {
		            var item = xml.childNodes.item(i);
		            var nodeName = item.nodeName;
		            if (nodeName == undefined) {
		                continue;
		            }
		            if (typeof (obj[nodeName]) == "undefined") {
		                obj[nodeName] = xmlToJson(item);
		            }
		            else {
		                if (typeof (obj[nodeName].push) == "undefined") {
		                    var old = obj[nodeName];
		                    obj[nodeName] = [];
		                    obj[nodeName].push(old);
		                }
		                obj[nodeName].push(xmlToJson(item));
		            }
		        }
		    }
		    return obj;
		}
		;
		function cleanupText(j) {
		    for (var p in j) {
		        if (typeof (j[p]) == "object") {
		            for (var k in j[p]) {
		                if (k == '#text') {
		                    var txt = j[p]['#text'];
		                    if (typeof (txt) != 'string') {
		                        txt = txt.join("");
		                    }
		                    txt = txt.trim();
		                    if (txt.length == 0) {
		                        delete j[p]['#text'];
		                    }
		                }
		            }
		            cleanupText(j[p]);
		        }
		    }
		    return j;
		}
		function cleanupJson(j) {
		    for (var p in j) {
		        if (typeof (j[p]) == "object") {
		            var keys = Object.keys(j[p]);
		            if (keys.length == 1) {
		                if (keys[0] == '#text') {
		                    j[p] = j[p]['#text'];
		                }
		            }
		            cleanupJson(j[p]);
		        }
		    }
		    return j;
		}
		function parseXML(value) {
		    var v = new DomParser.DOMParser();
		    var parsed = v.parseFromString(value);
		    return cleanupJson(cleanupText(xmlToJson(parsed)));
		}
		module.exports = parseXML;


	/***/ },
	/* 58 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(11);

	/***/ },
	/* 59 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(14);

	/***/ },
	/* 60 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(15);

	/***/ },
	/* 61 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(32);

	/***/ },
	/* 62 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var universe = __webpack_require__(54);
		/////////////////////// properties
		function isDocumentationProperty(p) {
		    return p.nameId() === universe.Universe10.Api.properties.documentation.name || p.nameId() === universe.Universe08.Api.properties.documentation.name;
		}
		exports.isDocumentationProperty = isDocumentationProperty;
		function isUsageProperty(p) {
		    return p.nameId() === universe.Universe10.Trait.properties.usage.name || p.nameId() === universe.Universe08.Trait.properties.usage.name || p.nameId() === universe.Universe10.ResourceType.properties.usage.name || p.nameId() === universe.Universe08.ResourceType.properties.usage.name || p.nameId() === universe.Universe10.Library.properties.usage.name || p.nameId() === universe.Universe10.Overlay.properties.usage.name || p.nameId() === universe.Universe10.Extension.properties.usage.name;
		}
		exports.isUsageProperty = isUsageProperty;
		function isDescriptionProperty(p) {
		    return p.nameId() === universe.Universe10.TypeDeclaration.properties.description.name || p.nameId() === universe.Universe10.RAMLLanguageElement.properties.description.name || p.nameId() === universe.Universe08.RAMLLanguageElement.properties.description.name || p.nameId() === "description";
		    //TODO too long to actually list every element having a description, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
		}
		exports.isDescriptionProperty = isDescriptionProperty;
		function isDisplayNameProperty(p) {
		    return p.nameId() === universe.Universe10.TypeDeclaration.properties.displayName.name || p.nameId() === universe.Universe10.RAMLLanguageElement.properties.displayName.name || p.nameId() === "displayName";
		    //TODO too long to actually list every element having displayname, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
		}
		exports.isDisplayNameProperty = isDisplayNameProperty;
		function isTitleProperty(p) {
		    return p.nameId() === universe.Universe10.Api.properties.title.name || p.nameId() === universe.Universe08.Api.properties.title.name || p.nameId() === universe.Universe10.DocumentationItem.properties.title.name || p.nameId() === universe.Universe08.DocumentationItem.properties.title.name || p.nameId() === universe.Universe10.Overlay.properties.title.name || p.nameId() === universe.Universe10.Extension.properties.title.name;
		}
		exports.isTitleProperty = isTitleProperty;
		function isAnnotationsProperty(p) {
		    return p.nameId() === universe.Universe10.Api.properties.annotations.name || p.nameId() === universe.Universe10.Method.properties.annotations.name || p.nameId() === universe.Universe10.Resource.properties.annotations.name || p.nameId() === universe.Universe10.RAMLLanguageElement.properties.annotations.name || p.nameId() === universe.Universe10.ExampleSpec.properties.annotations.name || p.nameId() === universe.Universe10.TypeDeclaration.properties.annotations.name || p.nameId() === universe.Universe10.Response.properties.annotations.name;
		}
		exports.isAnnotationsProperty = isAnnotationsProperty;
		function isIsProperty(p) {
		    return p.nameId() === universe.Universe10.MethodBase.properties.is.name || p.nameId() === universe.Universe08.MethodBase.properties.is.name || p.nameId() === universe.Universe10.ResourceBase.properties.is.name || p.nameId() === universe.Universe08.ResourceType.properties.is.name || p.nameId() === universe.Universe08.Resource.properties.is.name;
		}
		exports.isIsProperty = isIsProperty;
		function isSecuredByProperty(p) {
		    return p.nameId() === universe.Universe10.Api.properties.securedBy.name || p.nameId() === universe.Universe08.Api.properties.securedBy.name || p.nameId() === universe.Universe10.MethodBase.properties.securedBy.name || p.nameId() === universe.Universe08.MethodBase.properties.securedBy.name || p.nameId() === universe.Universe08.ResourceType.properties.securedBy.name || p.nameId() === universe.Universe10.Method.properties.securedBy.name || p.nameId() === universe.Universe08.Method.properties.securedBy.name || p.nameId() === universe.Universe08.Resource.properties.securedBy.name || p.nameId() === universe.Universe10.ResourceBase.properties.securedBy.name;
		}
		exports.isSecuredByProperty = isSecuredByProperty;
		function isTypeProperty(p) {
		    return p.nameId() === universe.Universe10.AbstractSecurityScheme.properties.type.name || p.nameId() === universe.Universe08.SecuritySchema.properties.type.name || p.nameId() === universe.Universe08.ResourceType.properties.type.name || p.nameId() === universe.Universe08.Resource.properties.type.name || p.nameId() === universe.Universe08.Parameter.properties.type.name || p.nameId() === universe.Universe10.MimeTypeModel.properties.type.name || p.nameId() === universe.Universe08.MimeTypeModel.properties.type.name || p.nameId() === universe.Universe10.ApiDescription.properties.type.name || p.nameId() === universe.Universe10.ResourceBase.properties.type.name || p.nameId() === universe.Universe10.TypeDeclaration.properties.type.name;
		}
		exports.isTypeProperty = isTypeProperty;
		function isProtocolsProperty(p) {
		    return p.nameId() === universe.Universe10.Api.properties.protocols.name || p.nameId() === universe.Universe08.Api.properties.protocols.name || p.nameId() === universe.Universe08.Method.properties.protocols.name || p.nameId() === universe.Universe10.MethodBase.properties.protocols.name;
		}
		exports.isProtocolsProperty = isProtocolsProperty;
		function isNameProperty(p) {
		    return p.nameId() === universe.Universe10.TypeDeclaration.properties.name.name || p.nameId() === universe.Universe10.TypeDeclaration.properties.name.name || p.nameId() === universe.Universe08.SecuritySchema.properties.name.name || p.nameId() === universe.Universe10.AbstractSecurityScheme.properties.name.name || p.nameId() === universe.Universe08.Trait.properties.name.name || p.nameId() === universe.Universe10.Trait.properties.name.name || p.nameId() === "name";
		    //TODO too long to actually list every element having a name, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
		}
		exports.isNameProperty = isNameProperty;
		function isBodyProperty(p) {
		    return p.nameId() === universe.Universe10.MethodBase.properties.body.name || p.nameId() === universe.Universe08.MethodBase.properties.body.name || p.nameId() === universe.Universe10.Response.properties.body.name || p.nameId() === universe.Universe08.Response.properties.body.name || p.nameId() === universe.Universe10.Method.properties.body.name;
		}
		exports.isBodyProperty = isBodyProperty;
		function isSchemaProperty(p) {
		    return p.nameId() === universe.Universe08.BodyLike.properties.schema.name || p.nameId() === universe.Universe08.XMLBody.properties.schema.name || p.nameId() === universe.Universe08.JSONBody.properties.schema.name || p.nameId() === universe.Universe10.TypeDeclaration.properties.schema.name;
		}
		exports.isSchemaProperty = isSchemaProperty;
		function isSignatureProperty(p) {
		    return p.nameId() === universe.Universe10.Method.properties.signature.name || p.nameId() === universe.Universe10.Resource.properties.signature.name;
		}
		exports.isSignatureProperty = isSignatureProperty;
		function isResourcesProperty(p) {
		    return p.nameId() === universe.Universe10.Api.properties.resources.name || p.nameId() === universe.Universe08.Api.properties.resources.name || p.nameId() === universe.Universe10.Resource.properties.resources.name || p.nameId() === universe.Universe08.Resource.properties.resources.name;
		}
		exports.isResourcesProperty = isResourcesProperty;
		function isTypesProperty(p) {
		    return p.nameId() === universe.Universe10.LibraryBase.properties.types.name;
		}
		exports.isTypesProperty = isTypesProperty;
		function isExampleProperty(p) {
		    return p.nameId() === universe.Universe10.TypeDeclaration.properties.example.name || p.nameId() === "example";
		    //TODO too long to actually list every element having an example, so a couple of checks to cause compile error, and a simple equals check. Also we do not want to affect performance that much.
		}
		exports.isExampleProperty = isExampleProperty;
		function isValueProperty(p) {
		    return p.nameId() === universe.Universe10.GlobalSchema.properties.value.name || p.nameId() === universe.Universe08.GlobalSchema.properties.value.name || p.nameId() === universe.Universe10.ImportDeclaration.properties.value.name;
		}
		exports.isValueProperty = isValueProperty;
		function isUriParametersProperty(p) {
		    return p.nameId() === universe.Universe08.Api.properties.uriParameters.name || p.nameId() === universe.Universe08.ResourceType.properties.uriParameters.name || p.nameId() === universe.Universe08.Resource.properties.uriParameters.name || p.nameId() === universe.Universe10.ResourceBase.properties.uriParameters.name;
		}
		exports.isUriParametersProperty = isUriParametersProperty;
		function isBaseUriParametersProperty(p) {
		    return p.nameId() === universe.Universe08.Resource.properties.baseUriParameters.name || p.nameId() === universe.Universe08.Api.properties.baseUriParameters.name || p.nameId() === universe.Universe10.Api.properties.baseUriParameters.name;
		}
		exports.isBaseUriParametersProperty = isBaseUriParametersProperty;
		function isUsesProperty(p) {
		    return p.nameId() === universe.Universe10.LibraryBase.properties.uses.name || p.nameId() === universe.Universe10.Trait.properties.uses.name || p.nameId() === universe.Universe10.ResourceType.properties.uses.name || p.nameId() === universe.Universe10.ResourceTypeOrTrait.properties.uses.name;
		}
		exports.isUsesProperty = isUsesProperty;
		/////////////////////// types
		function isMethodType(type) {
		    return type.key() == universe.Universe10.Method || type.key() == universe.Universe08.Method;
		}
		exports.isMethodType = isMethodType;
		function isApiType(type) {
		    return type.key() == universe.Universe10.Api || type.key() == universe.Universe08.Api;
		}
		exports.isApiType = isApiType;
		function isBooleanTypeType(type) {
		    return type.key() == universe.Universe10.BooleanType || type.key() == universe.Universe08.BooleanType;
		}
		exports.isBooleanTypeType = isBooleanTypeType;
		function isMarkdownStringType(type) {
		    return type.key() == universe.Universe10.MarkdownString || type.key() == universe.Universe08.MarkdownString;
		}
		exports.isMarkdownStringType = isMarkdownStringType;
		function isResourceType(type) {
		    return type.key() == universe.Universe10.Resource || type.key() == universe.Universe08.Resource;
		}
		exports.isResourceType = isResourceType;
		function isTraitType(type) {
		    return type.key() == universe.Universe10.Trait || type.key() == universe.Universe08.Trait;
		}
		exports.isTraitType = isTraitType;
		function isGlobalSchemaType(type) {
		    return type.key() == universe.Universe10.GlobalSchema || type.key() == universe.Universe08.GlobalSchema;
		}
		exports.isGlobalSchemaType = isGlobalSchemaType;
		function isSecuritySchemaType(type) {
		    return type.key() == universe.Universe10.AbstractSecurityScheme || type.key() == universe.Universe08.SecuritySchema;
		}
		exports.isSecuritySchemaType = isSecuritySchemaType;
		function isTypeDeclarationType(type) {
		    return type.key() == universe.Universe10.TypeDeclaration;
		}
		exports.isTypeDeclarationType = isTypeDeclarationType;
		function isResponseType(type) {
		    return type.key() == universe.Universe10.Response || type.key() == universe.Universe08.Response;
		}
		exports.isResponseType = isResponseType;
		function isBodyLikeType(type) {
		    return type.key() == universe.Universe08.BodyLike;
		}
		exports.isBodyLikeType = isBodyLikeType;
		function isOverlayType(type) {
		    return type.key() == universe.Universe10.Overlay;
		}
		exports.isOverlayType = isOverlayType;
		function isAnnotationTypeType(type) {
		    return type.key() == universe.Universe10.AnnotationTypeDeclaration;
		}
		exports.isAnnotationTypeType = isAnnotationTypeType;
		function isResourceTypeType(type) {
		    return type.key() == universe.Universe10.ResourceType || type.key() == universe.Universe08.ResourceType;
		}
		exports.isResourceTypeType = isResourceTypeType;
		function isSchemaStringType(type) {
		    return type.key() == universe.Universe10.SchemaString || type.key() == universe.Universe08.SchemaString;
		}
		exports.isSchemaStringType = isSchemaStringType;
		function isMethodBaseType(type) {
		    return type.key() == universe.Universe10.MethodBase || type.key() == universe.Universe08.MethodBase;
		}
		exports.isMethodBaseType = isMethodBaseType;
		function isPointerType(type) {
		    return type.key() == universe.Universe10.pointer;
		}
		exports.isPointerType = isPointerType;
		function isRamlExpressionType(type) {
		    return false;
		}
		exports.isRamlExpressionType = isRamlExpressionType;
		function isRamlSelectorType(type) {
		    return type.key() == universe.Universe10.RAMLSelector;
		}
		exports.isRamlSelectorType = isRamlSelectorType;
		function isLibraryType(type) {
		    return type.key() == universe.Universe10.Library;
		}
		exports.isLibraryType = isLibraryType;
		function isStringTypeType(type) {
		    return type.key() == universe.Universe10.StringType || type.key() == universe.Universe08.StringType;
		}
		exports.isStringTypeType = isStringTypeType;
		function isExampleSpecType(type) {
		    return type.key() == universe.Universe10.ExampleSpec;
		}
		exports.isExampleSpecType = isExampleSpecType;


	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/underscore/underscore.d.ts" />
		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var _ = __webpack_require__(4);
		var extraInjections = [];
		function registerInjector(i) {
		    extraInjections.push(i);
		}
		exports.registerInjector = registerInjector;
		var Adaptable = (function () {
		    function Adaptable() {
		        var _this = this;
		        this.adapters = [];
		        extraInjections.forEach(function (x) { return x.inject(_this); });
		    }
		    Adaptable.prototype.addAdapter = function (q) {
		        this.adapters.push(q);
		    };
		    Adaptable.prototype.getAdapter = function (adapterType) {
		        var result = null;
		        this.adapters.forEach(function (x) {
		            if (x instanceof adapterType) {
		                result = x;
		            }
		        });
		        return result;
		    };
		    return Adaptable;
		})();
		exports.Adaptable = Adaptable;
		var Described = (function (_super) {
		    __extends(Described, _super);
		    function Described(_name, _description) {
		        if (_description === void 0) { _description = ""; }
		        _super.call(this);
		        this._name = _name;
		        this._description = _description;
		        this._tags = [];
		        this._annotations = [];
		    }
		    Described.prototype.nameId = function () {
		        return this._name;
		    };
		    Described.prototype.description = function () {
		        return this._description;
		    };
		    Described.prototype.addAnnotation = function (a) {
		        this._annotations.push(a);
		    };
		    Described.prototype.removeAnnotation = function (a) {
		        this._annotations = this._annotations.filter(function (x) { return x != a; });
		    };
		    Described.prototype.annotations = function () {
		        return [].concat(this._annotations);
		    };
		    Described.prototype.tags = function () {
		        return this._tags;
		    };
		    Described.prototype.withDescription = function (d) {
		        this._description = d;
		        return this;
		    };
		    return Described;
		})(Adaptable);
		exports.Described = Described;
		var ValueRequirement = (function () {
		    /**
		     *
		     * @param name name of the property to discriminate
		     * @param value expected value of discriminating property
		     */
		    function ValueRequirement(name, value) {
		        this.name = name;
		        this.value = value;
		    }
		    return ValueRequirement;
		})();
		exports.ValueRequirement = ValueRequirement;
		var Annotation = (function (_super) {
		    __extends(Annotation, _super);
		    function Annotation(type, parameters) {
		        _super.call(this, type.nameId());
		        this.type = type;
		        this.parameters = parameters;
		    }
		    Annotation.prototype.parameterNames = function () {
		        return Object.keys(this.parameters);
		    };
		    Annotation.prototype.parameter = function (name) {
		        return this.parameters[name];
		    };
		    Annotation.prototype.getType = function () {
		        return this.type;
		    };
		    return Annotation;
		})(Described);
		exports.Annotation = Annotation;
		var AbstractType = (function (_super) {
		    __extends(AbstractType, _super);
		    function AbstractType(_name, _universe, _path) {
		        if (_universe === void 0) { _universe = null; }
		        if (_path === void 0) { _path = ""; }
		        _super.call(this, _name);
		        this._universe = _universe;
		        this._path = _path;
		        this._superTypes = [];
		        this._subTypes = [];
		        this._requirements = [];
		        this.fixedFacets = {};
		        this.uc = false;
		    }
		    AbstractType.prototype.properties = function () {
		        return [];
		    };
		    AbstractType.prototype.printDetails = function () {
		        var result = "";
		        result += this.nameId() + "\n";
		        this.properties().forEach(function (property) {
		            result += "  " + property.nameId() + ":" + property.range() + "\n";
		        });
		        return result;
		    };
		    AbstractType.prototype.allFacets = function (ps) {
		        if (ps === void 0) { ps = {}; }
		        if (this._allFacets) {
		            return this._allFacets;
		        }
		        if (ps[this.nameId()]) {
		            return [];
		        }
		        ps[this.typeId()] = this;
		        var n = {};
		        if (this.superTypes().length > 0) {
		            this.superTypes().forEach(function (x) {
		                if (x instanceof AbstractType) {
		                    x.allFacets(ps).forEach(function (y) { return n[y.nameId()] = y; });
		                }
		            });
		        }
		        this.properties().forEach(function (x) { return n[x.nameId()] = x; });
		        this._allFacets = Object.keys(n).map(function (x) { return n[x]; });
		        return this._allFacets;
		    };
		    AbstractType.prototype.facet = function (name) {
		        return _.find(this.allFacets(), function (x) { return x.nameId() == name; });
		    };
		    AbstractType.prototype.typeId = function () {
		        return this.nameId();
		    };
		    AbstractType.prototype.allProperties = function (ps) {
		        if (ps === void 0) { ps = {}; }
		        if (this._props) {
		            return this._props;
		        }
		        if (ps[this.typeId()]) {
		            return [];
		        }
		        ps[this.typeId()] = this;
		        var n = {};
		        if (this.superTypes().length > 0) {
		            this.superTypes().forEach(function (x) {
		                if (x instanceof AbstractType) {
		                    x.allProperties(ps).forEach(function (y) { return n[y.nameId()] = y; });
		                }
		                else {
		                    x.allProperties().forEach(function (y) { return n[y.nameId()] = y; });
		                }
		            });
		        }
		        for (var x in this.getFixedFacets()) {
		            delete n[x];
		        }
		        this.properties().forEach(function (x) { return n[x.nameId()] = x; });
		        this._props = Object.keys(n).map(function (x) { return n[x]; });
		        return this._props;
		    };
		    AbstractType.prototype.property = function (propName) {
		        return _.find(this.allProperties(), function (x) { return x.nameId() == propName; });
		    };
		    AbstractType.prototype.isValueType = function () {
		        return _.find(this.allSuperTypes(), function (x) {
		            var mm = x;
		            if (mm.uc) {
		                return false;
		            }
		            mm.uc = true;
		            try {
		                return x.isValueType();
		            }
		            finally {
		                mm.uc = false;
		            }
		        }) != null;
		    };
		    AbstractType.prototype.isAnnotationType = function () {
		        return false;
		    };
		    AbstractType.prototype.hasStructure = function () {
		        return false;
		    };
		    AbstractType.prototype.key = function () {
		        if (this._key) {
		            return this._key;
		        }
		        if (this._universe) {
		            this._key = this.universe().matched()[this.nameId()];
		            if (!this._key) {
		                return null;
		            }
		        }
		        return this._key;
		    };
		    AbstractType.prototype.isUserDefined = function () {
		        return false;
		    };
		    AbstractType.prototype.isArray = function () {
		        var arr = _.find(this.allSuperTypes(), function (x) { return x instanceof Array; }) != null;
		        return arr;
		    };
		    AbstractType.prototype.array = function () {
		        var x = this.allSuperTypes();
		        var res = null;
		        x.forEach(function (y) {
		            if (y instanceof Array) {
		                res = y;
		            }
		        });
		        return res;
		    };
		    AbstractType.prototype.union = function () {
		        var x = this.allSuperTypes();
		        var res = null;
		        x.forEach(function (y) {
		            if (y instanceof Union) {
		                res = y;
		            }
		        });
		        return res;
		    };
		    AbstractType.prototype.isUnion = function () {
		        return _.find(this.allSuperTypes(), function (x) {
		            var mm = x;
		            if (mm.uc) {
		                return false;
		            }
		            mm.uc = true;
		            try {
		                return x.isUnion();
		            }
		            finally {
		                mm.uc = false;
		            }
		        }) != null;
		    };
		    AbstractType.prototype.fixFacet = function (name, v) {
		        this.fixedFacets[name] = v;
		    };
		    AbstractType.prototype.getFixedFacets = function () {
		        if (this._af) {
		            return this._af;
		        }
		        var sp = this.allSuperTypes();
		        var mm = {};
		        for (var q in this.fixedFacets) {
		            mm[q] = this.fixedFacets[q];
		        }
		        sp.forEach(function (x) {
		            if (x instanceof AbstractType) {
		                x.contributeFacets(mm);
		                var ff = x.fixedFacets;
		                for (var q in ff) {
		                    mm[q] = ff[q];
		                }
		            }
		        });
		        this.contributeFacets(mm);
		        this._af = mm;
		        return mm;
		    };
		    AbstractType.prototype.contributeFacets = function (x) {
		    };
		    AbstractType.prototype.getPath = function () {
		        return this._path;
		    };
		    AbstractType.prototype.setNameAtRuntime = function (name) {
		        this._nameAtRuntime = name;
		    };
		    AbstractType.prototype.getNameAtRuntime = function () {
		        return this._nameAtRuntime;
		    };
		    AbstractType.prototype.universe = function () {
		        return this._universe;
		    };
		    AbstractType.prototype.superTypes = function () {
		        return [].concat(this._superTypes);
		    };
		    AbstractType.prototype.isAssignableFrom = function (typeName) {
		        if (this.nameId() == typeName) {
		            if (this.isUserDefined()) {
		                return false;
		            }
		            return true;
		        }
		        var currentSuperTypes = this.allSuperTypes();
		        for (var i = 0; i < currentSuperTypes.length; i++) {
		            if (currentSuperTypes[i].nameId() == typeName) {
		                return true;
		            }
		        }
		        return false;
		    };
		    AbstractType.prototype.annotationType = function () {
		        return null;
		    };
		    AbstractType.prototype.subTypes = function () {
		        return [].concat(this._subTypes);
		    };
		    AbstractType.prototype.allSubTypes = function () {
		        var rs = [];
		        this.subTypes().forEach(function (x) {
		            rs.push(x);
		            rs = rs.concat(x.allSubTypes());
		        });
		        return _.unique(rs);
		    };
		    AbstractType.prototype.allSuperTypes = function () {
		        var rs = [];
		        this.allSuperTypesRecurrent(this, {}, rs);
		        return _.unique(rs);
		    };
		    AbstractType.prototype.allSuperTypesRecurrent = function (t, m, result) {
		        var _this = this;
		        t.superTypes().forEach(function (x) {
		            if (!m[x.nameId()]) {
		                result.push(x);
		                m[x.nameId()] = x;
		                _this.allSuperTypesRecurrent(x, m, result);
		            }
		        });
		    };
		    AbstractType.prototype.addSuperType = function (q) {
		        q._subTypes.push(this);
		        this._superTypes.push(q);
		    };
		    AbstractType.prototype.addRequirement = function (name, value) {
		        this._requirements.push(new ValueRequirement(name, value));
		    };
		    //FIXME simplify it
		    AbstractType.prototype.valueRequirements = function () {
		        return this._requirements;
		    };
		    AbstractType.prototype.requiredProperties = function () {
		        return this.allProperties().filter(function (x) { return x.isRequired(); });
		    };
		    return AbstractType;
		})(Described);
		exports.AbstractType = AbstractType;
		var ValueType = (function (_super) {
		    __extends(ValueType, _super);
		    function ValueType(name, _universe, path, description) {
		        if (_universe === void 0) { _universe = null; }
		        if (path === void 0) { path = ""; }
		        if (description === void 0) { description = ""; }
		        _super.call(this, name, _universe, path);
		    }
		    ValueType.prototype.hasStructure = function () {
		        return false;
		    };
		    ValueType.prototype.isValueType = function () {
		        return true;
		    };
		    ValueType.prototype.isUnionType = function () {
		        return false;
		    };
		    return ValueType;
		})(AbstractType);
		exports.ValueType = ValueType;
		var StructuredType = (function (_super) {
		    __extends(StructuredType, _super);
		    function StructuredType() {
		        _super.apply(this, arguments);
		        this._properties = [];
		    }
		    StructuredType.prototype.hasStructure = function () {
		        return true;
		    };
		    StructuredType.prototype.propertyIndex = function (name) {
		        var props = this.properties();
		        for (var i = 0; i < props.length; i++) {
		            if (props[i].nameId() == name)
		                return i;
		        }
		        return -1;
		    };
		    StructuredType.prototype.addProperty = function (name, range) {
		        return new Property(name).withDomain(this).withRange(range);
		    };
		    StructuredType.prototype.allPropertyIndex = function (name) {
		        var props = this.allProperties();
		        for (var i = 0; i < props.length; i++) {
		            if (props[i].nameId() == name)
		                return i;
		        }
		        return -1;
		    };
		    StructuredType.prototype.properties = function () {
		        return [].concat(this._properties);
		    };
		    StructuredType.prototype.registerProperty = function (p) {
		        if (p.domain() != this) {
		            throw new Error("Should be already owned by this");
		        }
		        if (this._properties.indexOf(p) != -1) {
		            throw new Error("Already included");
		        }
		        this._properties.push(p);
		    };
		    return StructuredType;
		})(AbstractType);
		exports.StructuredType = StructuredType;
		var Property = (function (_super) {
		    __extends(Property, _super);
		    function Property() {
		        _super.apply(this, arguments);
		        this._keyShouldStartFrom = null;
		        this._isRequired = false;
		        this._isMultiValue = false;
		        this._descriminates = false;
		    }
		    Property.prototype.withMultiValue = function (v) {
		        if (v === void 0) { v = true; }
		        this._isMultiValue = v;
		        return this;
		    };
		    Property.prototype.withDescriminating = function (b) {
		        this._descriminates = b;
		        return this;
		    };
		    Property.prototype.withRequired = function (req) {
		        this._isRequired = req;
		        return this;
		    };
		    Property.prototype.isRequired = function () {
		        return this._isRequired;
		    };
		    Property.prototype.withKeyRestriction = function (keyShouldStartFrom) {
		        this._keyShouldStartFrom = keyShouldStartFrom;
		        return this;
		    };
		    Property.prototype.withDomain = function (d) {
		        this._ownerClass = d;
		        d.registerProperty(this);
		        return this;
		    };
		    Property.prototype.setDefaultVal = function (s) {
		        this._defaultVal = s;
		        return this;
		    };
		    Property.prototype.defaultValue = function () {
		        return this._defaultVal;
		    };
		    Property.prototype.isPrimitive = function () {
		        return false;
		    };
		    Property.prototype.withRange = function (t) {
		        this._nodeRange = t;
		        return this;
		    };
		    Property.prototype.isValueProperty = function () {
		        return this._nodeRange.isValueType();
		    };
		    Property.prototype.enumOptions = function () {
		        if (this._enumOptions && typeof this._enumOptions == 'string') {
		            return [this._enumOptions + ""];
		        }
		        return this._enumOptions;
		    };
		    Property.prototype.keyPrefix = function () {
		        return this._keyShouldStartFrom;
		    };
		    Property.prototype.withEnumOptions = function (op) {
		        this._enumOptions = op;
		        return this;
		    };
		    Property.prototype.withKeyRegexp = function (regexp) {
		        this._keyRegexp = regexp;
		        return this;
		    };
		    Property.prototype.getKeyRegexp = function () {
		        return this._keyRegexp;
		    };
		    Property.prototype.matchKey = function (k) {
		        if (k == null) {
		            return false;
		        }
		        if (this._groupName != null) {
		            return this._groupName == k;
		        }
		        else {
		            if (this._keyShouldStartFrom != null) {
		                if (k.indexOf(this._keyShouldStartFrom) == 0) {
		                    return true;
		                }
		            }
		            if (this._enumOptions) {
		                if (this._enumOptions.indexOf(k) != -1) {
		                    return true;
		                }
		            }
		            if (this.getKeyRegexp()) {
		                try {
		                    if (new RegExp(this.getKeyRegexp()).test(k)) {
		                        return true;
		                    }
		                }
		                catch (Error) {
		                }
		            }
		            return false;
		        }
		    };
		    Property.prototype.getFacetValidator = function () {
		        return this.facetValidator;
		    };
		    Property.prototype.setFacetValidator = function (f) {
		        this.facetValidator = f;
		    };
		    Property.prototype.domain = function () {
		        return this._ownerClass;
		    };
		    Property.prototype.range = function () {
		        return this._nodeRange;
		    };
		    Property.prototype.isMultiValue = function () {
		        if (this.range() && this.range().isArray()) {
		            return true;
		        }
		        return this._isMultiValue;
		    };
		    Property.prototype.isDescriminator = function () {
		        return this._descriminates;
		    };
		    return Property;
		})(Described);
		exports.Property = Property;
		var Union = (function (_super) {
		    __extends(Union, _super);
		    function Union() {
		        _super.apply(this, arguments);
		    }
		    Union.prototype.key = function () {
		        return null;
		    };
		    Union.prototype.leftType = function () {
		        return this.left;
		    };
		    Union.prototype.rightType = function () {
		        return this.right;
		    };
		    Union.prototype.isUserDefined = function () {
		        return true;
		    };
		    Union.prototype.union = function () {
		        return this;
		    };
		    Union.prototype.isUnion = function () {
		        return true;
		    };
		    Union.prototype.isArray = function () {
		        if (this.left && this.right) {
		            return this.left.isArray() || this.right.isArray();
		        }
		        if (this.left) {
		            return this.left.isArray();
		        }
		        if (this.right) {
		            return this.right.isArray();
		        }
		    };
		    return Union;
		})(AbstractType);
		exports.Union = Union;
		var Array = (function (_super) {
		    __extends(Array, _super);
		    function Array() {
		        _super.apply(this, arguments);
		    }
		    Array.prototype.isArray = function () {
		        return true;
		    };
		    Array.prototype.array = function () {
		        return this;
		    };
		    Array.prototype.isUserDefined = function () {
		        return true;
		    };
		    Array.prototype.componentType = function () {
		        return this.component;
		    };
		    Array.prototype.key = function () {
		        return null;
		    };
		    return Array;
		})(AbstractType);
		exports.Array = Array;


	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var hl = __webpack_require__(2);
		var _ = __webpack_require__(4);
		var linter = __webpack_require__(55);
		var wrapperHelper = __webpack_require__(65);
		function escapeUri(u) {
		    var ss = "";
		    var level = 0;
		    for (var i = 0; i < u.length; i++) {
		        var c = u.charAt(i);
		        if (level == 0) {
		            ss = ss + c;
		        }
		        if (c == '{') {
		            level++;
		        }
		        if (c == '}') {
		            level--;
		        }
		    }
		    return ss;
		}
		var OverloadingValidator = (function () {
		    function OverloadingValidator() {
		        this.holder = {};
		        this.conflicting = {};
		    }
		    OverloadingValidator.prototype.validateApi = function (q, v) {
		        var _this = this;
		        q.resources().forEach(function (x) {
		            _this.acceptResource(x);
		            x.resources().forEach(function (y) { return _this.acceptResource(y); });
		        });
		        for (var c in this.conflicting) {
		            var ms = this.conflicting[c];
		            //now we should layout parameters by items
		            var overmapQuery = {};
		            var overmapHeaders = {};
		            var pushed = [];
		            ms.forEach(function (m) {
		                m.queryParameters().forEach(function (q) {
		                    var key = q.name();
		                    if (!q.required()) {
		                        return;
		                    }
		                    var set = overmapQuery[key];
		                    if (!set) {
		                        set = [];
		                        overmapQuery[key] = set;
		                    }
		                    set.push(m);
		                    pushed.push(m);
		                });
		                m.headers().forEach(function (q) {
		                    var key = q.name();
		                    if (!q.required()) {
		                        return;
		                    }
		                    var set = overmapHeaders[key];
		                    if (!set) {
		                        set = [];
		                        overmapHeaders[key] = set;
		                    }
		                    set.push(m);
		                    pushed.push(m);
		                });
		            });
		            var notPushed = ms.filter(function (x) { return !_.find(pushed, function (y) { return y == x; }); });
		            if (notPushed.length > 0) {
		                notPushed.forEach(function (m) {
		                    v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous", m.highLevel(), true));
		                });
		            }
		            for (var key in overmapQuery) {
		                var cm = overmapQuery[key];
		                if (cm.length > 1) {
		                    var over = {};
		                    var pushed2 = [];
		                    cm.forEach(function (m) {
		                        var pr = _.find(m.queryParameters(), function (x) { return x.name() == key; });
		                        if (pr['enum']) {
		                            var ev = pr['enum']();
		                            if (ev && ev.length > 0) {
		                                ev.forEach(function (value) {
		                                    var t = over[value];
		                                    if (!t) {
		                                        t = [];
		                                        over[value] = t;
		                                    }
		                                    t.push(m);
		                                    pushed2.push(m);
		                                });
		                            }
		                        }
		                    });
		                    var notPushed2 = cm.filter(function (x) { return !_.find(pushed2, function (y) { return y == x; }); });
		                    if (notPushed2.length > 0) {
		                        notPushed2.forEach(function (m) {
		                            v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous no domain restrictions", m.highLevel(), true));
		                        });
		                    }
		                    for (var k in over) {
		                        var rs = over[k];
		                        if (rs.length > 1) {
		                            rs.forEach(function (m) { return v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous ( enum value " + k + ")", m.highLevel(), true)); });
		                        }
		                    }
		                }
		            }
		        }
		    };
		    OverloadingValidator.prototype.acceptResource = function (x) {
		        var _this = this;
		        x.methods().forEach(function (m) {
		            _this.acceptMethod(x, m);
		        });
		    };
		    OverloadingValidator.prototype.acceptMethod = function (x, m) {
		        var uri = escapeUri(wrapperHelper.absoluteUri(x)) + m.method();
		        var pos = this.holder[uri];
		        if (!pos) {
		            pos = [];
		            this.holder[uri] = pos;
		        }
		        pos.push(m);
		        if (pos.length > 1) {
		            this.conflicting[uri] = pos;
		        }
		        //wrapperHelper.absoluteUri(m.parent().)
		    };
		    return OverloadingValidator;
		})();
		module.exports = OverloadingValidator;


	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {

		var RamlWrapper = __webpack_require__(1);
		var ramlPathMatch = __webpack_require__(66);
		var hl = __webpack_require__(2);
		var hlimpl = __webpack_require__(5);
		var universes = __webpack_require__(54);
		var Opt = __webpack_require__(12);
		var util = __webpack_require__(11);
		var typeexpression = __webpack_require__(50);
		var expander = __webpack_require__(73);
		var lowLevelProxy = __webpack_require__(6);
		var search = __webpack_require__(53);
		var ll = __webpack_require__(15);
		var path = __webpack_require__(16);
		var ramlservices = __webpack_require__(49);
		function resolveType(p) {
		    var tpe = typeexpression.typeFromNode(p.highLevel());
		    return tpe.getAdapter(ramlservices.RAMLService).toRuntime();
		}
		exports.resolveType = resolveType;
		//__$helperMethod__ Runtime representation of type represented by this AST node
		function runtimeType(p) {
		    var tpe = typeexpression.typeFromNode(p.highLevel());
		    return tpe.getAdapter(ramlservices.RAMLService).toRuntimeWithInheritance();
		}
		exports.runtimeType = runtimeType;
		function load(pth) {
		    var m = new ll.Project(path.dirname(pth));
		    var unit = m.unit(path.basename(pth));
		    if (unit) {
		        if (unit.isRAMLUnit()) {
		            return hl.fromUnit(unit).wrapperNode();
		        }
		    }
		    return null;
		}
		exports.load = load;
		//__$helperMethod__ Path relative to API root
		function completeRelativeUri(res) {
		    var uri = '';
		    var parent = res;
		    do {
		        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
		        uri = res.relativeUri().value() + uri;
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe10.Resource.name);
		    return uri;
		}
		exports.completeRelativeUri = completeRelativeUri;
		//__$helperMethod__ Equivalent API with traits and resource types expanded __$meta__={"name":"expand"}
		function expandTraitsAndResourceTypes(api) {
		    var lowLevelNode = api.highLevel().lowLevel();
		    if (lowLevelNode instanceof lowLevelProxy.LowLevelProxyNode) {
		        return api;
		    }
		    return expander.expandTraitsAndResourceTypes(api);
		}
		exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
		//__$helperMethod__ baseUri of owning Api concatenated with completeRelativeUri
		function absoluteUri(res) {
		    var uri = '';
		    var parent = res;
		    do {
		        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
		        uri = res.relativeUri().value() + uri;
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe10.Resource.name);
		    uri = uri.replace(/\/\//g, '/');
		    var buri = parent.baseUri();
		    var base = buri ? buri.value() : "";
		    base = base ? base : '';
		    if (util.stringEndsWith(base, '/')) {
		        uri = uri.substring(1);
		    }
		    uri = base + uri;
		    return uri;
		}
		exports.absoluteUri = absoluteUri;
		function qName(c) {
		    return hlimpl.qName(c.highLevel(), c.highLevel().root());
		}
		exports.qName = qName;
		//__$helperMethod__ Retrieve all traits including those defined in libraries
		function allTraits(a) {
		    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().key() == universes.Universe08.Trait || x.definition().key() == universes.Universe10.Trait; }).map(function (x) { return x.wrapperNode(); });
		}
		exports.allTraits = allTraits;
		//__$helperMethod__ Retrieve all resource types including those defined in libraries
		function allResourceTypes(a) {
		    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().key() == universes.Universe08.ResourceType || x.definition().key() == universes.Universe10.ResourceType; }).map(function (x) { return x.wrapperNode(); });
		}
		exports.allResourceTypes = allResourceTypes;
		function relativeUriSegments(res) {
		    var result = [];
		    var parent = res;
		    do {
		        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
		        result.push(res.relativeUri().value());
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe10.Resource.name);
		    return result.reverse();
		}
		exports.relativeUriSegments = relativeUriSegments;
		//__$helperMethod__ For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
		function parentResource(method) {
		    if (method.parent() instanceof RamlWrapper.ResourceImpl) {
		        return method.parent();
		    }
		    return null;
		}
		exports.parentResource = parentResource;
		//__$helperMethod__ Parent resource for non top level resources __$meta__={"name":"parentResource"}
		function parent(resource) {
		    var parent = resource.parent();
		    if (isApi(parent)) {
		        return null;
		    }
		    return parent;
		}
		exports.parent = parent;
		//__$helperMethod__ Get child resource by its relative path
		function getChildResource(container, relPath) {
		    if (container == null) {
		        return null;
		    }
		    var resources = container.resources();
		    if (!resources) {
		        return null;
		    }
		    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
		    if (resources.length == 0) {
		        return null;
		    }
		    return resources[0];
		}
		exports.getChildResource = getChildResource;
		function getResource(container, path) {
		    if (!container) {
		        return null;
		    }
		    var res = null;
		    for (var i = 0; i < path.length; i++) {
		        res = getChildResource(container, path[i]);
		        if (!res) {
		            return null;
		        }
		        container = res;
		    }
		    return res;
		}
		exports.getResource = getResource;
		//__$helperMethod__ Get child method by its name
		function getChildMethod(resource, method) {
		    if (!resource) {
		        return null;
		    }
		    return resource.methods().filter(function (x) { return x.method() == method; });
		}
		exports.getChildMethod = getChildMethod;
		function getMethod(container, path, method) {
		    var resource = getResource(container, path);
		    if (!resource) {
		        return null;
		    }
		    return getChildMethod(resource, method);
		}
		exports.getMethod = getMethod;
		function isApi(obj) {
		    return obj.definition().key().name == universes.Universe10.Api.name;
		}
		;
		//__$helperMethod__ Api owning the resource as a sibling
		function ownerApi(method) {
		    var obj = method;
		    while (!isApi(obj)) {
		        obj = obj.parent();
		    }
		    return obj;
		}
		exports.ownerApi = ownerApi;
		//__$helperMethod__
		// For methods of Resources: `{parent Resource relative path} {methodName}`.
		// For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
		// For other methods throws Exception.
		function methodId(method) {
		    var parent = method.parent();
		    if (parent instanceof RamlWrapper.ResourceImpl) {
		        return completeRelativeUri(parent) + ' ' + method.method().toLowerCase();
		    }
		    else if (parent instanceof RamlWrapper.ResourceTypeImpl) {
		        return parent.name() + ' ' + method.method().toLowerCase();
		    }
		    throw new Error("Method is supposed to be owned by Resource or ResourceType.\nHere the method is owned by " + method.definition().key().name);
		}
		exports.methodId = methodId;
		//__$helperMethod__ true for codes < 400 and false otherwise
		function isOkRange(response) {
		    return parseInt(response.code().value()) < 400;
		}
		exports.isOkRange = isOkRange;
		//__$helperMethod__  Retrieve all resources of the Api
		function allResources(api) {
		    var resources = [];
		    var visitor = function (res) {
		        resources.push(res);
		        res.resources().forEach(function (x) { return visitor(x); });
		    };
		    api.resources().forEach(function (x) { return visitor(x); });
		    return resources;
		}
		exports.allResources = allResources;
		function matchUri(apiRootRelativeUri, resource) {
		    var allParameters = {};
		    while (resource != null) {
		        uriParameters(resource).forEach(function (x) { return allParameters[x.name()] = new ParamWrapper(x); });
		        resource = parent(resource);
		    }
		    var result = ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
		    if (result) {
		        return new Opt(Object.keys(result.params).map(function (x) { return new ParamValue(x, result['params'][x]); }));
		    }
		    return Opt.empty();
		}
		exports.matchUri = matchUri;
		var schemaContentChars = ['{', '<'];
		function schema(body, api) {
		    var schemaNode = body.schema();
		    if (!schemaNode) {
		        return Opt.empty();
		    }
		    var schemaString = schemaNode;
		    var isContent = false;
		    schemaContentChars.forEach(function (x) {
		        try {
		            isContent = isContent || schemaString.indexOf(x) >= 0;
		        }
		        catch (e) {
		        }
		    });
		    var schDef;
		    if (isContent) {
		        schDef = new SchemaDef(schemaString);
		    }
		    else {
		        var globalSchemes = api.schemas().filter(function (x) { return x.key() == schemaString; });
		        if (globalSchemes.length > 0) {
		            schDef = new SchemaDef(globalSchemes[0].value().value(), globalSchemes[0].key());
		        }
		        else {
		            return Opt.empty();
		        }
		    }
		    return new Opt(schDef);
		}
		exports.schema = schema;
		/**
		 * __$helperMethod__ Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
		 * Consider a fragment of RAML specification:
		 * ```yaml
		 * /resource/{objectId}/{propertyId}:
		 *   uriParameters:
		 *     objectId:
		 * ```
		 * Here `propertyId` uri parameter is not described in the `uriParameters` node.
		 * Thus, it is not among Resource.uriParameters(), but it is among Resource.allUriParameters().
		 * __$meta__={"name":"allUriParameters"}
		 **/
		function uriParameters(resource) {
		    var uri = resource.relativeUri().value();
		    var params = resource.uriParameters();
		    return extractParams(params, uri, resource);
		}
		exports.uriParameters = uriParameters;
		/**__$helperMethod__
		 * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
		 * Consider a fragment of RAML specification:
		 * ```yaml
		 * version: v1
		 * baseUri: https://{organization}.example.com/{version}/{service}
		 * baseUriParameters:
		 *   service:
		 * ```
		 * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node.
		 * Thus, they are not among `Api.baseUriParameters()`, but they are among `Api.allBaseUriParameters()`.
		 * __$meta__={"name":"allBaseUriParameters"}
		 **/
		function baseUriParameters(api) {
		    var uri = api.baseUri() ? api.baseUri().value() : '';
		    var params = api.baseUriParameters();
		    return extractParams(params, uri, api);
		}
		exports.baseUriParameters = baseUriParameters;
		/**__$helperMethod__
		 * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.allBaseUriParameters()`
		 * for `Api` owning the `Resource` and `Resource.allUriParameters()`.
		 */
		function absoluteUriParameters(res) {
		    var params = [];
		    var parent = res;
		    do {
		        res = parent;
		        var uri = res.relativeUri().value();
		        var uriParams = res.uriParameters();
		        params = extractParams(uriParams, uri, res).concat(params);
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe10.Resource.name);
		    var api = parent;
		    var baseUri = api.baseUri().value();
		    var baseUriParams = api.baseUriParameters();
		    params = extractParams(baseUriParams, baseUri, api).concat(params);
		    return params;
		}
		exports.absoluteUriParameters = absoluteUriParameters;
		/**
		 * __$helperMethod__ Protocols used by the API. Returns the `protocols` property value if it is specified.
		 * Otherwise, returns protocol, specified in the base URI.
		 **/
		function allProtocols(api) {
		    var result = api.protocols();
		    if (result.length != 0) {
		        return result;
		    }
		    var baseUri = api.baseUri().value();
		    if (baseUri && baseUri.trim().length != 0) {
		        var ind = baseUri.indexOf('://');
		        if (ind >= 0) {
		            result = [baseUri.substring(0, ind)];
		        }
		    }
		    return result;
		}
		exports.allProtocols = allProtocols;
		function extractParams(params, uri, resource) {
		    if (!uri) {
		        return [];
		    }
		    var describedParams = {};
		    params.forEach(function (x) { return describedParams[x.name()] = x; });
		    var allParams = [];
		    var prev = 0;
		    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
		        prev = uri.indexOf('}', ++i);
		        var paramName = uri.substring(i, prev);
		        if (describedParams[paramName]) {
		            allParams.push(describedParams[paramName]);
		        }
		        else {
		            allParams.push(new HelperUriParam(paramName, resource));
		        }
		    }
		    return allParams;
		}
		;
		var HelperUriParam = (function () {
		    function HelperUriParam(_name, _parent) {
		        this._name = _name;
		        this._parent = _parent;
		    }
		    HelperUriParam.prototype.wrapperClassName = function () {
		        return "HelperUriParam";
		    };
		    HelperUriParam.prototype.getKind = function () {
		        return "HelperUriParam";
		    };
		    HelperUriParam.prototype.name = function () {
		        return this._name;
		    };
		    HelperUriParam.prototype["type"] = function () {
		        return ["string"];
		    };
		    HelperUriParam.prototype.location = function () {
		        return {
		            wrapperClassName: function () { return "HelperModelLocation"; },
		            getKind: function () { return "HelperModelLocation"; }
		        };
		    };
		    HelperUriParam.prototype.locationKind = function () {
		        return {
		            wrapperClassName: function () { return "HelperLocationKind"; },
		            getKind: function () { return "HelperLocationKind"; }
		        };
		    };
		    HelperUriParam.prototype["default"] = function () {
		        return null;
		    };
		    HelperUriParam.prototype.xml = function () {
		        return null;
		    };
		    HelperUriParam.prototype.runtimeType = function () {
		        return null;
		    };
		    HelperUriParam.prototype.sendDefaultByClient = function () {
		        return false;
		    };
		    HelperUriParam.prototype.example = function () {
		        return '';
		    };
		    HelperUriParam.prototype.schema = function () {
		        return null;
		    };
		    HelperUriParam.prototype.formParameters = function () {
		        return [];
		    };
		    HelperUriParam.prototype.examples = function () {
		        return [];
		    };
		    HelperUriParam.prototype.repeat = function () {
		        return false;
		    };
		    HelperUriParam.prototype.enum = function () {
		        return [];
		    };
		    HelperUriParam.prototype.collectionFormat = function () {
		        return 'multi';
		    };
		    HelperUriParam.prototype.required = function () {
		        return true;
		    };
		    HelperUriParam.prototype.readOnly = function () {
		        return false;
		    };
		    HelperUriParam.prototype.facets = function () {
		        return [];
		    };
		    HelperUriParam.prototype.scope = function () {
		        return [];
		    };
		    //xml(  ):RamlWrapper.XMLInfo{ return null; }
		    //validWhen(  ):RamlWrapper.ramlexpression{ return null; }
		    //requiredWhen(  ):RamlWrapper.ramlexpression{ return null; }
		    HelperUriParam.prototype.displayName = function () {
		        return this._name;
		    };
		    HelperUriParam.prototype.description = function () {
		        return null;
		    };
		    HelperUriParam.prototype.annotations = function () {
		        return [];
		    };
		    HelperUriParam.prototype.usage = function () {
		        return null;
		    };
		    HelperUriParam.prototype.parent = function () {
		        return this._parent;
		    };
		    HelperUriParam.prototype.highLevel = function () {
		        return null;
		    };
		    HelperUriParam.prototype.errors = function () {
		        return [];
		    };
		    HelperUriParam.prototype.definition = function () {
		        return null;
		    };
		    HelperUriParam.prototype.runtimeDefinition = function () {
		        return null;
		    };
		    HelperUriParam.prototype.toJSON = function () {
		        return { "name": this.name() };
		    };
		    return HelperUriParam;
		})();
		exports.HelperUriParam = HelperUriParam;
		var SchemaDef = (function () {
		    function SchemaDef(_content, _name) {
		        this._content = _content;
		        this._name = _name;
		    }
		    SchemaDef.prototype.name = function () {
		        return this._name;
		    };
		    SchemaDef.prototype.content = function () {
		        return this._content;
		    };
		    return SchemaDef;
		})();
		exports.SchemaDef = SchemaDef;
		var ParamValue = (function () {
		    function ParamValue(key, value) {
		        this.key = key;
		        this.value = value;
		    }
		    return ParamValue;
		})();
		exports.ParamValue = ParamValue;
		var ParamWrapper = (function () {
		    function ParamWrapper(_param) {
		        this._param = _param;
		        this.description = _param.description() ? _param.description().value() : this.description;
		        this.displayName = _param.displayName();
		        //        this.enum = _param.enum();
		        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
		        this.example = _param.example();
		        this.repeat = _param.repeat();
		        this.required = _param.required();
		        this.default = _param.default();
		    }
		    return ParamWrapper;
		})();


	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var ramlSanitize = __webpack_require__(67);
		var ramlValidate = __webpack_require__(68);
		var REGEXP_MATCH = {
		    number: '[-+]?\\d+(?:\\.\\d+)?',
		    integer: '[-+]?\\d+',
		    date: '(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} (?:[0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d GMT',
		    boolean: '(?:true|false)'
		};
		var ESCAPE_CHARACTERS = /([.*+?=^!:${}()|[\]\/\\])/g;
		var REGEXP_REPLACE = new RegExp([
		    '([.\\/])?\\{([^}]+)\\}',
		    ESCAPE_CHARACTERS.source
		].join('|'), 'g');
		function toRegExp(path, parameters, keys, options) {
		    var end = options.end !== false;
		    var strict = options.strict;
		    var flags = '';
		    if (!options.sensitive) {
		        flags += 'i';
		    }
		    var route = path.replace(REGEXP_REPLACE, function (match, prefix, key, escape) {
		        if (escape) {
		            return '\\' + escape;
		        }
		        // Push the current key into the keys array.
		        keys.push({
		            name: key,
		            prefix: prefix || '/'
		        });
		        prefix = prefix ? '\\' + prefix : '';
		        // TODO: Support an array of parameters.
		        var param = parameters[key];
		        var capture = param && REGEXP_MATCH[param.type] || '[^' + (prefix || '\\/') + ']+';
		        var optional = param && param.required === false;
		        if (Array.isArray(param.enum) && param.enum.length) {
		            capture = '(?:' + param.enum.map(function (value) {
		                return String(value).replace(ESCAPE_CHARACTERS, '\\$1');
		            }).join('|') + ')';
		        }
		        return prefix + '(' + capture + ')' + (optional ? '?' : '');
		    });
		    var endsWithSlash = path.charAt(path.length - 1) === '/';
		    // In non-strict mode we allow a slash at the end of match. If the path to
		    // match already ends with a slash, we remove it for consistency. The slash
		    // is valid at the end of a path match, not in the middle. This is important
		    // in non-ending mode, where "/test/" shouldn't match "/test//route".
		    if (!strict) {
		        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
		    }
		    if (end) {
		        route += '$';
		    }
		    else {
		        // In non-ending mode, we need the capturing groups to match as much as
		        // possible by using a positive lookahead to the end or next path segment.
		        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
		    }
		    return new RegExp('^' + route + (end ? '$' : ''), flags);
		}
		function decodeParam(param) {
		    try {
		        return decodeURIComponent(param);
		    }
		    catch (_) {
		        var err = new Error('Failed to decode param "' + param + '"');
		        err.status = 400;
		        throw err;
		    }
		}
		function ramlPathMatch(path, parameters, options) {
		    options = options || {};
		    if (path === '/' && options.end === false) {
		        return truth;
		    }
		    parameters = parameters || {};
		    var keys = [];
		    var re = toRegExp(path, parameters, keys, options);
		    var sanitize = ramlSanitize()(parameters);
		    var validate = ramlValidate()(parameters);
		    return function (pathname) {
		        var m = re.exec(pathname);
		        if (!m) {
		            return false;
		        }
		        if (parameters['mediaTypeExtension']) {
		            if (m.length > 1 && !m[m.length - 1]) {
		                var beforeLast = m[m.length - 2];
		                var ind = beforeLast.lastIndexOf('.');
		                if (ind >= 0) {
		                    m[m.length - 2] = beforeLast.substring(0, ind);
		                    m[m.length - 1] = beforeLast.substring(ind);
		                }
		            }
		        }
		        var path = m[0];
		        var params = {};
		        for (var i = 1; i < m.length; i++) {
		            var key = keys[i - 1];
		            var param = m[i];
		            params[key.name] = param == null ? param : decodeParam(param);
		        }
		        params = sanitize(params);
		        if (!validate(params).valid) {
		            return false;
		        }
		        return {
		            path: path,
		            params: params
		        };
		    };
		}
		function truth(path) {
		    return { path: '', params: {} };
		}
		module.exports = ramlPathMatch;


	/***/ },
	/* 67 */
	/***/ function(module, exports) {

		/// <reference path="../../typings/tsd.d.ts" />
		function isEmpty(value) {
		    return value == null;
		}
		function toString(value) {
		    return isEmpty(value) ? '' : String(value);
		}
		function toBoolean(value) {
		    return [0, false, '', '0', 'false'].indexOf(value) === -1;
		}
		function toNumber(value) {
		    return isFinite(value) ? Number(value) : null;
		}
		function toInteger(value) {
		    return value % 1 === 0 ? Number(value) : null;
		}
		function toDate(value) {
		    return !isNaN(Date.parse(value)) ? new Date(value) : null;
		}
		function toSanitization(parameter, rules, types) {
		    var parameters = Array.isArray(parameter) ? parameter : [parameter];
		    var sanitizations = parameters.map(function (parameter) {
		        var fns = [];
		        var typeSanitization = types[parameter.type];
		        if (typeof typeSanitization === 'function') {
		            fns.push(typeSanitization);
		        }
		        Object.keys(parameter).filter(function (key) {
		            return key !== 'type' && key !== 'repeat' && key !== 'default';
		        }).forEach(function (key) {
		            var fn = rules[key];
		            if (typeof fn === 'function') {
		                fns.push(fn(parameter[key], key));
		            }
		        });
		        function sanitize(value, key, src) {
		            for (var i = 0; i < fns.length; i++) {
		                var fn = fns[i];
		                var value = fn(value, key, src);
		                if (value != null) {
		                    return value;
		                }
		            }
		            return null;
		        }
		        return function (value, key, src) {
		            if (isEmpty(value)) {
		                if (parameter.default != null) {
		                    return sanitize(parameter.default, key, src);
		                }
		                return parameter.repeat && !parameter.required ? [] : value;
		            }
		            if (parameter.repeat) {
		                var values = Array.isArray(value) ? value : [value];
		                values = values.map(function (value) {
		                    return sanitize(value, key, src);
		                });
		                return values.some(isEmpty) ? null : value;
		            }
		            if (Array.isArray(value)) {
		                if (value.length > 1) {
		                    return null;
		                }
		                value = value[0];
		            }
		            return sanitize(value, key, src);
		        };
		    });
		    return function (value, key, src) {
		        for (var i = 0; i < sanitizations.length; i++) {
		            var sanitization = sanitizations[i];
		            var result = sanitization(value, key, src);
		            if (result != null) {
		                return result;
		            }
		        }
		        return value;
		    };
		}
		function sanitize() {
		    var RULES = {};
		    var TYPES = {
		        string: toString,
		        number: toNumber,
		        integer: toInteger,
		        boolean: toBoolean,
		        date: toDate
		    };
		    function rule(parameter) {
		        return toSanitization(parameter, RULES, TYPES);
		    }
		    var sanitize = function (parameterMap) {
		        if (!parameterMap) {
		            return function () {
		                return {};
		            };
		        }
		        var sanitizations = {};
		        Object.keys(parameterMap).forEach(function (key) {
		            sanitizations[key] = sanitize.rule(parameterMap[key]);
		        });
		        return function (src) {
		            src = src || {};
		            var dest = {};
		            // Iterate the sanitized parameters to get a clean model.
		            Object.keys(sanitizations).forEach(function (key) {
		                var value = src[key];
		                var fn = sanitizations[key];
		                if (Object.prototype.hasOwnProperty.call(src, key)) {
		                    dest[key] = fn(value, key, src);
		                }
		            });
		            return dest;
		        };
		    };
		    var s;
		    s = sanitize;
		    s.rule = rule;
		    s.TYPES = TYPES;
		    s.RULES = RULES;
		    return s;
		}
		module.exports = sanitize;


	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../typings/tsd.d.ts" />
		var _toString = Object.prototype.toString;
		function isDateType(check) {
		    return _toString.call(check) === '[object Date]' && !isNaN(check.getTime());
		}
		function isBooleanType(check) {
		    return typeof check === 'boolean';
		}
		function isStringType(check) {
		    return typeof check === 'string';
		}
		function isIntegerType(check) {
		    return typeof check === 'number' && check % 1 === 0;
		}
		function isNumberType(check) {
		    return typeof check === 'number' && isFinite(check);
		}
		function isMinimum(min) {
		    return function (check) {
		        return check >= min;
		    };
		}
		function isMaximum(max) {
		    return function (check) {
		        return check <= max;
		    };
		}
		function isMinimumLength(min) {
		    return function (check) {
		        return Buffer.byteLength(check) >= min;
		    };
		}
		function isMaximumLength(max) {
		    return function (check) {
		        return Buffer.byteLength(check) <= max;
		    };
		}
		function isEnum(values) {
		    if (values && values.length != 0) {
		        return function (check) {
		            return values.indexOf(check) > -1;
		        };
		    }
		    else {
		        return function (check) {
		            return true;
		        };
		    }
		}
		function isPattern(pattern) {
		    var regexp = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;
		    return regexp.test.bind(regexp);
		}
		function toValidationResult(valid, key, value, rule, attr) {
		    return {
		        valid: valid,
		        rule: rule,
		        attr: attr,
		        value: value,
		        key: key
		    };
		}
		function toValidationFunction(parameter, rules) {
		    var validations = [];
		    Object.keys(parameter).forEach(function (name) {
		        var rule = rules[name];
		        if (!rule) {
		            return;
		        }
		        var value = parameter[name];
		        validations.push([name, rule(value, name), value]);
		    });
		    return function (value, key, src) {
		        for (var i = 0; i < validations.length; i++) {
		            var validation = validations[i];
		            var name = validation[0];
		            var fn = validation[1];
		            var attr = validation[2];
		            var valid = fn(value, key, src);
		            if (!valid) {
		                return toValidationResult(false, key, value, name, attr);
		            }
		        }
		        return toValidationResult(true, key, value);
		    };
		}
		function toValidation(parameter, rules, types) {
		    var parameters = Array.isArray(parameter) ? parameter : [parameter];
		    var isOptional = !parameters.length;
		    var simpleValidations = [];
		    var repeatValidations = [];
		    parameters.forEach(function (parameter) {
		        var validation = [parameter.type || 'string', toValidationFunction(parameter, rules)];
		        if (!parameter.required) {
		            isOptional = true;
		        }
		        if (parameter.repeat) {
		            repeatValidations.push(validation);
		        }
		        else {
		            simpleValidations.push(validation);
		        }
		    });
		    return function (value, key, src) {
		        if (value == null) {
		            return toValidationResult(isOptional, key, value, 'required', !isOptional);
		        }
		        var isArray = Array.isArray(value);
		        var values = isArray ? value : [value];
		        var validations = isArray ? repeatValidations : simpleValidations;
		        if (!validations.length) {
		            return toValidationResult(false, key, value, 'repeat', !isArray);
		        }
		        var response = null;
		        var originalValue = value;
		        validations.some(function (validation) {
		            var isValidType = values.every(function (value) {
		                var paramType = validation[0];
		                var isValidType = types[paramType] && types[paramType](value, key, src);
		                if (!isValidType) {
		                    response = toValidationResult(false, key, originalValue, 'type', paramType);
		                }
		                return isValidType;
		            });
		            if (!isValidType) {
		                return false;
		            }
		            values.every(function (value) {
		                var fn = validation[1];
		                response = fn(value, key);
		                return response.valid;
		            });
		            return true;
		        });
		        return response;
		    };
		}
		function validate() {
		    var TYPES = {
		        date: isDateType,
		        number: isNumberType,
		        integer: isIntegerType,
		        boolean: isBooleanType,
		        string: isStringType
		    };
		    var RULES = {
		        minimum: isMinimum,
		        maximum: isMaximum,
		        minLength: isMinimumLength,
		        maxLength: isMaximumLength,
		        'enum': isEnum,
		        pattern: isPattern
		    };
		    function rule(parameter) {
		        return toValidation(parameter, RULES, TYPES);
		    }
		    var v;
		    var validate = function (parameterMap) {
		        if (!parameterMap) {
		            return function (check) {
		                return { valid: true, errors: [] };
		            };
		        }
		        var validations = {};
		        Object.keys(parameterMap).forEach(function (key) {
		            validations[key] = rule(parameterMap[key]);
		        });
		        return function (src) {
		            src = src || {};
		            var errors = Object.keys(validations).map(function (param) {
		                var value = src[param];
		                var fn = validations[param];
		                return fn(value, param, src);
		            }).filter(function (result) {
		                return !result.valid;
		            });
		            return {
		                valid: errors.length === 0,
		                errors: errors
		            };
		        };
		    };
		    v = validate;
		    v.rule = rule;
		    v.TYPES = TYPES;
		    v.RULES = RULES;
		    return v;
		}
		module.exports = validate;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(69).Buffer))

	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
		 * @license  MIT
		 */
		/* eslint-disable no-proto */

		var base64 = __webpack_require__(70)
		var ieee754 = __webpack_require__(71)
		var isArray = __webpack_require__(72)

		exports.Buffer = Buffer
		exports.SlowBuffer = SlowBuffer
		exports.INSPECT_MAX_BYTES = 50
		Buffer.poolSize = 8192 // not used by this implementation

		var rootParent = {}

		/**
		 * If `Buffer.TYPED_ARRAY_SUPPORT`:
		 *   === true    Use Uint8Array implementation (fastest)
		 *   === false   Use Object implementation (most compatible, even IE6)
		 *
		 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
		 * Opera 11.6+, iOS 4.2+.
		 *
		 * Due to various browser bugs, sometimes the Object implementation will be used even
		 * when the browser supports typed arrays.
		 *
		 * Note:
		 *
		 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
		 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
		 *
		 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
		 *     on objects.
		 *
		 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
		 *
		 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
		 *     incorrect length in some situations.

		 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
		 * get the Object implementation, which is slower but behaves correctly.
		 */
		Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
		  ? global.TYPED_ARRAY_SUPPORT
		  : typedArraySupport()

		function typedArraySupport () {
		  function Bar () {}
		  try {
		    var arr = new Uint8Array(1)
		    arr.foo = function () { return 42 }
		    arr.constructor = Bar
		    return arr.foo() === 42 && // typed array instances can be augmented
		        arr.constructor === Bar && // constructor can be set
		        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
		        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
		  } catch (e) {
		    return false
		  }
		}

		function kMaxLength () {
		  return Buffer.TYPED_ARRAY_SUPPORT
		    ? 0x7fffffff
		    : 0x3fffffff
		}

		/**
		 * Class: Buffer
		 * =============
		 *
		 * The Buffer constructor returns instances of `Uint8Array` that are augmented
		 * with function properties for all the node `Buffer` API functions. We use
		 * `Uint8Array` so that square bracket notation works as expected -- it returns
		 * a single octet.
		 *
		 * By augmenting the instances, we can avoid modifying the `Uint8Array`
		 * prototype.
		 */
		function Buffer (arg) {
		  if (!(this instanceof Buffer)) {
		    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
		    if (arguments.length > 1) return new Buffer(arg, arguments[1])
		    return new Buffer(arg)
		  }

		  this.length = 0
		  this.parent = undefined

		  // Common case.
		  if (typeof arg === 'number') {
		    return fromNumber(this, arg)
		  }

		  // Slightly less common case.
		  if (typeof arg === 'string') {
		    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
		  }

		  // Unusual.
		  return fromObject(this, arg)
		}

		function fromNumber (that, length) {
		  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) {
		    for (var i = 0; i < length; i++) {
		      that[i] = 0
		    }
		  }
		  return that
		}

		function fromString (that, string, encoding) {
		  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

		  // Assumption: byteLength() return value is always < kMaxLength.
		  var length = byteLength(string, encoding) | 0
		  that = allocate(that, length)

		  that.write(string, encoding)
		  return that
		}

		function fromObject (that, object) {
		  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

		  if (isArray(object)) return fromArray(that, object)

		  if (object == null) {
		    throw new TypeError('must start with number, buffer, array or string')
		  }

		  if (typeof ArrayBuffer !== 'undefined') {
		    if (object.buffer instanceof ArrayBuffer) {
		      return fromTypedArray(that, object)
		    }
		    if (object instanceof ArrayBuffer) {
		      return fromArrayBuffer(that, object)
		    }
		  }

		  if (object.length) return fromArrayLike(that, object)

		  return fromJsonObject(that, object)
		}

		function fromBuffer (that, buffer) {
		  var length = checked(buffer.length) | 0
		  that = allocate(that, length)
		  buffer.copy(that, 0, 0, length)
		  return that
		}

		function fromArray (that, array) {
		  var length = checked(array.length) | 0
		  that = allocate(that, length)
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		// Duplicate of fromArray() to keep fromArray() monomorphic.
		function fromTypedArray (that, array) {
		  var length = checked(array.length) | 0
		  that = allocate(that, length)
		  // Truncating the elements is probably not what people expect from typed
		  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
		  // of the old Buffer constructor.
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		function fromArrayBuffer (that, array) {
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    array.byteLength
		    that = Buffer._augment(new Uint8Array(array))
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    that = fromTypedArray(that, new Uint8Array(array))
		  }
		  return that
		}

		function fromArrayLike (that, array) {
		  var length = checked(array.length) | 0
		  that = allocate(that, length)
		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
		// Returns a zero-length buffer for inputs that don't conform to the spec.
		function fromJsonObject (that, object) {
		  var array
		  var length = 0

		  if (object.type === 'Buffer' && isArray(object.data)) {
		    array = object.data
		    length = checked(array.length) | 0
		  }
		  that = allocate(that, length)

		  for (var i = 0; i < length; i += 1) {
		    that[i] = array[i] & 255
		  }
		  return that
		}

		if (Buffer.TYPED_ARRAY_SUPPORT) {
		  Buffer.prototype.__proto__ = Uint8Array.prototype
		  Buffer.__proto__ = Uint8Array
		}

		function allocate (that, length) {
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    // Return an augmented `Uint8Array` instance, for best performance
		    that = Buffer._augment(new Uint8Array(length))
		    that.__proto__ = Buffer.prototype
		  } else {
		    // Fallback: Return an object instance of the Buffer class
		    that.length = length
		    that._isBuffer = true
		  }

		  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
		  if (fromPool) that.parent = rootParent

		  return that
		}

		function checked (length) {
		  // Note: cannot use `length < kMaxLength` here because that fails when
		  // length is NaN (which is otherwise coerced to zero.)
		  if (length >= kMaxLength()) {
		    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
		                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
		  }
		  return length | 0
		}

		function SlowBuffer (subject, encoding) {
		  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

		  var buf = new Buffer(subject, encoding)
		  delete buf.parent
		  return buf
		}

		Buffer.isBuffer = function isBuffer (b) {
		  return !!(b != null && b._isBuffer)
		}

		Buffer.compare = function compare (a, b) {
		  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
		    throw new TypeError('Arguments must be Buffers')
		  }

		  if (a === b) return 0

		  var x = a.length
		  var y = b.length

		  var i = 0
		  var len = Math.min(x, y)
		  while (i < len) {
		    if (a[i] !== b[i]) break

		    ++i
		  }

		  if (i !== len) {
		    x = a[i]
		    y = b[i]
		  }

		  if (x < y) return -1
		  if (y < x) return 1
		  return 0
		}

		Buffer.isEncoding = function isEncoding (encoding) {
		  switch (String(encoding).toLowerCase()) {
		    case 'hex':
		    case 'utf8':
		    case 'utf-8':
		    case 'ascii':
		    case 'binary':
		    case 'base64':
		    case 'raw':
		    case 'ucs2':
		    case 'ucs-2':
		    case 'utf16le':
		    case 'utf-16le':
		      return true
		    default:
		      return false
		  }
		}

		Buffer.concat = function concat (list, length) {
		  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

		  if (list.length === 0) {
		    return new Buffer(0)
		  }

		  var i
		  if (length === undefined) {
		    length = 0
		    for (i = 0; i < list.length; i++) {
		      length += list[i].length
		    }
		  }

		  var buf = new Buffer(length)
		  var pos = 0
		  for (i = 0; i < list.length; i++) {
		    var item = list[i]
		    item.copy(buf, pos)
		    pos += item.length
		  }
		  return buf
		}

		function byteLength (string, encoding) {
		  if (typeof string !== 'string') string = '' + string

		  var len = string.length
		  if (len === 0) return 0

		  // Use a for loop to avoid recursion
		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'ascii':
		      case 'binary':
		      // Deprecated
		      case 'raw':
		      case 'raws':
		        return len
		      case 'utf8':
		      case 'utf-8':
		        return utf8ToBytes(string).length
		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return len * 2
		      case 'hex':
		        return len >>> 1
		      case 'base64':
		        return base64ToBytes(string).length
		      default:
		        if (loweredCase) return utf8ToBytes(string).length // assume utf8
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}
		Buffer.byteLength = byteLength

		// pre-set for values that may exist in the future
		Buffer.prototype.length = undefined
		Buffer.prototype.parent = undefined

		function slowToString (encoding, start, end) {
		  var loweredCase = false

		  start = start | 0
		  end = end === undefined || end === Infinity ? this.length : end | 0

		  if (!encoding) encoding = 'utf8'
		  if (start < 0) start = 0
		  if (end > this.length) end = this.length
		  if (end <= start) return ''

		  while (true) {
		    switch (encoding) {
		      case 'hex':
		        return hexSlice(this, start, end)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Slice(this, start, end)

		      case 'ascii':
		        return asciiSlice(this, start, end)

		      case 'binary':
		        return binarySlice(this, start, end)

		      case 'base64':
		        return base64Slice(this, start, end)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return utf16leSlice(this, start, end)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = (encoding + '').toLowerCase()
		        loweredCase = true
		    }
		  }
		}

		Buffer.prototype.toString = function toString () {
		  var length = this.length | 0
		  if (length === 0) return ''
		  if (arguments.length === 0) return utf8Slice(this, 0, length)
		  return slowToString.apply(this, arguments)
		}

		Buffer.prototype.equals = function equals (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return true
		  return Buffer.compare(this, b) === 0
		}

		Buffer.prototype.inspect = function inspect () {
		  var str = ''
		  var max = exports.INSPECT_MAX_BYTES
		  if (this.length > 0) {
		    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
		    if (this.length > max) str += ' ... '
		  }
		  return '<Buffer ' + str + '>'
		}

		Buffer.prototype.compare = function compare (b) {
		  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		  if (this === b) return 0
		  return Buffer.compare(this, b)
		}

		Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
		  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
		  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
		  byteOffset >>= 0

		  if (this.length === 0) return -1
		  if (byteOffset >= this.length) return -1

		  // Negative offsets start from the end of the buffer
		  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

		  if (typeof val === 'string') {
		    if (val.length === 0) return -1 // special case: looking for empty string always fails
		    return String.prototype.indexOf.call(this, val, byteOffset)
		  }
		  if (Buffer.isBuffer(val)) {
		    return arrayIndexOf(this, val, byteOffset)
		  }
		  if (typeof val === 'number') {
		    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
		      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
		    }
		    return arrayIndexOf(this, [ val ], byteOffset)
		  }

		  function arrayIndexOf (arr, val, byteOffset) {
		    var foundIndex = -1
		    for (var i = 0; byteOffset + i < arr.length; i++) {
		      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
		        if (foundIndex === -1) foundIndex = i
		        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
		      } else {
		        foundIndex = -1
		      }
		    }
		    return -1
		  }

		  throw new TypeError('val must be string, number or Buffer')
		}

		// `get` is deprecated
		Buffer.prototype.get = function get (offset) {
		  console.log('.get() is deprecated. Access using array indexes instead.')
		  return this.readUInt8(offset)
		}

		// `set` is deprecated
		Buffer.prototype.set = function set (v, offset) {
		  console.log('.set() is deprecated. Access using array indexes instead.')
		  return this.writeUInt8(v, offset)
		}

		function hexWrite (buf, string, offset, length) {
		  offset = Number(offset) || 0
		  var remaining = buf.length - offset
		  if (!length) {
		    length = remaining
		  } else {
		    length = Number(length)
		    if (length > remaining) {
		      length = remaining
		    }
		  }

		  // must be an even number of digits
		  var strLen = string.length
		  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

		  if (length > strLen / 2) {
		    length = strLen / 2
		  }
		  for (var i = 0; i < length; i++) {
		    var parsed = parseInt(string.substr(i * 2, 2), 16)
		    if (isNaN(parsed)) throw new Error('Invalid hex string')
		    buf[offset + i] = parsed
		  }
		  return i
		}

		function utf8Write (buf, string, offset, length) {
		  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
		}

		function asciiWrite (buf, string, offset, length) {
		  return blitBuffer(asciiToBytes(string), buf, offset, length)
		}

		function binaryWrite (buf, string, offset, length) {
		  return asciiWrite(buf, string, offset, length)
		}

		function base64Write (buf, string, offset, length) {
		  return blitBuffer(base64ToBytes(string), buf, offset, length)
		}

		function ucs2Write (buf, string, offset, length) {
		  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
		}

		Buffer.prototype.write = function write (string, offset, length, encoding) {
		  // Buffer#write(string)
		  if (offset === undefined) {
		    encoding = 'utf8'
		    length = this.length
		    offset = 0
		  // Buffer#write(string, encoding)
		  } else if (length === undefined && typeof offset === 'string') {
		    encoding = offset
		    length = this.length
		    offset = 0
		  // Buffer#write(string, offset[, length][, encoding])
		  } else if (isFinite(offset)) {
		    offset = offset | 0
		    if (isFinite(length)) {
		      length = length | 0
		      if (encoding === undefined) encoding = 'utf8'
		    } else {
		      encoding = length
		      length = undefined
		    }
		  // legacy write(string, encoding, offset, length) - remove in v0.13
		  } else {
		    var swap = encoding
		    encoding = offset
		    offset = length | 0
		    length = swap
		  }

		  var remaining = this.length - offset
		  if (length === undefined || length > remaining) length = remaining

		  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
		    throw new RangeError('attempt to write outside buffer bounds')
		  }

		  if (!encoding) encoding = 'utf8'

		  var loweredCase = false
		  for (;;) {
		    switch (encoding) {
		      case 'hex':
		        return hexWrite(this, string, offset, length)

		      case 'utf8':
		      case 'utf-8':
		        return utf8Write(this, string, offset, length)

		      case 'ascii':
		        return asciiWrite(this, string, offset, length)

		      case 'binary':
		        return binaryWrite(this, string, offset, length)

		      case 'base64':
		        // Warning: maxLength not taken into account in base64Write
		        return base64Write(this, string, offset, length)

		      case 'ucs2':
		      case 'ucs-2':
		      case 'utf16le':
		      case 'utf-16le':
		        return ucs2Write(this, string, offset, length)

		      default:
		        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
		        encoding = ('' + encoding).toLowerCase()
		        loweredCase = true
		    }
		  }
		}

		Buffer.prototype.toJSON = function toJSON () {
		  return {
		    type: 'Buffer',
		    data: Array.prototype.slice.call(this._arr || this, 0)
		  }
		}

		function base64Slice (buf, start, end) {
		  if (start === 0 && end === buf.length) {
		    return base64.fromByteArray(buf)
		  } else {
		    return base64.fromByteArray(buf.slice(start, end))
		  }
		}

		function utf8Slice (buf, start, end) {
		  end = Math.min(buf.length, end)
		  var res = []

		  var i = start
		  while (i < end) {
		    var firstByte = buf[i]
		    var codePoint = null
		    var bytesPerSequence = (firstByte > 0xEF) ? 4
		      : (firstByte > 0xDF) ? 3
		      : (firstByte > 0xBF) ? 2
		      : 1

		    if (i + bytesPerSequence <= end) {
		      var secondByte, thirdByte, fourthByte, tempCodePoint

		      switch (bytesPerSequence) {
		        case 1:
		          if (firstByte < 0x80) {
		            codePoint = firstByte
		          }
		          break
		        case 2:
		          secondByte = buf[i + 1]
		          if ((secondByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
		            if (tempCodePoint > 0x7F) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 3:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
		            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
		              codePoint = tempCodePoint
		            }
		          }
		          break
		        case 4:
		          secondByte = buf[i + 1]
		          thirdByte = buf[i + 2]
		          fourthByte = buf[i + 3]
		          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
		            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
		            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
		              codePoint = tempCodePoint
		            }
		          }
		      }
		    }

		    if (codePoint === null) {
		      // we did not generate a valid codePoint so insert a
		      // replacement char (U+FFFD) and advance only 1 byte
		      codePoint = 0xFFFD
		      bytesPerSequence = 1
		    } else if (codePoint > 0xFFFF) {
		      // encode to utf16 (surrogate pair dance)
		      codePoint -= 0x10000
		      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
		      codePoint = 0xDC00 | codePoint & 0x3FF
		    }

		    res.push(codePoint)
		    i += bytesPerSequence
		  }

		  return decodeCodePointsArray(res)
		}

		// Based on http://stackoverflow.com/a/22747272/680742, the browser with
		// the lowest limit is Chrome, with 0x10000 args.
		// We go 1 magnitude less, for safety
		var MAX_ARGUMENTS_LENGTH = 0x1000

		function decodeCodePointsArray (codePoints) {
		  var len = codePoints.length
		  if (len <= MAX_ARGUMENTS_LENGTH) {
		    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		  }

		  // Decode in chunks to avoid "call stack size exceeded".
		  var res = ''
		  var i = 0
		  while (i < len) {
		    res += String.fromCharCode.apply(
		      String,
		      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
		    )
		  }
		  return res
		}

		function asciiSlice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)

		  for (var i = start; i < end; i++) {
		    ret += String.fromCharCode(buf[i] & 0x7F)
		  }
		  return ret
		}

		function binarySlice (buf, start, end) {
		  var ret = ''
		  end = Math.min(buf.length, end)

		  for (var i = start; i < end; i++) {
		    ret += String.fromCharCode(buf[i])
		  }
		  return ret
		}

		function hexSlice (buf, start, end) {
		  var len = buf.length

		  if (!start || start < 0) start = 0
		  if (!end || end < 0 || end > len) end = len

		  var out = ''
		  for (var i = start; i < end; i++) {
		    out += toHex(buf[i])
		  }
		  return out
		}

		function utf16leSlice (buf, start, end) {
		  var bytes = buf.slice(start, end)
		  var res = ''
		  for (var i = 0; i < bytes.length; i += 2) {
		    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
		  }
		  return res
		}

		Buffer.prototype.slice = function slice (start, end) {
		  var len = this.length
		  start = ~~start
		  end = end === undefined ? len : ~~end

		  if (start < 0) {
		    start += len
		    if (start < 0) start = 0
		  } else if (start > len) {
		    start = len
		  }

		  if (end < 0) {
		    end += len
		    if (end < 0) end = 0
		  } else if (end > len) {
		    end = len
		  }

		  if (end < start) end = start

		  var newBuf
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    newBuf = Buffer._augment(this.subarray(start, end))
		  } else {
		    var sliceLen = end - start
		    newBuf = new Buffer(sliceLen, undefined)
		    for (var i = 0; i < sliceLen; i++) {
		      newBuf[i] = this[i + start]
		    }
		  }

		  if (newBuf.length) newBuf.parent = this.parent || this

		  return newBuf
		}

		/*
		 * Need to make sure that buffer isn't trying to write out of bounds.
		 */
		function checkOffset (offset, ext, length) {
		  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
		}

		Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)

		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }

		  return val
		}

		Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) {
		    checkOffset(offset, byteLength, this.length)
		  }

		  var val = this[offset + --byteLength]
		  var mul = 1
		  while (byteLength > 0 && (mul *= 0x100)) {
		    val += this[offset + --byteLength] * mul
		  }

		  return val
		}

		Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  return this[offset]
		}

		Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return this[offset] | (this[offset + 1] << 8)
		}

		Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  return (this[offset] << 8) | this[offset + 1]
		}

		Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return ((this[offset]) |
		      (this[offset + 1] << 8) |
		      (this[offset + 2] << 16)) +
		      (this[offset + 3] * 0x1000000)
		}

		Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return (this[offset] * 0x1000000) +
		    ((this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    this[offset + 3])
		}

		Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)

		  var val = this[offset]
		  var mul = 1
		  var i = 0
		  while (++i < byteLength && (mul *= 0x100)) {
		    val += this[offset + i] * mul
		  }
		  mul *= 0x80

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

		  return val
		}

		Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkOffset(offset, byteLength, this.length)

		  var i = byteLength
		  var mul = 1
		  var val = this[offset + --i]
		  while (i > 0 && (mul *= 0x100)) {
		    val += this[offset + --i] * mul
		  }
		  mul *= 0x80

		  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

		  return val
		}

		Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 1, this.length)
		  if (!(this[offset] & 0x80)) return (this[offset])
		  return ((0xff - this[offset] + 1) * -1)
		}

		Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset] | (this[offset + 1] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}

		Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 2, this.length)
		  var val = this[offset + 1] | (this[offset] << 8)
		  return (val & 0x8000) ? val | 0xFFFF0000 : val
		}

		Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return (this[offset]) |
		    (this[offset + 1] << 8) |
		    (this[offset + 2] << 16) |
		    (this[offset + 3] << 24)
		}

		Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)

		  return (this[offset] << 24) |
		    (this[offset + 1] << 16) |
		    (this[offset + 2] << 8) |
		    (this[offset + 3])
		}

		Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, true, 23, 4)
		}

		Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 4, this.length)
		  return ieee754.read(this, offset, false, 23, 4)
		}

		Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, true, 52, 8)
		}

		Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		  if (!noAssert) checkOffset(offset, 8, this.length)
		  return ieee754.read(this, offset, false, 52, 8)
		}

		function checkInt (buf, value, offset, ext, max, min) {
		  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
		  if (value > max || value < min) throw new RangeError('value is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('index out of range')
		}

		Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

		  var mul = 1
		  var i = 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  byteLength = byteLength | 0
		  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

		  var i = byteLength - 1
		  var mul = 1
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = (value / mul) & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  this[offset] = (value & 0xff)
		  return offset + 1
		}

		function objectWriteUInt16 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
		    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
		      (littleEndian ? i : 1 - i) * 8
		  }
		}

		Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}

		Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}

		function objectWriteUInt32 (buf, value, offset, littleEndian) {
		  if (value < 0) value = 0xffffffff + value + 1
		  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
		    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
		  }
		}

		Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset + 3] = (value >>> 24)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 1] = (value >>> 8)
		    this[offset] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}

		Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}

		Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)

		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }

		  var i = 0
		  var mul = 1
		  var sub = value < 0 ? 1 : 0
		  this[offset] = value & 0xFF
		  while (++i < byteLength && (mul *= 0x100)) {
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) {
		    var limit = Math.pow(2, 8 * byteLength - 1)

		    checkInt(this, value, offset, byteLength, limit - 1, -limit)
		  }

		  var i = byteLength - 1
		  var mul = 1
		  var sub = value < 0 ? 1 : 0
		  this[offset + i] = value & 0xFF
		  while (--i >= 0 && (mul *= 0x100)) {
		    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		  }

		  return offset + byteLength
		}

		Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
		  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		  if (value < 0) value = 0xff + value + 1
		  this[offset] = (value & 0xff)
		  return offset + 1
		}

		Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		  } else {
		    objectWriteUInt16(this, value, offset, true)
		  }
		  return offset + 2
		}

		Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 8)
		    this[offset + 1] = (value & 0xff)
		  } else {
		    objectWriteUInt16(this, value, offset, false)
		  }
		  return offset + 2
		}

		Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value & 0xff)
		    this[offset + 1] = (value >>> 8)
		    this[offset + 2] = (value >>> 16)
		    this[offset + 3] = (value >>> 24)
		  } else {
		    objectWriteUInt32(this, value, offset, true)
		  }
		  return offset + 4
		}

		Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		  value = +value
		  offset = offset | 0
		  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		  if (value < 0) value = 0xffffffff + value + 1
		  if (Buffer.TYPED_ARRAY_SUPPORT) {
		    this[offset] = (value >>> 24)
		    this[offset + 1] = (value >>> 16)
		    this[offset + 2] = (value >>> 8)
		    this[offset + 3] = (value & 0xff)
		  } else {
		    objectWriteUInt32(this, value, offset, false)
		  }
		  return offset + 4
		}

		function checkIEEE754 (buf, value, offset, ext, max, min) {
		  if (value > max || value < min) throw new RangeError('value is out of bounds')
		  if (offset + ext > buf.length) throw new RangeError('index out of range')
		  if (offset < 0) throw new RangeError('index out of range')
		}

		function writeFloat (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 23, 4)
		  return offset + 4
		}

		Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, true, noAssert)
		}

		Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		  return writeFloat(this, value, offset, false, noAssert)
		}

		function writeDouble (buf, value, offset, littleEndian, noAssert) {
		  if (!noAssert) {
		    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
		  }
		  ieee754.write(buf, value, offset, littleEndian, 52, 8)
		  return offset + 8
		}

		Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, true, noAssert)
		}

		Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		  return writeDouble(this, value, offset, false, noAssert)
		}

		// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
		Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		  if (!start) start = 0
		  if (!end && end !== 0) end = this.length
		  if (targetStart >= target.length) targetStart = target.length
		  if (!targetStart) targetStart = 0
		  if (end > 0 && end < start) end = start

		  // Copy 0 bytes; we're done
		  if (end === start) return 0
		  if (target.length === 0 || this.length === 0) return 0

		  // Fatal error conditions
		  if (targetStart < 0) {
		    throw new RangeError('targetStart out of bounds')
		  }
		  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
		  if (end < 0) throw new RangeError('sourceEnd out of bounds')

		  // Are we oob?
		  if (end > this.length) end = this.length
		  if (target.length - targetStart < end - start) {
		    end = target.length - targetStart + start
		  }

		  var len = end - start
		  var i

		  if (this === target && start < targetStart && targetStart < end) {
		    // descending copy from end
		    for (i = len - 1; i >= 0; i--) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
		    // ascending copy from start
		    for (i = 0; i < len; i++) {
		      target[i + targetStart] = this[i + start]
		    }
		  } else {
		    target._set(this.subarray(start, start + len), targetStart)
		  }

		  return len
		}

		// fill(value, start=0, end=buffer.length)
		Buffer.prototype.fill = function fill (value, start, end) {
		  if (!value) value = 0
		  if (!start) start = 0
		  if (!end) end = this.length

		  if (end < start) throw new RangeError('end < start')

		  // Fill 0 bytes; we're done
		  if (end === start) return
		  if (this.length === 0) return

		  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
		  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

		  var i
		  if (typeof value === 'number') {
		    for (i = start; i < end; i++) {
		      this[i] = value
		    }
		  } else {
		    var bytes = utf8ToBytes(value.toString())
		    var len = bytes.length
		    for (i = start; i < end; i++) {
		      this[i] = bytes[i % len]
		    }
		  }

		  return this
		}

		/**
		 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
		 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
		 */
		Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
		  if (typeof Uint8Array !== 'undefined') {
		    if (Buffer.TYPED_ARRAY_SUPPORT) {
		      return (new Buffer(this)).buffer
		    } else {
		      var buf = new Uint8Array(this.length)
		      for (var i = 0, len = buf.length; i < len; i += 1) {
		        buf[i] = this[i]
		      }
		      return buf.buffer
		    }
		  } else {
		    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
		  }
		}

		// HELPER FUNCTIONS
		// ================

		var BP = Buffer.prototype

		/**
		 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
		 */
		Buffer._augment = function _augment (arr) {
		  arr.constructor = Buffer
		  arr._isBuffer = true

		  // save reference to original Uint8Array set method before overwriting
		  arr._set = arr.set

		  // deprecated
		  arr.get = BP.get
		  arr.set = BP.set

		  arr.write = BP.write
		  arr.toString = BP.toString
		  arr.toLocaleString = BP.toString
		  arr.toJSON = BP.toJSON
		  arr.equals = BP.equals
		  arr.compare = BP.compare
		  arr.indexOf = BP.indexOf
		  arr.copy = BP.copy
		  arr.slice = BP.slice
		  arr.readUIntLE = BP.readUIntLE
		  arr.readUIntBE = BP.readUIntBE
		  arr.readUInt8 = BP.readUInt8
		  arr.readUInt16LE = BP.readUInt16LE
		  arr.readUInt16BE = BP.readUInt16BE
		  arr.readUInt32LE = BP.readUInt32LE
		  arr.readUInt32BE = BP.readUInt32BE
		  arr.readIntLE = BP.readIntLE
		  arr.readIntBE = BP.readIntBE
		  arr.readInt8 = BP.readInt8
		  arr.readInt16LE = BP.readInt16LE
		  arr.readInt16BE = BP.readInt16BE
		  arr.readInt32LE = BP.readInt32LE
		  arr.readInt32BE = BP.readInt32BE
		  arr.readFloatLE = BP.readFloatLE
		  arr.readFloatBE = BP.readFloatBE
		  arr.readDoubleLE = BP.readDoubleLE
		  arr.readDoubleBE = BP.readDoubleBE
		  arr.writeUInt8 = BP.writeUInt8
		  arr.writeUIntLE = BP.writeUIntLE
		  arr.writeUIntBE = BP.writeUIntBE
		  arr.writeUInt16LE = BP.writeUInt16LE
		  arr.writeUInt16BE = BP.writeUInt16BE
		  arr.writeUInt32LE = BP.writeUInt32LE
		  arr.writeUInt32BE = BP.writeUInt32BE
		  arr.writeIntLE = BP.writeIntLE
		  arr.writeIntBE = BP.writeIntBE
		  arr.writeInt8 = BP.writeInt8
		  arr.writeInt16LE = BP.writeInt16LE
		  arr.writeInt16BE = BP.writeInt16BE
		  arr.writeInt32LE = BP.writeInt32LE
		  arr.writeInt32BE = BP.writeInt32BE
		  arr.writeFloatLE = BP.writeFloatLE
		  arr.writeFloatBE = BP.writeFloatBE
		  arr.writeDoubleLE = BP.writeDoubleLE
		  arr.writeDoubleBE = BP.writeDoubleBE
		  arr.fill = BP.fill
		  arr.inspect = BP.inspect
		  arr.toArrayBuffer = BP.toArrayBuffer

		  return arr
		}

		var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

		function base64clean (str) {
		  // Node strips out invalid characters like \n and \t from the string, base64-js does not
		  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
		  // Node converts strings with length < 2 to ''
		  if (str.length < 2) return ''
		  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		  while (str.length % 4 !== 0) {
		    str = str + '='
		  }
		  return str
		}

		function stringtrim (str) {
		  if (str.trim) return str.trim()
		  return str.replace(/^\s+|\s+$/g, '')
		}

		function toHex (n) {
		  if (n < 16) return '0' + n.toString(16)
		  return n.toString(16)
		}

		function utf8ToBytes (string, units) {
		  units = units || Infinity
		  var codePoint
		  var length = string.length
		  var leadSurrogate = null
		  var bytes = []

		  for (var i = 0; i < length; i++) {
		    codePoint = string.charCodeAt(i)

		    // is surrogate component
		    if (codePoint > 0xD7FF && codePoint < 0xE000) {
		      // last char was a lead
		      if (!leadSurrogate) {
		        // no lead yet
		        if (codePoint > 0xDBFF) {
		          // unexpected trail
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        } else if (i + 1 === length) {
		          // unpaired lead
		          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		          continue
		        }

		        // valid lead
		        leadSurrogate = codePoint

		        continue
		      }

		      // 2 leads in a row
		      if (codePoint < 0xDC00) {
		        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		        leadSurrogate = codePoint
		        continue
		      }

		      // valid surrogate pair
		      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
		    } else if (leadSurrogate) {
		      // valid bmp char, but last char was a lead
		      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
		    }

		    leadSurrogate = null

		    // encode utf8
		    if (codePoint < 0x80) {
		      if ((units -= 1) < 0) break
		      bytes.push(codePoint)
		    } else if (codePoint < 0x800) {
		      if ((units -= 2) < 0) break
		      bytes.push(
		        codePoint >> 0x6 | 0xC0,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x10000) {
		      if ((units -= 3) < 0) break
		      bytes.push(
		        codePoint >> 0xC | 0xE0,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else if (codePoint < 0x110000) {
		      if ((units -= 4) < 0) break
		      bytes.push(
		        codePoint >> 0x12 | 0xF0,
		        codePoint >> 0xC & 0x3F | 0x80,
		        codePoint >> 0x6 & 0x3F | 0x80,
		        codePoint & 0x3F | 0x80
		      )
		    } else {
		      throw new Error('Invalid code point')
		    }
		  }

		  return bytes
		}

		function asciiToBytes (str) {
		  var byteArray = []
		  for (var i = 0; i < str.length; i++) {
		    // Node's code seems to be doing this and not & 0x7F..
		    byteArray.push(str.charCodeAt(i) & 0xFF)
		  }
		  return byteArray
		}

		function utf16leToBytes (str, units) {
		  var c, hi, lo
		  var byteArray = []
		  for (var i = 0; i < str.length; i++) {
		    if ((units -= 2) < 0) break

		    c = str.charCodeAt(i)
		    hi = c >> 8
		    lo = c % 256
		    byteArray.push(lo)
		    byteArray.push(hi)
		  }

		  return byteArray
		}

		function base64ToBytes (str) {
		  return base64.toByteArray(base64clean(str))
		}

		function blitBuffer (src, dst, offset, length) {
		  for (var i = 0; i < length; i++) {
		    if ((i + offset >= dst.length) || (i >= src.length)) break
		    dst[i + offset] = src[i]
		  }
		  return i
		}

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(69).Buffer, (function() { return this; }())))

	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {

		var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

		;(function (exports) {
			'use strict';

		  var Arr = (typeof Uint8Array !== 'undefined')
		    ? Uint8Array
		    : Array

			var PLUS   = '+'.charCodeAt(0)
			var SLASH  = '/'.charCodeAt(0)
			var NUMBER = '0'.charCodeAt(0)
			var LOWER  = 'a'.charCodeAt(0)
			var UPPER  = 'A'.charCodeAt(0)
			var PLUS_URL_SAFE = '-'.charCodeAt(0)
			var SLASH_URL_SAFE = '_'.charCodeAt(0)

			function decode (elt) {
				var code = elt.charCodeAt(0)
				if (code === PLUS ||
				    code === PLUS_URL_SAFE)
					return 62 // '+'
				if (code === SLASH ||
				    code === SLASH_URL_SAFE)
					return 63 // '/'
				if (code < NUMBER)
					return -1 //no match
				if (code < NUMBER + 10)
					return code - NUMBER + 26 + 26
				if (code < UPPER + 26)
					return code - UPPER
				if (code < LOWER + 26)
					return code - LOWER + 26
			}

			function b64ToByteArray (b64) {
				var i, j, l, tmp, placeHolders, arr

				if (b64.length % 4 > 0) {
					throw new Error('Invalid string. Length must be a multiple of 4')
				}

				// the number of equal signs (place holders)
				// if there are two placeholders, than the two characters before it
				// represent one byte
				// if there is only one, then the three characters before it represent 2 bytes
				// this is just a cheap hack to not do indexOf twice
				var len = b64.length
				placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

				// base64 is 4/3 + up to two characters of the original data
				arr = new Arr(b64.length * 3 / 4 - placeHolders)

				// if there are placeholders, only get up to the last complete 4 chars
				l = placeHolders > 0 ? b64.length - 4 : b64.length

				var L = 0

				function push (v) {
					arr[L++] = v
				}

				for (i = 0, j = 0; i < l; i += 4, j += 3) {
					tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
					push((tmp & 0xFF0000) >> 16)
					push((tmp & 0xFF00) >> 8)
					push(tmp & 0xFF)
				}

				if (placeHolders === 2) {
					tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
					push(tmp & 0xFF)
				} else if (placeHolders === 1) {
					tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
					push((tmp >> 8) & 0xFF)
					push(tmp & 0xFF)
				}

				return arr
			}

			function uint8ToBase64 (uint8) {
				var i,
					extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
					output = "",
					temp, length

				function encode (num) {
					return lookup.charAt(num)
				}

				function tripletToBase64 (num) {
					return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
				}

				// go through the array every three bytes, we'll deal with trailing stuff later
				for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
					temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
					output += tripletToBase64(temp)
				}

				// pad the end with zeros, but make sure to not forget the extra bytes
				switch (extraBytes) {
					case 1:
						temp = uint8[uint8.length - 1]
						output += encode(temp >> 2)
						output += encode((temp << 4) & 0x3F)
						output += '=='
						break
					case 2:
						temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
						output += encode(temp >> 10)
						output += encode((temp >> 4) & 0x3F)
						output += encode((temp << 2) & 0x3F)
						output += '='
						break
				}

				return output
			}

			exports.toByteArray = b64ToByteArray
			exports.fromByteArray = uint8ToBase64
		}( false ? (this.base64js = {}) : exports))


	/***/ },
	/* 71 */
	/***/ function(module, exports) {

		exports.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var nBits = -7
		  var i = isLE ? (nBytes - 1) : 0
		  var d = isLE ? -1 : 1
		  var s = buffer[offset + i]

		  i += d

		  e = s & ((1 << (-nBits)) - 1)
		  s >>= (-nBits)
		  nBits += eLen
		  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

		  m = e & ((1 << (-nBits)) - 1)
		  e >>= (-nBits)
		  nBits += mLen
		  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

		  if (e === 0) {
		    e = 1 - eBias
		  } else if (e === eMax) {
		    return m ? NaN : ((s ? -1 : 1) * Infinity)
		  } else {
		    m = m + Math.pow(2, mLen)
		    e = e - eBias
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		}

		exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c
		  var eLen = nBytes * 8 - mLen - 1
		  var eMax = (1 << eLen) - 1
		  var eBias = eMax >> 1
		  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
		  var i = isLE ? 0 : (nBytes - 1)
		  var d = isLE ? 1 : -1
		  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

		  value = Math.abs(value)

		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0
		    e = eMax
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2)
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--
		      c *= 2
		    }
		    if (e + eBias >= 1) {
		      value += rt / c
		    } else {
		      value += rt * Math.pow(2, 1 - eBias)
		    }
		    if (value * c >= 2) {
		      e++
		      c /= 2
		    }

		    if (e + eBias >= eMax) {
		      m = 0
		      e = eMax
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen)
		      e = e + eBias
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
		      e = 0
		    }
		  }

		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

		  e = (e << mLen) | m
		  eLen += mLen
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

		  buffer[offset + i - d] |= s * 128
		}


	/***/ },
	/* 72 */
	/***/ function(module, exports) {

		
		/**
		 * isArray
		 */

		var isArray = Array.isArray;

		/**
		 * toString
		 */

		var str = Object.prototype.toString;

		/**
		 * Whether or not the given `val`
		 * is an array.
		 *
		 * example:
		 *
		 *        isArray([]);
		 *        // > true
		 *        isArray(arguments);
		 *        // > false
		 *        isArray('');
		 *        // > false
		 *
		 * @param {mixed} val
		 * @return {bool}
		 */

		module.exports = isArray || function (val) {
		  return !! val && '[object Array]' == str.call(val);
		};


	/***/ },
	/* 73 */
	/***/ function(module, exports, __webpack_require__) {

		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var hl = __webpack_require__(2);
		var hlimpl = __webpack_require__(5);
		var Error = __webpack_require__(9);
		var util = __webpack_require__(11);
		var proxy = __webpack_require__(6);
		var RamlWrapper = __webpack_require__(1);
		var RamlWrapper08 = __webpack_require__(74);
		var wrapperHelper = __webpack_require__(65);
		var pluralize = __webpack_require__(89);
		var universeProvider = __webpack_require__(77);
		var changeCase = __webpack_require__(90);
		function expandTraitsAndResourceTypes(api) {
		    if (!(api instanceof RamlWrapper.ApiImpl || api instanceof RamlWrapper08.ApiImpl)) {
		        return null;
		    }
		    return new TraitsAndResourceTypesExpander().expandTraitsAndResourceTypes(api);
		}
		exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
		function mergeAPIs(masterUnit, extensionsAndOverlays, mergeMode) {
		    var masterApi = hl.fromUnit(masterUnit);
		    if (!masterApi)
		        throw new Error("couldn't load api from " + masterUnit.absolutePath());
		    if (!extensionsAndOverlays || extensionsAndOverlays.length == 0) {
		        return masterApi;
		    }
		    var currentMaster = masterApi;
		    var lastExtensionOrOverlay = null;
		    for (var i = 0; i < extensionsAndOverlays.length; i++) {
		        var currentUnit = extensionsAndOverlays[i];
		        var currentApi = hl.fromUnit(currentUnit);
		        if (!currentApi)
		            throw new Error("couldn't load api from " + currentUnit.absolutePath());
		        currentApi.overrideMaster(currentMaster);
		        currentApi.setMergeMode(mergeMode);
		        currentMaster = currentApi;
		        if (i == extensionsAndOverlays.length - 1) {
		            lastExtensionOrOverlay = currentApi;
		        }
		    }
		    return lastExtensionOrOverlay;
		}
		exports.mergeAPIs = mergeAPIs;
		var TraitsAndResourceTypesExpander = (function () {
		    function TraitsAndResourceTypesExpander() {
		    }
		    TraitsAndResourceTypesExpander.prototype.expandTraitsAndResourceTypes = function (_api) {
		        var _this = this;
		        var isRAML1 = _api instanceof RamlWrapper.ApiImpl;
		        var api = _api;
		        var traits = wrapperHelper.allTraits(api);
		        var resourceTypes = wrapperHelper.allResourceTypes(api);
		        //if ((!traits || traits.length == 0) && (!resourceTypes || resourceTypes.length == 0)) {
		        //    return api;
		        //}
		        var llNode = api.highLevel().lowLevel();
		        this.ramlVersion = _api.highLevel().definition().universe().version();
		        var topComposite = new proxy.LowLevelCompositeNode(llNode, null, null);
		        var apiType = isRAML1 ? universeProvider('RAML10').type('Api') : universeProvider('RAML08').type('Api');
		        var hlNode = new hlimpl.ASTNodeImpl(topComposite, null, apiType, null);
		        var result = isRAML1 ? new RamlWrapper.ApiImpl(hlNode) : new RamlWrapper08.ApiImpl(hlNode);
		        this.traitMap = {};
		        this.resourceTypeMap = {};
		        result.highLevel().setMergeMode(_api.highLevel().getMergeMode());
		        if (traits) {
		            traits.forEach(function (x) { return _this.traitMap[wrapperHelper.qName(x)] = x; });
		        }
		        if (resourceTypes) {
		            resourceTypes.forEach(function (x) { return _this.resourceTypeMap[wrapperHelper.qName(x)] = x; });
		        }
		        var resources = result.resources();
		        resources.forEach(function (x) { return _this.processResource(x); });
		        return result;
		    };
		    TraitsAndResourceTypesExpander.prototype.processResource = function (resource) {
		        var _this = this;
		        var resourceData = this.collectResourceData(resource);
		        if (resource instanceof RamlWrapper.ResourceImpl) {
		            var mb = resource;
		        }
		        var resourceLowLevel = resource.highLevel().lowLevel();
		        resourceData.filter(function (x) { return x.resourceType != null; }).forEach(function (x) {
		            var resourceTypeLowLevel = x.resourceType.node.highLevel().lowLevel();
		            var resourceTypeTransformer = new DefaultTransformer(resource, x.resourceType.transformer);
		            resourceLowLevel.adopt(resourceTypeLowLevel, resourceTypeTransformer);
		        });
		        var methods = resource.methods();
		        methods.forEach(function (m) {
		            var methodLowLevel = m.highLevel().lowLevel();
		            var name = m.method();
		            var map = {};
		            resourceData.forEach(function (x) {
		                var methodTraits = x.methodTraits[name];
		                if (methodTraits) {
		                    methodTraits.forEach(function (x) {
		                        var traitLowLevel = x.node.highLevel().lowLevel();
		                        var traitTransformer = new DefaultTransformer(m, x.transformer);
		                        methodLowLevel.adopt(traitLowLevel, traitTransformer);
		                    });
		                }
		                var resourceTraits = x.traits;
		                if (resourceTraits) {
		                    resourceTraits.forEach(function (x) {
		                        var traitLowLevel = x.node.highLevel().lowLevel();
		                        var traitTransformer = new DefaultTransformer(m, x.transformer);
		                        methodLowLevel.adopt(traitLowLevel, traitTransformer);
		                    });
		                }
		            });
		        });
		        var resources = resource.resources();
		        resources.forEach(function (x) { return _this.processResource(x); });
		    };
		    TraitsAndResourceTypesExpander.prototype.collectResourceData = function (obj, arr, transformer) {
		        var _this = this;
		        if (arr === void 0) { arr = []; }
		        var ownTraits = this.extractTraits(obj);
		        var methodTraitsMap = {};
		        var methods = obj.methods();
		        methods.forEach(function (x) {
		            var methodTraits = _this.extractTraits(x);
		            if (methodTraits && methodTraits.length > 0) {
		                methodTraitsMap[x.method()] = methodTraits;
		            }
		        });
		        var rtData;
		        var rt = obj.type();
		        if (rt) {
		            rtData = this.readGenerictData(rt, this.resourceTypeMap, 'resource type', transformer);
		        }
		        arr.push({
		            resourceType: rtData,
		            traits: ownTraits,
		            methodTraits: methodTraitsMap
		        });
		        if (rtData) {
		            this.collectResourceData(rtData.node, arr, rtData.transformer);
		        }
		        return arr;
		    };
		    TraitsAndResourceTypesExpander.prototype.extractTraits = function (obj, _transformer, map) {
		        var _this = this;
		        if (map === void 0) { map = {}; }
		        var arr = [];
		        for (var i = -1; i < arr.length; i++) {
		            var gd = i < 0 ? null : arr[i];
		            var _obj = gd ? gd.node : obj;
		            var transformer = gd ? gd.transformer : _transformer;
		            _obj.is().forEach(function (x) {
		                var traitData = _this.readGenerictData(x, _this.traitMap, 'trait', transformer);
		                if (traitData) {
		                    var name = traitData.name;
		                    if (!map[name]) {
		                        map[name] = true;
		                        arr.push(traitData);
		                    }
		                }
		            });
		        }
		        if (obj instanceof RamlWrapper.MethodImpl) {
		            var mb = obj;
		        }
		        return arr;
		    };
		    TraitsAndResourceTypesExpander.prototype.readGenerictData = function (obj, globalMap, template, transformer) {
		        var value = obj.value();
		        if (typeof (value) == 'string') {
		            if (transformer) {
		                value = transformer.transform(value).value;
		            }
		            var node = globalMap[value];
		            if (node) {
		                return {
		                    name: value,
		                    transformer: null,
		                    node: node
		                };
		            }
		        }
		        else if (value instanceof hlimpl.StructuredValue) {
		            var sv = value;
		            var name = sv.valueName();
		            var params = {};
		            var node = globalMap[name];
		            //var t = hlimpl.typeFromNode(node.highLevel());
		            if (node) {
		                if (this.ramlVersion == 'RAML08' && transformer) {
		                    sv.children().forEach(function (x) { return params[x.valueName()] = transformer.transform(x.lowLevel().value()).value; });
		                }
		                else {
		                    sv.children().forEach(function (x) { return params[x.valueName()] = x.lowLevel().value(); });
		                }
		                return {
		                    name: name,
		                    transformer: new ValueTransformer(template, name, params),
		                    node: node
		                };
		            }
		        }
		        return null;
		    };
		    return TraitsAndResourceTypesExpander;
		})();
		var TransformMatches = (function () {
		    function TransformMatches(name, transformer) {
		        this.name = name;
		        this.regexp = new RegExp(TransformMatches.leftTransformRegexp.source + name + TransformMatches.rightTransformRegexp.source);
		        this.transformer = transformer;
		    }
		    TransformMatches.leftTransformRegexp = /\|\s*!\s*/;
		    TransformMatches.rightTransformRegexp = /\s*$/;
		    return TransformMatches;
		})();
		var transformers = [
		    new TransformMatches("singularize", function (arg) { return pluralize.singular(arg); }),
		    new TransformMatches("pluralize", function (arg) { return pluralize.plural(arg); }),
		    new TransformMatches("uppercase", function (arg) { return arg ? arg.toUpperCase() : arg; }),
		    new TransformMatches("lowercase", function (arg) { return arg ? arg.toLowerCase() : arg; }),
		    new TransformMatches("lowercamelcase", function (arg) {
		        if (!arg) {
		            return arg;
		        }
		        return changeCase.camelCase(arg);
		    }),
		    new TransformMatches("uppercamelcase", function (arg) {
		        if (!arg) {
		            return arg;
		        }
		        var lowerCamelCase = changeCase.camelCase(arg);
		        return lowerCamelCase[0].toUpperCase() + lowerCamelCase.substring(1, lowerCamelCase.length);
		    }),
		    new TransformMatches("lowerunderscorecase", function (arg) {
		        if (!arg) {
		            return arg;
		        }
		        var snakeCase = changeCase.snake(arg);
		        return snakeCase.toLowerCase();
		    }),
		    new TransformMatches("upperunderscorecase", function (arg) {
		        if (!arg) {
		            return arg;
		        }
		        var snakeCase = changeCase.snake(arg);
		        return snakeCase.toUpperCase();
		    }),
		    new TransformMatches("lowerhyphencase", function (arg) {
		        if (!arg) {
		            return arg;
		        }
		        var paramCase = changeCase.param(arg);
		        return paramCase.toLowerCase();
		    }),
		    new TransformMatches("upperhyphencase", function (arg) {
		        if (!arg) {
		            return arg;
		        }
		        var paramCase = changeCase.param(arg);
		        return paramCase.toUpperCase();
		    })
		];
		function getTransformNames() {
		    return transformers.map(function (transformer) { return transformer.name; });
		}
		exports.getTransformNames = getTransformNames;
		function getTransformerForOccurence(occurence) {
		    var result;
		    for (var i = 0; i < transformers.length; i++) {
		        if (occurence.match(transformers[i].regexp)) {
		            result = transformers[i].transformer;
		            break;
		        }
		    }
		    return result;
		}
		var ValueTransformer = (function () {
		    function ValueTransformer(templateKind, templateName, params) {
		        this.templateKind = templateKind;
		        this.templateName = templateName;
		        this.params = params;
		    }
		    ValueTransformer.prototype.transform = function (obj) {
		        var undefParams = {};
		        var errors = [];
		        if (typeof (obj) === 'string') {
		            var str = obj;
		            var str1 = '';
		            var prev = 0;
		            for (var i = str.indexOf('<<'); i >= 0; i = str.indexOf('<<', prev)) {
		                str1 += str.substring(prev, i);
		                var i0 = i;
		                i += '<<'.length;
		                prev = str.indexOf('>>', i);
		                var paramOccurence = str.substring(i, prev);
		                prev += '>>'.length;
		                var originalString = str.substring(i0, prev);
		                var val;
		                var paramName;
		                var transformer = getTransformerForOccurence(paramOccurence);
		                if (transformer) {
		                    var ind = paramOccurence.lastIndexOf('|');
		                    paramName = paramOccurence.substring(0, ind).trim();
		                    val = this.params[paramName];
		                    if (val) {
		                        val = transformer(val);
		                    }
		                }
		                else {
		                    paramName = paramOccurence.trim();
		                    val = this.params[paramName];
		                }
		                if (!val) {
		                    undefParams[paramName] = true;
		                    val = originalString;
		                }
		                str1 += val;
		            }
		            var upArr = Object.keys(undefParams);
		            if (upArr.length > 0) {
		                var errStr = upArr.join(', ').trim();
		                var message = "Undefined " + this.templateKind + " parameter" + (upArr.length > 1 ? 's' : '') + ": " + errStr;
		                var error = {
		                    code: 3 /* MISSING_REQUIRED_PROPERTY */,
		                    isWarning: false,
		                    message: message,
		                    node: null,
		                    start: -1,
		                    end: -1,
		                    path: null
		                };
		                errors.push(error);
		            }
		            str1 += str.substring(prev, str.length);
		            return { value: str1, errors: errors };
		        }
		        else {
		            return { value: obj, errors: errors };
		        }
		    };
		    return ValueTransformer;
		})();
		var DefaultTransformer = (function (_super) {
		    __extends(DefaultTransformer, _super);
		    function DefaultTransformer(owner, delegate) {
		        _super.call(this, delegate.templateKind, delegate.templateName, null);
		        this.owner = owner;
		        this.delegate = delegate;
		    }
		    DefaultTransformer.prototype.transform = function (obj) {
		        if (obj == null) {
		            return {
		                value: obj,
		                errors: []
		            };
		        }
		        var ownResult = {
		            value: obj,
		            errors: []
		        };
		        var gotDefaultParam = false;
		        defaultParameters.forEach(function (x) { return gotDefaultParam = gotDefaultParam || obj.toString().indexOf('<<' + x) >= 0; });
		        if (gotDefaultParam) {
		            this.initParams();
		            ownResult = _super.prototype.transform.call(this, obj);
		        }
		        var result = this.delegate.transform(ownResult.value);
		        return result;
		    };
		    DefaultTransformer.prototype.initParams = function () {
		        var methodName;
		        var resourcePath = "";
		        var resourcePathName;
		        var node = this.owner.highLevel().lowLevel().originalNode().originalNode();
		        while (node) {
		            var key = node.key();
		            if (key != null) {
		                if (util.stringStartsWith(key, '/')) {
		                    if (!resourcePathName) {
		                        resourcePathName = key.replace(/[\/\{\}]/g, '');
		                    }
		                    resourcePath = key + resourcePath;
		                }
		                else {
		                    methodName = key;
		                }
		            }
		            node = node.parent();
		        }
		        this.params = {
		            resourcePath: resourcePath,
		            resourcePathName: resourcePathName
		        };
		        if (methodName) {
		            this.params['methodName'] = methodName;
		        }
		    };
		    return DefaultTransformer;
		})(ValueTransformer);
		var defaultParameters = ['resourcePath', 'resourcePathName', 'methodName'];


	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {

		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var hl = __webpack_require__(2);
		var services = __webpack_require__(49);
		var core = __webpack_require__(75);
		var apiLoader = __webpack_require__(76);
		var helper = __webpack_require__(88);
		var RAMLLanguageElementImpl = (function (_super) {
		    __extends(RAMLLanguageElementImpl, _super);
		    function RAMLLanguageElementImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLLanguageElementImpl.prototype.wrapperClassName = function () {
		        return "RAMLLanguageElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLLanguageElementImpl.prototype.getKind = function () {
		        return "RAMLLanguageElement";
		    };
		    /**
		     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]
		     **/
		    RAMLLanguageElementImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    return RAMLLanguageElementImpl;
		})(core.BasicNodeImpl);
		exports.RAMLLanguageElementImpl = RAMLLanguageElementImpl;
		var ValueTypeImpl = (function (_super) {
		    __extends(ValueTypeImpl, _super);
		    function ValueTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ValueTypeImpl.prototype.wrapperClassName = function () {
		        return "ValueTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ValueTypeImpl.prototype.getKind = function () {
		        return "ValueType";
		    };
		    /**
		     * @return String representation of the node value
		     **/
		    ValueTypeImpl.prototype.value = function () {
		        return this.attr.value();
		    };
		    return ValueTypeImpl;
		})(core.AttributeNodeImpl);
		exports.ValueTypeImpl = ValueTypeImpl;
		var NumberTypeImpl = (function (_super) {
		    __extends(NumberTypeImpl, _super);
		    function NumberTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    NumberTypeImpl.prototype.wrapperClassName = function () {
		        return "NumberTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    NumberTypeImpl.prototype.getKind = function () {
		        return "NumberType";
		    };
		    return NumberTypeImpl;
		})(ValueTypeImpl);
		exports.NumberTypeImpl = NumberTypeImpl;
		var BooleanTypeImpl = (function (_super) {
		    __extends(BooleanTypeImpl, _super);
		    function BooleanTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    BooleanTypeImpl.prototype.wrapperClassName = function () {
		        return "BooleanTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    BooleanTypeImpl.prototype.getKind = function () {
		        return "BooleanType";
		    };
		    return BooleanTypeImpl;
		})(ValueTypeImpl);
		exports.BooleanTypeImpl = BooleanTypeImpl;
		var ReferenceImpl = (function (_super) {
		    __extends(ReferenceImpl, _super);
		    function ReferenceImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ReferenceImpl.prototype.wrapperClassName = function () {
		        return "ReferenceImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ReferenceImpl.prototype.getKind = function () {
		        return "Reference";
		    };
		    /**
		     * @return StructuredValue object representing the node value
		     **/
		    ReferenceImpl.prototype.value = function () {
		        return core.toStructuredValue(this.attr);
		    };
		    return ReferenceImpl;
		})(core.AttributeNodeImpl);
		exports.ReferenceImpl = ReferenceImpl;
		var ResourceTypeRefImpl = (function (_super) {
		    __extends(ResourceTypeRefImpl, _super);
		    function ResourceTypeRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceTypeRefImpl.prototype.wrapperClassName = function () {
		        return "ResourceTypeRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceTypeRefImpl.prototype.getKind = function () {
		        return "ResourceTypeRef";
		    };
		    return ResourceTypeRefImpl;
		})(ReferenceImpl);
		exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
		var TraitRefImpl = (function (_super) {
		    __extends(TraitRefImpl, _super);
		    function TraitRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    TraitRefImpl.prototype.wrapperClassName = function () {
		        return "TraitRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    TraitRefImpl.prototype.getKind = function () {
		        return "TraitRef";
		    };
		    return TraitRefImpl;
		})(ReferenceImpl);
		exports.TraitRefImpl = TraitRefImpl;
		var SecuritySchemaRefImpl = (function (_super) {
		    __extends(SecuritySchemaRefImpl, _super);
		    function SecuritySchemaRefImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemaRefImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemaRefImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemaRefImpl.prototype.getKind = function () {
		        return "SecuritySchemaRef";
		    };
		    return SecuritySchemaRefImpl;
		})(ReferenceImpl);
		exports.SecuritySchemaRefImpl = SecuritySchemaRefImpl;
		var StringTypeImpl = (function (_super) {
		    __extends(StringTypeImpl, _super);
		    function StringTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    StringTypeImpl.prototype.wrapperClassName = function () {
		        return "StringTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    StringTypeImpl.prototype.getKind = function () {
		        return "StringType";
		    };
		    return StringTypeImpl;
		})(ValueTypeImpl);
		exports.StringTypeImpl = StringTypeImpl;
		/**
		 * This type currently serves both for absolute and relative urls
		 **/
		var UriTemplateImpl = (function (_super) {
		    __extends(UriTemplateImpl, _super);
		    function UriTemplateImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    UriTemplateImpl.prototype.wrapperClassName = function () {
		        return "UriTemplateImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    UriTemplateImpl.prototype.getKind = function () {
		        return "UriTemplate";
		    };
		    return UriTemplateImpl;
		})(StringTypeImpl);
		exports.UriTemplateImpl = UriTemplateImpl;
		/**
		 * This  type describes relative uri templates
		 **/
		var RelativeUriStringImpl = (function (_super) {
		    __extends(RelativeUriStringImpl, _super);
		    function RelativeUriStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RelativeUriStringImpl.prototype.wrapperClassName = function () {
		        return "RelativeUriStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RelativeUriStringImpl.prototype.getKind = function () {
		        return "RelativeUriString";
		    };
		    return RelativeUriStringImpl;
		})(UriTemplateImpl);
		exports.RelativeUriStringImpl = RelativeUriStringImpl;
		/**
		 * This  type describes absolute uri templates
		 **/
		var FullUriTemplateStringImpl = (function (_super) {
		    __extends(FullUriTemplateStringImpl, _super);
		    function FullUriTemplateStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FullUriTemplateStringImpl.prototype.wrapperClassName = function () {
		        return "FullUriTemplateStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FullUriTemplateStringImpl.prototype.getKind = function () {
		        return "FullUriTemplateString";
		    };
		    return FullUriTemplateStringImpl;
		})(UriTemplateImpl);
		exports.FullUriTemplateStringImpl = FullUriTemplateStringImpl;
		/**
		 * This  type describes fixed uris
		 **/
		var FixedUriImpl = (function (_super) {
		    __extends(FixedUriImpl, _super);
		    function FixedUriImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FixedUriImpl.prototype.wrapperClassName = function () {
		        return "FixedUriImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FixedUriImpl.prototype.getKind = function () {
		        return "FixedUri";
		    };
		    return FixedUriImpl;
		})(StringTypeImpl);
		exports.FixedUriImpl = FixedUriImpl;
		/**
		 * Schema at this moment only two subtypes are supported (json schema and xsd)
		 **/
		var SchemaStringImpl = (function (_super) {
		    __extends(SchemaStringImpl, _super);
		    function SchemaStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SchemaStringImpl.prototype.wrapperClassName = function () {
		        return "SchemaStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SchemaStringImpl.prototype.getKind = function () {
		        return "SchemaString";
		    };
		    return SchemaStringImpl;
		})(StringTypeImpl);
		exports.SchemaStringImpl = SchemaStringImpl;
		/**
		 * JSON schema
		 **/
		var JSonSchemaStringImpl = (function (_super) {
		    __extends(JSonSchemaStringImpl, _super);
		    function JSonSchemaStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    JSonSchemaStringImpl.prototype.wrapperClassName = function () {
		        return "JSonSchemaStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    JSonSchemaStringImpl.prototype.getKind = function () {
		        return "JSonSchemaString";
		    };
		    return JSonSchemaStringImpl;
		})(SchemaStringImpl);
		exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
		/**
		 * XSD schema
		 **/
		var XMLSchemaStringImpl = (function (_super) {
		    __extends(XMLSchemaStringImpl, _super);
		    function XMLSchemaStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    XMLSchemaStringImpl.prototype.wrapperClassName = function () {
		        return "XMLSchemaStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    XMLSchemaStringImpl.prototype.getKind = function () {
		        return "XMLSchemaString";
		    };
		    return XMLSchemaStringImpl;
		})(SchemaStringImpl);
		exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
		var ExampleStringImpl = (function (_super) {
		    __extends(ExampleStringImpl, _super);
		    function ExampleStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ExampleStringImpl.prototype.wrapperClassName = function () {
		        return "ExampleStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ExampleStringImpl.prototype.getKind = function () {
		        return "ExampleString";
		    };
		    return ExampleStringImpl;
		})(StringTypeImpl);
		exports.ExampleStringImpl = ExampleStringImpl;
		var JSONExampleImpl = (function (_super) {
		    __extends(JSONExampleImpl, _super);
		    function JSONExampleImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    JSONExampleImpl.prototype.wrapperClassName = function () {
		        return "JSONExampleImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    JSONExampleImpl.prototype.getKind = function () {
		        return "JSONExample";
		    };
		    return JSONExampleImpl;
		})(ExampleStringImpl);
		exports.JSONExampleImpl = JSONExampleImpl;
		var XMLExampleImpl = (function (_super) {
		    __extends(XMLExampleImpl, _super);
		    function XMLExampleImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    XMLExampleImpl.prototype.wrapperClassName = function () {
		        return "XMLExampleImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    XMLExampleImpl.prototype.getKind = function () {
		        return "XMLExample";
		    };
		    return XMLExampleImpl;
		})(ExampleStringImpl);
		exports.XMLExampleImpl = XMLExampleImpl;
		var StatusCodeStringImpl = (function (_super) {
		    __extends(StatusCodeStringImpl, _super);
		    function StatusCodeStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    StatusCodeStringImpl.prototype.wrapperClassName = function () {
		        return "StatusCodeStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    StatusCodeStringImpl.prototype.getKind = function () {
		        return "StatusCodeString";
		    };
		    return StatusCodeStringImpl;
		})(StringTypeImpl);
		exports.StatusCodeStringImpl = StatusCodeStringImpl;
		/**
		 * This sub type of the string represents mime types
		 **/
		var MimeTypeImpl = (function (_super) {
		    __extends(MimeTypeImpl, _super);
		    function MimeTypeImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MimeTypeImpl.prototype.wrapperClassName = function () {
		        return "MimeTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MimeTypeImpl.prototype.getKind = function () {
		        return "MimeType";
		    };
		    return MimeTypeImpl;
		})(StringTypeImpl);
		exports.MimeTypeImpl = MimeTypeImpl;
		/**
		 * Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0
		 **/
		var MarkdownStringImpl = (function (_super) {
		    __extends(MarkdownStringImpl, _super);
		    function MarkdownStringImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MarkdownStringImpl.prototype.wrapperClassName = function () {
		        return "MarkdownStringImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MarkdownStringImpl.prototype.getKind = function () {
		        return "MarkdownString";
		    };
		    return MarkdownStringImpl;
		})(StringTypeImpl);
		exports.MarkdownStringImpl = MarkdownStringImpl;
		/**
		 * Declares globally referenceable security schema definition
		 **/
		var SecuritySchemaImpl = (function (_super) {
		    __extends(SecuritySchemaImpl, _super);
		    function SecuritySchemaImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchema(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemaImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemaImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemaImpl.prototype.getKind = function () {
		        return "SecuritySchema";
		    };
		    SecuritySchemaImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    SecuritySchemaImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
		     **/
		    SecuritySchemaImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', this.toString);
		    };
		    /**
		     * @hidden
		     * Set type value
		     **/
		    SecuritySchemaImpl.prototype.setType = function (param) {
		        this.highLevel().attrOrCreate("type").setValue("" + param);
		        return this;
		    };
		    /**
		     * The description attribute MAY be used to describe a securitySchemes property.
		     **/
		    SecuritySchemaImpl.prototype.description = function () {
		        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    /**
		     * The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.
		     * This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation.
		     **/
		    SecuritySchemaImpl.prototype.describedBy = function () {
		        return _super.prototype.element.call(this, 'describedBy');
		    };
		    /**
		     * The settings attribute MAY be used to provide security schema-specific information. Depending on the value of the type parameter, its attributes can vary.
		     * The following lists describe the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the Security Scheme type. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, an so on.
		     **/
		    SecuritySchemaImpl.prototype.settings = function () {
		        return _super.prototype.element.call(this, 'settings');
		    };
		    return SecuritySchemaImpl;
		})(RAMLLanguageElementImpl);
		exports.SecuritySchemaImpl = SecuritySchemaImpl;
		var RAMLSimpleElementImpl = (function (_super) {
		    __extends(RAMLSimpleElementImpl, _super);
		    function RAMLSimpleElementImpl() {
		        _super.apply(this, arguments);
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    RAMLSimpleElementImpl.prototype.wrapperClassName = function () {
		        return "RAMLSimpleElementImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    RAMLSimpleElementImpl.prototype.getKind = function () {
		        return "RAMLSimpleElement";
		    };
		    return RAMLSimpleElementImpl;
		})(core.BasicNodeImpl);
		exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
		/**
		 * Content of the schema
		 **/
		var GlobalSchemaImpl = (function (_super) {
		    __extends(GlobalSchemaImpl, _super);
		    function GlobalSchemaImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    GlobalSchemaImpl.prototype.wrapperClassName = function () {
		        return "GlobalSchemaImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    GlobalSchemaImpl.prototype.getKind = function () {
		        return "GlobalSchema";
		    };
		    /**
		     * Name of the global schema, used to refer on schema content
		     **/
		    GlobalSchemaImpl.prototype.key = function () {
		        return _super.prototype.attribute.call(this, 'key', this.toString);
		    };
		    /**
		     * @hidden
		     * Set key value
		     **/
		    GlobalSchemaImpl.prototype.setKey = function (param) {
		        this.highLevel().attrOrCreate("key").setValue("" + param);
		        return this;
		    };
		    /**
		     * Content of the schema
		     **/
		    GlobalSchemaImpl.prototype.value = function () {
		        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
		    };
		    return GlobalSchemaImpl;
		})(RAMLSimpleElementImpl);
		exports.GlobalSchemaImpl = GlobalSchemaImpl;
		var DocumentationItemImpl = (function (_super) {
		    __extends(DocumentationItemImpl, _super);
		    function DocumentationItemImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DocumentationItemImpl.prototype.wrapperClassName = function () {
		        return "DocumentationItemImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DocumentationItemImpl.prototype.getKind = function () {
		        return "DocumentationItem";
		    };
		    /**
		     * title of documentation section
		     **/
		    DocumentationItemImpl.prototype.title = function () {
		        return _super.prototype.attribute.call(this, 'title', this.toString);
		    };
		    /**
		     * @hidden
		     * Set title value
		     **/
		    DocumentationItemImpl.prototype.setTitle = function (param) {
		        this.highLevel().attrOrCreate("title").setValue("" + param);
		        return this;
		    };
		    /**
		     * Content of documentation section
		     **/
		    DocumentationItemImpl.prototype.content = function () {
		        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
		    };
		    return DocumentationItemImpl;
		})(RAMLSimpleElementImpl);
		exports.DocumentationItemImpl = DocumentationItemImpl;
		var SecuritySchemaSettingsImpl = (function (_super) {
		    __extends(SecuritySchemaSettingsImpl, _super);
		    function SecuritySchemaSettingsImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaSettings(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemaSettingsImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemaSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemaSettingsImpl.prototype.getKind = function () {
		        return "SecuritySchemaSettings";
		    };
		    return SecuritySchemaSettingsImpl;
		})(RAMLSimpleElementImpl);
		exports.SecuritySchemaSettingsImpl = SecuritySchemaSettingsImpl;
		var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
		    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
		    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
		        return "OAuth1SecuritySchemeSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.getKind = function () {
		        return "OAuth1SecuritySchemeSettings";
		    };
		    /**
		     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
		        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriImpl(attr); });
		    };
		    /**
		     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
		        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
		    };
		    /**
		     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
		     **/
		    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
		        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriImpl(attr); });
		    };
		    return OAuth1SecuritySchemeSettingsImpl;
		})(SecuritySchemaSettingsImpl);
		exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
		var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
		    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
		    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
		        return "OAuth2SecuritySchemeSettingsImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.getKind = function () {
		        return "OAuth2SecuritySchemeSettings";
		    };
		    /**
		     * The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
		        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriImpl(attr); });
		    };
		    /**
		     * The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
		        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
		    };
		    /**
		     * A list of the Authorization grants supported by the API As defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of: code, token, owner or credentials.
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
		        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
		    };
		    /**
		     * @hidden
		     * Set authorizationGrants value
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
		        this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
		        return this;
		    };
		    /**
		     * A list of scopes supported by the API as defined in RFC6749 [RFC6749] Section 3.3
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
		        return _super.prototype.attributes.call(this, 'scopes', this.toString);
		    };
		    /**
		     * @hidden
		     * Set scopes value
		     **/
		    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
		        this.highLevel().attrOrCreate("scopes").setValue("" + param);
		        return this;
		    };
		    return OAuth2SecuritySchemeSettingsImpl;
		})(SecuritySchemaSettingsImpl);
		exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
		var SecuritySchemaPartImpl = (function (_super) {
		    __extends(SecuritySchemaPartImpl, _super);
		    function SecuritySchemaPartImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaPart(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    SecuritySchemaPartImpl.prototype.wrapperClassName = function () {
		        return "SecuritySchemaPartImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    SecuritySchemaPartImpl.prototype.getKind = function () {
		        return "SecuritySchemaPart";
		    };
		    return SecuritySchemaPartImpl;
		})(RAMLSimpleElementImpl);
		exports.SecuritySchemaPartImpl = SecuritySchemaPartImpl;
		var ResourceTypeImpl = (function (_super) {
		    __extends(ResourceTypeImpl, _super);
		    function ResourceTypeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceTypeImpl.prototype.wrapperClassName = function () {
		        return "ResourceTypeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceTypeImpl.prototype.getKind = function () {
		        return "ResourceType";
		    };
		    /**
		     * Name of the resource type
		     **/
		    ResourceTypeImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    ResourceTypeImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    ResourceTypeImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    ResourceTypeImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    /**
		     * Methods that are part of this resource type definition
		     **/
		    ResourceTypeImpl.prototype.methods = function () {
		        return _super.prototype.elements.call(this, 'methods');
		    };
		    /**
		     * Instantiation of applyed traits
		     **/
		    ResourceTypeImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * Instantiation of applyed resource type
		     **/
		    ResourceTypeImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
		    };
		    /**
		     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
		     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
		     **/
		    ResourceTypeImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
		    };
		    /**
		     * Uri parameters of this resource
		     **/
		    ResourceTypeImpl.prototype.uriParameters = function () {
		        return _super.prototype.elements.call(this, 'uriParameters');
		    };
		    return ResourceTypeImpl;
		})(RAMLLanguageElementImpl);
		exports.ResourceTypeImpl = ResourceTypeImpl;
		var HasNormalParametersImpl = (function (_super) {
		    __extends(HasNormalParametersImpl, _super);
		    function HasNormalParametersImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createHasNormalParameters(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    HasNormalParametersImpl.prototype.wrapperClassName = function () {
		        return "HasNormalParametersImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    HasNormalParametersImpl.prototype.getKind = function () {
		        return "HasNormalParameters";
		    };
		    /**
		     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
		     **/
		    HasNormalParametersImpl.prototype.queryParameters = function () {
		        return _super.prototype.elements.call(this, 'queryParameters');
		    };
		    HasNormalParametersImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    HasNormalParametersImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * Headers that allowed at this position
		     **/
		    HasNormalParametersImpl.prototype.headers = function () {
		        return _super.prototype.elements.call(this, 'headers');
		    };
		    return HasNormalParametersImpl;
		})(RAMLLanguageElementImpl);
		exports.HasNormalParametersImpl = HasNormalParametersImpl;
		var ParameterImpl = (function (_super) {
		    __extends(ParameterImpl, _super);
		    function ParameterImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createParameter(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ParameterImpl.prototype.wrapperClassName = function () {
		        return "ParameterImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ParameterImpl.prototype.getKind = function () {
		        return "Parameter";
		    };
		    /**
		     * name of the parameter
		     **/
		    ParameterImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    ParameterImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    ParameterImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    ParameterImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string.
		     **/
		    ParameterImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', this.toString);
		    };
		    /**
		     * @hidden
		     * Set type value
		     **/
		    ParameterImpl.prototype.setType = function (param) {
		        this.highLevel().attrOrCreate("type").setValue("" + param);
		        return this;
		    };
		    /**
		     * Location of the parameter (can not be edited by user)
		     **/
		    ParameterImpl.prototype.location = function () {
		        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ParameterLocationImpl(attr); });
		    };
		    /**
		     * Set to true if parameter is required
		     **/
		    ParameterImpl.prototype.required = function () {
		        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set required value
		     **/
		    ParameterImpl.prototype.setRequired = function (param) {
		        this.highLevel().attrOrCreate("required").setValue("" + param);
		        return this;
		    };
		    /**
		     * The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value.
		     **/
		    ParameterImpl.prototype["default"] = function () {
		        return _super.prototype.attribute.call(this, 'default', this.toString);
		    };
		    /**
		     * @hidden
		     * Set default value
		     **/
		    ParameterImpl.prototype.setDefault = function (param) {
		        this.highLevel().attrOrCreate("default").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property.
		     **/
		    ParameterImpl.prototype.example = function () {
		        return _super.prototype.attribute.call(this, 'example', this.toString);
		    };
		    /**
		     * @hidden
		     * Set example value
		     **/
		    ParameterImpl.prototype.setExample = function (param) {
		        this.highLevel().attrOrCreate("example").setValue("" + param);
		        return this;
		    };
		    /**
		     * The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated.
		     **/
		    ParameterImpl.prototype.repeat = function () {
		        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
		    };
		    /**
		     * @hidden
		     * Set repeat value
		     **/
		    ParameterImpl.prototype.setRepeat = function (param) {
		        this.highLevel().attrOrCreate("repeat").setValue("" + param);
		        return this;
		    };
		    return ParameterImpl;
		})(RAMLLanguageElementImpl);
		exports.ParameterImpl = ParameterImpl;
		var ParameterLocationImpl = (function () {
		    function ParameterLocationImpl(attr) {
		        this.attr = attr;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ParameterLocationImpl.prototype.wrapperClassName = function () {
		        return "ParameterLocationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ParameterLocationImpl.prototype.getKind = function () {
		        return "ParameterLocation";
		    };
		    return ParameterLocationImpl;
		})();
		exports.ParameterLocationImpl = ParameterLocationImpl;
		/**
		 * Value must be a string
		 **/
		var StringTypeDeclarationImpl = (function (_super) {
		    __extends(StringTypeDeclarationImpl, _super);
		    function StringTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createStringTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    StringTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "StringTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    StringTypeDeclarationImpl.prototype.getKind = function () {
		        return "StringTypeDeclaration";
		    };
		    /**
		     * (Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity.
		     **/
		    StringTypeDeclarationImpl.prototype.pattern = function () {
		        return _super.prototype.attribute.call(this, 'pattern', this.toString);
		    };
		    /**
		     * @hidden
		     * Set pattern value
		     **/
		    StringTypeDeclarationImpl.prototype.setPattern = function (param) {
		        this.highLevel().attrOrCreate("pattern").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
		     **/
		    StringTypeDeclarationImpl.prototype.enum = function () {
		        return _super.prototype.attributes.call(this, 'enum', this.toString);
		    };
		    /**
		     * @hidden
		     * Set enum value
		     **/
		    StringTypeDeclarationImpl.prototype.setEnum = function (param) {
		        this.highLevel().attrOrCreate("enum").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters.
		     **/
		    StringTypeDeclarationImpl.prototype.minLength = function () {
		        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minLength value
		     **/
		    StringTypeDeclarationImpl.prototype.setMinLength = function (param) {
		        this.highLevel().attrOrCreate("minLength").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters.
		     **/
		    StringTypeDeclarationImpl.prototype.maxLength = function () {
		        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maxLength value
		     **/
		    StringTypeDeclarationImpl.prototype.setMaxLength = function (param) {
		        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
		        return this;
		    };
		    return StringTypeDeclarationImpl;
		})(ParameterImpl);
		exports.StringTypeDeclarationImpl = StringTypeDeclarationImpl;
		/**
		 * Value must be a boolean
		 **/
		var BooleanTypeDeclarationImpl = (function (_super) {
		    __extends(BooleanTypeDeclarationImpl, _super);
		    function BooleanTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    BooleanTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "BooleanTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    BooleanTypeDeclarationImpl.prototype.getKind = function () {
		        return "BooleanTypeDeclaration";
		    };
		    return BooleanTypeDeclarationImpl;
		})(ParameterImpl);
		exports.BooleanTypeDeclarationImpl = BooleanTypeDeclarationImpl;
		/**
		 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
		 **/
		var NumberTypeDeclarationImpl = (function (_super) {
		    __extends(NumberTypeDeclarationImpl, _super);
		    function NumberTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createNumberTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    NumberTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "NumberTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    NumberTypeDeclarationImpl.prototype.getKind = function () {
		        return "NumberTypeDeclaration";
		    };
		    /**
		     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
		     **/
		    NumberTypeDeclarationImpl.prototype.minimum = function () {
		        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set minimum value
		     **/
		    NumberTypeDeclarationImpl.prototype.setMinimum = function (param) {
		        this.highLevel().attrOrCreate("minimum").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
		     **/
		    NumberTypeDeclarationImpl.prototype.maximum = function () {
		        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
		    };
		    /**
		     * @hidden
		     * Set maximum value
		     **/
		    NumberTypeDeclarationImpl.prototype.setMaximum = function (param) {
		        this.highLevel().attrOrCreate("maximum").setValue("" + param);
		        return this;
		    };
		    return NumberTypeDeclarationImpl;
		})(ParameterImpl);
		exports.NumberTypeDeclarationImpl = NumberTypeDeclarationImpl;
		/**
		 * Value MUST be a integer.
		 **/
		var IntegerTypeDeclarationImpl = (function (_super) {
		    __extends(IntegerTypeDeclarationImpl, _super);
		    function IntegerTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    IntegerTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "IntegerTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    IntegerTypeDeclarationImpl.prototype.getKind = function () {
		        return "IntegerTypeDeclaration";
		    };
		    return IntegerTypeDeclarationImpl;
		})(NumberTypeDeclarationImpl);
		exports.IntegerTypeDeclarationImpl = IntegerTypeDeclarationImpl;
		/**
		 * Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616].
		 **/
		var DateTypeDeclarationImpl = (function (_super) {
		    __extends(DateTypeDeclarationImpl, _super);
		    function DateTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createDateTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    DateTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "DateTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    DateTypeDeclarationImpl.prototype.getKind = function () {
		        return "DateTypeDeclaration";
		    };
		    return DateTypeDeclarationImpl;
		})(ParameterImpl);
		exports.DateTypeDeclarationImpl = DateTypeDeclarationImpl;
		/**
		 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
		 **/
		var FileTypeDeclarationImpl = (function (_super) {
		    __extends(FileTypeDeclarationImpl, _super);
		    function FileTypeDeclarationImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createFileTypeDeclaration(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    FileTypeDeclarationImpl.prototype.wrapperClassName = function () {
		        return "FileTypeDeclarationImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    FileTypeDeclarationImpl.prototype.getKind = function () {
		        return "FileTypeDeclaration";
		    };
		    return FileTypeDeclarationImpl;
		})(ParameterImpl);
		exports.FileTypeDeclarationImpl = FileTypeDeclarationImpl;
		var MethodBaseImpl = (function (_super) {
		    __extends(MethodBaseImpl, _super);
		    function MethodBaseImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MethodBaseImpl.prototype.wrapperClassName = function () {
		        return "MethodBaseImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MethodBaseImpl.prototype.getKind = function () {
		        return "MethodBase";
		    };
		    /**
		     * Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties.
		     **/
		    MethodBaseImpl.prototype.responses = function () {
		        return _super.prototype.elements.call(this, 'responses');
		    };
		    /**
		     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.
		     * Resources CAN have alternate representations. For example, an API might support both JSON and XML representations.
		     * A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
		     **/
		    MethodBaseImpl.prototype.body = function () {
		        return _super.prototype.elements.call(this, 'body');
		    };
		    /**
		     * Instantiation of applyed traits
		     **/
		    MethodBaseImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * A list of the security schemas to apply, these must be defined in the securitySchemes declaration.
		     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
		     * Security schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
		     **/
		    MethodBaseImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
		    };
		    return MethodBaseImpl;
		})(HasNormalParametersImpl);
		exports.MethodBaseImpl = MethodBaseImpl;
		var ResponseImpl = (function (_super) {
		    __extends(ResponseImpl, _super);
		    function ResponseImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResponseImpl.prototype.wrapperClassName = function () {
		        return "ResponseImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResponseImpl.prototype.getKind = function () {
		        return "Response";
		    };
		    /**
		     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
		     **/
		    ResponseImpl.prototype.code = function () {
		        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeStringImpl(attr); });
		    };
		    /**
		     * An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property.
		     * API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data.
		     *
		     * In the following example, the header x-metadata-{?} is used to send metadata that has been saved with the media.
		     **/
		    ResponseImpl.prototype.headers = function () {
		        return _super.prototype.elements.call(this, 'headers');
		    };
		    /**
		     * Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined.
		     * For APIs without a priori knowledge of the response types for their responses, "* /*" MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if "* /*" is used.
		     **/
		    ResponseImpl.prototype.body = function () {
		        return _super.prototype.elements.call(this, 'body');
		    };
		    /**
		     * true for codes < 400 and false otherwise
		     **/
		    ResponseImpl.prototype.isOkRange = function () {
		        return helper.isOkRange(this);
		    };
		    return ResponseImpl;
		})(RAMLLanguageElementImpl);
		exports.ResponseImpl = ResponseImpl;
		var BodyLikeImpl = (function (_super) {
		    __extends(BodyLikeImpl, _super);
		    function BodyLikeImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createBodyLike(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    BodyLikeImpl.prototype.wrapperClassName = function () {
		        return "BodyLikeImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    BodyLikeImpl.prototype.getKind = function () {
		        return "BodyLike";
		    };
		    /**
		     * Mime type of the request or response body
		     **/
		    BodyLikeImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    BodyLikeImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    /**
		     * The structure of a request or response body MAY be further specified by the schema property under the appropriate media type.
		     *
		     * The schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data.
		     *
		     * All parsers of RAML MUST be able to interpret JSON Schema [JSON_SCHEMA] and XML Schema [XML_SCHEMA].
		     *
		     * Schema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline.
		     * Alternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property (see Named Parameters, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type.
		     **/
		    BodyLikeImpl.prototype.schema = function () {
		        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new SchemaStringImpl(attr); });
		    };
		    /**
		     * Documentation generators MUST use body properties' example attributes to generate example invocations.
		     * This example shows example attributes for two body property media types.
		     **/
		    BodyLikeImpl.prototype.example = function () {
		        return _super.prototype.attribute.call(this, 'example', function (attr) { return new ExampleStringImpl(attr); });
		    };
		    /**
		     * Web forms REQUIRE special encoding and custom declaration.
		     * If the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting.
		     * The formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes
		     **/
		    BodyLikeImpl.prototype.formParameters = function () {
		        return _super.prototype.elements.call(this, 'formParameters');
		    };
		    return BodyLikeImpl;
		})(RAMLLanguageElementImpl);
		exports.BodyLikeImpl = BodyLikeImpl;
		/**
		 * Needed to set connection between xml related mime types and xsd schema
		 **/
		var XMLBodyImpl = (function (_super) {
		    __extends(XMLBodyImpl, _super);
		    function XMLBodyImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createXMLBody(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    XMLBodyImpl.prototype.wrapperClassName = function () {
		        return "XMLBodyImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    XMLBodyImpl.prototype.getKind = function () {
		        return "XMLBody";
		    };
		    /**
		     * XSD Schema
		     **/
		    XMLBodyImpl.prototype.schema = function () {
		        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new XMLSchemaStringImpl(attr); });
		    };
		    return XMLBodyImpl;
		})(BodyLikeImpl);
		exports.XMLBodyImpl = XMLBodyImpl;
		/**
		 * Needed to set connection between json related mime types and json schema
		 **/
		var JSONBodyImpl = (function (_super) {
		    __extends(JSONBodyImpl, _super);
		    function JSONBodyImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createJSONBody(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    JSONBodyImpl.prototype.wrapperClassName = function () {
		        return "JSONBodyImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    JSONBodyImpl.prototype.getKind = function () {
		        return "JSONBody";
		    };
		    /**
		     * JSON Schema
		     **/
		    JSONBodyImpl.prototype.schema = function () {
		        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new JSonSchemaStringImpl(attr); });
		    };
		    return JSONBodyImpl;
		})(BodyLikeImpl);
		exports.JSONBodyImpl = JSONBodyImpl;
		var TraitImpl = (function (_super) {
		    __extends(TraitImpl, _super);
		    function TraitImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    TraitImpl.prototype.wrapperClassName = function () {
		        return "TraitImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    TraitImpl.prototype.getKind = function () {
		        return "Trait";
		    };
		    /**
		     * Name of the trait
		     **/
		    TraitImpl.prototype.name = function () {
		        return _super.prototype.attribute.call(this, 'name', this.toString);
		    };
		    /**
		     * @hidden
		     * Set name value
		     **/
		    TraitImpl.prototype.setName = function (param) {
		        this.highLevel().attrOrCreate("name").setValue("" + param);
		        return this;
		    };
		    TraitImpl.prototype.usage = function () {
		        return _super.prototype.attribute.call(this, 'usage', this.toString);
		    };
		    /**
		     * @hidden
		     * Set usage value
		     **/
		    TraitImpl.prototype.setUsage = function (param) {
		        this.highLevel().attrOrCreate("usage").setValue("" + param);
		        return this;
		    };
		    return TraitImpl;
		})(MethodBaseImpl);
		exports.TraitImpl = TraitImpl;
		/**
		 * Method object allows description of http methods
		 **/
		var MethodImpl = (function (_super) {
		    __extends(MethodImpl, _super);
		    function MethodImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    MethodImpl.prototype.wrapperClassName = function () {
		        return "MethodImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    MethodImpl.prototype.getKind = function () {
		        return "Method";
		    };
		    /**
		     * Method that can be called
		     **/
		    MethodImpl.prototype.method = function () {
		        return _super.prototype.attribute.call(this, 'method', this.toString);
		    };
		    /**
		     * @hidden
		     * Set method value
		     **/
		    MethodImpl.prototype.setMethod = function (param) {
		        this.highLevel().attrOrCreate("method").setValue("" + param);
		        return this;
		    };
		    /**
		     * A method can override an API's protocols value for that single method by setting a different value for the fields.
		     **/
		    MethodImpl.prototype.protocols = function () {
		        return _super.prototype.attributes.call(this, 'protocols', this.toString);
		    };
		    /**
		     * @hidden
		     * Set protocols value
		     **/
		    MethodImpl.prototype.setProtocols = function (param) {
		        this.highLevel().attrOrCreate("protocols").setValue("" + param);
		        return this;
		    };
		    /**
		     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
		     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
		     **/
		    MethodImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
		    };
		    /**
		     * For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
		     **/
		    MethodImpl.prototype.parentResource = function () {
		        return helper.parentResource(this);
		    };
		    /**
		     * Api owning the resource as a sibling
		     **/
		    MethodImpl.prototype.ownerApi = function () {
		        return helper.ownerApi(this);
		    };
		    /**
		     * For methods of Resources: `{parent Resource relative path} {methodName}`.
		     * For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
		     * For other methods throws Exception.
		     **/
		    MethodImpl.prototype.methodId = function () {
		        return helper.methodId(this);
		    };
		    return MethodImpl;
		})(MethodBaseImpl);
		exports.MethodImpl = MethodImpl;
		var ResourceImpl = (function (_super) {
		    __extends(ResourceImpl, _super);
		    function ResourceImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ResourceImpl.prototype.wrapperClassName = function () {
		        return "ResourceImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ResourceImpl.prototype.getKind = function () {
		        return "Resource";
		    };
		    /**
		     * Relative URL of this resource from the parent resource
		     **/
		    ResourceImpl.prototype.relativeUri = function () {
		        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriStringImpl(attr); });
		    };
		    /**
		     * Instantiation of applyed resource type
		     **/
		    ResourceImpl.prototype["type"] = function () {
		        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
		    };
		    /**
		     * Instantiation of applyed traits
		     **/
		    ResourceImpl.prototype.is = function () {
		        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
		    };
		    /**
		     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
		     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
		     **/
		    ResourceImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
		    };
		    /**
		     * Uri parameters of this resource
		     **/
		    ResourceImpl.prototype.uriParameters = function () {
		        return _super.prototype.elements.call(this, 'uriParameters');
		    };
		    /**
		     * Methods that can be called on this resource
		     **/
		    ResourceImpl.prototype.methods = function () {
		        return _super.prototype.elements.call(this, 'methods');
		    };
		    /**
		     * Children resources
		     **/
		    ResourceImpl.prototype.resources = function () {
		        return _super.prototype.elements.call(this, 'resources');
		    };
		    ResourceImpl.prototype.displayName = function () {
		        return _super.prototype.attribute.call(this, 'displayName', this.toString);
		    };
		    /**
		     * @hidden
		     * Set displayName value
		     **/
		    ResourceImpl.prototype.setDisplayName = function (param) {
		        this.highLevel().attrOrCreate("displayName").setValue("" + param);
		        return this;
		    };
		    /**
		     * A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level.
		     **/
		    ResourceImpl.prototype.baseUriParameters = function () {
		        return _super.prototype.elements.call(this, 'baseUriParameters');
		    };
		    /**
		     * Path relative to API root
		     **/
		    ResourceImpl.prototype.completeRelativeUri = function () {
		        return helper.completeRelativeUri(this);
		    };
		    /**
		     * baseUri of owning Api concatenated with completeRelativeUri
		     **/
		    ResourceImpl.prototype.absoluteUri = function () {
		        return helper.absoluteUri(this);
		    };
		    /**
		     * Parent resource for non top level resources
		     **/
		    ResourceImpl.prototype.parentResource = function () {
		        return helper.parent(this);
		    };
		    /**
		     * Get child resource by its relative path
		     **/
		    ResourceImpl.prototype.getChildResource = function (relPath) {
		        return helper.getChildResource(this, relPath);
		    };
		    /**
		     * Get child method by its name
		     **/
		    ResourceImpl.prototype.getChildMethod = function (method) {
		        return helper.getChildMethod(this, method);
		    };
		    /**
		     * Api owning the resource as a sibling
		     **/
		    ResourceImpl.prototype.ownerApi = function () {
		        return helper.ownerApi(this);
		    };
		    /**
		     * Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
		     * Consider a fragment of RAML specification:
		     * ```yaml
		     * /resource/{objectId}/{propertyId}:
		     * uriParameters:
		     * objectId:
		     * ```
		     * Here `propertyId` uri parameter is not described in the `uriParameters` node.
		     * Thus, it is not among Resource.uriParameters(), but it is among Resource.allUriParameters().
		     **/
		    ResourceImpl.prototype.allUriParameters = function () {
		        return helper.uriParameters(this);
		    };
		    /**
		     * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.allBaseUriParameters()`
		     * for `Api` owning the `Resource` and `Resource.allUriParameters()`.
		     **/
		    ResourceImpl.prototype.absoluteUriParameters = function () {
		        return helper.absoluteUriParameters(this);
		    };
		    return ResourceImpl;
		})(RAMLLanguageElementImpl);
		exports.ResourceImpl = ResourceImpl;
		var ApiImpl = (function (_super) {
		    __extends(ApiImpl, _super);
		    function ApiImpl(nodeOrKey) {
		        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey);
		        this.nodeOrKey = nodeOrKey;
		    }
		    /**
		     * @hidden
		     * @return Actual name of instance class
		     **/
		    ApiImpl.prototype.wrapperClassName = function () {
		        return "ApiImpl";
		    };
		    /**
		     * @return Actual name of instance interface
		     **/
		    ApiImpl.prototype.getKind = function () {
		        return "Api";
		    };
		    /**
		     * The title property is a short plain text description of the RESTful API. The title property's value SHOULD be suitable for use as a title for the contained user documentation.
		     **/
		    ApiImpl.prototype.title = function () {
		        return _super.prototype.attribute.call(this, 'title', this.toString);
		    };
		    /**
		     * @hidden
		     * Set title value
		     **/
		    ApiImpl.prototype.setTitle = function (param) {
		        this.highLevel().attrOrCreate("title").setValue("" + param);
		        return this;
		    };
		    /**
		     * If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if:
		     * The API itself is not versioned.
		     * The API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change.
		     * The API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, "v3", "v3.0", and "V3" are all allowed, but are not considered to be equal.
		     **/
		    ApiImpl.prototype.version = function () {
		        return _super.prototype.attribute.call(this, 'version', this.toString);
		    };
		    /**
		     * @hidden
		     * Set version value
		     **/
		    ApiImpl.prototype.setVersion = function (param) {
		        this.highLevel().attrOrCreate("version").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification [RFC2396] or a Level 1 Template URI as defined in RFC 6570 [RFC6570].
		     * The baseUri property SHOULD only be used as a reference value. API client generators MAY make the baseUri configurable by the API client's users.
		     * If the baseUri value is a Level 1 Template URI, the following reserved base URI parameters are available for replacement:
		     **/
		    ApiImpl.prototype.baseUri = function () {
		        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateStringImpl(attr); });
		    };
		    /**
		     * Base uri parameters are named parameters which described template parameters in the base uri
		     **/
		    ApiImpl.prototype.baseUriParameters = function () {
		        return _super.prototype.elements.call(this, 'baseUriParameters');
		    };
		    /**
		     * URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters
		     **/
		    ApiImpl.prototype.uriParameters = function () {
		        return _super.prototype.elements.call(this, 'uriParameters');
		    };
		    /**
		     * A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`.
		     **/
		    ApiImpl.prototype.protocols = function () {
		        return _super.prototype.attributes.call(this, 'protocols', this.toString);
		    };
		    /**
		     * @hidden
		     * Set protocols value
		     **/
		    ApiImpl.prototype.setProtocols = function (param) {
		        this.highLevel().attrOrCreate("protocols").setValue("" + param);
		        return this;
		    };
		    /**
		     * (Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type:
		     * One of the following YAML media types:
		     * text/yaml
		     * text/x-yaml
		     * application/yaml
		     * application/x-yaml*
		     * Any type from the list of IANA MIME Media Types, http://www.iana.org/assignments/media-types
		     * A custom type that conforms to the regular expression, "application/[A-Za-z.-0-1]*+?(json|xml)"
		     * For any combination of resource and operation in the API, if a media type is specified as a key of the body property for that resource and operation, or if a media type is specified in the mediaType property, the body MUST be in the specified media types. Moreover, if the client specifies an Accepts header containing multiple media types that are allowed by the specification for the requested resource and operation, the server SHOULD return a body using the media type in the Accepts header's mediaType list.
		     **/
		    ApiImpl.prototype.mediaType = function () {
		        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
		    };
		    /**
		     * To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type.
		     **/
		    ApiImpl.prototype.schemas = function () {
		        return _super.prototype.elements.call(this, 'schemas');
		    };
		    /**
		     * Declarations of traits used in this API
		     **/
		    ApiImpl.prototype.traits = function () {
		        return _super.prototype.elements.call(this, 'traits');
		    };
		    /**
		     * A list of the security schemas to apply to all methods, these must be defined in the securitySchemes declaration.
		     **/
		    ApiImpl.prototype.securedBy = function () {
		        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
		    };
		    /**
		     * Security schemas that can be applied with securedBy
		     **/
		    ApiImpl.prototype.securitySchemes = function () {
		        return _super.prototype.elements.call(this, 'securitySchemes');
		    };
		    /**
		     * Declaration of resource types used in this API
		     **/
		    ApiImpl.prototype.resourceTypes = function () {
		        return _super.prototype.elements.call(this, 'resourceTypes');
		    };
		    /**
		     * Resources are identified by their relative URI, which MUST begin with a slash (/).
		     * A resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri.
		     * A resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI.
		     * Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. "/bom/items" may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if "/bom" is itself a resource then "/items" should be a nested resource of "/bom", while "/bom/items" should not be used.
		     **/
		    ApiImpl.prototype.resources = function () {
		        return _super.prototype.elements.call(this, 'resources');
		    };
		    /**
		     * The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context.
		     * Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared.
		     * To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document.
		     * Documentation-generators MUST process the content field as if it was defined using Markdown [MARKDOWN].
		     *
		     * This example shows an API definition with a single user document.
		     **/
		    ApiImpl.prototype.documentation = function () {
		        return _super.prototype.elements.call(this, 'documentation');
		    };
		    /**
		     * Equivalent API with traits and resource types expanded
		     **/
		    ApiImpl.prototype.expand = function () {
		        return helper.expandTraitsAndResourceTypes(this);
		    };
		    /**
		     * Retrieve all traits including those defined in libraries
		     **/
		    ApiImpl.prototype.allTraits = function () {
		        return helper.allTraits(this);
		    };
		    /**
		     * Retrieve all resource types including those defined in libraries
		     **/
		    ApiImpl.prototype.allResourceTypes = function () {
		        return helper.allResourceTypes(this);
		    };
		    /**
		     * Get child resource by its relative path
		     **/
		    ApiImpl.prototype.getChildResource = function (relPath) {
		        return helper.getChildResource(this, relPath);
		    };
		    /**
		     * Retrieve all resources of the Api
		     **/
		    ApiImpl.prototype.allResources = function () {
		        return helper.allResources(this);
		    };
		    /**
		     * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
		     * Consider a fragment of RAML specification:
		     * ```yaml
		     * version: v1
		     * baseUri: https://{organization}.example.com/{version}/{service}
		     * baseUriParameters:
		     * service:
		     * ```
		     * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node.
		     * Thus, they are not among `Api.baseUriParameters()`, but they are among `Api.allBaseUriParameters()`.
		     **/
		    ApiImpl.prototype.allBaseUriParameters = function () {
		        return helper.baseUriParameters(this);
		    };
		    /**
		     * Protocols used by the API. Returns the `protocols` property value if it is specified.
		     * Otherwise, returns protocol, specified in the base URI.
		     **/
		    ApiImpl.prototype.allProtocols = function () {
		        return helper.allProtocols(this);
		    };
		    return ApiImpl;
		})(RAMLLanguageElementImpl);
		exports.ApiImpl = ApiImpl;
		/**
		 * @hidden
		 **/
		function createApi(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("Api");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLLanguageElement(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("RAMLLanguageElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSecuritySchema(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("SecuritySchema");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSecuritySchemaPart(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("SecuritySchemaPart");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createRAMLSimpleElement(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("RAMLSimpleElement");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createGlobalSchema(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("GlobalSchema");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createDocumentationItem(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("DocumentationItem");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createSecuritySchemaSettings(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("SecuritySchemaSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOAuth1SecuritySchemeSettings(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("OAuth1SecuritySchemeSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createOAuth2SecuritySchemeSettings(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("OAuth2SecuritySchemeSettings");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResourceType(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("ResourceType");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createMethod(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("Method");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createMethodBase(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("MethodBase");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createHasNormalParameters(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("HasNormalParameters");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createParameter(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("Parameter");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createStringTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("StringTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createBooleanTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("BooleanTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createNumberTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("NumberTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createIntegerTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("IntegerTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createDateTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("DateTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createFileTypeDeclaration(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("FileTypeDeclaration");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResponse(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("Response");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createBodyLike(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("BodyLike");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createXMLBody(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("XMLBody");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createJSONBody(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("JSONBody");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createTrait(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("Trait");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		/**
		 * @hidden
		 **/
		function createResource(key) {
		    var universe = hl.universeProvider("RAML08");
		    var nc = universe.type("Resource");
		    var node = nc.getAdapter(services.RAMLService).createStubNode(null, key);
		    return node;
		}
		function loadApiSync(apiPath, arg1, arg2) {
		    return apiLoader.loadApi(apiPath, arg1, arg2).getOrElse(null);
		}
		exports.loadApiSync = loadApiSync;
		function loadApi(apiPath, arg1, arg2) {
		    return apiLoader.loadApiAsync(apiPath, arg1, arg2);
		}
		exports.loadApi = loadApi;


	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {

		var hlImpl = __webpack_require__(5);
		var jsyaml = __webpack_require__(15);
		var ramlService = __webpack_require__(49);
		var json2lowlevel = __webpack_require__(8);
		var BasicNodeImpl = (function () {
		    /***
		     * @hidden
		     */
		    function BasicNodeImpl(_node) {
		        this._node = _node;
		        _node.setWrapperNode(this);
		    }
		    /***
		     * @hidden
		     */
		    BasicNodeImpl.prototype.wrapperClassName = function () {
		        return 'BasicNodeImpl';
		    };
		    BasicNodeImpl.prototype.getKind = function () {
		        return 'BasicNode';
		    };
		    /***
		     * @return Direct ancestor in RAML hierarchy
		     **/
		    BasicNodeImpl.prototype.parent = function () {
		        var parent = this._node.parent();
		        return parent ? parent.wrapperNode() : null;
		    };
		    /***
		     * @hidden
		     * @return Underlying node of the High Level model
		     **/
		    BasicNodeImpl.prototype.highLevel = function () {
		        return this._node;
		    };
		    /***
		     * @hidden
		     ***/
		    BasicNodeImpl.prototype.attributes = function (name, constr) {
		        var attrs = this._node.attributes(name);
		        if (!attrs) {
		            return null;
		        }
		        if (constr) {
		            return attrs.map(function (x) { return constr(x); });
		        }
		        else {
		            return attrs.map(function (x) { return x.value(); });
		        }
		    };
		    /***
		     * @hidden
		     ***/
		    BasicNodeImpl.prototype.attribute = function (name, constr) {
		        var attr = this._node.attr(name);
		        if (!attr) {
		            return null;
		        }
		        if (constr) {
		            return constr(attr);
		        }
		        else {
		            return attr.value();
		        }
		    };
		    /***
		     * @hidden
		     ***/
		    BasicNodeImpl.prototype.elements = function (name) {
		        var elements = this._node.elementsOfKind(name);
		        if (!elements) {
		            return null;
		        }
		        return elements.map(function (x) { return x.wrapperNode(); });
		    };
		    /***
		     * @hidden
		     ***/
		    BasicNodeImpl.prototype.element = function (name) {
		        var element = this._node.element(name);
		        if (!element) {
		            return null;
		        }
		        return element.wrapperNode();
		    };
		    /***
		     * Append node as child
		     * @param node node to be appended
		     ***/
		    BasicNodeImpl.prototype.add = function (node) {
		        this.highLevel().add(node.highLevel());
		    };
		    /***
		     * Append node as property value
		     * @param node node to be set as property value
		     * @param prop name of property to set value for
		     ***/
		    BasicNodeImpl.prototype.addToProp = function (node, prop) {
		        var hl = node.highLevel();
		        var pr = this.highLevel().definition().property(prop);
		        hl._prop = pr;
		        this.highLevel().add(hl);
		    };
		    /***
		     * Remove node from children set
		     * @param node node to be removed
		     ***/
		    BasicNodeImpl.prototype.remove = function (node) {
		        this.highLevel().remove(node.highLevel());
		    };
		    /***
		     * @return YAML string representing the node
		     ***/
		    BasicNodeImpl.prototype.dump = function () {
		        return this.highLevel().dump("yaml");
		    };
		    BasicNodeImpl.prototype.toString = function (attr) {
		        var obj = attr.value();
		        return obj != null ? obj.toString() : obj;
		    };
		    BasicNodeImpl.prototype.toBoolean = function (attr) {
		        var obj = attr.value();
		        return obj != null ? obj.toString() == 'true' : obj;
		    };
		    BasicNodeImpl.prototype.toNumber = function (attr) {
		        var obj = attr.value();
		        if (!obj) {
		            return obj;
		        }
		        try {
		            var nValue = parseFloat(obj.toString());
		            return nValue;
		        }
		        catch (e) {
		        }
		        return Number.MAX_VALUE;
		    };
		    /***
		     * @return Array of errors
		     **/
		    BasicNodeImpl.prototype.errors = function () {
		        var issues = [];
		        if (this._node.errors() != null) {
		            issues = issues.concat(this._node.errors());
		        }
		        this._node.attrs().filter(function (x) { return x.errors() != null; }).forEach(function (x) { return issues = issues.concat(x.errors()); });
		        var lineMapper = this._node.lowLevel().unit().lineMapper();
		        var result = issues.map(function (x) {
		            var startPoint = null;
		            try {
		                startPoint = lineMapper.position(x.start);
		            }
		            catch (e) {
		                console.warn(e);
		            }
		            var endPoint = null;
		            try {
		                endPoint = lineMapper.position(x.end);
		            }
		            catch (e) {
		                console.warn(e);
		            }
		            return {
		                code: x.code,
		                message: x.message,
		                path: x.path,
		                start: x.start,
		                end: x.end,
		                line: startPoint.errorMessage ? null : startPoint.line,
		                column: startPoint.errorMessage ? null : startPoint.column,
		                range: [startPoint, endPoint],
		                isWarning: x.isWarning
		            };
		        });
		        return result;
		    };
		    /***
		     * @return object representing class of the node
		     **/
		    BasicNodeImpl.prototype.definition = function () {
		        return this.highLevel().definition();
		    };
		    /***
		     * @return for user class instances returns object representing actual user class
		     **/
		    BasicNodeImpl.prototype.runtimeDefinition = function () {
		        return this.highLevel().definition().getAdapter(ramlService.RAMLService).toRuntime();
		    };
		    BasicNodeImpl.prototype.toJSON = function (serializeOptions) {
		        return json2lowlevel.serialize(this.highLevel().lowLevel(), serializeOptions);
		    };
		    return BasicNodeImpl;
		})();
		exports.BasicNodeImpl = BasicNodeImpl;
		var AttributeNodeImpl = (function () {
		    function AttributeNodeImpl(attr) {
		        this.attr = attr;
		    }
		    /***
		     * @return Underlying High Level attribute node
		     ***/
		    AttributeNodeImpl.prototype.highLevel = function () {
		        return this.attr;
		    };
		    /***
		     * @hidden
		     */
		    AttributeNodeImpl.prototype.wrapperClassName = function () {
		        return 'AttributeNodeImpl';
		    };
		    AttributeNodeImpl.prototype.getKind = function () {
		        return 'AttributeNode';
		    };
		    return AttributeNodeImpl;
		})();
		exports.AttributeNodeImpl = AttributeNodeImpl;
		/***
		 * @hidden
		 ***/
		function toStructuredValue(node) {
		    var value = node.value();
		    if (typeof value === 'string') {
		        var mockNode = jsyaml.createNode(value.toString());
		        mockNode._actualNode().startPosition = node.lowLevel().valueStart();
		        mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
		        var stv = new hlImpl.StructuredValue(mockNode, node.parent(), node.property());
		        return stv;
		    }
		    else {
		        return value;
		    }
		}
		exports.toStructuredValue = toStructuredValue;


	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var RamlWrapper1 = __webpack_require__(1);
		var RamlWrapper08 = __webpack_require__(74);
		var path = __webpack_require__(16);
		var Opt = __webpack_require__(12);
		var jsyaml = __webpack_require__(15);
		var hlimpl = __webpack_require__(5);
		var llimpl = __webpack_require__(15);
		var expander = __webpack_require__(73);
		var universeDef = __webpack_require__(54);
		var universeProvider = __webpack_require__(77);
		/***
		 * Load API synchronously. Detects RAML version and uses corresponding parser.
		 * @param apiPath Path to API: local file system path or Web URL
		 * @param options Load options
		 * @return Opt&lt;Api&gt;, where Api belongs to RAML 1.0 or RAML 0.8 model.
		 ***/
		function loadApi(apiPath, arg1, arg2) {
		    var gotArray = Array.isArray(arg1);
		    var extensionsAndOverlays = (gotArray ? arg1 : null);
		    var options = (gotArray ? arg2 : arg1);
		    options = options || {};
		    var project = getProject(apiPath, options);
		    var unitName = path.basename(apiPath);
		    var unit = project.unit(unitName);
		    if (arg2 && !extensionsAndOverlays) {
		        throw new Error("Extensions and overlays list should be defined");
		    }
		    var api;
		    if (unit) {
		        if (extensionsAndOverlays && extensionsAndOverlays.length > 0) {
		            var extensionUnits = [];
		            extensionsAndOverlays.forEach(function (currentPath) {
		                if (!currentPath || currentPath.trim().length == 0) {
		                    throw new Error("Extensions and overlays list should contain legal file paths");
		                }
		            });
		            extensionsAndOverlays.forEach(function (unitPath) {
		                extensionUnits.push(project.unit(path.basename(unitPath)));
		            });
		            //calling to perform the checks, we do not actually need the api itself
		            extensionUnits.forEach(function (extensionUnit) { return toApi(extensionUnit, options); });
		            api = toApi(expander.mergeAPIs(unit, extensionUnits, 0 /* MERGE */), options);
		        }
		        else {
		            api = toApi(unit, options);
		            api.highLevel().setMergeMode(0 /* MERGE */);
		        }
		    }
		    if (options.rejectOnErrors && api && api.errors().length) {
		        throw toError(api);
		    }
		    return new Opt(api);
		}
		exports.loadApi = loadApi;
		/***
		 * Load API asynchronously. Detects RAML version and uses corresponding parser.
		 * @param apiPath Path to API: local file system path or Web URL
		 * @param options Load options
		 * @return Promise&lt;Api&gt;, where Api belongs to RAML 1.0 or RAML 0.8 model.
		 ***/
		function loadApiAsync(apiPath, arg1, arg2) {
		    var gotArray = Array.isArray(arg1);
		    var extensionsAndOverlays = (gotArray ? arg1 : null);
		    var options = (gotArray ? arg2 : arg1);
		    options = options || {};
		    var project = getProject(apiPath, options);
		    var unitName = path.basename(apiPath);
		    if (arg2 && !extensionsAndOverlays) {
		        throw new Error("Extensions and overlays list should be defined");
		    }
		    if (!extensionsAndOverlays || extensionsAndOverlays.length == 0) {
		        return fetchAndLoadApiAsync(project, unitName, options).then(function (masterApi) {
		            masterApi.highLevel().setMergeMode(0 /* MERGE */);
		            return masterApi;
		        });
		    }
		    else {
		        extensionsAndOverlays.forEach(function (currentPath) {
		            if (!currentPath || currentPath.trim().length == 0) {
		                throw new Error("Extensions and overlays list should contain legal file paths");
		            }
		        });
		        return fetchAndLoadApiAsync(project, unitName, options).then(function (masterApi) {
		            var apiPromises = [];
		            extensionsAndOverlays.forEach(function (extensionUnitPath) {
		                apiPromises.push(fetchAndLoadApiAsync(project, path.basename(extensionUnitPath), options));
		            });
		            return Promise.all(apiPromises).then(function (apis) {
		                var overlayUnits = [];
		                apis.forEach(function (currentApi) { return overlayUnits.push(currentApi.highLevel().lowLevel().unit()); });
		                return expander.mergeAPIs(masterApi.highLevel().lowLevel().unit(), overlayUnits, 0 /* MERGE */);
		            }).then(function (mergedHighLevel) {
		                return toApi(mergedHighLevel, options);
		            });
		        });
		    }
		}
		exports.loadApiAsync = loadApiAsync;
		function fetchAndLoadApiAsync(project, unitName, options) {
		    return llimpl.fetchIncludesAsync(project, unitName).then(function (x) {
		        try {
		            var api = toApi(x, options);
		            if (options.rejectOnErrors && api && api.errors().length) {
		                return Promise.reject(toError(api));
		            }
		            return api;
		        }
		        catch (err) {
		            return Promise.reject(err);
		        }
		    });
		}
		function getProject(apiPath, options) {
		    options = options || {};
		    var includeResolver = options.fsResolver;
		    var httpResolver = options.httpResolver;
		    var projectRoot = path.dirname(apiPath);
		    var project = new jsyaml.Project(projectRoot, includeResolver, httpResolver);
		    return project;
		}
		;
		function toApi(unitOrHighlevel, options, checkApisOverlays) {
		    if (checkApisOverlays === void 0) { checkApisOverlays = false; }
		    if (!unitOrHighlevel) {
		        return null;
		    }
		    var unit = null;
		    var highLevel = null;
		    if (unitOrHighlevel.isRAMLUnit) {
		        unit = unitOrHighlevel;
		    }
		    else {
		        highLevel = unitOrHighlevel;
		        unit = highLevel.lowLevel().unit();
		    }
		    var api;
		    var contents = unit.contents();
		    var ramlFirstLine = contents.match(/^#%RAML\s+(\d\.\d)\s*(\w*)\s*$/m);
		    if (!ramlFirstLine) {
		        //TODO throw sensible error
		        return null;
		    }
		    var verStr = ramlFirstLine[1];
		    var ramlFileType = ramlFirstLine[2];
		    var typeName;
		    var apiImpl;
		    var ramlVersion;
		    if (verStr == '0.8') {
		        ramlVersion = 'RAML08';
		    }
		    else if (verStr == '1.0') {
		        ramlVersion = 'RAML10';
		    }
		    if (!ramlVersion) {
		        //TODO throw sensible error
		        return null;
		    }
		    if (ramlVersion == 'RAML08' && checkApisOverlays) {
		        throw new Error('Extensions and overlays are not supported in RAML 0.8.');
		    }
		    if (!ramlFileType || ramlFileType.trim() === "") {
		        if (verStr == '0.8') {
		            typeName = universeDef.Universe08.Api.name;
		            apiImpl = RamlWrapper08.ApiImpl;
		        }
		        else if (verStr == '1.0') {
		            typeName = universeDef.Universe10.Api.name;
		            apiImpl = RamlWrapper1.ApiImpl;
		        }
		    }
		    else if (ramlFileType === "Overlay") {
		        apiImpl = RamlWrapper1.OverlayImpl;
		        typeName = universeDef.Universe10.Overlay.name;
		    }
		    else if (ramlFileType === "Extension") {
		        apiImpl = RamlWrapper1.ExtensionImpl;
		        typeName = universeDef.Universe10.Extension.name;
		    }
		    var universe = universeProvider(ramlVersion);
		    var apiType = universe.type(typeName);
		    if (!highLevel) {
		        highLevel = new hlimpl.ASTNodeImpl(unit.ast(), null, apiType, null);
		    }
		    api = new apiImpl(highLevel);
		    return api;
		}
		;
		function toError(api) {
		    var error = new Error('Api contains errors.');
		    error.parserErrors = api.errors();
		    return error;
		}
		exports.toError = toError;
		function loadApis1(projectRoot, cacheChildren, expandTraitsAndResourceTypes) {
		    if (cacheChildren === void 0) { cacheChildren = false; }
		    if (expandTraitsAndResourceTypes === void 0) { expandTraitsAndResourceTypes = true; }
		    var universe = universeProvider("RAML10");
		    var apiType = universe.type(universeDef.Universe10.Api.name);
		    var p = new jsyaml.Project(projectRoot);
		    var result = [];
		    p.units().forEach(function (x) {
		        var lowLevel = x.ast();
		        if (cacheChildren) {
		            lowLevel = llimpl.toChildCahcingNode(lowLevel);
		        }
		        var api = new RamlWrapper1.ApiImpl(new hlimpl.ASTNodeImpl(lowLevel, null, apiType, null));
		        if (expandTraitsAndResourceTypes) {
		            api = expander.expandTraitsAndResourceTypes(api);
		        }
		        result.push(api);
		    });
		    return result;
		}
		exports.loadApis1 = loadApis1;


	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(global, __dirname) {var fs = __webpack_require__(17);
		var path = __webpack_require__(16);
		var tsstruct = __webpack_require__(78);
		var ts2def = __webpack_require__(82);
		var universes = {};
		var locations = {
		    "RAML10": "../spec-1.0/api.ts",
		    "RAML08": "../spec-0.8/api.ts"
		};
		var jsonDefinitions = {
		    "RAML10": __webpack_require__(85),
		    "RAML08": __webpack_require__(86)
		};
		var getUniverse = (function () {
		    var x = function (key) {
		        if (universes[key]) {
		            return universes[key];
		        }
		        var src = getDecl(key);
		        var universe = ts2def.toDefSystem(src);
		        if (universe) {
		            universe.setUniverseVersion(key);
		            universes[key] = universe;
		        }
		        var mediaTypeParser = __webpack_require__(87);
		        global.mediaTypeParser = mediaTypeParser;
		        return universe;
		    };
		    x.availableUniverses = function () {
		        return Object.keys(locations);
		    };
		    x.clean = function () {
		        Object.keys(jsonDefinitions).forEach(function (x) {
		            jsonDefinitions[x] = null;
		            universes[x] = null;
		            fs.writeFileSync(path.resolve(__dirname, "../artifacts/" + x + ".json"), 'null');
		        });
		    };
		    return x;
		})();
		function getDecl(key) {
		    if (jsonDefinitions[key]) {
		        return toModule(jsonDefinitions[key]);
		    }
		    var tsPath = path.resolve(__dirname, locations[key]);
		    var decls = fs.readFileSync(tsPath).toString();
		    var src = tsstruct.parseStruct(decls, {}, tsPath);
		    var arr = toModulesCollection(src);
		    var jsonPath = path.resolve(path.resolve(path.dirname(tsPath), '../artifacts'), key + '.json');
		    fs.writeFileSync(jsonPath, JSON.stringify(arr, null, 2));
		    src = toModule(arr);
		    return src;
		}
		function toModulesCollection(mod, map, arr) {
		    if (map === void 0) { map = {}; }
		    if (arr === void 0) { arr = []; }
		    var name = mod['name'];
		    if (map[name]) {
		        return;
		    }
		    map[name] = mod;
		    arr.push(mod);
		    var imports = mod['imports'];
		    Object.keys(imports).forEach(function (x) {
		        var submod = imports[x];
		        var n = submod['name'];
		        imports[x] = n;
		        toModulesCollection(submod, map, arr);
		    });
		    return arr;
		}
		function toModule(arr) {
		    var main = arr[0];
		    var map = {};
		    arr.forEach(function (x) { return map[x['name']] = x; });
		    arr.forEach(function (x) {
		        var imports = x['imports'];
		        Object.keys(imports).forEach(function (y) {
		            var name = imports[y];
		            imports[y] = map[name];
		        });
		    });
		    return main;
		}
		module.exports = getUniverse;

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), "../../src/raml1/definition-system"))

	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Created by kor on 08/05/15.
		 */
		/// <reference path="../../../typings/tsd.d.ts" />
		var ts = __webpack_require__(79);
		var tsm = __webpack_require__(80);
		var pth = __webpack_require__(16);
		var fs = __webpack_require__(17);
		var tsModel = __webpack_require__(81);
		function parse(content) {
		    return ts.createSourceFile("sample.ts", content, 0 /* ES3 */, "1.4.1", true);
		}
		var fld = tsm.Matching.field();
		var clazzMatcher = tsm.Matching.classDeclaration();
		function classDecl(name, isInteface) {
		    return {
		        name: name,
		        methods: [],
		        typeParameters: [],
		        typeParameterConstraint: [],
		        implements: [],
		        fields: [],
		        isInterface: isInteface,
		        annotations: [],
		        extends: [],
		        moduleName: null,
		        annotationOverridings: {}
		    };
		}
		exports.classDecl = classDecl;
		function parseStruct(content, modules, mpth) {
		    var mod = parse(content);
		    var module = { classes: [], aliases: [], enumDeclarations: [], imports: {}, name: mpth };
		    modules[mpth] = module;
		    var currentModule = null;
		    tsm.Matching.visit(mod, function (x) {
		        if (x.kind == 189 /* ModuleDeclaration */) {
		            var cmod = x;
		            currentModule = cmod.name.text;
		        }
		        if (x.kind == 191 /* ImportDeclaration */) {
		            var imp = x;
		            var namespace = imp.name.text;
		            if (namespace == "RamlWrapper") {
		                return;
		            }
		            if (imp.moduleReference.kind != 193 /* ExternalModuleReference */) {
		                throw new Error("Only external module references are supported now");
		            }
		            var path = imp.moduleReference;
		            if (path.expression.kind != 7 /* StringLiteral */) {
		                throw new Error("Only string literals are supported in module references ");
		            }
		            var literal = path.expression;
		            var importPath = literal.text;
		            var absPath = pth.resolve(pth.dirname(mpth) + "/", importPath) + ".ts";
		            if (!fs.existsSync(absPath)) {
		                throw new Error("Path " + importPath + " resolve to " + absPath + "do not exists");
		            }
		            if (!modules[absPath]) {
		                var cnt = fs.readFileSync(absPath).toString();
		                var mod = parseStruct(cnt, modules, absPath);
		            }
		            module.imports[namespace] = modules[absPath];
		        }
		        if (x.kind == 187 /* TypeAliasDeclaration */) {
		            var u = x;
		            var aliasName = u.name.text;
		            var type = buildType(u.type, mpth);
		            module.aliases.push({ name: aliasName, type: type });
		        }
		        if (x.kind == 188 /* EnumDeclaration */) {
		            var e = x;
		            var members = [];
		            e.members.forEach(function (y) {
		                members.push(y['name']['text']);
		            });
		            module.enumDeclarations.push({ name: e.name.text, members: members });
		        }
		        var isInterface = x.kind == 186 /* InterfaceDeclaration */;
		        var isClass = x.kind == 185 /* ClassDeclaration */;
		        if (!isInterface && !isClass) {
		            return;
		        }
		        var c = x;
		        if (c) {
		            var fields = {};
		            var clazz = classDecl(c.name.text, isInterface);
		            clazz.moduleName = currentModule;
		            module.classes.push(clazz);
		            c.members.forEach(function (x) {
		                if (x.kind == 125 /* Method */) {
		                    var md = x;
		                    var aliasName = md.name.text;
		                    var text = content.substring(md.pos, md.end);
		                    clazz.methods.push({ name: aliasName, start: md.pos, end: md.end, text: text });
		                }
		                var field = fld.doMatch(x);
		                if (field) {
		                    var f = buildField(field, mpth);
		                    if (f.name == '$') {
		                        clazz.annotations = f.annotations;
		                    }
		                    else if (f.name.charAt(0) != '$' || f.name == '$ref') {
		                        fields[f.name] = f;
		                        clazz.fields.push(f);
		                    }
		                    else {
		                        var targetField = f.name.substr(1);
		                        var of = fields[targetField];
		                        if (!of) {
		                            if (f.name != '$$') {
		                                //console.log('Overriding annotations for field:'+targetField);
		                                var overridings = clazz.annotationOverridings[targetField];
		                                if (!overridings) {
		                                    overridings = [];
		                                }
		                                clazz.annotationOverridings[targetField] = overridings.concat(f.annotations);
		                            }
		                        }
		                        else {
		                            of.annotations = f.annotations;
		                        }
		                    }
		                }
		            });
		            if (c.typeParameters) {
		                c.typeParameters.forEach(function (x) {
		                    clazz.typeParameters.push(x.name['text']);
		                    if (x.constraint == null) {
		                        clazz.typeParameterConstraint.push(null);
		                    }
		                    else {
		                        clazz.typeParameterConstraint.push(x.constraint['typeName']['text']);
		                    }
		                });
		            }
		            if (c.heritageClauses) {
		                c.heritageClauses.forEach(function (x) {
		                    x.types.forEach(function (y) {
		                        if (x.token == 77 /* ExtendsKeyword */) {
		                            clazz.extends.push(buildType(y, mpth));
		                        }
		                        else if (x.token == 100 /* ImplementsKeyword */) {
		                            clazz.implements.push(buildType(y, mpth));
		                        }
		                        else {
		                            throw new Error("Unknown token class heritage");
		                        }
		                    });
		                });
		            }
		            return tsm.Matching.SKIP;
		        }
		    });
		    return module;
		}
		exports.parseStruct = parseStruct;
		function buildField(f, path) {
		    return {
		        name: f.name['text'],
		        type: buildType(f.type, path),
		        annotations: f.name['text'].charAt(0) == '$' ? buildInitializer(f.initializer) : [],
		        valueConstraint: f.name['text'].charAt(0) != '$' ? buildConstraint(f.initializer) : null,
		        optional: f.questionToken != null
		    };
		}
		function buildConstraint(e) {
		    if (e == null) {
		        return null;
		    }
		    if (e.kind == 145 /* CallExpression */) {
		        return {
		            isCallConstraint: true,
		            value: buildAnnotation(e)
		        };
		    }
		    else {
		        return {
		            isCallConstraint: false,
		            value: parseArg(e)
		        };
		    }
		}
		function buildInitializer(i) {
		    if (i == null) {
		        return [];
		    }
		    if (i.kind == 141 /* ArrayLiteralExpression */) {
		        var arr = i;
		        var annotations = [];
		        arr.elements.forEach(function (x) {
		            annotations.push(buildAnnotation(x));
		        });
		        return annotations;
		    }
		    else {
		        throw new Error("Only Array Literals supported now");
		    }
		}
		function buildAnnotation(e) {
		    if (e.kind == 145 /* CallExpression */) {
		        var call = e;
		        var name = parseName(call.expression);
		        var a = {
		            name: name,
		            arguments: []
		        };
		        call.arguments.forEach(function (x) {
		            a.arguments.push(parseArg(x));
		        });
		        return a;
		    }
		    else {
		        throw new Error("Only call expressions may be annotations");
		    }
		}
		function parseArg(n) {
		    if (n.kind == 7 /* StringLiteral */) {
		        var l = n;
		        return l.text;
		    }
		    if (n.kind == 9 /* NoSubstitutionTemplateLiteral */) {
		        var ls = n;
		        return ls.text;
		    }
		    if (n.kind == 141 /* ArrayLiteralExpression */) {
		        var arr = n;
		        var annotations = [];
		        arr.elements.forEach(function (x) {
		            annotations.push(parseArg(x));
		        });
		        return annotations;
		    }
		    if (n.kind == 93 /* TrueKeyword */) {
		        return true;
		    }
		    if (n.kind == 143 /* PropertyAccessExpression */) {
		        var pa = n;
		        return parseArg(pa.expression) + "." + parseArg(pa.name);
		    }
		    if (n.kind == 63 /* Identifier */) {
		        var ident = n;
		        return ident.text;
		    }
		    if (n.kind == 78 /* FalseKeyword */) {
		        return false;
		    }
		    if (n.kind == 6 /* NumericLiteral */) {
		        var nl = n;
		        return nl.text;
		    }
		    if (n.kind == 157 /* BinaryExpression */) {
		        var bin = n;
		        if (bin.operator = 32 /* PlusToken */) {
		            return parseArg(bin.left) + parseArg(bin.right);
		        }
		    }
		    throw new Error("Unknown value in annotation");
		}
		function parseName(n) {
		    if (n.kind == 63 /* Identifier */) {
		        return n['text'];
		    }
		    if (n.kind == 143 /* PropertyAccessExpression */) {
		        var m = n;
		        return parseName(m.expression) + "." + parseName(m.name);
		    }
		    throw new Error("Only simple identifiers are supported now");
		}
		function basicType(n, path) {
		    var namespaceIndex = n.indexOf(".");
		    var namespace = namespaceIndex != -1 ? n.substring(0, namespaceIndex) : "";
		    var basicName = namespaceIndex != -1 ? n.substring(namespaceIndex + 1) : n;
		    return { typeName: n, nameSpace: namespace, basicName: basicName, typeKind: 0 /* BASIC */, typeArguments: [], modulePath: path };
		}
		function arrayType(b) {
		    return { base: b, typeKind: 1 /* ARRAY */ };
		}
		function unionType(b) {
		    return { options: b, typeKind: 2 /* UNION */ };
		}
		function buildType(t, path) {
		    if (t == null) {
		        return null;
		    }
		    if (t.kind == 118 /* StringKeyword */) {
		        return basicType("string", null);
		    }
		    if (t.kind == 116 /* NumberKeyword */) {
		        return basicType("number", null);
		    }
		    if (t.kind == 110 /* BooleanKeyword */) {
		        return basicType("boolean", null);
		    }
		    if (t.kind == 109 /* AnyKeyword */) {
		        return basicType("any", null);
		    }
		    if (t.kind == 132 /* TypeReference */) {
		        var tr = t;
		        var res = basicType(parseQualified(tr.typeName), path);
		        if (tr.typeArguments) {
		            tr.typeArguments.forEach(function (x) {
		                res.typeArguments.push(buildType(x, path));
		            });
		        }
		        return res;
		    }
		    if (t.kind == 137 /* ArrayType */) {
		        var q = t;
		        return arrayType(buildType(q.elementType, path));
		    }
		    if (t.kind == 139 /* UnionType */) {
		        var ut = t;
		        return unionType(ut.types.map(function (x) { return buildType(x, path); }));
		    }
		    throw new Error("Case not supported" + t.kind);
		}
		exports.buildType = buildType;
		function parseQualified(n) {
		    if (n.kind == 63 /* Identifier */) {
		        return n['text'];
		    }
		    else {
		        var q = n;
		        return parseQualified(q.left) + "." + parseQualified(q.right);
		    }
		}


	/***/ },
	/* 79 */
	/***/ function(module, exports) {

		module.exports = {};

	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {

		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		/// <reference path="../../typings/tsd.d.ts" />
		var ts = __webpack_require__(79);
		/***
		 * This module is designed to match simple patterns on Typescript AST Tree
		 * it functionality mirrors jsASTMatchers which allows you to match on jsAST
		 */
		//TODO RENAME TO MATCHERS
		var Matching;
		(function (Matching) {
		    /**
		     * do match checks the node type and if node type is ok
		     * calls match function otherwise it returns null
		     */
		    var BasicMatcher = (function () {
		        function BasicMatcher() {
		        }
		        BasicMatcher.prototype.match = function (node) {
		            throw new Error();
		        };
		        BasicMatcher.prototype.nodeType = function () {
		            throw new Error();
		        };
		        BasicMatcher.prototype.doMatch = function (n) {
		            if (!n) {
		                return null;
		            }
		            if (this.nodeType() == n.kind) {
		                return this.match(n);
		            }
		        };
		        return BasicMatcher;
		    })();
		    var ClassDeclarationMatcher = (function (_super) {
		        __extends(ClassDeclarationMatcher, _super);
		        function ClassDeclarationMatcher() {
		            _super.call(this);
		        }
		        ClassDeclarationMatcher.prototype.match = function (node) {
		            return node;
		        };
		        ClassDeclarationMatcher.prototype.nodeType = function () {
		            return 185 /* ClassDeclaration */;
		        };
		        return ClassDeclarationMatcher;
		    })(BasicMatcher);
		    var FieldMatcher = (function (_super) {
		        __extends(FieldMatcher, _super);
		        function FieldMatcher() {
		            _super.apply(this, arguments);
		        }
		        FieldMatcher.prototype.match = function (node) {
		            return node;
		        };
		        FieldMatcher.prototype.nodeType = function () {
		            return 124 /* Property */;
		        };
		        return FieldMatcher;
		    })(BasicMatcher);
		    var AssignmentExpressionMatcher = (function (_super) {
		        __extends(AssignmentExpressionMatcher, _super);
		        function AssignmentExpressionMatcher(left, right, tr) {
		            _super.call(this);
		            this.left = left;
		            this.right = right;
		            this.tr = tr;
		        }
		        AssignmentExpressionMatcher.prototype.match = function (node) {
		            if (node.operator == 51 /* EqualsToken */) {
		                if (this.left.doMatch(node.left) && this.right.doMatch(node.right)) {
		                    return this.tr(node);
		                }
		            }
		            return null;
		        };
		        AssignmentExpressionMatcher.prototype.nodeType = function () {
		            return 157 /* BinaryExpression */;
		        };
		        return AssignmentExpressionMatcher;
		    })(BasicMatcher);
		    var VariableDeclarationMatcher = (function (_super) {
		        __extends(VariableDeclarationMatcher, _super);
		        function VariableDeclarationMatcher(left, right, tr) {
		            _super.call(this);
		            this.left = left;
		            this.right = right;
		            this.tr = tr;
		        }
		        VariableDeclarationMatcher.prototype.match = function (node) {
		            if (this.left.doMatch(node.name) && this.right.doMatch(node.initializer)) {
		                return this.tr(node);
		            }
		        };
		        VariableDeclarationMatcher.prototype.nodeType = function () {
		            return 183 /* VariableDeclaration */;
		        };
		        return VariableDeclarationMatcher;
		    })(BasicMatcher);
		    var ExpressionStatementMatcher = (function (_super) {
		        __extends(ExpressionStatementMatcher, _super);
		        function ExpressionStatementMatcher(expression, tr) {
		            _super.call(this);
		            this.expression = expression;
		            this.tr = tr;
		        }
		        ExpressionStatementMatcher.prototype.match = function (node) {
		            var exp = this.expression.doMatch(node.expression);
		            if (exp) {
		                var v = this.tr(node.expression);
		                if (v == true) {
		                    return exp;
		                }
		                return v;
		            }
		            return null;
		        };
		        ExpressionStatementMatcher.prototype.nodeType = function () {
		            return 166 /* ExpressionStatement */;
		        };
		        return ExpressionStatementMatcher;
		    })(BasicMatcher);
		    var SimpleIdentMatcher = (function (_super) {
		        __extends(SimpleIdentMatcher, _super);
		        function SimpleIdentMatcher(val) {
		            _super.call(this);
		            this.val = val;
		        }
		        SimpleIdentMatcher.prototype.match = function (node) {
		            if (node.text == this.val) {
		                return true;
		            }
		            return null;
		        };
		        SimpleIdentMatcher.prototype.nodeType = function () {
		            return 63 /* Identifier */;
		        };
		        return SimpleIdentMatcher;
		    })(BasicMatcher);
		    var TrueMatcher = (function () {
		        function TrueMatcher() {
		        }
		        TrueMatcher.prototype.doMatch = function (node) {
		            return true;
		        };
		        TrueMatcher.prototype.nodeType = function () {
		            return null;
		        };
		        return TrueMatcher;
		    })();
		    var CallExpressionMatcher = (function (_super) {
		        __extends(CallExpressionMatcher, _super);
		        function CallExpressionMatcher(calleeMatcher, tr) {
		            _super.call(this);
		            this.calleeMatcher = calleeMatcher;
		            this.tr = tr;
		        }
		        CallExpressionMatcher.prototype.match = function (node) {
		            if (this.calleeMatcher.doMatch(node.expression)) {
		                return this.tr(node);
		            }
		            return null;
		        };
		        CallExpressionMatcher.prototype.nodeType = function () {
		            return 145 /* CallExpression */;
		        };
		        return CallExpressionMatcher;
		    })(BasicMatcher);
		    Matching.SKIP = {};
		    function visit(n, cb) {
		        var r0 = cb(n);
		        if (r0) {
		            if (r0 == Matching.SKIP) {
		                return null;
		            }
		            return r0;
		        }
		        var r = ts.forEachChild(n, function (x) {
		            var r = visit(x, cb);
		            if (r) {
		                return r;
		            }
		        });
		        return r;
		    }
		    Matching.visit = visit;
		    var PathNode = (function () {
		        function PathNode(name, _base) {
		            this._base = _base;
		            this.arguments = null;
		            this.name = name;
		        }
		        return PathNode;
		    })();
		    var CallPath = (function () {
		        function CallPath(base, _baseNode) {
		            this._baseNode = _baseNode;
		            this.path = [];
		            this.base = base;
		        }
		        CallPath.prototype.start = function () {
		            return this._baseNode.pos;
		        };
		        CallPath.prototype.startLocation = function () {
		            return this._baseNode.getSourceFile().getLineAndCharacterFromPosition(this.start());
		        };
		        CallPath.prototype.endLocation = function () {
		            return this._baseNode.getSourceFile().getLineAndCharacterFromPosition(this.end());
		        };
		        CallPath.prototype.end = function () {
		            var ce = this.path[this.path.length - 1]._callExpression;
		            if (ce) {
		                return ce.end;
		            }
		            return this.start();
		        };
		        CallPath.prototype.toString = function () {
		            return this.path.map(function (x) { return x.name; }).join(".");
		        };
		        return CallPath;
		    })();
		    Matching.CallPath = CallPath;
		    var MemberExpressionMatcher = (function (_super) {
		        __extends(MemberExpressionMatcher, _super);
		        function MemberExpressionMatcher(objectMatcher, propertyMatcher, tr) {
		            _super.call(this);
		            this.objectMatcher = objectMatcher;
		            this.propertyMatcher = propertyMatcher;
		            this.tr = tr;
		        }
		        MemberExpressionMatcher.prototype.match = function (node) {
		            if (this.objectMatcher.doMatch(node.expression) && this.propertyMatcher.doMatch(node.name)) {
		                return this.tr(node);
		            }
		            return null;
		        };
		        MemberExpressionMatcher.prototype.nodeType = function () {
		            return 143 /* PropertyAccessExpression */;
		        };
		        return MemberExpressionMatcher;
		    })(BasicMatcher);
		    function memberFromExp(objMatcher, tr) {
		        if (tr === void 0) { tr = function (x) { return true; }; }
		        var array = objMatcher.split(".");
		        var result = null;
		        for (var a = 0; a < array.length; a++) {
		            var arg = array[a];
		            var ci = arg.indexOf("(*)");
		            var isCall = false;
		            if (ci != -1) {
		                arg = arg.substr(0, ci);
		                isCall = true;
		            }
		            if (result == null) {
		                result = arg == '*' ? anyNode() : ident(arg);
		            }
		            else {
		                result = new MemberExpressionMatcher(result, arg == '*' ? anyNode() : ident(arg), tr);
		            }
		            if (isCall) {
		                result = new CallExpressionMatcher(result, tr);
		            }
		        }
		        //console.log(result)
		        return result;
		    }
		    Matching.memberFromExp = memberFromExp;
		    var CallBaseMatcher = (function () {
		        function CallBaseMatcher(rootMatcher) {
		            this.rootMatcher = rootMatcher;
		        }
		        CallBaseMatcher.prototype.doMatch = function (node) {
		            var original = node;
		            if (node.kind == 145 /* CallExpression */) {
		                var call = node;
		                var res = this.doMatch(call.expression);
		                if (res) {
		                    if (res.path.length > 0 && res.path[res.path.length - 1].arguments == null) {
		                        res.path[res.path.length - 1].arguments = call.arguments;
		                        res.path[res.path.length - 1]._callExpression = call;
		                        return res;
		                    }
		                    //This case should not exist in type script clients now
		                    //but leaving it here for possible future use at the moment;
		                    //if (res.path.length==0&&call.arguments.length==1){
		                    //    //this is not resource based call!!!
		                    //    if (call.arguments[0].kind==ts.SyntaxKind.StringLiteral){
		                    //        var l:ts.LiteralExpression=<ts.LiteralExpression>call.arguments[0];
		                    //        var url=l.text;
		                    //        var uriPath=url.toString().split("/");
		                    //        uriPath.forEach(x=>res.path.push(
		                    //            new PathNode(x)
		                    //        ))
		                    //        return res;
		                    //    }
		                    //}
		                    return null;
		                }
		            }
		            else if (node.kind == 143 /* PropertyAccessExpression */) {
		                var me = node;
		                var v = this.doMatch(me.expression);
		                if (v) {
		                    if (me.name.kind == 63 /* Identifier */) {
		                        v.path.push(new PathNode(me.name.text, me.name));
		                        return v;
		                    }
		                    return null;
		                }
		            }
		            else if (node.kind == 63 /* Identifier */) {
		                var id = node;
		                if (this.rootMatcher.doMatch(id)) {
		                    return new CallPath(id.text, id);
		                }
		            }
		            return null;
		        };
		        CallBaseMatcher.prototype.nodeType = function () {
		            return null;
		        };
		        return CallBaseMatcher;
		    })();
		    Matching.CallBaseMatcher = CallBaseMatcher;
		    function ident(name) {
		        return new SimpleIdentMatcher(name);
		    }
		    Matching.ident = ident;
		    function anyNode() {
		        return new TrueMatcher();
		    }
		    Matching.anyNode = anyNode;
		    function call(calleeMatcher, tr) {
		        if (tr === void 0) { tr = function (x) { return true; }; }
		        return new CallExpressionMatcher(calleeMatcher, tr);
		    }
		    Matching.call = call;
		    function exprStmt(eM, tr) {
		        if (tr === void 0) { tr = function (x) { return true; }; }
		        return new ExpressionStatementMatcher(eM, tr);
		    }
		    Matching.exprStmt = exprStmt;
		    function assign(left, right, tr) {
		        if (tr === void 0) { tr = function (x) { return true; }; }
		        return new AssignmentExpressionMatcher(left, right, tr);
		    }
		    Matching.assign = assign;
		    function varDecl(left, right, tr) {
		        if (tr === void 0) { tr = function (x) { return true; }; }
		        return new VariableDeclarationMatcher(left, right, tr);
		    }
		    Matching.varDecl = varDecl;
		    function field() {
		        return new FieldMatcher();
		    }
		    Matching.field = field;
		    function classDeclaration() {
		        return new ClassDeclarationMatcher();
		    }
		    Matching.classDeclaration = classDeclaration;
		})(Matching = exports.Matching || (exports.Matching = {}));


	/***/ },
	/* 81 */
	/***/ function(module, exports) {

		var EnumDeclaration = (function () {
		    function EnumDeclaration() {
		    }
		    return EnumDeclaration;
		})();
		exports.EnumDeclaration = EnumDeclaration;
		(function (TypeKind) {
		    TypeKind[TypeKind["BASIC"] = 0] = "BASIC";
		    TypeKind[TypeKind["ARRAY"] = 1] = "ARRAY";
		    TypeKind[TypeKind["UNION"] = 2] = "UNION";
		})(exports.TypeKind || (exports.TypeKind = {}));
		var TypeKind = exports.TypeKind;


	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {

		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		/// <reference path="../../../typings/tsd.d.ts" />
		var tsModel = __webpack_require__(81);
		var def = __webpack_require__(3);
		var _ = __webpack_require__(4);
		var aHandlers = __webpack_require__(83);
		var services = __webpack_require__(49);
		var FieldWrapper = (function () {
		    function FieldWrapper(_field, _clazz) {
		        this._field = _field;
		        this._clazz = _clazz;
		    }
		    FieldWrapper.prototype.name = function () {
		        return this._field.name;
		    };
		    FieldWrapper.prototype.range = function () {
		        return this._clazz.getModule().typeFor(this._field.type, this._clazz);
		    };
		    FieldWrapper.prototype.isMultiValue = function () {
		        return this._field.type.typeKind == 1 /* ARRAY */;
		    };
		    FieldWrapper.prototype.isKey = function () {
		        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.key"; }) != null;
		    };
		    FieldWrapper.prototype.isSimpleValue = function () {
		        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.value"; }) != null;
		    };
		    FieldWrapper.prototype.annotations = function () {
		        return this._field.annotations;
		    };
		    return FieldWrapper;
		})();
		var FieldConstraint = (function () {
		    function FieldConstraint(_field, _clazz) {
		        this._field = _field;
		        this._clazz = _clazz;
		    }
		    FieldConstraint.prototype.name = function () {
		        return this._field.name;
		    };
		    FieldConstraint.prototype.value = function () {
		        return this._field.valueConstraint;
		    };
		    return FieldConstraint;
		})();
		var ClassWrapper = (function () {
		    function ClassWrapper(_clazz, mw) {
		        this._clazz = _clazz;
		        this.mw = mw;
		    }
		    ClassWrapper.prototype.typeMeta = function () {
		        return this._clazz.annotations;
		    };
		    ClassWrapper.prototype.path = function () {
		        return this.mw.path();
		    };
		    ClassWrapper.prototype.getModule = function () {
		        return this.mw;
		    };
		    ClassWrapper.prototype.typeArgs = function () {
		        return this._clazz.typeParameters;
		    };
		    ClassWrapper.prototype.typConstraints = function () {
		        var _this = this;
		        return this._clazz.typeParameterConstraint.map(function (x) {
		            if (x) {
		                return _this.mw.classForName(x);
		            }
		            return null;
		        });
		    };
		    ClassWrapper.prototype.methods = function () {
		        return this._clazz.methods;
		    };
		    ClassWrapper.prototype.name = function () {
		        return this._clazz.name;
		    };
		    ClassWrapper.prototype.members = function () {
		        var _this = this;
		        return this._clazz.fields.filter(function (x) { return x.valueConstraint == null; }).map(function (x) { return new FieldWrapper(x, _this); });
		    };
		    ClassWrapper.prototype.constraints = function () {
		        var _this = this;
		        return this._clazz.fields.filter(function (x) { return x.valueConstraint != null; }).map(function (x) { return new FieldConstraint(x, _this); });
		    };
		    ClassWrapper.prototype.isSubTypeOf = function (of) {
		        if (this == of) {
		            return true;
		        }
		        var _res = false;
		        this.getAllSuperTypes().forEach(function (x) {
		            if (!_res) {
		                _res = _res || x.isSubTypeOf(of);
		            }
		        });
		        return _res;
		    };
		    ClassWrapper.prototype.getExtendsClauses = function () {
		        return this._clazz.extends;
		    };
		    ClassWrapper.prototype.getSuperTypes = function () {
		        var _this = this;
		        var result = [];
		        this._clazz.extends.forEach(function (x) {
		            var tp = _this.mw.classForName(x.typeName);
		            if (tp) {
		                result.push(tp);
		            }
		        });
		        return result;
		    };
		    ClassWrapper.prototype.getAllSuperTypes = function () {
		        var _this = this;
		        var result = [];
		        this._clazz.extends.forEach(function (x) {
		            var tp = _this.mw.classForName(x.typeName);
		            if (tp) {
		                var mm = tp.getAllSuperTypes();
		                result.push(tp);
		                result.concat(mm);
		            }
		        });
		        return _.unique(result);
		    };
		    ClassWrapper.prototype.annotationOverridings = function () {
		        return this._clazz.annotationOverridings;
		    };
		    return ClassWrapper;
		})();
		var AbstractSimpleWrapper = (function () {
		    function AbstractSimpleWrapper() {
		    }
		    AbstractSimpleWrapper.prototype.members = function () {
		        return []; //this._clazz.members.map(x=>new FieldWrapper(x,this))
		    };
		    AbstractSimpleWrapper.prototype.methods = function () {
		        return [];
		    };
		    AbstractSimpleWrapper.prototype.isSubTypeOf = function (of) {
		        return false;
		    };
		    AbstractSimpleWrapper.prototype.getSuperTypes = function () {
		        return [];
		    };
		    AbstractSimpleWrapper.prototype.getAllSuperTypes = function () {
		        return [];
		    };
		    AbstractSimpleWrapper.prototype.name = function () {
		        return null;
		    };
		    AbstractSimpleWrapper.prototype.constraints = function () {
		        return [];
		    };
		    AbstractSimpleWrapper.prototype.typeMeta = function () {
		        return [];
		    };
		    AbstractSimpleWrapper.prototype.getModule = function () {
		        throw new Error("Not implemented");
		    };
		    AbstractSimpleWrapper.prototype.annotationOverridings = function () {
		        return {};
		    };
		    return AbstractSimpleWrapper;
		})();
		var EnumWrapper = (function (_super) {
		    __extends(EnumWrapper, _super);
		    function EnumWrapper(_clazz, mw) {
		        _super.call(this);
		        this._clazz = _clazz;
		        this.mw = mw;
		    }
		    EnumWrapper.prototype.getModule = function () {
		        return this.mw;
		    };
		    EnumWrapper.prototype.values = function () {
		        return this._clazz.members;
		    };
		    EnumWrapper.prototype.name = function () {
		        return this._clazz.name;
		    };
		    return EnumWrapper;
		})(AbstractSimpleWrapper);
		var UnionWrapper = (function (_super) {
		    __extends(UnionWrapper, _super);
		    function UnionWrapper(_clazz, mw) {
		        _super.call(this);
		        this._clazz = _clazz;
		        this.mw = mw;
		    }
		    UnionWrapper.prototype.elements = function () {
		        return this._clazz;
		    };
		    UnionWrapper.prototype.name = function () {
		        return this._clazz.map(function (x) { return x.name(); }).join("|");
		    };
		    return UnionWrapper;
		})(AbstractSimpleWrapper);
		var ModuleWrapper = (function () {
		    function ModuleWrapper(_univers) {
		        var _this = this;
		        this._univers = _univers;
		        this.name2Class = {};
		        this.namespaceToMod = {};
		        this._classes = [];
		        _univers.classes.forEach(function (x) {
		            var c = new ClassWrapper(x, _this);
		            _this._classes.push(c);
		            _this.name2Class[x.name] = c;
		            if (x.moduleName) {
		                //FIXME
		                _this.name2Class[x.moduleName + "." + x.name] = c;
		            }
		        });
		        _univers.enumDeclarations.forEach(function (x) {
		            var c = new EnumWrapper(x, _this);
		            _this._classes.push(c);
		            _this.name2Class[x.name] = c;
		        });
		    }
		    ModuleWrapper.prototype.typeFor = function (t, ow) {
		        var _this = this;
		        switch (t.typeKind) {
		            case 0 /* BASIC */:
		                var bt = t;
		                var typeName = bt.typeName;
		                if (typeName == "string") {
		                    typeName = "StringType";
		                }
		                if (typeName == "number") {
		                    typeName = "NumberType";
		                }
		                if (typeName == "boolean") {
		                    typeName = "BooleanType";
		                }
		                var ti = _.indexOf(ow.typeArgs(), typeName);
		                if (ti != -1) {
		                    var cnst = ow.typConstraints()[ti];
		                    if (!cnst) {
		                        return this.classForName("ValueType");
		                    }
		                    return cnst;
		                }
		                return this.classForName(typeName);
		            case 2 /* UNION */:
		                var ut = t;
		                return new UnionWrapper(ut.options.map(function (x) { return _this.typeFor(x, ow); }), this);
		            case 1 /* ARRAY */:
		                var at = t;
		                return this.typeFor(at.base, ow);
		        }
		        return null;
		    };
		    ModuleWrapper.prototype.path = function () {
		        return this._univers.name;
		    };
		    ModuleWrapper.prototype.classForName = function (name, stack) {
		        var _this = this;
		        if (stack === void 0) { stack = {}; }
		        if (!name) {
		            return null;
		        }
		        var result = this.name2Class[name];
		        if (!result && !stack[this.path()]) {
		            stack[this.path()] = this;
		            var nmsp = name.indexOf(".");
		            if (nmsp != -1) {
		                var actualMod = this.namespaceToMod[name.substring(0, nmsp)];
		                if (!actualMod) {
		                    throw new Error();
		                }
		                return actualMod.classForName(name.substring(nmsp + 1), stack);
		            }
		            Object.keys(this.namespaceToMod).forEach(function (x) {
		                if (x != "MetaModel") {
		                    var nm = _this.namespaceToMod[x].classForName(name, stack);
		                    if (nm) {
		                        result = nm;
		                    }
		                }
		            });
		        }
		        return result;
		    };
		    ModuleWrapper.prototype.classes = function () {
		        return this._classes;
		    };
		    return ModuleWrapper;
		})();
		var wrapperToType = function (range, u) {
		    if (range) {
		        var rangeType;
		        if (range instanceof UnionWrapper) {
		            var uw = range;
		            throw new Error("Union type support was removed from definition system");
		        }
		        else {
		            rangeType = u.type(range.name());
		        }
		        return rangeType;
		    }
		    else {
		        return;
		    }
		};
		var registerClasses = function (m, u) {
		    var valueType = m.classForName("ValueType");
		    m.classes().forEach(function (x) {
		        if (x instanceof EnumWrapper) {
		            var et = new def.EnumType(x.name(), u, x.getModule().path());
		            et.values = x.values();
		            u.register(et);
		            return;
		        }
		        if (x.isSubTypeOf(valueType)) {
		            var st = x.getAllSuperTypes();
		            st.push(x);
		            var refTo = null;
		            st.forEach(function (t) {
		                var cs = t.getExtendsClauses();
		                cs.forEach(function (z) {
		                    if (z.typeKind == 0 /* BASIC */) {
		                        var bas = z;
		                        if (bas.basicName == 'Reference') {
		                            var of = bas.typeArguments[0];
		                            refTo = of.typeName;
		                        }
		                    }
		                });
		            });
		            if (refTo) {
		                //console.log("New reference type" + x.name())
		                var ref = new def.ReferenceType(x.name(), x.getModule().path(), refTo, u);
		                u.register(ref);
		            }
		            var vt = new def.ValueType(x.name(), u, x.getModule().path());
		            u.register(vt);
		        }
		        else {
		            var gt = new def.NodeClass(x.name(), u, x.getModule().path());
		            u.register(gt);
		        }
		    });
		};
		var registerHierarchy = function (m, u) {
		    m.classes().forEach(function (x) {
		        x.getSuperTypes().forEach(function (y) {
		            var tp0 = u.type(x.name());
		            var tp1 = u.type(y.name());
		            if (!tp0 || !tp1) {
		                var tp0 = u.type(x.name());
		                var tp1 = u.type(y.name());
		                throw new Error();
		            }
		            u.registerSuperClass(tp0, tp1);
		        });
		    });
		};
		var registerEverything = function (m, u) {
		    m.classes().forEach(function (x) {
		        var tp = u.type(x.name());
		        x.typeMeta().forEach(function (a) {
		            var rangeType = wrapperToType(x, u);
		            aHandlers.handleTypeAnnotation(a, rangeType);
		        });
		        x.members().forEach(function (x) {
		            var range = x.range();
		            var rangeType = wrapperToType(range, u);
		            if (rangeType == null) {
		                console.log(range + ":" + x.name());
		            }
		            createProp(x, tp, rangeType);
		        });
		        Object.keys(x.annotationOverridings()).forEach(function (fName) {
		            var arr = [].concat(x.annotationOverridings()[fName]);
		            var map = {};
		            arr.forEach(function (ann) { return map[ann.name] = true; });
		            var targetField;
		            var stArr = x.getSuperTypes();
		            var stMap = {};
		            for (var i = 0; i < stArr.length; i++) {
		                var st = stArr[i];
		                if (stMap[st.name()]) {
		                    continue;
		                }
		                stMap[st.name()] = true;
		                st.getSuperTypes().forEach(function (sst) { return stArr.push(sst); });
		                var arr1 = st.annotationOverridings()[fName];
		                if (arr1) {
		                    arr1.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
		                        map[ann.name] = true;
		                        arr.push(ann);
		                    });
		                }
		                else {
		                    var stFields = st.members();
		                    for (var j = 0; j < stFields.length; j++) {
		                        var stField = stFields[j];
		                        if (stField.name() == fName) {
		                            targetField = stField;
		                            break;
		                        }
		                    }
		                }
		                if (targetField) {
		                    var arr2 = targetField.annotations();
		                    arr2.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
		                        map[ann.name] = true;
		                        arr.push(ann);
		                    });
		                    break;
		                }
		            }
		            if (!targetField) {
		                return;
		            }
		            var range = targetField.range();
		            var rangeType = wrapperToType(range, u);
		            if (rangeType == null) {
		                console.log(range + ":" + x.name());
		            }
		            createProp(targetField, tp, rangeType, arr);
		        });
		        x.methods().forEach(function (x) {
		            var at = tp;
		            //at.addMethod(x.name, x.text);
		            //console.log(x.name);
		            //createMember(x, <def.AbstractType>tp, rangeType)
		        });
		        x.constraints().forEach(function (x) {
		            if (x.value().isCallConstraint) {
		                throw new Error();
		            }
		            var mm = x.value();
		            tp.addRequirement(x.name(), "" + mm.value);
		        });
		    });
		    u.types().forEach(function (x) {
		        var at = x;
		        at.getAdapter(services.RAMLService).getAliases().forEach(function (y) { return u.registerAlias(y, at); });
		    });
		};
		var processModule = function (ts, u, used, declared) {
		    if (ts.name.indexOf("metamodel.ts") != -1) {
		        return; //FIXME
		    }
		    if (declared[ts.name]) {
		        return declared[ts.name];
		    }
		    var m = new ModuleWrapper(ts);
		    used[ts.name] = m;
		    declared[ts.name] = m;
		    Object.keys(ts.imports).forEach(function (x) {
		        var pMod = ts.imports[x];
		        if (used[pMod.name]) {
		            m.namespaceToMod[x] = used[pMod.name];
		            return;
		        }
		        var vMod = processModule(pMod, u, used, declared);
		        m.namespaceToMod[x] = vMod;
		    });
		    used[ts.name] = null;
		    return m;
		};
		function toDefSystem(ts) {
		    var u = new def.Universe("");
		    var c = {};
		    processModule(ts, u, {}, c);
		    Object.keys(c).forEach(function (x) {
		        registerClasses(c[x], u);
		    });
		    Object.keys(c).forEach(function (x) {
		        registerHierarchy(c[x], u);
		    });
		    Object.keys(c).forEach(function (x) {
		        registerEverything(c[x], u);
		    });
		    u.types().forEach(function (x) {
		        if (x instanceof def.NodeClass) {
		            var cl = x;
		            cl.properties().forEach(function (y) {
		                var t = y.range();
		                var ap = y;
		                if (!t.isValueType()) {
		                    t.properties().forEach(function (p0) {
		                        if (p0.getAdapter(services.RAMLPropertyService).isKey()) {
		                            var kp = p0.keyPrefix();
		                            if (kp) {
		                                ap.withKeyRestriction(kp);
		                                ap.merge();
		                            }
		                            var eo = p0.enumOptions();
		                            if (eo) {
		                                ap.withEnumOptions(eo);
		                                ap.merge();
		                            }
		                        }
		                    });
		                }
		            });
		            if (cl.getAdapter(services.RAMLService).isGlobalDeclaration()) {
		                if (cl.getAdapter(services.RAMLService).getActuallyExports() && cl.getAdapter(services.RAMLService).getActuallyExports() != "$self") {
		                    var tp = cl.property(cl.getAdapter(services.RAMLService).getActuallyExports()).range();
		                    if (tp.isValueType()) {
		                        var vt = tp.getAdapter(services.RAMLService);
		                        vt.setGloballyDeclaredBy(cl);
		                    }
		                }
		                if (cl.getAdapter(services.RAMLService).getConvertsToGlobal()) {
		                    var tp = u.type(cl.getAdapter(services.RAMLService).getConvertsToGlobal());
		                    if (tp.isValueType()) {
		                        var vt = tp.getAdapter(services.RAMLService);
		                        vt.setGloballyDeclaredBy(cl);
		                    }
		                }
		            }
		        }
		    });
		    return u;
		}
		exports.toDefSystem = toDefSystem;
		var processAnnotations = function (x, p, annotations) {
		    if (!annotations) {
		        annotations = x.annotations();
		    }
		    annotations.forEach(function (x) {
		        var nm = x.name.substring(x.name.lastIndexOf(".") + 1);
		        if (!aHandlers.annotationHandlers[nm]) {
		            console.log("Can not find handler for:");
		        }
		        aHandlers.annotationHandlers[nm](x, p);
		    });
		};
		function createProp(x, clazz, t, annotations) {
		    var p = def.prop(x.name(), "", clazz, t);
		    if (x.isMultiValue()) {
		        p.withMultiValue(true);
		    }
		    p.unmerge();
		    if (!t.isValueType()) {
		        t.properties().forEach(function (p0) {
		            if (p0.getAdapter(services.RAMLPropertyService).isKey()) {
		                var kp = p0.keyPrefix();
		                if (kp) {
		                    p.withKeyRestriction(kp);
		                    p.merge();
		                }
		                var eo = p0.enumOptions();
		                if (eo) {
		                    p.withEnumOptions(eo);
		                    p.merge();
		                }
		            }
		        });
		    }
		    processAnnotations(x, p, annotations);
		}


	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {

		var def = __webpack_require__(3);
		var khttp = __webpack_require__(84);
		var _ = __webpack_require__(4);
		var services = __webpack_require__(49);
		function handleTypeAnnotation(a, rangeType) {
		    if (a.name == 'MetaModel.declaresSubTypeOf') {
		        rangeType.getAdapter(services.RAMLService).setExtendedTypeName(a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.nameAtRuntime') {
		        rangeType.setNameAtRuntime(a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.description') {
		        rangeType.withDescription(a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.inlinedTemplates') {
		        rangeType.getAdapter(services.RAMLService).setInlinedTemplates(true);
		    }
		    if (a.name == 'MetaModel.requireValue') {
		        rangeType.getAdapter(services.RAMLService).withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
		    }
		    if (a.name == 'MetaModel.referenceIs') {
		        rangeType.getAdapter(services.RAMLService).withReferenceIs("" + a.arguments[0]);
		    }
		    //MetaModel.referenceIs
		    if (a.name == 'MetaModel.actuallyExports') {
		        rangeType.getAdapter(services.RAMLService).withActuallyExports("" + a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.convertsToGlobalOfType') {
		        rangeType.getAdapter(services.RAMLService).withConvertsToGlobal("" + a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.allowAny') {
		        rangeType.getAdapter(services.RAMLService).withAllowAny();
		    }
		    if (a.name == 'MetaModel.allowQuestion') {
		        rangeType.getAdapter(services.RAMLService).withAllowQuestion();
		    }
		    if (a.name == 'MetaModel.alias') {
		        rangeType.getAdapter(services.RAMLService).addAlias("" + a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.consumesRefs') {
		        rangeType.getAdapter(services.RAMLService).setConsumesRefs(true);
		    }
		    if (a.name == 'MetaModel.canInherit') {
		        rangeType.getAdapter(services.RAMLService).withCanInherit("" + a.arguments[0]);
		    }
		    if (a.name == 'MetaModel.definingPropertyIsEnough') {
		        rangeType.getAdapter(services.RAMLService).definingPropertyIsEnough("" + a.arguments[0]);
		    }
		}
		exports.handleTypeAnnotation = handleTypeAnnotation;
		exports.annotationHandlers = {
		    key: function (a, f) {
		        f.withFromParentKey();
		        f.withKey(true);
		    },
		    value: function (a, f) {
		        f.withFromParentValue();
		    },
		    canBeValue: function (a, f) {
		        f.withCanBeValue();
		    },
		    unmerged: function (a, f) {
		        f.unmerge();
		    },
		    startFrom: function (a, f) {
		        f.withKeyRestriction(a.arguments[0]);
		        f.merge();
		    },
		    oneOf: function (a, f) {
		        f.withEnumOptions(a.arguments[0]);
		    },
		    oftenKeys: function (a, f) {
		        f.withOftenKeys(a.arguments[0]);
		    },
		    embeddedInMaps: function (a, f) {
		        f.getAdapter(services.RAMLPropertyParserService).withEmbedMap();
		    },
		    system: function (a, f) {
		        f.getAdapter(services.RAMLPropertyParserService).withSystem(true);
		    },
		    required: function (a, f) {
		        if (a.arguments[0] != 'false') {
		            f.withRequired(true);
		        }
		    },
		    noDirectParse: function (a, f) {
		        if (a.arguments[0] != 'false') {
		            f.withNoDirectParse();
		        }
		    },
		    setsContextValue: function (a, f) {
		        f.addChildValueConstraint(new def.ChildValueConstraint("" + a.arguments[0], "" + a.arguments[1]));
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    defaultValue: function (a, f) {
		        f.setDefaultVal("" + a.arguments[0]);
		    },
		    facetId: function (a, f) {
		        if (a.arguments[0] == "minItems") {
		            f.setFacetValidator(function (x, f) {
		                if (x instanceof Array) {
		                    var length = Number.parseInt("" + f.value());
		                    if (length > x.length) {
		                        return "array should contain at least " + f.value() + " items";
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "maxItems") {
		            f.setFacetValidator(function (x, f) {
		                if (x instanceof Array) {
		                    var length = Number.parseInt("" + f.value());
		                    if (length < x.length) {
		                        return "array should contain not more then " + f.value() + " items";
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "minProperties") {
		            f.setFacetValidator(function (x, f) {
		                if (x instanceof Object) {
		                    var length = Number.parseInt("" + f.value());
		                    if (length > Object.keys(x).length) {
		                        return "object should contain at least " + f.value() + " properties";
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "maxProperties") {
		            f.setFacetValidator(function (x, f) {
		                if (x instanceof Object) {
		                    var length = Number.parseInt("" + f.value());
		                    if (length < Object.keys(x).length) {
		                        return "object should contain not more then " + f.value() + " properties";
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "uniqueItems") {
		            f.setFacetValidator(function (x, f) {
		                if (x instanceof Array) {
		                    var length = _.unique(x).length;
		                    if (length < x.length) {
		                        return "array should contain only unique items";
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "minLength") {
		            f.setFacetValidator(function (x, f) {
		                if (typeof x == 'number' || typeof x == 'boolean') {
		                    x = "" + x;
		                }
		                if (typeof x == 'string') {
		                    var length = Number.parseInt("" + f.value());
		                    if (length > x.length) {
		                        return "string length should be at least " + length;
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "maxLength") {
		            f.setFacetValidator(function (x, f) {
		                if (typeof x == 'number' || typeof x == 'boolean') {
		                    x = "" + x;
		                }
		                if (typeof x == 'string') {
		                    var length = Number.parseInt("" + f.value());
		                    if (length < x.length) {
		                        return "string length should be not more then " + length;
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "minimum") {
		            f.setFacetValidator(function (x, f) {
		                if (typeof x == 'string') {
		                    x = parseFloat(x);
		                }
		                if (typeof x == 'number') {
		                    var length = parseFloat(f.value());
		                    if (length > x) {
		                        return "value should be not less then " + length;
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "maximum") {
		            f.setFacetValidator(function (x, f) {
		                if (typeof x == 'string') {
		                    x = parseFloat(x);
		                }
		                if (typeof x == 'number') {
		                    var length = parseFloat(f.value());
		                    if (length < x) {
		                        return "value should be not more then " + length;
		                    }
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "pattern") {
		            f.setFacetValidator(function (x, f) {
		                if (typeof x == 'number' || typeof x == 'boolean') {
		                    x = "" + x;
		                }
		                if (typeof x == 'string') {
		                    var regExp = new RegExp(f.value());
		                    if (!regExp.test(x)) {
		                        return "string should match to " + f.value();
		                    }
		                }
		                return null;
		            });
		        }
		    },
		    extraMetaKey: function (a, f) {
		        if (a.arguments[0] == "statusCodes") {
		            f.withOftenKeys(khttp.statusCodes.map(function (x) { return x.code; }));
		            f.setValueDocProvider(function (name) {
		                var s = _.find(khttp.statusCodes, function (x) { return x.code == name; });
		                if (s) {
		                    return (name + ":" + s.description);
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "headers") {
		            f.setValueSuggester(function (x) {
		                if (x.property()) {
		                    var c = x.property().getChildValueConstraints();
		                    if (_.find(c, function (x) {
		                        return x.name == "location" && x.value == "Params.ParameterLocation.HEADERS";
		                    })) {
		                        return khttp.headers.map(function (x) { return x.header; });
		                    }
		                    if (x.property()) {
		                        if (x.property().nameId() == "headers") {
		                            return khttp.headers.map(function (x) { return x.header; });
		                        }
		                    }
		                }
		                return null;
		            });
		            f.setValueDocProvider(function (name) {
		                var s = _.find(khttp.headers, function (x) { return x.header == name; });
		                if (s) {
		                    return (name + ":" + s.description);
		                }
		                return null;
		            });
		        }
		        if (a.arguments[0] == "methods") {
		            f.setValueDocProvider(function (name) {
		                var s = _.find(khttp.methods, function (x) { return x.method == name.toUpperCase(); });
		                if (s) {
		                    return (name + ":" + s.description);
		                }
		                return null;
		            });
		        }
		    },
		    requireValue: function (a, f) {
		        f.withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    allowMultiple: function (a, f) {
		        f.withMultiValue(true);
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    selector: function (a, f) {
		        f.setSelector("" + a.arguments[0]);
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    constraint: function (a, f) {
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    newInstanceName: function (a, f) {
		        f.withNewInstanceName("" + a.arguments[0]);
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    declaringFields: function (a, f) {
		        f.withThisPropertyDeclaresFields();
		        //f.withKeyRestriction(<string>a.arguments[0])
		    },
		    describesAnnotation: function (a, f) {
		        //f.withReferenceParameters();
		        f.withDescribes(a.arguments[0]);
		    },
		    allowNull: function (a, f) {
		        f.withAllowNull();
		    },
		    descriminatingProperty: function (a, f) {
		        //f.withReferenceParameters();
		        f.withDescriminating(true);
		    },
		    description: function (a, f) {
		        f.withDescription("" + a.arguments[0]);
		        //f.withReferenceParameters();
		        //f.withDescriminating(true)
		    },
		    inherited: function (a, f) {
		        f.withInherited(true);
		    },
		    selfNode: function (a, f) {
		        f.withSelfNode();
		    },
		    grammarTokenKind: function (a, f) {
		        f.getAdapter(services.RAMLPropertyService).withPropertyGrammarType("" + a.arguments[0]);
		    },
		    canInherit: function (a, f) {
		        f.withInheritedContextValue("" + a.arguments[0]);
		    },
		    canBeDuplicator: function (a, f) {
		        f.setCanBeDuplicator();
		    },
		    hide: function (a, f) {
		        if (a.arguments.length == 0) {
		            f.getAdapter(services.RAMLPropertyDocumentationService).setHidden(true);
		        }
		        else {
		            f.getAdapter(services.RAMLPropertyDocumentationService).setHidden(a.arguments[0]);
		        }
		    },
		    documentationTableLabel: function (a, f) {
		        f.getAdapter(services.RAMLPropertyDocumentationService).setDocTableName("" + a.arguments[0]);
		    },
		    markdownDescription: function (a, f) {
		        f.getAdapter(services.RAMLPropertyDocumentationService).setMarkdownDescription("" + a.arguments[0]);
		    },
		    valueDescription: function (a, f) {
		        f.getAdapter(services.RAMLPropertyDocumentationService).setValueDescription(a.arguments[0] != null ? ("" + a.arguments[0]) : null);
		    }
		};
		function recordAnnotation(p, a) {
		    exports.annotationHandlers[a.name](a, p);
		}
		exports.recordAnnotation = recordAnnotation;


	/***/ },
	/* 84 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(33);

	/***/ },
	/* 85 */
	/***/ function(module, exports) {

		module.exports = [
			{
				"classes": [
					{
						"name": "GlobalSchema",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.Referencable",
								"nameSpace": "Sys",
								"basicName": "Referencable",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "Sys.SchemaString",
										"nameSpace": "Sys",
										"basicName": "SchemaString",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"fields": [
							{
								"name": "key",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the global schema, used to refer on schema content"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "value",
								"type": {
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Content of the schema"
										]
									},
									{
										"name": "MetaModel.canBeValue",
										"arguments": []
									},
									{
										"name": "MetaModel.value",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"value"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"Content of the schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLSimpleElement",
								"nameSpace": "Common",
								"basicName": "RAMLSimpleElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ImportDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "key",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name prefix (without dot) used to refer imported declarations"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "value",
								"type": {
									"typeName": "Library",
									"nameSpace": "",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Content of the declared namespace"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLSimpleElement",
								"nameSpace": "Common",
								"basicName": "RAMLSimpleElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Library",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"contains description of why library exist"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "LibraryBase",
								"nameSpace": "",
								"basicName": "LibraryBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "LibraryBase",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "schemas",
								"type": {
									"base": {
										"typeName": "GlobalSchema",
										"nameSpace": "",
										"basicName": "GlobalSchema",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Alias for the equivalent \"types\" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the \"types\" property, as the \"schemas\" alias for that property name may be removed in a future RAML version. The \"types\" property allows for XML and JSON schemas."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "types",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"models.LocationKind.MODELS"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of (data) types for use within this API"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"Declarations of (data) types for use within this API. See [[raml-10-spec-types|Types]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map type names to type declarations; or an array of such objects"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "traits",
								"type": {
									"base": {
										"typeName": "RM.Trait",
										"nameSpace": "RM",
										"basicName": "Trait",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of traits used in this API"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of traits for use within this API"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"Declarations of traits for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map trait names to trait declarations; or an array of such objects"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "resourceTypes",
								"type": {
									"base": {
										"typeName": "RM.ResourceType",
										"nameSpace": "RM",
										"basicName": "ResourceType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declaration of resource types used in this API"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of resource types for use within this API"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"Declarations of resource types for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map resource type names to resource type declarations; or an array of such objects"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "annotationTypes",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"decls",
											"true"
										]
									},
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of annotation types for use by annotations"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"Declarations of annotation types for use by annotations. See [[raml-10-spec-declaring-annotation-types|Annotation Types]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map annotation type names to annotation type declarations; or an array of such objects"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securitySchemaTypes",
								"type": {
									"base": {
										"typeName": "RM.SecuritySchemaType",
										"nameSpace": "RM",
										"basicName": "SecuritySchemaType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Security schemas types declarations"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securitySchemes",
								"type": {
									"base": {
										"typeName": "RM.AbstractSecurityScheme",
										"nameSpace": "RM",
										"basicName": "AbstractSecurityScheme",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Security schemas declarations"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of security schemes for use within this API."
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"Declarations of security schemes for use within this API. See [[raml-10-spec-security|Security Schemes]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map security scheme names to security scheme declarations; or an array of such objects"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uses",
								"type": {
									"base": {
										"typeName": "Library",
										"nameSpace": "",
										"basicName": "Library",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Importing libraries"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"decls",
											"true"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An array of libraries or a single library"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.internalClass",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Overlay",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"contains description of why overlay exist"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "masterRef",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Short plain-text label for the API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Api",
								"nameSpace": "",
								"basicName": "Api",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Extension",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"contains description of why extension exist"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "masterRef",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Short plain-text label for the API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Api",
								"nameSpace": "",
								"basicName": "Api",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Api",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Short plain-text label for the API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "version",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The version of the API, e.g. \"v1\""
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "baseUri",
								"type": {
									"typeName": "Sys.FullUriTemplateString",
									"nameSpace": "Sys",
									"basicName": "FullUriTemplateString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "baseUriParameters",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"models.ModelLocation.BURI"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"models.LocationKind.APISTRUCTURE"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Named parameters used in the baseUri (template)"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "protocols",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"HTTP",
												"HTTPS"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The protocols supported by the API"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Array of strings, with each being \"HTTP\" or \"HTTPS\", case-insensitive"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "mediaType",
								"type": {
									"typeName": "Bodies.MimeType",
									"nameSpace": "Bodies",
									"basicName": "MimeType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.oftenKeys",
										"arguments": [
											[
												"application/json",
												"application/xml",
												"application/x-www-form-urlencoded",
												"multipart/formdata"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The default media type to use for request and response bodies (payloads), e.g. \"application/json\""
										]
									},
									{
										"name": "MetaModel.inherited",
										"arguments": []
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Media type string"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "RM.SecuritySchemeRef",
										"nameSpace": "RM",
										"basicName": "SecuritySchemeRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The security schemes that apply to every resource and method in the API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "resources",
								"type": {
									"base": {
										"typeName": "RM.Resource",
										"nameSpace": "RM",
										"basicName": "Resource",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.documentationTableLabel",
										"arguments": [
											"/&lt;relativeUri&gt;"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Resource"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "documentation",
								"type": {
									"base": {
										"typeName": "DocumentationItem",
										"nameSpace": "",
										"basicName": "DocumentationItem",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Additional overall documentation for the API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "LibraryBase",
								"nameSpace": "",
								"basicName": "LibraryBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"name": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the API"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Annotations to be applied to this API. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
									]
								}
							],
							"securitySchemaTypes": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							]
						}
					},
					{
						"name": "DocumentationItem",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Title of documentation section"
										]
									},
									{
										"name": "MetaModel.required",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "content",
								"type": {
									"typeName": "Sys.MarkdownString",
									"nameSpace": "Sys",
									"basicName": "MarkdownString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Content of documentation section"
										]
									},
									{
										"name": "MetaModel.required",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ScriptSpec",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "language",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "content",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ApiDescription",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "apiFiles",
								"type": {
									"base": {
										"typeName": "Api",
										"nameSpace": "",
										"basicName": "Api",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "script",
								"type": {
									"base": {
										"typeName": "ScriptSpec",
										"nameSpace": "",
										"basicName": "ScriptSpec",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"endpoint",
												"callback"
											]
										]
									},
									{
										"name": "MetaModel.descriminatingProperty",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "CallbackAPIDescription",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "callback"
								},
								"optional": false
							},
							{
								"name": "callbackFor",
								"type": {
									"typeName": "Api",
									"nameSpace": "",
									"basicName": "Api",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "ApiDescription",
								"nameSpace": "",
								"basicName": "ApiDescription",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLProject",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "relatedProjects",
								"type": {
									"base": {
										"typeName": "RAMLProject",
										"nameSpace": "",
										"basicName": "RAMLProject",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "declaredApis",
								"type": {
									"base": {
										"typeName": "ApiDescription",
										"nameSpace": "",
										"basicName": "ApiDescription",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "license",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "overview",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "url",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"RM": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts",
					"Decls": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts",
					"Params": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts",
					"Bodies": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts",
					"models": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
			},
			{
				"classes": [
					{
						"name": "SpecPartMetaData",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts"
			},
			{
				"classes": [
					{
						"name": "ValueType",
						"methods": [
							{
								"name": "parse",
								"start": 87,
								"end": 252,
								"text": "\n    /**\n     * parses inner structure of value type if value type has invalid value you should throw error\n     * with descriptive message\n     */\n    parse():any{}"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "StringType",
						"methods": [
							{
								"name": "value",
								"start": 339,
								"end": 367,
								"text": " value():string{return null}"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"string"
								]
							}
						],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "NumberType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"number"
								]
							},
							{
								"name": "MetaModel.alias",
								"arguments": [
									"integer"
								]
							},
							{
								"name": "MetaModel.alias",
								"arguments": [
									"number"
								]
							}
						],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "BooleanType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"boolean"
								]
							},
							{
								"name": "MetaModel.alias",
								"arguments": [
									"boolean"
								]
							}
						],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Referencable",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Reference",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DeclaresDynamicType",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [
							{
								"typeName": "Referencable",
								"nameSpace": "",
								"basicName": "Referencable",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "T",
										"nameSpace": "",
										"basicName": "T",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "UriTemplate",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This type currently serves both for absolute and relative urls"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "StatusCodeString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RelativeUriString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This  type describes relative uri templates"
								]
							}
						],
						"extends": [
							{
								"typeName": "UriTemplate",
								"nameSpace": "",
								"basicName": "UriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "FullUriTemplateString",
						"methods": [
							{
								"name": "validate",
								"start": 2345,
								"end": 3275,
								"text": "\n    //parse():string[]{\n    //    var value=this.value();\n    //    var result=[]\n    //    var temp=\"\";\n    //    var inPar=false;\n    //    var count=0;\n    //    for (var a=0;a<value.length;a++){\n    //        var c=value[a];\n    //        if (c=='{'){\n    //            count++;\n    //            inPar=true;\n    //            continue;\n    //        }\n    //        if (c=='}'){\n    //            count--;\n    //            inPar=false;\n    //            result.push(temp);\n    //            temp=\"\";\n    //            continue;\n    //        }\n    //        if (inPar){\n    //            temp+=c;\n    //        }\n    //    }\n    //    if (count>0){\n    //        throw new Error(\"Unmatched '{'\")\n    //    }\n    //    if (count<0){\n    //        throw new Error(\"Unmatched '}'\")\n    //    }\n    //    return result;\n    //}\n\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This  type describes absolute uri templates"
								]
							}
						],
						"extends": [
							{
								"typeName": "UriTemplate",
								"nameSpace": "",
								"basicName": "UriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "FixedUriString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This  type describes fixed uris"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ContentType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ValidityExpression",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "MarkdownString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.innerType",
								"arguments": [
									"markdown"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"[GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DateFormatSpec",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "FunctionalInterface",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SchemaString",
						"methods": [
							{
								"name": "validate",
								"start": 4052,
								"end": 4235,
								"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Schema at this moment only two subtypes are supported (json schema and xsd)"
								]
							},
							{
								"name": "MetaModel.alias",
								"arguments": [
									"schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ExampleString",
						"methods": [
							{
								"name": "validate",
								"start": 4389,
								"end": 4572,
								"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Examples at this moment only two subtypes are supported (json  and xml)"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "JSonSchemaString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.innerType",
								"arguments": [
									"json"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"JSON schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "SchemaString",
								"nameSpace": "",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "XMLSchemaString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.innerType",
								"arguments": [
									"xsd"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"XSD schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "SchemaString",
								"nameSpace": "",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLPointer",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLSelector",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
			},
			{
				"classes": [
					{
						"name": "ResourceTypeRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "ResourceType",
										"nameSpace": "",
										"basicName": "ResourceType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "TraitRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "Trait",
										"nameSpace": "",
										"basicName": "Trait",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemePart",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "MethodBase",
								"nameSpace": "",
								"basicName": "MethodBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"headers": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Optional array of headers, documenting the possible headers that could be accepted. See [[raml-10-spec-headers|Headers]] section."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the request header names and whose values describe the values."
									]
								}
							],
							"queryParameters": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Query parameters, used by the schema in order to authorize the request. Mutually exclusive with queryString. See [[raml-10-spec-query-parameters-in-a-query-string|Query Parameters]] section."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the query parameter names and whose values describe the values."
									]
								}
							],
							"queryString": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Specifies the query string, used by the schema in order to authorize the request. Mutually exclusive with queryParameters."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Type name or type declaration"
									]
								}
							],
							"responses": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Optional array of responses, describing the possible responses that could be sent. See [[raml-10-spec-responses|Responses]] section."
									]
								}
							],
							"is": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"securedBy": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"displayName": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the security scheme part"
									]
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the security scheme part"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Annotations to be applied to this security scheme part. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See [[raml-10-spec-annotations|the section on annotations]]."
									]
								}
							]
						}
					},
					{
						"name": "SecuritySchemaType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "requiredSettings",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"You may declare settings needed to use this type of security security schemas"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"models.LocationKind.DECLARATIONS"
										]
									},
									{
										"name": "MetaModel.declaringFields",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "describedBy",
								"type": {
									"typeName": "SecuritySchemePart",
									"nameSpace": "",
									"basicName": "SecuritySchemePart",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.\n        This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"SecuritySchemeSettings"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"Security schema type allows you to contribute your own security schema type with settings and optinal configurator for plugging into client sdks auth mechanism"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemeSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "OAuth1SecuritySchemeSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "requestTokenUri",
								"type": {
									"typeName": "Sys.FixedUriString",
									"nameSpace": "Sys",
									"basicName": "FixedUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"FixedUriString"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "authorizationUri",
								"type": {
									"typeName": "Sys.FixedUriString",
									"nameSpace": "Sys",
									"basicName": "FixedUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"FixedUriString"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "tokenCredentialsUri",
								"type": {
									"typeName": "Sys.FixedUriString",
									"nameSpace": "Sys",
									"basicName": "FixedUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"FixedUriString"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "signatures",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"HMAC-SHA1",
												"RSA-SHA1",
												"PLAINTEXT"
											]
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"$parent.type=='OAuth 1.0'"
								]
							}
						],
						"extends": [
							{
								"typeName": "SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"description": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"authentificationConfigurator": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							]
						}
					},
					{
						"name": "OAuth2SecuritySchemeSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "accessTokenUri",
								"type": {
									"typeName": "Sys.FixedUriString",
									"nameSpace": "Sys",
									"basicName": "FixedUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2. Not required forby implicit grant type."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"FixedUriString"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "authorizationUri",
								"type": {
									"typeName": "Sys.FixedUriString",
									"nameSpace": "Sys",
									"basicName": "FixedUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1. Required forby authorization_code and implicit grant types."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"FixedUriString"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "authorizationGrants",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"A list of the Authorization grants supported by the API as defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of:<br>* authorization_code<br>* password<br>* client_credentials<br>* implicit<br>* refresh_token."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "scopes",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A list of scopes supported by the security scheme as defined in RFC6749 [RFC6749] Section 3.3"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"description": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"authentificationConfigurator": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							]
						}
					},
					{
						"name": "PassThroughSecuritySchemeSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "queryParameterName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "headerName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemeRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "AbstractSecurityScheme",
										"nameSpace": "",
										"basicName": "AbstractSecurityScheme",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "AbstractSecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.Referencable",
								"nameSpace": "Sys",
								"basicName": "Referencable",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "AbstractSecurityScheme",
										"nameSpace": "",
										"basicName": "AbstractSecurityScheme",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.startFrom",
										"arguments": [
											""
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"OAuth 1.0",
												"OAuth 2.0",
												"Basic Authentication",
												"DigestSecurityScheme Authentication",
												"Pass Through",
												"x-{other}"
											]
										]
									},
									{
										"name": "MetaModel.descriminatingProperty",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"string<br><br>The value MUST be one of<br>* OAuth 1.0,<br>* OAuth 2.0,<br>* BasicSecurityScheme Authentication<br>* DigestSecurityScheme Authentication<br>* Pass Through<br>* x-&lt;other&gt;"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "description",
								"type": {
									"typeName": "Sys.MarkdownString",
									"nameSpace": "Sys",
									"basicName": "MarkdownString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The description attribute MAY be used to describe a security schemes property."
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The description MAY be used to describe a securityScheme."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "describedBy",
								"type": {
									"typeName": "SecuritySchemePart",
									"nameSpace": "",
									"basicName": "SecuritySchemePart",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes.\nIncluding the security scheme description completes an API documentation."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "settings",
								"type": {
									"typeName": "SecuritySchemeSettings",
									"nameSpace": "",
									"basicName": "SecuritySchemeSettings",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared.\nIt describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "OAuth2SecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "OAuth 2.0"
								},
								"optional": false
							},
							{
								"name": "settings",
								"type": {
									"typeName": "OAuth2SecuritySchemeSettings",
									"nameSpace": "",
									"basicName": "OAuth2SecuritySchemeSettings",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "OAuth1SecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "OAuth 1.0"
								},
								"optional": false
							},
							{
								"name": "settings",
								"type": {
									"typeName": "OAuth1SecuritySchemeSettings",
									"nameSpace": "",
									"basicName": "OAuth1SecuritySchemeSettings",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "PassThroughSecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "Pass Through"
								},
								"optional": false
							},
							{
								"name": "settings",
								"type": {
									"typeName": "PassThroughSecuritySchemeSettings",
									"nameSpace": "",
									"basicName": "PassThroughSecuritySchemeSettings",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "BasicSecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "Basic Authentication"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DigestSecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "DigestSecurityScheme Authentication"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "CustomSecurityScheme",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "x-{other}"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "AbstractSecurityScheme",
								"nameSpace": "",
								"basicName": "AbstractSecurityScheme",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "MethodBase",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "responses",
								"type": {
									"base": {
										"typeName": "Bodies.Response",
										"nameSpace": "Bodies",
										"basicName": "Response",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"response",
											"true"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Response"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Information about the expected responses to a request"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose keys are the HTTP status codes of the responses and whose values describe the responses."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "body",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Body"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.\nResources CAN have alternate representations. For example, an API might support both JSON and XML representations.\nA method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "protocols",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"HTTP",
												"HTTPS"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A method can override the protocols specified in the resource or at the API root, by employing this property."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"array of strings of value HTTP or HTTPS, or a single string of such kind, case-insensitive"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "is",
								"type": {
									"base": {
										"typeName": "TraitRef",
										"nameSpace": "",
										"basicName": "TraitRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instantiation of applyed traits"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "SecuritySchemeRef",
										"nameSpace": "",
										"basicName": "SecuritySchemeRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.allowNull",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Params.HasNormalParameters",
								"nameSpace": "Params",
								"basicName": "HasNormalParameters",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Trait",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.DeclaresDynamicType",
								"nameSpace": "Sys",
								"basicName": "DeclaresDynamicType",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "Trait",
										"nameSpace": "",
										"basicName": "Trait",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the trait"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uses",
								"type": {
									"base": {
										"typeName": "api.Library",
										"nameSpace": "api",
										"basicName": "Library",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"You may import library locally here it contents is accessible only inside of this trait"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"decls",
											"true"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An array of libraries or a single library"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.inlinedTemplates",
								"arguments": []
							},
							{
								"name": "MetaModel.allowQuestion",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "MethodBase",
								"nameSpace": "",
								"basicName": "MethodBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ResourceBase",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "methods",
								"type": {
									"base": {
										"typeName": "Method",
										"nameSpace": "",
										"basicName": "Method",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Methods that are part of this resource type definition"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"The methods available on this resource. See [[raml-10-spec-methods|the section on method properties]]."
										]
									},
									{
										"name": "MetaModel.documentationTableLabel",
										"arguments": [
											"get?<br>patch?<br>put?<br>post?<br>delete?<br>options?<br>head?"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Object describing the method"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "is",
								"type": {
									"base": {
										"typeName": "TraitRef",
										"nameSpace": "",
										"basicName": "TraitRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section. Individual methods may override this declaration"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"array, which can contain each of the following elements:<br>* name of unparametrized trait<br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration<br><br>(or a single element of any above kind)"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "ResourceTypeRef",
									"nameSpace": "",
									"basicName": "ResourceTypeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The resource type which this resource inherits. . See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"one of the following elements:<br>* name of unparametrized resource type<br>* a key-value pair with resource type name as key and a map of its parameters as value<br>* inline resource type declaration"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "SecuritySchemeRef",
										"nameSpace": "",
										"basicName": "SecuritySchemeRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.allowNull",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The security schemes that apply to all methods declared (implicitly or explicitly) for this resource."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"array of security scheme names or a single security scheme name"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uriParameters",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"models.ModelLocation.URI"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"models.LocationKind.APISTRUCTURE"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Detailed information about any URI parameters of this resource"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"object whose property names are the URI parameter names and whose values describe the values"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ResourceType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.DeclaresDynamicType",
								"nameSpace": "Sys",
								"basicName": "DeclaresDynamicType",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "ResourceType",
										"nameSpace": "",
										"basicName": "ResourceType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the resource type"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uses",
								"type": {
									"base": {
										"typeName": "api.Library",
										"nameSpace": "api",
										"basicName": "Library",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"You may import library locally here it contents is accessible only inside of this resource type"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"decls",
											"true"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An array of libraries"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.inlinedTemplates",
								"arguments": []
							},
							{
								"name": "MetaModel.allowQuestion",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "ResourceBase",
								"nameSpace": "",
								"basicName": "ResourceBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ResourceTypeOrTrait",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instructions on how and when to use this resource type in a RAML spec"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Markdown string"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uses",
								"type": {
									"base": {
										"typeName": "api.Library",
										"nameSpace": "api",
										"basicName": "Library",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"You may import library locally here it contents is accessible only inside of this trait"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An array of libraries"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "parameters",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Optional declaration of the parameters that the resource type employs."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose property names are the parameter names and whose property values describe the parameter data types."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Method",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "signature",
								"type": {
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.canBeValue",
										"arguments": []
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "method",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"methods"
										]
									},
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"get",
												"put",
												"post",
												"delete",
												"options",
												"head",
												"patch"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Method that can be called"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "MethodBase",
								"nameSpace": "",
								"basicName": "MethodBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the method (in the resource's context)."
									]
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the method (in the resource's context)"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"queryString": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Specifies the query string needed by this method. Mutually exclusive with queryParameters."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Type name or type declaration"
									]
								}
							],
							"queryParameters": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any query parameters needed by this method. Mutually exclusive with queryString."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the query parameter names and whose values describe the values."
									]
								}
							],
							"headers": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any request headers needed by this method."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the request header names and whose values describe the values."
									]
								}
							],
							"body": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some methods admit request bodies, which are described by this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose properties are either<br>1) media types and whose values are type objects describing the request body for that media type, or<br>2) a type object describing the request body for the default media type specified in the root mediaType property"
									]
								}
							],
							"is": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the traits to apply to this method. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array, which can contain each of the following elements:<br>* name of unparametrized trait<br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration<br><br>(or a single element of any above kind)"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Annotations to be applied to this method. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
									]
								}
							],
							"securedBy": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to this method"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array of security scheme names or a  single security scheme name"
									]
								}
							]
						}
					},
					{
						"name": "Resource",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "signature",
								"type": {
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.canBeValue",
										"arguments": []
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "relativeUri",
								"type": {
									"typeName": "Sys.RelativeUriString",
									"nameSpace": "Sys",
									"basicName": "RelativeUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.startFrom",
										"arguments": [
											"/"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Relative URL of this resource from the parent resource"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "resources",
								"type": {
									"base": {
										"typeName": "Resource",
										"nameSpace": "",
										"basicName": "Resource",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Resource"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A nested resource is identified as any property whose name begins with a slash (\"/\") and is therefore treated as a relative URI."
										]
									},
									{
										"name": "MetaModel.documentationTableLabel",
										"arguments": [
											"/&lt;relativeUri&gt;"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"object describing the nested resource"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "ResourceBase",
								"nameSpace": "",
								"basicName": "ResourceBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the resource."
									]
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the resource."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Annotations to be applied to this resource. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
									]
								}
							]
						}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"Params": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts",
					"Bodies": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts",
					"Declarations": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts",
					"models": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts",
					"auth": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/auth.ts",
					"api": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/api.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/methodsAndResources.ts"
			},
			{
				"classes": [
					{
						"name": "FileTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "file"
								},
								"optional": false
							},
							{
								"name": "fileTypes",
								"type": {
									"base": {
										"typeName": "Sys.ContentType",
										"nameSpace": "Sys",
										"basicName": "ContentType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type */* should be a valid value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "minLength",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The minLength attribute specifies the parameter value's minimum number of bytes."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maxLength",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The maxLength attribute specifies the parameter value's maximum number of bytes."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
								]
							}
						],
						"extends": [
							{
								"typeName": "datamodel.TypeDeclaration",
								"nameSpace": "datamodel",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "HasNormalParameters",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "queryParameters",
								"type": {
									"base": {
										"typeName": "datamodel.TypeDeclaration",
										"nameSpace": "datamodel",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"datamodel.ModelLocation.QUERY"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"datamodel.LocationKind.APISTRUCTURE"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New query parameter"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "headers",
								"type": {
									"base": {
										"typeName": "datamodel.TypeDeclaration",
										"nameSpace": "datamodel",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"datamodel.ModelLocation.HEADERS"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"datamodel.LocationKind.APISTRUCTURE"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Headers that allowed at this position"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Header"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "queryString",
								"type": {
									"typeName": "datamodel.TypeDeclaration",
									"nameSpace": "datamodel",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts",
					"datamodel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/parameters.ts"
			},
			{
				"classes": [
					{
						"name": "RAMLLanguageElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "displayName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "description",
								"type": {
									"typeName": "Sys.MarkdownString",
									"nameSpace": "Sys",
									"basicName": "MarkdownString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "annotations",
								"type": {
									"base": {
										"typeName": "Decls.AnnotationRef",
										"nameSpace": "Decls",
										"basicName": "AnnotationRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.noDirectParse",
										"arguments": []
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"datamodel.LocationKind.APISTRUCTURE"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"datamodel.ModelLocation.ANNOTATION"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Most of RAML model elements may have attached annotations decribing additional meta data about this element"
										]
									},
									{
										"name": "MetaModel.documentationTableLabel",
										"arguments": [
											"(&lt;annotationName&gt;)"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"A value corresponding to the declared type of this annotation."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLSimpleElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"Decls": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts"
			},
			{
				"classes": [
					{
						"name": "AnnotationTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.DeclaresDynamicType",
								"nameSpace": "Sys",
								"basicName": "DeclaresDynamicType",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "AnnotationTypeDeclaration",
										"nameSpace": "",
										"basicName": "AnnotationTypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
							}
						],
						"fields": [
							{
								"name": "allowMultiple",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Whether multiple instances of annotations of this type may be applied simultaneously at the same location"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "allowedTargets",
								"type": {
									"base": {
										"typeName": "AnnotationTarget",
										"nameSpace": "",
										"basicName": "AnnotationTarget",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"API",
												"DocumentationItem",
												"Resource",
												"Method",
												"Response",
												"RequestBody",
												"ResponseBody",
												"TypeDeclaration",
												"NamedExample",
												"ResourceType",
												"Trait",
												"SecurityScheme",
												"SecuritySchemeSettings",
												"AnnotationTypeDeclaration",
												"Library",
												"Overlay",
												"Extension"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An array of names (or a single name) from the list of Target Names in the [[raml-10-spec-target-locations-table|Target Locations table]]  below. "
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"Annotation"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"AnnotationTypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "common.RAMLLanguageElement",
								"nameSpace": "common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"usage": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when to use this annotation in a RAML spec."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							]
						}
					},
					{
						"name": "AnnotationRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Annotations allow you to attach information to your API"
								]
							},
							{
								"name": "MetaModel.tags",
								"arguments": [
									[
										"annotations"
									]
								]
							}
						],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "AnnotationTypeDeclaration",
										"nameSpace": "",
										"basicName": "AnnotationTypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "AnnotationTarget",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Elements to which this Annotation can be applied (enum)"
								]
							},
							{
								"name": "MetaModel.tags",
								"arguments": [
									[
										"annotations"
									]
								]
							}
						],
						"extends": [
							{
								"typeName": "Sys.ValueType",
								"nameSpace": "Sys",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Annotation",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"datamodel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts",
					"common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
			},
			{
				"classes": [
					{
						"name": "ExampleSpec",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "content",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.selfNode",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The example itself"
										]
									},
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"* Valid value for this type<br>* String representing the serialized version of a valid value"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "strict",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the example"
									]
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the example"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"markdown string"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Annotations to be applied to this example. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
									]
								}
							]
						}
					},
					{
						"name": "DataElementProperty",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"name of the parameter"
										]
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"headers"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "location",
								"type": {
									"typeName": "ModelLocation",
									"nameSpace": "",
									"basicName": "ModelLocation",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.system",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Location of the parameter (can not be edited by user)"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "locationKind",
								"type": {
									"typeName": "LocationKind",
									"nameSpace": "",
									"basicName": "LocationKind",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.system",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Kind of location"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "default",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Provides default value for a property"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"any"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "required",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.requireValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Sets if property is optional or not"
										]
									},
									{
										"name": "MetaModel.describesAnnotation",
										"arguments": [
											"required"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"boolean = true"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "TypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"name of the parameter"
										]
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"headers"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "facets",
								"type": {
									"base": {
										"typeName": "TypeDeclaration",
										"nameSpace": "",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.declaringFields",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"When extending from a type you can define new facets (which can then be set to concrete values by subtypes)."
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "schema",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Alias for the equivalent \"type\" property, for compatibility with RAML 0.8. Deprecated - API definitions should use the \"type\" property, as the \"schema\" alias for that property name may be removed in a future RAML version. The \"type\" property allows for XML and JSON schemas."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Single string denoting the base type or type expression"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.allowMultiple",
										"arguments": []
									},
									{
										"name": "MetaModel.canBeValue",
										"arguments": []
									},
									{
										"name": "MetaModel.defaultValue",
										"arguments": [
											"string"
										]
									},
									{
										"name": "MetaModel.descriminatingProperty",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A base type which the current type extends, or more generally a type expression."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"string denoting the base type or type expression"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "location",
								"type": {
									"typeName": "ModelLocation",
									"nameSpace": "",
									"basicName": "ModelLocation",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.system",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Location of the parameter (can not be edited by user)"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "locationKind",
								"type": {
									"typeName": "LocationKind",
									"nameSpace": "",
									"basicName": "LocationKind",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.system",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Kind of location"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "default",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Provides default value for a property"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "example",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.selfNode",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"An example of an instance of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"* Valid value for this type<br>* String representing the serialized version of a valid value"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "examples",
								"type": {
									"base": {
										"typeName": "ExampleSpec",
										"nameSpace": "",
										"basicName": "ExampleSpec",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"An object containing named examples of instances of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map example names to Example objects (see [[raml-10-spec-examples|Examples]] section); or an array of Example objects."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "repeat",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.requireValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "required",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.requireValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Sets if property is optional or not"
										]
									},
									{
										"name": "MetaModel.describesAnnotation",
										"arguments": [
											"required"
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.convertsToGlobalOfType",
								"arguments": [
									"SchemaString"
								]
							},
							{
								"name": "MetaModel.canInherit",
								"arguments": [
									"mediaType"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the type"
									]
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the type"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"markdown string"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Annotations to be applied to this type. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
									]
								}
							]
						}
					},
					{
						"name": "ScalarElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "facets",
								"type": {
									"base": {
										"typeName": "TypeDeclaration",
										"nameSpace": "",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.declaringFields",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"When extending from a scalar type you can define new facets (which can then be set to concrete values by subtypes)."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map facets names to their types."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "enum",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.describesAnnotation",
										"arguments": [
											"oneOf"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Enumeration of possible values for this primitive type. Cannot be used with the file type."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Array containing string representations of possible values, or a single string if there is only one possible value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ArrayTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "array"
								},
								"optional": false
							},
							{
								"name": "uniqueItems",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"uniqueItems"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Should items in array be unique"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "items",
								"type": {
									"typeName": "TypeDeclaration",
									"nameSpace": "",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Array component type."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Inline type declaration or type name."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "minItems",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"minItems"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Minimum amount of items in array"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"integer ( >= 0 ). Defaults to 0"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maxItems",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"maxItems"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Maximum amount of items in array"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"integer ( >= 0 ). Defaults to undefined."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.convertsToGlobalOfType",
								"arguments": [
									"SchemaString"
								]
							},
							{
								"name": "MetaModel.alias",
								"arguments": [
									"array"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "UnionTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "discriminator",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.selector",
										"arguments": [
											"*.DataElement"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Type property name to be used as a discriminator or boolean"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "union"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.convertsToGlobalOfType",
								"arguments": [
									"SchemaString"
								]
							},
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"locationKind",
									"LocationKind.MODELS"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DataElementRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "TypeDeclaration",
										"nameSpace": "",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ObjectTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "properties",
								"type": {
									"base": {
										"typeName": "TypeDeclaration",
										"nameSpace": "",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The properties that instances of this type may or must have."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose keys are the properties' names and whose values are property declarations."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "minProperties",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"minProperties"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The minimum number of properties allowed for instances of this type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maxProperties",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"maxProperties"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The maximum number of properties allowed for instances of this type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "additionalProperties",
								"type": {
									"typeName": "TypeDeclaration",
									"nameSpace": "",
									"basicName": "TypeDeclaration",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"JSON schema style syntax for declaring maps"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"JSON schema style syntax for declaring maps. See [[raml-10-spec-map-types|Map Types]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Inline type declaration or typename"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "patternProperties",
								"type": {
									"base": {
										"typeName": "TypeDeclaration",
										"nameSpace": "",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"JSON schema style syntax for declaring key restricted maps"
										]
									},
									{
										"name": "MetaModel.markdownDescription",
										"arguments": [
											"JSON schema style syntax for declaring key restricted maps. See [[raml-10-spec-map-types|Map Types]]."
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"An object whose properties map regular expressions (which are regarded as defining ranges for property names) to types of properties expressed as Inline type declaration or typename."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "discriminator",
								"type": {
									"typeName": "pointer",
									"nameSpace": "",
									"basicName": "pointer",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.selector",
										"arguments": [
											"*.DataElement"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Type property name to be used as discriminator, or boolean"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "discriminatorValue",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The value of discriminator for the type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": null,
								"annotations": [
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "object"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.definingPropertyIsEnough",
								"arguments": [
									"properties"
								]
							},
							{
								"name": "MetaModel.setsContextValue",
								"arguments": [
									"field",
									"true"
								]
							},
							{
								"name": "MetaModel.convertsToGlobalOfType",
								"arguments": [
									"SchemaString"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "StringTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "pattern",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"pattern"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Regular expression that this string should path"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"regexp"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "minLength",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"minLength"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Minimum length of the string"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maxLength",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"maxLength"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Maximum length of the string"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "string"
								},
								"optional": false
							},
							{
								"name": "enum",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.describesAnnotation",
										"arguments": [
											"oneOf"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value must be a string"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "BooleanTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "boolean"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value must be a boolean"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ValueTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "value"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value must be a boolean"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "NumberTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "number"
								},
								"optional": false
							},
							{
								"name": "minimum",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"minimum"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maximum",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.facetId",
										"arguments": [
											"maximum"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "enum",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.describesAnnotation",
										"arguments": [
											"oneOf"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "format",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"int32",
												"int64",
												"int",
												"long",
												"float",
												"double",
												"int16",
												"int8"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Value format"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "multipleOf",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A numeric instance is valid against \"multipleOf\" if the result of the division of the instance by this keyword's value is an integer."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value MUST be a number. Indicate floating point numbers as defined by YAML."
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "IntegerTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "integer"
								},
								"optional": false
							},
							{
								"name": "format",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"int32",
												"int64",
												"int",
												"long",
												"int16",
												"int8"
											]
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value MUST be a integer."
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "NumberTypeDeclaration",
								"nameSpace": "",
								"basicName": "NumberTypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLPointerElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "pointer"
								},
								"optional": false
							},
							{
								"name": "target",
								"type": {
									"typeName": "Sys.RAMLSelector",
									"nameSpace": "Sys",
									"basicName": "RAMLSelector",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"locationKind",
									"LocationKind.APISTRUCTURE"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "pointer",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.ValueType",
								"nameSpace": "Sys",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLExpression",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "ramlexpression"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"locationKind",
									"LocationKind.APISTRUCTURE"
								]
							},
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"location",
									"ModelLocation.ANNOTATION"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ScriptHookElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "script"
								},
								"optional": false
							},
							{
								"name": "declaredIn",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Typescript file defining interface which this scrip should comply to"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "interfaceName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the interface which scripts should comply to"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"locationKind",
									"LocationKind.APISTRUCTURE"
								]
							},
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"location",
									"ModelLocation.ANNOTATION"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SchemaElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "schema"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"locationKind",
									"LocationKind.APISTRUCTURE"
								]
							},
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"SchemaString"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DateTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "date"
								},
								"optional": false
							},
							{
								"name": "dateFormat",
								"type": {
									"typeName": "Sys.DateFormatSpec",
									"nameSpace": "Sys",
									"basicName": "DateFormatSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. or according to specified date format"
								]
							},
							{
								"name": "MetaModel.declaresSubTypeOf",
								"arguments": [
									"TypeDeclaration"
								]
							}
						],
						"extends": [
							{
								"typeName": "TypeDeclaration",
								"nameSpace": "",
								"basicName": "TypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [
					{
						"name": "ModelLocation",
						"members": [
							"QUERY",
							"HEADERS",
							"URI",
							"FORM",
							"BURI",
							"ANNOTATION",
							"MODEL",
							"SECURITYSCHEMATYPE"
						]
					},
					{
						"name": "LocationKind",
						"members": [
							"APISTRUCTURE",
							"DECLARATIONS",
							"MODELS"
						]
					}
				],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"Bodies": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts",
					"Declarations": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/declarations.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts"
			},
			{
				"classes": [
					{
						"name": "MimeTypeModel",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "tree",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": true
							},
							{
								"name": "subtype",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "suffix",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": true
							},
							{
								"name": "parameters",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": true
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "MimeType",
						"methods": [
							{
								"name": "isForm",
								"start": 401,
								"end": 626,
								"text": "\n    isForm(){\n        if (this.value()==\"application/x-www-form-urlencoded\"||this.value()=='multipart/form-data'){\n            return true;\n        }\n        //TODO USE PARSE\n        return false;//more smart code here\n    }"
							},
							{
								"name": "isXML",
								"start": 626,
								"end": 797,
								"text": "\n\n    isXML(){\n        //TODO USE PARSE\n\n        if (this.value()==\"application/xml\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
							},
							{
								"name": "isJSON",
								"start": 797,
								"end": 970,
								"text": "\n\n    isJSON(){\n        //TODO USE PARSE\n\n        if (this.value()==\"application/json\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This sub type of the string represents mime types"
								]
							}
						],
						"extends": [
							{
								"typeName": "Sys.StringType",
								"nameSpace": "Sys",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Response",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "code",
								"type": {
									"typeName": "Sys.StatusCodeString",
									"nameSpace": "Sys",
									"basicName": "StatusCodeString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"statusCodes"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
										]
									},
									{
										"name": "MetaModel.hide",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "headers",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"models.ModelLocation.HEADERS"
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"locationKind",
											"models.LocationKind.APISTRUCTURE"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Header"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Detailed information about any response headers returned by this method"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Object whose property names are the response header names and whose values describe the values."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "body",
								"type": {
									"base": {
										"typeName": "models.TypeDeclaration",
										"nameSpace": "models",
										"basicName": "TypeDeclaration",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Body"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The body of the response: a body declaration"
										]
									},
									{
										"name": "MetaModel.valueDescription",
										"arguments": [
											"Object whose properties are either<br>* Media types and whose values are type objects describing the request body for that media type, or<br>* a type object describing the request body for the default media type specified in the root mediaType property."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {
							"displayName": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An alternate, human-friendly name for the response"
									]
								}
							],
							"description": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A longer, human-friendly description of the response"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"annotations": [
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Annotations to be applied to this response. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
									]
								}
							]
						}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts",
					"models": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/datamodel.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/common.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/bodies.ts"
			},
			{
				"classes": [
					{
						"name": "Status",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "code",
								"type": {
									"typeName": "StatusCode",
									"nameSpace": "",
									"basicName": "StatusCode",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/auth.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "message",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "AuthentificationState",
						"methods": [
							{
								"name": "testAccessControl",
								"start": 435,
								"end": 564,
								"text": "\n\n    /**\n     * allows to test if method can be accessed\n     * @param req\n     */\n    testAccessControl(req:har.Request):Status"
							},
							{
								"name": "testAccessControl",
								"start": 564,
								"end": 622,
								"text": "\n\n\n    testAccessControl(method:RamlWrapper.Method):Status"
							},
							{
								"name": "status",
								"start": 622,
								"end": 644,
								"text": "\n\n    status():Status;"
							},
							{
								"name": "schemeId",
								"start": 644,
								"end": 667,
								"text": "\n\n    schemeId():string"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "AuthentificationParameters",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "AuthData",
						"methods": [
							{
								"name": "api",
								"start": 754,
								"end": 780,
								"text": "\n    api():RamlWrapper.Api"
							},
							{
								"name": "apiUrl",
								"start": 780,
								"end": 801,
								"text": "\n    apiUrl():string;"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "authentificationParameters",
								"type": {
									"typeName": "AuthentificationParameters",
									"nameSpace": "",
									"basicName": "AuthentificationParameters",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/auth.ts"
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ParameterSpec",
						"methods": [
							{
								"name": "name",
								"start": 887,
								"end": 905,
								"text": "\n    name():string"
							},
							{
								"name": "required",
								"start": 905,
								"end": 929,
								"text": "\n    required():boolean;"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "PromptSpec",
						"methods": [
							{
								"name": "name",
								"start": 1031,
								"end": 1049,
								"text": "\n    name():string"
							},
							{
								"name": "description",
								"start": 1049,
								"end": 1074,
								"text": "\n    description():string"
							},
							{
								"name": "toPrompt",
								"start": 1074,
								"end": 1106,
								"text": "\n    toPrompt():ParameterSpec[];"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "UserResponse",
						"methods": [
							{
								"name": "isCancelled",
								"start": 1157,
								"end": 1183,
								"text": "\n    isCancelled():boolean"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "QueryListener",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "EndPoint",
						"methods": [
							{
								"name": "endpointUrl",
								"start": 1265,
								"end": 1290,
								"text": "\n    endpointUrl():string"
							},
							{
								"name": "addListener",
								"start": 1290,
								"end": 1331,
								"text": "\n    addListener(listener:QueryListener);"
							},
							{
								"name": "removeListener",
								"start": 1331,
								"end": 1374,
								"text": "\n    removeListener(listenr:QueryListener);"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "EndPointSpec",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "url",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "needToSendResponse",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecurityEnvironment",
						"methods": [
							{
								"name": "executeHTTPRequest",
								"start": 1481,
								"end": 1635,
								"text": "\n\n    /**\n     * execute authentification step to external service\n     * @param reg\n     */\n    executeHTTPRequest(reg:har.Request):Promise<har.Response>"
							},
							{
								"name": "askForExtraData",
								"start": 1635,
								"end": 1822,
								"text": "\n\n\n    /**\n     * asks for extra parameters( stored in cfg file or asked in dialog)\n     * @param parameterSpec\n     */\n    askForExtraData(parameterSpec:PromptSpec):Promise<UserResponse>"
							},
							{
								"name": "getOrCreateEndPoint",
								"start": 1822,
								"end": 1894,
								"text": "\n\n\n    // create\n    getOrCreateEndPoint(EndPointSpec):Promise<EndPoint>"
							},
							{
								"name": "hasEndpoints",
								"start": 1894,
								"end": 1923,
								"text": "\n\n    hasEndpoints():boolean;"
							},
							{
								"name": "isInteractive",
								"start": 1923,
								"end": 1952,
								"text": "\n    isInteractive():boolean;"
							},
							{
								"name": "isGraphical",
								"start": 1952,
								"end": 1978,
								"text": "\n    isGraphical():boolean"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "AuthentificationManager",
						"methods": [
							{
								"name": "supports",
								"start": 2016,
								"end": 2067,
								"text": "\n\n    supports(client:SecurityEnvironment):boolean;"
							},
							{
								"name": "doAuth",
								"start": 2067,
								"end": 2318,
								"text": "\n\n    /**\n     * performs authentification\n     * everything may happen here even sending horse rider to a new city\n     * or flight to moon\n     * @param env\n     */\n    doAuth(env:SecurityEnvironment,authData:AuthData):Promise<AuthentificationState>"
							},
							{
								"name": "doLogout",
								"start": 2318,
								"end": 2540,
								"text": "\n\n    /**\n     * performs log out\n     * if it is needed to blow a nuke to logout it is possible\n     * @param env\n     */\n    doLogout(env:SecurityEnvironment,authData:AuthentificationState):Promise<AuthentificationState>"
							},
							{
								"name": "addAuthDataToRequest",
								"start": 2540,
								"end": 2780,
								"text": "\n\n\n    /**\n     * performs arbitrary request transform (as a sample might change actual url)\n     * or do complex encoding\n     * @param req\n     */\n    addAuthDataToRequest(req:har.Request,state:AuthentificationState):Promise<har.Response>"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SchemeInfo",
						"methods": [
							{
								"name": "name",
								"start": 2838,
								"end": 2856,
								"text": "\n    name():string"
							},
							{
								"name": "description",
								"start": 2856,
								"end": 2881,
								"text": "\n    description():string"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "parameterSpec",
								"type": {
									"base": {
										"typeName": "ParameterSpec",
										"nameSpace": "",
										"basicName": "ParameterSpec",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/auth.ts"
									},
									"typeKind": 1
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecurityScheme",
						"methods": [
							{
								"name": "info",
								"start": 2909,
								"end": 2932,
								"text": "\n\n    info():SchemeInfo"
							},
							{
								"name": "id",
								"start": 2932,
								"end": 2948,
								"text": "\n    id():string"
							},
							{
								"name": "needsEndpoints",
								"start": 2948,
								"end": 2978,
								"text": "\n    needsEndpoints():boolean;"
							},
							{
								"name": "isInteractive",
								"start": 2978,
								"end": 3007,
								"text": "\n    isInteractive():boolean;"
							},
							{
								"name": "isGraphical",
								"start": 3007,
								"end": 3126,
								"text": "\n    /***\n     * means that you potentially need to have graphical display to pass it\n     */\n    isGraphical():boolean"
							},
							{
								"name": "createAuthManager",
								"start": 3126,
								"end": 3176,
								"text": "\n\n    createAuthManager():AuthentificationManager;"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecurityAwareApiClient",
						"methods": [
							{
								"name": "api",
								"start": 3213,
								"end": 3239,
								"text": "\n    api():RamlWrapper.Api"
							},
							{
								"name": "securitySchemes",
								"start": 3239,
								"end": 3279,
								"text": "\n\n    securitySchemes():SecurityScheme[]"
							},
							{
								"name": "getOrCreateAuthManager",
								"start": 3279,
								"end": 3349,
								"text": "\n\n    getOrCreateAuthManager(s:SecurityScheme):AuthentificationManager"
							},
							{
								"name": "doAuth",
								"start": 3349,
								"end": 3415,
								"text": "\n\n    doAuth(scheme:SecurityScheme):Promise<AuthentificationState>"
							},
							{
								"name": "doAuthSync",
								"start": 3415,
								"end": 3475,
								"text": "\n    doAuthSync(scheme:SecurityScheme):AuthentificationState"
							},
							{
								"name": "setCurrentAuthData",
								"start": 3475,
								"end": 3531,
								"text": "\n\n\n\n    setCurrentAuthData(state:AuthentificationState);"
							},
							{
								"name": "getCurrentAuthData",
								"start": 3531,
								"end": 3605,
								"text": "//needed for multiple users\n    getCurrentAuthData():AuthentificationState"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemeHook",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [
					{
						"name": "StatusCode",
						"members": [
							"OK",
							"WARNING",
							"ERROR",
							"UNKNOWN",
							"CANCELLED"
						]
					}
				],
				"imports": {
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/systemTypes.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-1.0/auth.ts"
			}
		];

	/***/ },
	/* 86 */
	/***/ function(module, exports) {

		module.exports = [
			{
				"classes": [
					{
						"name": "GlobalSchema",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.Referencable",
								"nameSpace": "Sys",
								"basicName": "Referencable",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "Sys.SchemaString",
										"nameSpace": "Sys",
										"basicName": "SchemaString",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
							}
						],
						"fields": [
							{
								"name": "key",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the global schema, used to refer on schema content"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "value",
								"type": {
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Content of the schema"
										]
									},
									{
										"name": "MetaModel.value",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"value"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"Content of the schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLSimpleElement",
								"nameSpace": "Common",
								"basicName": "RAMLSimpleElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
							}
						],
						"moduleName": "RAMLSpec",
						"annotationOverridings": {}
					},
					{
						"name": "Api",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The title property is a short plain text description of the RESTful API. The title property's value SHOULD be suitable for use as a title for the contained user documentation."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "version",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if:\nThe API itself is not versioned.\nThe API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change.\nThe API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, \"v3\", \"v3.0\", and \"V3\" are all allowed, but are not considered to be equal."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "baseUri",
								"type": {
									"typeName": "Sys.FullUriTemplateString",
									"nameSpace": "Sys",
									"basicName": "FullUriTemplateString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification [RFC2396] or a Level 1 Template URI as defined in RFC 6570 [RFC6570].\n            The baseUri property SHOULD only be used as a reference value. API client generators MAY make the baseUri configurable by the API client's users.\n            If the baseUri value is a Level 1 Template URI, the following reserved base URI parameters are available for replacement:"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "baseUriParameters",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.BURI"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Base uri parameters are named parameters which described template parameters in the base uri"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uriParameters",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.BURI"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "protocols",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"HTTP",
												"HTTPS"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "mediaType",
								"type": {
									"typeName": "Bodies.MimeType",
									"nameSpace": "Bodies",
									"basicName": "MimeType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.oftenKeys",
										"arguments": [
											[
												"application/json",
												"application/xml",
												"application/x-www-form-urlencoded",
												"multipart/formdata"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type:\nOne of the following YAML media types:\ntext/yaml\ntext/x-yaml\napplication/yaml\napplication/x-yaml*\nAny type from the list of IANA MIME Media Types, http://www.iana.org/assignments/media-types\nA custom type that conforms to the regular expression, \"application/[A-Za-z.-0-1]*+?(json|xml)\"\nFor any combination of resource and operation in the API, if a media type is specified as a key of the body property for that resource and operation, or if a media type is specified in the mediaType property, the body MUST be in the specified media types. Moreover, if the client specifies an Accepts header containing multiple media types that are allowed by the specification for the requested resource and operation, the server SHOULD return a body using the media type in the Accepts header's mediaType list.\n"
										]
									},
									{
										"name": "MetaModel.inherited",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "schemas",
								"type": {
									"base": {
										"typeName": "GlobalSchema",
										"nameSpace": "",
										"basicName": "GlobalSchema",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "traits",
								"type": {
									"base": {
										"typeName": "RM.Trait",
										"nameSpace": "RM",
										"basicName": "Trait",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declarations of traits used in this API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "RM.SecuritySchemaRef",
										"nameSpace": "RM",
										"basicName": "SecuritySchemaRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A list of the security schemas to apply to all methods, these must be defined in the securitySchemes declaration."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securitySchemes",
								"type": {
									"base": {
										"typeName": "RM.SecuritySchema",
										"nameSpace": "RM",
										"basicName": "SecuritySchema",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Security schemas that can be applied with securedBy"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "resourceTypes",
								"type": {
									"base": {
										"typeName": "RM.ResourceType",
										"nameSpace": "RM",
										"basicName": "ResourceType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.embeddedInMaps",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Declaration of resource types used in this API"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "resources",
								"type": {
									"base": {
										"typeName": "RM.Resource",
										"nameSpace": "RM",
										"basicName": "Resource",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Resource"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Resources are identified by their relative URI, which MUST begin with a slash (/).\nA resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri.\nA resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI.\nEvery property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. \"/bom/items\" may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if \"/bom\" is itself a resource then \"/items\" should be a nested resource of \"/bom\", while \"/bom/items\" should not be used."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "documentation",
								"type": {
									"base": {
										"typeName": "DocumentationItem",
										"nameSpace": "",
										"basicName": "DocumentationItem",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context.\n            Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared.\n            To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document.\n            Documentation-generators MUST process the content field as if it was defined using Markdown [MARKDOWN].\n\n        This example shows an API definition with a single user document."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
							}
						],
						"moduleName": "RAMLSpec",
						"annotationOverridings": {}
					},
					{
						"name": "DocumentationItem",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"title of documentation section"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "content",
								"type": {
									"typeName": "Sys.MarkdownString",
									"nameSpace": "Sys",
									"basicName": "MarkdownString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Content of documentation section"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLSimpleElement",
								"nameSpace": "Common",
								"basicName": "RAMLSimpleElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
							}
						],
						"moduleName": "RAMLSpec",
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts",
					"RM": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts",
					"Params": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/common.ts",
					"Bodies": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/api.ts"
			},
			{
				"classes": [
					{
						"name": "SpecPartMetaData",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "title",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts"
			},
			{
				"classes": [
					{
						"name": "ValueType",
						"methods": [
							{
								"name": "parse",
								"start": 87,
								"end": 253,
								"text": "\n\n    /**\n     * parses inner structure of value type if value type has invalid value you should throw error\n     * with descriptive message\n     */\n    parse():any{}"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "StringType",
						"methods": [
							{
								"name": "value",
								"start": 339,
								"end": 367,
								"text": " value():string{return null}"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"string"
								]
							}
						],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "NumberType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"number"
								]
							}
						],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "BooleanType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.nameAtRuntime",
								"arguments": [
									"boolean"
								]
							}
						],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Referencable",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Reference",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "ValueType",
								"nameSpace": "",
								"basicName": "ValueType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DeclaresDynamicType",
						"methods": [],
						"typeParameters": [
							"T"
						],
						"typeParameterConstraint": [
							null
						],
						"implements": [],
						"fields": [],
						"isInterface": true,
						"annotations": [],
						"extends": [
							{
								"typeName": "Referencable",
								"nameSpace": "",
								"basicName": "Referencable",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "T",
										"nameSpace": "",
										"basicName": "T",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "UriTemplate",
						"methods": [
							{
								"name": "templateArguments",
								"start": 1091,
								"end": 1529,
								"text": "\n\n    templateArguments():string[]{\n        var pos=0;\n        var str=this.value();\n        var result=[];\n        while(true){\n            var start=str.indexOf(\"{\",pos)\n            if (start!=-1){\n                var end=str.indexOf(\"}\",start+1);\n                result.push(str.substring(start+1,end))\n                pos=end;\n            }\n            else{\n                break;\n            }\n        }\n        return result;\n    }"
							},
							{
								"name": "validate",
								"start": 1529,
								"end": 1629,
								"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This type currently serves both for absolute and relative urls"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RelativeUriString",
						"methods": [
							{
								"name": "parse",
								"start": 1760,
								"end": 2554,
								"text": "\n    parse():string[]{\n        //FIXME INHERITANCE\n        var value=this.value();\n        var result=[]\n        var temp=\"\";\n        var inPar=false;\n        var count=0;\n        for (var a=0;a<value.length;a++){\n            var c=value[a];\n            if (c=='{'){\n                count++;\n                inPar=true;\n                continue;\n            }\n            if (c=='}'){\n                count--;\n                inPar=false;\n                result.push(temp);\n                temp=\"\";\n                continue;\n            }\n            if (inPar){\n                temp+=c;\n            }\n        }\n        if (count>0){\n            throw new Error(\"Unmatched '{'\")\n        }\n        if (count<0){\n            throw new Error(\"Unmatched '}'\")\n        }\n        return result;\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This  type describes relative uri templates"
								]
							}
						],
						"extends": [
							{
								"typeName": "UriTemplate",
								"nameSpace": "",
								"basicName": "UriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "FullUriTemplateString",
						"methods": [
							{
								"name": "parse",
								"start": 2689,
								"end": 3474,
								"text": "\n    parse():string[]{//FIXME INHERITANCE\n        var value=this.value();\n        var result=[]\n        var temp=\"\";\n        var inPar=false;\n        var count=0;\n        for (var a=0;a<value.length;a++){\n            var c=value[a];\n            if (c=='{'){\n                count++;\n                inPar=true;\n                continue;\n            }\n            if (c=='}'){\n                count--;\n                inPar=false;\n                result.push(temp);\n                temp=\"\";\n                continue;\n            }\n            if (inPar){\n                temp+=c;\n            }\n        }\n        if (count>0){\n            throw new Error(\"Unmatched '{'\")\n        }\n        if (count<0){\n            throw new Error(\"Unmatched '}'\")\n        }\n        return result;\n    }"
							},
							{
								"name": "validate",
								"start": 3474,
								"end": 3573,
								"text": "\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This  type describes absolute uri templates"
								]
							}
						],
						"extends": [
							{
								"typeName": "UriTemplate",
								"nameSpace": "",
								"basicName": "UriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "FixedUri",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This  type describes fixed uris"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "MarkdownString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.innerType",
								"arguments": [
									"markdown"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SchemaString",
						"methods": [
							{
								"name": "validate",
								"start": 4110,
								"end": 4293,
								"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Schema at this moment only two subtypes are supported (json schema and xsd)"
								]
							}
						],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "JSonSchemaString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"this.mediaType&&this.mediaType.isJSON()"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"JSON schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "SchemaString",
								"nameSpace": "",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "XMLSchemaString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.innerType",
								"arguments": [
									"xml"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"XSD schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "SchemaString",
								"nameSpace": "",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ExampleString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "StatusCodeString",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "StringType",
								"nameSpace": "",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "JSONExample",
						"methods": [
							{
								"name": "parse",
								"start": 4831,
								"end": 5233,
								"text": "\n\n    parse():any{\n        try {\n            JSON.parse(this.value());\n        } catch (e){\n            var ne=new Error(\"Warning: Can not parse JSON:\"+e.message);\n            throw ne\n        }\n        var a=this.$$.parent().attr('schema');\n        if (a) {\n          var sm=  a.findReferencedValue()\n          if (sm&&sm.validate){\n              sm.validate(this.value());\n          }\n        }\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"this.mediaType.isJSON()"
								]
							}
						],
						"extends": [
							{
								"typeName": "ExampleString",
								"nameSpace": "",
								"basicName": "ExampleString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "XMLExample",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"this.mediaType.isXML()"
								]
							}
						],
						"extends": [
							{
								"typeName": "ExampleString",
								"nameSpace": "",
								"basicName": "ExampleString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
			},
			{
				"classes": [
					{
						"name": "ResourceTypeRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "ResourceType",
										"nameSpace": "",
										"basicName": "ResourceType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "TraitRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "Trait",
										"nameSpace": "",
										"basicName": "Trait",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemaPart",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.allowAny",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLSimpleElement",
								"nameSpace": "Common",
								"basicName": "RAMLSimpleElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemaSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.allowAny",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLSimpleElement",
								"nameSpace": "Common",
								"basicName": "RAMLSimpleElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "OAuth1SecuritySchemeSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "requestTokenUri",
								"type": {
									"typeName": "Sys.FixedUri",
									"nameSpace": "Sys",
									"basicName": "FixedUri",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "authorizationUri",
								"type": {
									"typeName": "Sys.FixedUri",
									"nameSpace": "Sys",
									"basicName": "FixedUri",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "tokenCredentialsUri",
								"type": {
									"typeName": "Sys.FixedUri",
									"nameSpace": "Sys",
									"basicName": "FixedUri",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"$parent.type=='OAuth 1.0'"
								]
							},
							{
								"name": "MetaModel.allowAny",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "SecuritySchemaSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemaSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "OAuth2SecuritySchemeSettings",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "accessTokenUri",
								"type": {
									"typeName": "Sys.FixedUri",
									"nameSpace": "Sys",
									"basicName": "FixedUri",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "authorizationUri",
								"type": {
									"typeName": "Sys.FixedUri",
									"nameSpace": "Sys",
									"basicName": "FixedUri",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "authorizationGrants",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A list of the Authorization grants supported by the API As defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of: code, token, owner or credentials."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "scopes",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"A list of scopes supported by the API as defined in RFC6749 [RFC6749] Section 3.3"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"$parent.type=='OAuth 2.0'"
								]
							},
							{
								"name": "MetaModel.allowAny",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "SecuritySchemaSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemaSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchemaRef",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Sys.Reference",
								"nameSpace": "Sys",
								"basicName": "Reference",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "SecuritySchema",
										"nameSpace": "",
										"basicName": "SecuritySchema",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "SecuritySchema",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.Referencable",
								"nameSpace": "Sys",
								"basicName": "Referencable",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "SecuritySchema",
										"nameSpace": "",
										"basicName": "SecuritySchema",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.required",
										"arguments": []
									},
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"OAuth 1.0",
												"OAuth 2.0",
												"Basic Authentication",
												"DigestSecurityScheme Authentication",
												"x-{other}"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "description",
								"type": {
									"typeName": "Sys.MarkdownString",
									"nameSpace": "Sys",
									"basicName": "MarkdownString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The description attribute MAY be used to describe a securitySchemes property."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "describedBy",
								"type": {
									"typeName": "SecuritySchemaPart",
									"nameSpace": "",
									"basicName": "SecuritySchemaPart",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.\n        This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "settings",
								"type": {
									"typeName": "SecuritySchemaSettings",
									"nameSpace": "",
									"basicName": "SecuritySchemaSettings",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The settings attribute MAY be used to provide security schema-specific information. Depending on the value of the type parameter, its attributes can vary.\n        The following lists describe the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the Security Scheme type. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, an so on."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Declares globally referenceable security schema definition"
								]
							},
							{
								"name": "MetaModel.actuallyExports",
								"arguments": [
									"$self"
								]
							},
							{
								"name": "MetaModel.referenceIs",
								"arguments": [
									"settings"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "MethodBase",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "responses",
								"type": {
									"base": {
										"typeName": "Bodies.Response",
										"nameSpace": "Bodies",
										"basicName": "Response",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Response"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties.\n"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "body",
								"type": {
									"base": {
										"typeName": "Bodies.BodyLike",
										"nameSpace": "Bodies",
										"basicName": "BodyLike",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Body"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.\nResources CAN have alternate representations. For example, an API might support both JSON and XML representations.\nA method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "is",
								"type": {
									"base": {
										"typeName": "TraitRef",
										"nameSpace": "",
										"basicName": "TraitRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instantiation of applyed traits"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "SecuritySchemaRef",
										"nameSpace": "",
										"basicName": "SecuritySchemaRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.allowNull",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A list of the security schemas to apply, these must be defined in the securitySchemes declaration.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.\nSecurity schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Params.HasNormalParameters",
								"nameSpace": "Params",
								"basicName": "HasNormalParameters",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Trait",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.DeclaresDynamicType",
								"nameSpace": "Sys",
								"basicName": "DeclaresDynamicType",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "Trait",
										"nameSpace": "",
										"basicName": "Trait",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the trait"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.inlinedTemplates",
								"arguments": []
							},
							{
								"name": "MetaModel.allowQuestion",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "MethodBase",
								"nameSpace": "",
								"basicName": "MethodBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "ResourceType",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [
							{
								"typeName": "Sys.DeclaresDynamicType",
								"nameSpace": "Sys",
								"basicName": "DeclaresDynamicType",
								"typeKind": 0,
								"typeArguments": [
									{
										"typeName": "ResourceType",
										"nameSpace": "",
										"basicName": "ResourceType",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									}
								],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Name of the resource type"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "usage",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "methods",
								"type": {
									"base": {
										"typeName": "Method",
										"nameSpace": "",
										"basicName": "Method",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Methods that are part of this resource type definition"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "is",
								"type": {
									"base": {
										"typeName": "TraitRef",
										"nameSpace": "",
										"basicName": "TraitRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instantiation of applyed traits"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "ResourceTypeRef",
									"nameSpace": "",
									"basicName": "ResourceTypeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instantiation of applyed resource type"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "SecuritySchemaRef",
										"nameSpace": "",
										"basicName": "SecuritySchemaRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.allowNull",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uriParameters",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.URI"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Uri parameters of this resource"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.inlinedTemplates",
								"arguments": []
							},
							{
								"name": "MetaModel.allowQuestion",
								"arguments": []
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Method",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "method",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"methods"
										]
									},
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"get",
												"put",
												"post",
												"delete",
												"patch",
												"options",
												"head"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Method that can be called"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "protocols",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.oneOf",
										"arguments": [
											[
												"HTTP",
												"HTTPS"
											]
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A method can override an API's protocols value for that single method by setting a different value for the fields."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "SecuritySchemaRef",
										"nameSpace": "",
										"basicName": "SecuritySchemaRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.allowNull",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Method object allows description of http methods"
								]
							}
						],
						"extends": [
							{
								"typeName": "MethodBase",
								"nameSpace": "",
								"basicName": "MethodBase",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Resource",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "relativeUri",
								"type": {
									"typeName": "Sys.RelativeUriString",
									"nameSpace": "Sys",
									"basicName": "RelativeUriString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.startFrom",
										"arguments": [
											"/"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Relative URL of this resource from the parent resource"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "ResourceTypeRef",
									"nameSpace": "",
									"basicName": "ResourceTypeRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instantiation of applyed resource type"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "is",
								"type": {
									"base": {
										"typeName": "TraitRef",
										"nameSpace": "",
										"basicName": "TraitRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Instantiation of applyed traits"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "securedBy",
								"type": {
									"base": {
										"typeName": "SecuritySchemaRef",
										"nameSpace": "",
										"basicName": "SecuritySchemaRef",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.allowNull",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "uriParameters",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.URI"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Uri parameters of this resource"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "methods",
								"type": {
									"base": {
										"typeName": "Method",
										"nameSpace": "",
										"basicName": "Method",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Method"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Methods that can be called on this resource"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "resources",
								"type": {
									"base": {
										"typeName": "Resource",
										"nameSpace": "",
										"basicName": "Resource",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Resource"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Children resources"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "displayName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "baseUriParameters",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"fieldOrParam",
											true
										]
									},
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.BURI"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts",
					"Params": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts",
					"Bodies": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/common.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/methodsAndResources.ts"
			},
			{
				"classes": [
					{
						"name": "Parameter",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"name of the parameter"
										]
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"headers"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "displayName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.defaultValue",
										"arguments": [
											"string"
										]
									},
									{
										"name": "MetaModel.descriminatingProperty",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string."
										]
									},
									{
										"name": "MetaModel.canBeDuplicator",
										"arguments": []
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "location",
								"type": {
									"typeName": "ParameterLocation",
									"nameSpace": "",
									"basicName": "ParameterLocation",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.system",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Location of the parameter (can not be edited by user)"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "required",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Set to true if parameter is required"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "default",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "example",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "repeat",
								"type": {
									"typeName": "boolean",
									"nameSpace": "",
									"basicName": "boolean",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "StringTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "pattern",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "enum",
								"type": {
									"base": {
										"typeName": "string",
										"nameSpace": "",
										"basicName": "string",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": null
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "minLength",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maxLength",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "string"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value must be a string"
								]
							}
						],
						"extends": [
							{
								"typeName": "Parameter",
								"nameSpace": "",
								"basicName": "Parameter",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "BooleanTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "boolean"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value must be a boolean"
								]
							}
						],
						"extends": [
							{
								"typeName": "Parameter",
								"nameSpace": "",
								"basicName": "Parameter",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "NumberTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "number"
								},
								"optional": false
							},
							{
								"name": "minimum",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "maximum",
								"type": {
									"typeName": "number",
									"nameSpace": "",
									"basicName": "number",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value MUST be a number. Indicate floating point numbers as defined by YAML."
								]
							}
						],
						"extends": [
							{
								"typeName": "Parameter",
								"nameSpace": "",
								"basicName": "Parameter",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "IntegerTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "integer"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value MUST be a integer."
								]
							}
						],
						"extends": [
							{
								"typeName": "NumberTypeDeclaration",
								"nameSpace": "",
								"basicName": "NumberTypeDeclaration",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "DateTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "date"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. "
								]
							}
						],
						"extends": [
							{
								"typeName": "Parameter",
								"nameSpace": "",
								"basicName": "Parameter",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "FileTypeDeclaration",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": null,
								"annotations": [],
								"valueConstraint": {
									"isCallConstraint": false,
									"value": "file"
								},
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.requireValue",
								"arguments": [
									"location",
									"ParameterLocation.FORM"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
								]
							}
						],
						"extends": [
							{
								"typeName": "Parameter",
								"nameSpace": "",
								"basicName": "Parameter",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "HasNormalParameters",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "queryParameters",
								"type": {
									"base": {
										"typeName": "Parameter",
										"nameSpace": "",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"ParameterLocation.QUERY"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New query parameter"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "displayName",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "headers",
								"type": {
									"base": {
										"typeName": "Parameter",
										"nameSpace": "",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"ParameterLocation.HEADERS"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Headers that allowed at this position"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Header"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [
					{
						"name": "ParameterLocation",
						"members": [
							"QUERY",
							"HEADERS",
							"URI",
							"FORM",
							"BURI"
						]
					}
				],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/common.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts"
			},
			{
				"classes": [
					{
						"name": "RAMLLanguageElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "description",
								"type": {
									"typeName": "Sys.MarkdownString",
									"nameSpace": "Sys",
									"basicName": "MarkdownString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/common.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "RAMLSimpleElement",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/common.ts"
			},
			{
				"classes": [
					{
						"name": "MimeTypeModel",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "type",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "tree",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": true
							},
							{
								"name": "subtype",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "suffix",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": true
							},
							{
								"name": "parameters",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [],
								"valueConstraint": null,
								"optional": true
							}
						],
						"isInterface": true,
						"annotations": [],
						"extends": [],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "MimeType",
						"methods": [
							{
								"name": "isForm",
								"start": 448,
								"end": 649,
								"text": "\n    isForm(){\n        if (this.value()==\"application/x-www-form-urlencoded\"||this.value()=='multipart/form-data'){\n            return true;\n        }\n\n        return false;//more smart code here\n    }"
							},
							{
								"name": "isXML",
								"start": 649,
								"end": 794,
								"text": "\n\n    isXML(){\n        if (this.value()==\"application/xml\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
							},
							{
								"name": "isJSON",
								"start": 794,
								"end": 941,
								"text": "\n\n    isJSON(){\n        if (this.value()==\"application/json\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
							},
							{
								"name": "parse",
								"start": 1024,
								"end": 1566,
								"text": "\n    parse(){\n        /**\n         * top-level type name / subtype name [ ; parameters ]\n         *\n         * top-level type name / [ tree. ] subtype name [ +suffix ] [ ; parameters ]\n         */\n        var v=this.value();\n        if (v==\"*/*\"){\n            return\n        }\n        var res= mediaTypeParser.parse(v);\n        var types={application:1, audio:1, example:1, image:1, message:1, model:1, multipart:1, text:1, video:1}\n        if (!types[res.type]){\n            throw new Error(\"Unknown media type 'type' value\")\n        }\n    }"
							}
						],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"This sub type of the string represents mime types"
								]
							}
						],
						"extends": [
							{
								"typeName": "Sys.StringType",
								"nameSpace": "Sys",
								"basicName": "StringType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "BodyLike",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "name",
								"type": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Mime type of the request or response body"
										]
									},
									{
										"name": "MetaModel.canInherit",
										"arguments": [
											"mediaType"
										]
									},
									{
										"name": "MetaModel.oftenKeys",
										"arguments": [
											[
												"application/json",
												"application/xml",
												"application/x-www-form-urlencoded",
												"multipart/formdata"
											]
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "schema",
								"type": {
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.requireValue",
										"arguments": [
											"this.name.isForm()",
											"false"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"\n    The structure of a request or response body MAY be further specified by the schema property under the appropriate media type.\n\nThe schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data.\n\nAll parsers of RAML MUST be able to interpret JSON Schema [JSON_SCHEMA] and XML Schema [XML_SCHEMA].\n\nSchema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline.\nAlternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property (see Named Parameters, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "example",
								"type": {
									"typeName": "Sys.ExampleString",
									"nameSpace": "Sys",
									"basicName": "ExampleString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"Documentation generators MUST use body properties' example attributes to generate example invocations.\nThis example shows example attributes for two body property media types."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "formParameters",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.FORM"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Web forms REQUIRE special encoding and custom declaration.\nIf the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting.\nThe formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.canInherit",
								"arguments": [
									"mediaType"
								]
							}
						],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "XMLBody",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "schema",
								"type": {
									"typeName": "Sys.XMLSchemaString",
									"nameSpace": "Sys",
									"basicName": "XMLSchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"XSD Schema"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"this.mime.isXML()"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"Needed to set connection between xml related mime types and xsd schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "BodyLike",
								"nameSpace": "",
								"basicName": "BodyLike",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "JSONBody",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "schema",
								"type": {
									"typeName": "Sys.JSonSchemaString",
									"nameSpace": "Sys",
									"basicName": "JSonSchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.description",
										"arguments": [
											"JSON Schema"
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [
							{
								"name": "MetaModel.functionalDescriminator",
								"arguments": [
									"this.mime.isJSON()"
								]
							},
							{
								"name": "MetaModel.description",
								"arguments": [
									"Needed to set connection between json related mime types and json schema"
								]
							}
						],
						"extends": [
							{
								"typeName": "BodyLike",
								"nameSpace": "",
								"basicName": "BodyLike",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					},
					{
						"name": "Response",
						"methods": [],
						"typeParameters": [],
						"typeParameterConstraint": [],
						"implements": [],
						"fields": [
							{
								"name": "code",
								"type": {
									"typeName": "Sys.StatusCodeString",
									"nameSpace": "Sys",
									"basicName": "StatusCodeString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
								},
								"annotations": [
									{
										"name": "MetaModel.key",
										"arguments": []
									},
									{
										"name": "MetaModel.extraMetaKey",
										"arguments": [
											"statusCodes"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "headers",
								"type": {
									"base": {
										"typeName": "Params.Parameter",
										"nameSpace": "Params",
										"basicName": "Parameter",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.setsContextValue",
										"arguments": [
											"location",
											"Params.ParameterLocation.HEADERS"
										]
									},
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Header"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property.\n        API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data.\n\nIn the following example, the header x-metadata-{?} is used to send metadata that has been saved with the media."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							},
							{
								"name": "body",
								"type": {
									"base": {
										"typeName": "BodyLike",
										"nameSpace": "",
										"basicName": "BodyLike",
										"typeKind": 0,
										"typeArguments": [],
										"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
									},
									"typeKind": 1
								},
								"annotations": [
									{
										"name": "MetaModel.newInstanceName",
										"arguments": [
											"New Body"
										]
									},
									{
										"name": "MetaModel.description",
										"arguments": [
											"Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined.\nFor APIs without a priori knowledge of the response types for their responses, \"*/*\" MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if \"*/*\" is used."
										]
									}
								],
								"valueConstraint": null,
								"optional": false
							}
						],
						"isInterface": false,
						"annotations": [],
						"extends": [
							{
								"typeName": "Common.RAMLLanguageElement",
								"nameSpace": "Common",
								"basicName": "RAMLLanguageElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
							}
						],
						"moduleName": null,
						"annotationOverridings": {}
					}
				],
				"aliases": [],
				"enumDeclarations": [],
				"imports": {
					"MetaModel": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/definition-system/metamodel.ts",
					"Sys": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/systemTypes.ts",
					"Params": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/parameters.ts",
					"Common": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/common.ts"
				},
				"name": "/Users/munch/work/apiworkbench/api-workbench/src/raml1/spec-0.8/bodies.ts"
			}
		];

	/***/ },
	/* 87 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(38);

	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {

		var RamlWrapper = __webpack_require__(74);
		var hl = __webpack_require__(2);
		var hlimpl = __webpack_require__(5);
		var universes = __webpack_require__(54);
		var expander = __webpack_require__(73);
		var lowLevelProxy = __webpack_require__(6);
		var util = __webpack_require__(11);
		var search = __webpack_require__(53);
		var ll = __webpack_require__(15);
		var path = __webpack_require__(16);
		//export function resolveType(p:RamlWrapper.TypeDeclaration):hl.ITypeDefinition{
		//    var tpe=typeexpression.typeFromNode(p.highLevel());
		//    return tpe.toRuntime();
		//}
		function load(pth) {
		    var m = new ll.Project(path.dirname(pth));
		    var unit = m.unit(path.basename(pth));
		    if (unit) {
		        if (unit.isRAMLUnit()) {
		            return hl.fromUnit(unit).wrapperNode();
		        }
		    }
		    return null;
		}
		exports.load = load;
		//__$helperMethod__ Equivalent API with traits and resource types expanded __$meta__={"name":"expand"}
		function expandTraitsAndResourceTypes(api) {
		    var lowLevelNode = api.highLevel().lowLevel();
		    if (lowLevelNode instanceof lowLevelProxy.LowLevelProxyNode) {
		        return api;
		    }
		    return expander.expandTraitsAndResourceTypes(api);
		}
		exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
		//__$helperMethod__ Path relative to API root
		function completeRelativeUri(res) {
		    var uri = '';
		    var parent = res;
		    do {
		        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
		        uri = res.relativeUri().value() + uri;
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe08.Resource.name);
		    return uri;
		}
		exports.completeRelativeUri = completeRelativeUri;
		//__$helperMethod__ baseUri of owning Api concatenated with completeRelativeUri
		function absoluteUri(res) {
		    var uri = '';
		    var parent = res;
		    do {
		        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
		        uri = res.relativeUri().value() + uri;
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe08.Resource.name);
		    uri = uri.replace(/\/\//g, '/');
		    var buri = parent.baseUri();
		    var base = buri ? buri.value() : "";
		    base = base ? base : '';
		    if (util.stringEndsWith(base, '/')) {
		        uri = uri.substring(1);
		    }
		    uri = base + uri;
		    return uri;
		}
		exports.absoluteUri = absoluteUri;
		function qName(c) {
		    return hlimpl.qName(c.highLevel(), c.highLevel().root());
		}
		exports.qName = qName;
		//__$helperMethod__ Retrieve all traits including those defined in libraries
		function allTraits(a) {
		    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().key().name == "Trait"; }).map(function (x) { return x.wrapperNode(); });
		}
		exports.allTraits = allTraits;
		//__$helperMethod__ Retrieve all resource types including those defined in libraries
		function allResourceTypes(a) {
		    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().key().name == "ResourceType"; }).map(function (x) { return x.wrapperNode(); });
		}
		exports.allResourceTypes = allResourceTypes;
		function relativeUriSegments(res) {
		    var result = [];
		    var parent = res;
		    do {
		        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
		        result.push(res.relativeUri().value());
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe08.Resource.name);
		    return result.reverse();
		}
		exports.relativeUriSegments = relativeUriSegments;
		//__$helperMethod__ For methods of Resources returns parent resource. For methods of ResourceTypes returns null.
		function parentResource(method) {
		    if (method.parent() instanceof RamlWrapper.ResourceImpl) {
		        return method.parent();
		    }
		    return null;
		}
		exports.parentResource = parentResource;
		//__$helperMethod__ Parent resource for non top level resources __$meta__={"name":"parentResource"}
		function parent(resource) {
		    var parent = resource.parent();
		    if (isApi(parent)) {
		        return null;
		    }
		    return parent;
		}
		exports.parent = parent;
		//__$helperMethod__ Get child resource by its relative path
		function getChildResource(container, relPath) {
		    if (container == null) {
		        return null;
		    }
		    var resources = container.resources();
		    if (!resources) {
		        return null;
		    }
		    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
		    if (resources.length == 0) {
		        return null;
		    }
		    return resources[0];
		}
		exports.getChildResource = getChildResource;
		function getResource(container, path) {
		    if (!container) {
		        return null;
		    }
		    var res = null;
		    for (var i = 0; i < path.length; i++) {
		        res = getChildResource(container, path[i]);
		        if (!res) {
		            return null;
		        }
		        container = res;
		    }
		    return res;
		}
		exports.getResource = getResource;
		//__$helperMethod__ Get child method by its name
		function getChildMethod(resource, method) {
		    if (!resource) {
		        return null;
		    }
		    return resource.methods().filter(function (x) { return x.method() == method; });
		}
		exports.getChildMethod = getChildMethod;
		function getMethod(container, path, method) {
		    var resource = getResource(container, path);
		    if (resource == null) {
		        return null;
		    }
		    return getChildMethod(resource, method);
		}
		exports.getMethod = getMethod;
		function isApi(obj) {
		    return (obj.definition().key().name == universes.Universe08.Api.name);
		}
		;
		//__$helperMethod__ Api owning the resource as a sibling
		function ownerApi(method) {
		    var obj = method;
		    while (!isApi(obj)) {
		        obj = obj.parent();
		    }
		    return obj;
		}
		exports.ownerApi = ownerApi;
		//__$helperMethod__
		// For methods of Resources: `{parent Resource relative path} {methodName}`.
		// For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
		// For other methods throws Exception.
		function methodId(method) {
		    var parent = method.parent();
		    if (parent instanceof RamlWrapper.ResourceImpl) {
		        return completeRelativeUri(parent) + ' ' + method.method().toLowerCase();
		    }
		    else if (parent instanceof RamlWrapper.ResourceTypeImpl) {
		        return parent.name() + ' ' + method.method().toLowerCase();
		    }
		    throw new Error("Method is supposed to be owned by Resource or ResourceType.\nHere the method is owned by " + method.definition().key().name);
		}
		exports.methodId = methodId;
		//__$helperMethod__ true for codes < 400 and false otherwise
		function isOkRange(response) {
		    return parseInt(response.code().value()) < 400;
		}
		exports.isOkRange = isOkRange;
		//__$helperMethod__  Retrieve all resources of the Api
		function allResources(api) {
		    var resources = [];
		    var visitor = function (res) {
		        resources.push(res);
		        res.resources().forEach(function (x) { return visitor(x); });
		    };
		    api.resources().forEach(function (x) { return visitor(x); });
		    return resources;
		}
		exports.allResources = allResources;
		//export function matchUri(apiRootRelativeUri:string, resource:RamlWrapper.Resource):Opt<ParamValue[]>{
		//
		//    var allParameters:Raml08Parser.NamedParameterMap = {}
		//    var opt:Opt<RamlWrapper.Resource> = new Opt<RamlWrapper.Resource>(resource);
		//    while(opt.isDefined()){
		//        var res:RamlWrapper.Resource = opt.getOrThrow();
		//        uriParameters(res).forEach(x=>allParameters[x.name()]=new ParamWrapper(x));
		//        opt = parent(res);
		//    }
		//    var result = ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
		//    if (result) {
		//        return new Opt<ParamValue[]>(Object.keys((<any>result).params)
		//            .map(x=>new ParamValue(x, result['params'][x])));
		//    }
		//    return Opt.empty<ParamValue[]>();
		//}
		var schemaContentChars = ['{', '<'];
		//export function schema(body:RamlWrapper.TypeDeclaration, api:RamlWrapper.Api):Opt<SchemaDef>{
		//
		//    var schemaNode = body.schema();
		//    if(!schemaNode){
		//        return Opt.empty<SchemaDef>();
		//    }
		//    var schemaString = schemaNode;
		//    var isContent:boolean = false;
		//    schemaContentChars.forEach(x=>{try{ isContent = isContent||schemaString.indexOf(x)>=0}catch(e){}});
		//    var schDef:SchemaDef;
		//    if(isContent) {
		//        schDef = new SchemaDef(schemaString);
		//    }
		//    else{
		//        var globalSchemes = api.schemas().filter(x=>x.key()==schemaString);
		//        if(globalSchemes.length>0){
		//            schDef = new SchemaDef(globalSchemes[0].value().value(),globalSchemes[0].key());
		//        }
		//        else{
		//            return Opt.empty<SchemaDef>();
		//        }
		//    }
		//    return new Opt<SchemaDef>(schDef);
		//}
		/**
		 * __$helperMethod__ Retrieve an ordered list of all uri parameters including those which are not described in the `uriParameters` node.
		 * Consider a fragment of RAML specification:
		 * ```yaml
		 * /resource/{objectId}/{propertyId}:
		 *   uriParameters:
		 *     objectId:
		 * ```
		 * Here `propertyId` uri parameter is not described in the `uriParameters` node.
		 * Thus, it is not among Resource.uriParameters(), but it is among Resource.allUriParameters().
		 * __$meta__={"name":"allUriParameters"}
		 **/
		function uriParameters(resource) {
		    var uri = resource.relativeUri().value();
		    var params = resource.uriParameters();
		    return extractParams(params, uri, resource);
		}
		exports.uriParameters = uriParameters;
		/**__$helperMethod__
		 * Retrieve an ordered list of all base uri parameters regardless of whether they are described in `baseUriParameters` or not
		 * Consider a fragment of RAML specification:
		 * ```yaml
		 * version: v1
		 * baseUri: https://{organization}.example.com/{version}/{service}
		 * baseUriParameters:
		 *   service:
		 * ```
		 * Here `version` and `organization` are base uri parameters which are not described in the `baseUriParameters` node.
		 * Thus, they are not among `Api.baseUriParameters()`, but they are among `Api.allBaseUriParameters()`.
		 * __$meta__={"name":"allBaseUriParameters"}
		 **/
		function baseUriParameters(api) {
		    var uri = api.baseUri() ? api.baseUri().value() : '';
		    var params = api.baseUriParameters();
		    return extractParams(params, uri, api);
		}
		exports.baseUriParameters = baseUriParameters;
		/**__$helperMethod__
		 * Retrieve an ordered list of all absolute uri parameters. Returns a union of `Api.allBaseUriParameters()`
		 * for `Api` owning the `Resource` and `Resource.allUriParameters()`.
		 */
		function absoluteUriParameters(res) {
		    var params = [];
		    var parent = res;
		    do {
		        res = parent;
		        var uri = res.relativeUri().value();
		        var uriParams = res.uriParameters();
		        params = extractParams(uriParams, uri, res).concat(params);
		        parent = res.parent();
		    } while (parent.definition().key().name == universes.Universe08.Resource.name);
		    var api = parent;
		    var baseUri = api.baseUri().value();
		    var baseUriParams = api.baseUriParameters();
		    params = extractParams(baseUriParams, baseUri, api).concat(params);
		    return params;
		}
		exports.absoluteUriParameters = absoluteUriParameters;
		/**
		 * __$helperMethod__ Protocols used by the API. Returns the `protocols` property value if it is specified.
		 * Otherwise, returns protocol, specified in the base URI.
		 **/
		function allProtocols(api) {
		    var result = api.protocols();
		    if (result.length != 0) {
		        return result;
		    }
		    var baseUri = api.baseUri().value();
		    if (baseUri && baseUri.trim().length != 0) {
		        var ind = baseUri.indexOf('://');
		        if (ind >= 0) {
		            result = [baseUri.substring(0, ind)];
		        }
		    }
		    return result;
		}
		exports.allProtocols = allProtocols;
		function extractParams(params, uri, resource) {
		    if (!uri) {
		        return [];
		    }
		    var describedParams = {};
		    params.forEach(function (x) { return describedParams[x.name()] = x; });
		    var allParams = [];
		    var prev = 0;
		    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
		        prev = uri.indexOf('}', ++i);
		        var paramName = uri.substring(i, prev);
		        if (describedParams[paramName]) {
		            allParams.push(describedParams[paramName]);
		        }
		        else {
		            allParams.push(new HelperUriParam(paramName, resource));
		        }
		    }
		    return allParams;
		}
		;
		var HelperUriParam = (function () {
		    function HelperUriParam(_name, _parent) {
		        this._name = _name;
		        this._parent = _parent;
		    }
		    HelperUriParam.prototype.wrapperClassName = function () {
		        return "HelperUriParam";
		    };
		    HelperUriParam.prototype.getKind = function () {
		        return "HelperUriParam";
		    };
		    HelperUriParam.prototype.name = function () {
		        return this._name;
		    };
		    HelperUriParam.prototype["type"] = function () {
		        return "string";
		    };
		    HelperUriParam.prototype.location = function () {
		        return {
		            wrapperClassName: function () { return "HelperModelLocation"; },
		            getKind: function () { return "HelperModelLocation"; }
		        };
		    };
		    //    locationKind(  ):RamlWrapper.LocationKind{ return { wrapperClassName: ()=>"HelperLocationKind" }; }
		    HelperUriParam.prototype["default"] = function () {
		        return null;
		    };
		    HelperUriParam.prototype.xml = function () {
		        return null;
		    };
		    HelperUriParam.prototype.sendDefaultByClient = function () {
		        return false;
		    };
		    HelperUriParam.prototype.example = function () {
		        return '';
		    };
		    HelperUriParam.prototype.schema = function () {
		        return null;
		    };
		    //    formParameters():RamlWrapper.TypeDeclaration[]{return []}
		    //    examples(  ):RamlWrapper.ExampleSpec[]{ return []}
		    HelperUriParam.prototype.repeat = function () {
		        return false;
		    };
		    HelperUriParam.prototype.enum = function () {
		        return [];
		    };
		    HelperUriParam.prototype.collectionFormat = function () {
		        return 'multi';
		    };
		    HelperUriParam.prototype.required = function () {
		        return true;
		    };
		    HelperUriParam.prototype.readOnly = function () {
		        return false;
		    };
		    HelperUriParam.prototype.facets = function () {
		        return [];
		    };
		    HelperUriParam.prototype.scope = function () {
		        return [];
		    };
		    //xml(  ):RamlWrapper.XMLInfo{ return null; }
		    //    validWhen(  ):RamlWrapper.ramlexpression{ return null; }
		    //    requiredWhen(  ):RamlWrapper.ramlexpression{ return null; }
		    HelperUriParam.prototype.displayName = function () {
		        return this._name;
		    };
		    HelperUriParam.prototype.description = function () {
		        return null;
		    };
		    //    annotations(  ):RamlWrapper.AnnotationRef[]{ return []; }
		    HelperUriParam.prototype.usage = function () {
		        return null;
		    };
		    HelperUriParam.prototype.parent = function () {
		        return this._parent;
		    };
		    HelperUriParam.prototype.highLevel = function () {
		        return null;
		    };
		    HelperUriParam.prototype.errors = function () {
		        return [];
		    };
		    HelperUriParam.prototype.definition = function () {
		        return null;
		    };
		    HelperUriParam.prototype.runtimeDefinition = function () {
		        return null;
		    };
		    HelperUriParam.prototype.toJSON = function () {
		        return { "name": this.name() };
		    };
		    return HelperUriParam;
		})();
		exports.HelperUriParam = HelperUriParam;
		//
		//export class SchemaDef{
		//
		//    constructor(private _content:string, private _name?:string){}
		//
		//    name():string{return this._name}
		//
		//    content(): string{return this._content}
		//}
		//
		//
		//export class ParamValue{
		//    key:string
		//    value:any
		//
		//    constructor(key:string, value:any) {
		//        this.key = key;
		//        this.value = value;
		//    }
		//}
		//
		//
		//class ParamWrapper implements Raml08Parser.BasicNamedParameter{
		//
		//    constructor(private _param:RamlWrapper.TypeDeclaration){
		//
		//        this.description = _param.description() ? _param.description().value() : this.description;
		//
		//        this.displayName = _param.displayName();
		//
		////        this.enum = _param.enum();
		//
		//        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
		//
		//        this.example = _param.example();
		//
		//        this.repeat = _param.repeat();
		//
		//        this.required = _param.required();
		//
		//        this.default = _param.default();
		//    }
		//
		//    description: Raml08Parser.MarkdownString
		//
		//    displayName: string
		//
		//    'enum': any[]
		//
		//    type: string
		//
		//    example: any
		//
		//    repeat: boolean
		//
		//    required: boolean
		//
		//    'default': any
		//
		//}


	/***/ },
	/* 89 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(39);

	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {

		exports.dot = exports.dotCase = __webpack_require__(91)
		exports.swap = exports.swapCase = __webpack_require__(97)
		exports.path = exports.pathCase = __webpack_require__(99)
		exports.upper = exports.upperCase = __webpack_require__(98)
		exports.lower = exports.lowerCase = __webpack_require__(93)
		exports.camel = exports.camelCase = __webpack_require__(100)
		exports.snake = exports.snakeCase = __webpack_require__(101)
		exports.title = exports.titleCase = __webpack_require__(102)
		exports.param = exports.paramCase = __webpack_require__(103)
		exports.pascal = exports.pascalCase = __webpack_require__(104)
		exports.constant = exports.constantCase = __webpack_require__(106)
		exports.sentence = exports.sentenceCase = __webpack_require__(92)
		exports.isUpper = exports.isUpperCase = __webpack_require__(107)
		exports.isLower = exports.isLowerCase = __webpack_require__(108)
		exports.ucFirst = exports.upperCaseFirst = __webpack_require__(105)
		exports.lcFirst = exports.lowerCaseFirst = __webpack_require__(109)


	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {

		var sentenceCase = __webpack_require__(92);

		/**
		 * Dot case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (string, locale) {
		  return sentenceCase(string, locale, '.');
		};


	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {

		var lowerCase = __webpack_require__(93)

		var NON_WORD_REGEXP = __webpack_require__(94)
		var CAMEL_CASE_REGEXP = __webpack_require__(95)
		var TRAILING_DIGIT_REGEXP = __webpack_require__(96)

		/**
		 * Sentence case a string.
		 *
		 * @param  {String} str
		 * @param  {String} locale
		 * @param  {String} replacement
		 * @return {String}
		 */
		module.exports = function (str, locale, replacement) {
		  if (str == null) {
		    return ''
		  }

		  replacement = replacement || ' '

		  function replace (match, index, string) {
		    if (index === 0 || index === (string.length - match.length)) {
		      return ''
		    }

		    return replacement
		  }

		  str = String(str)
		    // Support camel case ("camelCase" -> "camel Case").
		    .replace(CAMEL_CASE_REGEXP, '$1 $2')
		    // Support digit groups ("test2012" -> "test 2012").
		    .replace(TRAILING_DIGIT_REGEXP, '$1 $2')
		    // Remove all non-word characters and replace with a single space.
		    .replace(NON_WORD_REGEXP, replace)

		  // Lower case the entire string.
		  return lowerCase(str, locale)
		}


	/***/ },
	/* 93 */
	/***/ function(module, exports) {

		/**
		 * Special language-specific overrides.
		 *
		 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
		 *
		 * @type {Object}
		 */
		var LANGUAGES = {
		  tr: {
		    regexp: /\u0130|\u0049|\u0049\u0307/g,
		    map: {
		      '\u0130': '\u0069',
		      '\u0049': '\u0131',
		      '\u0049\u0307': '\u0069'
		    }
		  },
		  az: {
		    regexp: /[\u0130]/g,
		    map: {
		      '\u0130': '\u0069',
		      '\u0049': '\u0131',
		      '\u0049\u0307': '\u0069'
		    }
		  },
		  lt: {
		    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
		    map: {
		      '\u0049': '\u0069\u0307',
		      '\u004A': '\u006A\u0307',
		      '\u012E': '\u012F\u0307',
		      '\u00CC': '\u0069\u0307\u0300',
		      '\u00CD': '\u0069\u0307\u0301',
		      '\u0128': '\u0069\u0307\u0303'
		    }
		  }
		}

		/**
		 * Lowercase a string.
		 *
		 * @param  {String} str
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  var lang = LANGUAGES[locale]

		  str = str == null ? '' : String(str)

		  if (lang) {
		    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
		  }

		  return str.toLowerCase()
		}


	/***/ },
	/* 94 */
	/***/ function(module, exports) {

		module.exports = /[^\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g


	/***/ },
	/* 95 */
	/***/ function(module, exports) {

		module.exports = /([\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])([\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g


	/***/ },
	/* 96 */
	/***/ function(module, exports) {

		module.exports = /([\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([^\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g


	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {

		var upperCase = __webpack_require__(98)
		var lowerCase = __webpack_require__(93)

		/**
		 * Swap the case of a string. Manually iterate over every character and check
		 * instead of replacing certain characters for better unicode support.
		 *
		 * @param  {String} str
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  if (str == null) {
		    return ''
		  }

		  var result = ''

		  for (var i = 0; i < str.length; i++) {
		    var c = str[i]
		    var u = upperCase(c, locale)

		    result += u === c ? lowerCase(c, locale) : u
		  }

		  return result
		}


	/***/ },
	/* 98 */
	/***/ function(module, exports) {

		/**
		 * Special language-specific overrides.
		 *
		 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
		 *
		 * @type {Object}
		 */
		var LANGUAGES = {
		  tr: {
		    regexp: /[\u0069]/g,
		    map: {
		      '\u0069': '\u0130'
		    }
		  },
		  az: {
		    regexp: /[\u0069]/g,
		    map: {
		      '\u0069': '\u0130'
		    }
		  },
		  lt: {
		    regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
		    map: {
		      '\u0069\u0307': '\u0049',
		      '\u006A\u0307': '\u004A',
		      '\u012F\u0307': '\u012E',
		      '\u0069\u0307\u0300': '\u00CC',
		      '\u0069\u0307\u0301': '\u00CD',
		      '\u0069\u0307\u0303': '\u0128'
		    }
		  }
		}

		/**
		 * Upper case a string.
		 *
		 * @param  {String} str
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  var lang = LANGUAGES[locale]

		  str = str == null ? '' : String(str)

		  if (lang) {
		    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
		  }

		  return str.toUpperCase()
		}


	/***/ },
	/* 99 */
	/***/ function(module, exports, __webpack_require__) {

		var sentenceCase = __webpack_require__(92);

		/**
		 * Path case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (string, locale) {
		  return sentenceCase(string, locale, '/');
		};


	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {

		var upperCase = __webpack_require__(98)
		var sentenceCase = __webpack_require__(92)

		/**
		 * Camel case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (string, locale, mergeNumbers) {
		  var result = sentenceCase(string, locale)

		  // Replace periods between numeric entities with an underscore.
		  if (!mergeNumbers) {
		    result = result.replace(/(\d) (?=\d)/g, '$1_')
		  }

		  // Replace spaces between words with an upper cased character.
		  return result.replace(/ (.)/g, function (m, $1) {
		    return upperCase($1, locale)
		  })
		}


	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {

		var sentenceCase = __webpack_require__(92);

		/**
		 * Snake case a string.
		 *
		 * @param  {String} str
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  return sentenceCase(str, locale, '_');
		};


	/***/ },
	/* 102 */
	/***/ function(module, exports, __webpack_require__) {

		var upperCase = __webpack_require__(98)
		var sentenceCase = __webpack_require__(92)

		/**
		 * Title case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  return sentenceCase(str, locale).replace(/^.| ./g, function (m) {
		    return upperCase(m, locale)
		  })
		}


	/***/ },
	/* 103 */
	/***/ function(module, exports, __webpack_require__) {

		var sentenceCase = __webpack_require__(92);

		/**
		 * Param case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (string, locale) {
		  return sentenceCase(string, locale, '-');
		};


	/***/ },
	/* 104 */
	/***/ function(module, exports, __webpack_require__) {

		var camelCase = __webpack_require__(100)
		var upperCaseFirst = __webpack_require__(105)

		/**
		 * Pascal case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (string, locale) {
		  return upperCaseFirst(camelCase(string, locale), locale)
		}


	/***/ },
	/* 105 */
	/***/ function(module, exports, __webpack_require__) {

		var upperCase = __webpack_require__(98)

		/**
		 * Upper case the first character of a string.
		 *
		 * @param  {String} str
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  if (str == null) {
		    return ''
		  }

		  str = String(str)

		  return upperCase(str.charAt(0), locale) + str.substr(1)
		}


	/***/ },
	/* 106 */
	/***/ function(module, exports, __webpack_require__) {

		var upperCase = __webpack_require__(98)
		var snakeCase = __webpack_require__(101)

		/**
		 * Constant case a string.
		 *
		 * @param  {String} string
		 * @param  {String} [locale]
		 * @return {String}
		 */
		module.exports = function (string, locale) {
		  return upperCase(snakeCase(string, locale), locale)
		}


	/***/ },
	/* 107 */
	/***/ function(module, exports, __webpack_require__) {

		var upperCase = __webpack_require__(98)

		/**
		 * Check if a string is upper case.
		 *
		 * @param  {String}  string
		 * @param  {String}  [locale]
		 * @return {Boolean}
		 */
		module.exports = function (string, locale) {
		  return upperCase(string, locale) === string
		}


	/***/ },
	/* 108 */
	/***/ function(module, exports, __webpack_require__) {

		var lowerCase = __webpack_require__(93)

		/**
		 * Check if a string is lower case.
		 *
		 * @param  {String}  string
		 * @param  {String}  [locale]
		 * @return {Boolean}
		 */
		module.exports = function (string, locale) {
		  return lowerCase(string, locale) === string
		}


	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {

		var lowerCase = __webpack_require__(93)

		/**
		 * Lower case the first character of a string.
		 *
		 * @param  {String} str
		 * @return {String}
		 */
		module.exports = function (str, locale) {
		  if (str == null) {
		    return ''
		  }

		  str = String(str)

		  return lowerCase(str.charAt(0), locale) + str.substr(1)
		}


	/***/ },
	/* 110 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(40);

	/***/ },
	/* 111 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../../typings/tsd.d.ts" />
		var HttpResponse = __webpack_require__(112);
		__webpack_require__(113);
		__webpack_require__(114);
		var lru = __webpack_require__(59);
		var globalCache = lru(50);
		//Function('', fs.readFileSync(require.resolve('./lib/worker.js'), 'utf8'));
		function doRequest(method, url, options) {
		    return null; //FIXME we need a better way to do it for now turn of support of fetching from url
		}
		function readFromCacheOrGet(url) {
		    var res = globalCache.get(url);
		    if (res) {
		        if (res == readFromCacheOrGet) {
		            return null;
		        }
		        return res;
		    }
		    try {
		        var res = doRequest("GET", url, { timeout: 3000, socketTimeout: 5000, retry: true });
		        res = new Buffer(res.body.data).toString();
		        globalCache.set(url, res);
		        return res;
		    }
		    catch (e) {
		        globalCache.set(url, readFromCacheOrGet);
		        return null;
		    }
		}
		exports.readFromCacheOrGet = readFromCacheOrGet;
		function readFromCacheOrGetAsync(url) {
		    return null;
		}
		exports.readFromCacheOrGetAsync = readFromCacheOrGetAsync;

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(69).Buffer))

	/***/ },
	/* 112 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(43);

	/***/ },
	/* 113 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(44);

	/***/ },
	/* 114 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(77);

	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../typings/tsd.d.ts" />
		var XMLHttpRequestConstructor = __webpack_require__(116).XMLHttpRequest;
		function buildXHR() {
		    var x = new XMLHttpRequestConstructor;
		    return x;
		}
		var SimpleExecutor = (function () {
		    function SimpleExecutor() {
		    }
		    SimpleExecutor.prototype.execute = function (req, doAppendParams) {
		        if (doAppendParams === void 0) { doAppendParams = true; }
		        var xhr = buildXHR();
		        var url = req.url;
		        if (doAppendParams) {
		            url = this.appendParams(req, req.url);
		        }
		        xhr.open(req.method, url, false);
		        this.doRequest(req, xhr);
		        //rheaders=xhr.getAllResponseHeaders();
		        var status = xhr.status;
		        if (status > 300 && status < 400) {
		            var locHeader = xhr.getResponseHeader('location');
		            if (locHeader) {
		                req.url = locHeader;
		                return this.execute(req, false);
		            }
		        }
		        var response = {
		            status: status,
		            statusText: xhr.statusText,
		            headers: xhr.getAllResponseHeaders().split('\n').map(function (x) {
		                var ind = x.indexOf(':');
		                return {
		                    name: x.substring(0, ind).trim(),
		                    value: x.substring(ind + 1).trim()
		                };
		            }),
		            content: {
		                text: xhr.responseText,
		                mimeType: xhr.responseType
		            }
		        };
		        return response;
		    };
		    SimpleExecutor.prototype.appendParams = function (req, url) {
		        var gotQueryParams = (req.queryString && req.queryString.length > 0);
		        if (gotQueryParams) {
		            url = url + '?';
		            var arr = [];
		            if (gotQueryParams) {
		                arr = arr.concat(req.queryString.map(function (q) {
		                    return encodeURIComponent(q.name) + '=' + encodeURIComponent(q.value);
		                }));
		            }
		            url += arr.join('&');
		        }
		        return url;
		    };
		    SimpleExecutor.prototype.log = function (varName, value) {
		    };
		    SimpleExecutor.prototype.executeAsync = function (req, doAppendParams) {
		        if (doAppendParams === void 0) { doAppendParams = true; }
		        var xhr = buildXHR();
		        var url = req.url;
		        if (doAppendParams) {
		            url = this.appendParams(req, req.url);
		        }
		        var outer = this;
		        return new Promise(function (resolve, reject) {
		            xhr.open(req.method, url, true);
		            xhr.onload = function () {
		                //rheaders=xhr.getAllResponseHeaders();
		                var status = xhr.status;
		                if (status > 300 && status < 400) {
		                    var locHeader = xhr.getResponseHeader('location');
		                    if (locHeader) {
		                        req.url = locHeader;
		                        return outer.executeAsync(req, false);
		                    }
		                }
		                var response = {
		                    status: status,
		                    statusText: xhr.statusText,
		                    headers: xhr.getAllResponseHeaders().split('\n').map(function (x) {
		                        var ind = x.indexOf(':');
		                        return {
		                            name: x.substring(0, ind).trim(),
		                            value: x.substring(ind + 1).trim()
		                        };
		                    }),
		                    content: {
		                        text: xhr.responseText,
		                        mimeType: xhr.responseType
		                    }
		                };
		                resolve(response);
		            };
		            xhr.onerror = function () {
		                reject(Error("Network Error"));
		            };
		            outer.doRequest(req, xhr);
		        });
		    };
		    SimpleExecutor.prototype.doRequest = function (req, xhr) {
		        // Make the request
		        if (req.headers) {
		            req.headers.forEach(function (x) { return xhr.setRequestHeader(x.name, x.value); });
		        }
		        if (req.postData) {
		            if (req.postData.params) {
		                var body = req.postData.params.map(function (p) { return encodeURIComponent(p.name) + '=' + encodeURIComponent(p.value); }).join('&');
		                xhr.send(body);
		            }
		            else {
		                xhr.send(req.postData.text);
		            }
		        }
		        else {
		            xhr.send();
		        }
		    };
		    return SimpleExecutor;
		})();
		exports.SimpleExecutor = SimpleExecutor;


	/***/ },
	/* 116 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(91);

	/***/ },
	/* 117 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(92);

	/***/ },
	/* 118 */
	/***/ function(module, exports) {

		module.exports = __webpack_require__(98);

	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var defs = __webpack_require__(3);
		var _ = __webpack_require__(4);
		var yaml = __webpack_require__(7);
		var typeExpression = __webpack_require__(51);
		var def = __webpack_require__(3);
		var hlimpl = __webpack_require__(5);
		var search = __webpack_require__(53);
		var universes = __webpack_require__(54);
		var services = __webpack_require__(49);
		var KeyMatcher = (function () {
		    function KeyMatcher(_props) {
		        this._props = _props;
		        this.parentValue = _.find(_props, function (x) { return x.isFromParentValue(); });
		        this.parentKey = _.find(_props, function (x) { return x.isFromParentKey(); });
		        this.canBeValue = _.find(_props, function (x) { return x.canBeValue(); });
		    }
		    KeyMatcher.prototype.match = function (key) {
		        var _this = this;
		        var _res = null;
		        var lastPref = "";
		        this._props.forEach(function (p) {
		            if (p.getAdapter(services.RAMLPropertyService).isSystem()) {
		                return;
		            }
		            if (p != _this.parentValue && p != _this.parentKey && p.matchKey(key)) {
		                if (p.keyPrefix() != null) {
		                    if (p.keyPrefix().length >= lastPref.length) {
		                        lastPref = p.keyPrefix();
		                        _res = p;
		                    }
		                }
		                else {
		                    _res = p;
		                    lastPref = p.nameId();
		                }
		            }
		        });
		        return _res;
		    };
		    return KeyMatcher;
		})();
		var deep = 0;
		function getAllOptions(c) {
		    if (deep > 20) {
		        return [];
		    }
		    deep++;
		    try {
		        var result = [];
		        var tp = c.leftType();
		        if (tp) {
		            result.push(tp);
		        }
		        var r = c.rightType();
		        if (r) {
		            if (r.isUnion()) {
		                var options = getAllOptions(r.union());
		                result = result.concat(options);
		            }
		            else {
		                result.push(r);
		            }
		        }
		        return result;
		    }
		    finally {
		        deep--;
		    }
		}
		var ad = 0;
		var BasicNodeBuilder = (function () {
		    function BasicNodeBuilder() {
		        this.shouldDescriminate = false;
		    }
		    BasicNodeBuilder.prototype.process = function (node, childrenToAdopt) {
		        var _this = this;
		        var nn = node.lowLevel();
		        var cha = nn._node ? nn._node : nn;
		        try {
		            if (cha['currentChildren']) {
		                return cha['currentChildren'];
		            }
		            if (!node.definition()) {
		                return;
		            }
		            if (node.parent() == null && (!this.shouldDescriminate)) {
		                this.shouldDescriminate = true;
		                try {
		                    var children = this.process(node, childrenToAdopt);
		                    var ts = node;
		                    ts._children = children;
		                    var t = doDescrimination(node);
		                    if (t) {
		                        ts.patchType(t);
		                    }
		                    var children = this.process(node, childrenToAdopt);
		                    ts._children = children;
		                }
		                finally {
		                    this.shouldDescriminate = false;
		                }
		            }
		            if (node.definition().isUnion()) {
		                if (true && (node.parent() && node.property().nameId() == universes.Universe10.RAMLLanguageElement.properties.annotations.name)) {
		                    var optins = getAllOptions(node.definition().union());
		                    var actualResult = null;
		                    var bestResult = null;
		                    var bestType = null;
		                    var bestCount = 1000;
		                    var llnode = node;
		                    optins.forEach(function (x) {
		                        if (!actualResult) {
		                            //TODO ADD UNION + Descriminator
		                            if (!(x).isUnion()) {
		                                var tp = llnode.patchType(x);
		                                if (ad == 0) {
		                                    ad++;
		                                    try {
		                                        var result = _this.process(node, childrenToAdopt);
		                                        var uc = 0;
		                                        for (var i = 0; i < result.length; i++) {
		                                            if (result[i].isUnknown()) {
		                                                uc++;
		                                            }
		                                        }
		                                        if (uc == 0) {
		                                            actualResult = result;
		                                        }
		                                        if (bestCount > uc) {
		                                            bestCount = uc;
		                                            bestResult = result;
		                                            bestType = x;
		                                        }
		                                    }
		                                    finally {
		                                        ad--;
		                                    }
		                                }
		                            }
		                        }
		                    });
		                    if (actualResult) {
		                        llnode.patchType(bestType);
		                        return actualResult;
		                    }
		                    if (bestResult) {
		                        llnode.patchType(bestType);
		                    }
		                }
		            }
		            var km = new KeyMatcher(node.definition().allProperties());
		            var aNode = node;
		            var allowsQuestion = aNode._allowQuestion || node.definition().getAdapter(services.RAMLService).getAllowQuestion();
		            var res = [];
		            //cha['currentChildren']=res;
		            if (km.parentKey) {
		                if (node.lowLevel().key()) {
		                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentKey.range(), km.parentKey, true));
		                }
		            }
		            if (node.lowLevel().value()) {
		                if (km.parentValue) {
		                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentValue.range(), km.parentValue));
		                }
		                else if (km.canBeValue) {
		                    var s = node.lowLevel().value();
		                    if (typeof s == 'string' && s.trim().length > 0) {
		                        if (km.canBeValue.nameId() == universes.Universe10.Resource.properties.signature.name) {
		                            if (s.trim().charAt(0) == '(') {
		                                //TODO BETTER DECITION current one prevents completion from working correctly
		                                //in few other cases
		                                res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
		                            }
		                        }
		                        else {
		                            res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
		                        }
		                    }
		                    else if (node.definition().isAssignableFrom(universes.Universe10.Annotation.name) && node.definition().property("value")) {
		                        //"value" is a magic property name we do not have reflected in serialized def. system, so have to use plain string
		                        var lowLevelNode = node.lowLevel();
		                        var valueAttribute = _.find(lowLevelNode.children(), function (child) {
		                            return child.kind() == 1 /* MAPPING */ && child.key() && child.key() == "value";
		                        });
		                        if (!valueAttribute) {
		                            //annotation reference is not a scalar and does not have value attribute, but has value defined in the annotation declaration
		                            //that means user wants to use a shortcut and specify value object directly under annotation
		                            var valueProperty = node.definition().property("value");
		                            //creating "value" high-level node referencing the same low-level node so the children can be collected
		                            var valueNode = new hlimpl.ASTNodeImpl(node.lowLevel(), node, valueProperty.range(), valueProperty);
		                            return [valueNode];
		                        }
		                    }
		                }
		            }
		            else {
		                if (km.canBeValue && (km.canBeValue.range() instanceof def.NodeClass || (km.canBeValue.range().isUnion() && node.definition().isAssignableFrom(universes.Universe10.Annotation.name)))) {
		                    //check check for annotation is just for safety, generally, imho, we should go inside for any unions
		                    var ch = new hlimpl.ASTNodeImpl(node.lowLevel(), aNode, km.canBeValue.range(), km.canBeValue);
		                    return [ch];
		                }
		            }
		            aNode._children = res;
		            if (!aNode.definition().getAdapter(services.RAMLService).isUserDefined()) {
		                if (aNode.definition().key() == universes.Universe08.Api || aNode.definition().key() == universes.Universe10.Api) {
		                    var uses = childrenToAdopt.filter(function (x) { return x.key() == "uses"; });
		                    res = this.processChildren(uses, aNode, res, allowsQuestion, km);
		                    var types = childrenToAdopt.filter(function (x) { return x.key() == "types"; });
		                    res = this.processChildren(types, aNode, res, allowsQuestion, km);
		                    var other = childrenToAdopt.filter(function (x) { return (x.key() != "types" && x.key() != "uses"); });
		                    res = this.processChildren(other, aNode, res, allowsQuestion, km);
		                }
		                else {
		                    res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
		                }
		            }
		            else {
		                res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
		            }
		            aNode._children = res;
		            return res;
		        }
		        finally {
		            if (ch) {
		                delete cha['currentChildren'];
		            }
		        }
		    };
		    BasicNodeBuilder.prototype.processChildren = function (childrenToAdopt, aNode, res, allowsQuestion, km) {
		        childrenToAdopt.forEach(function (x) {
		            var key = x.key();
		            if (allowsQuestion) {
		                if (key != null && key.charAt(key.length - 1) == '?') {
		                    key = key.substr(0, key.length - 1);
		                }
		            }
		            var p = key != null ? km.match(key) : null;
		            if (p != null) {
		                var range = p.range();
		                if (p.isAnnotation() && key != "annotations") {
		                    var pi = new hlimpl.ASTPropImpl(x, aNode, range, p);
		                    res.push(pi);
		                    return;
		                }
		                var um = false;
		                var multyValue = p.isMultiValue();
		                if (range instanceof def.Array) {
		                    var at = range;
		                    multyValue = true;
		                    range = at.component;
		                    um = true;
		                }
		                else if (range.isArray()) {
		                    multyValue = true;
		                    um = true;
		                }
		                //TODO DESCRIMINATORS
		                if (range.isValueType()) {
		                    var ch = x.children();
		                    var seq = (x.valueKind() == 3 /* SEQ */);
		                    if ((seq && ch.length > 0 || ch.length > 1) && multyValue) {
		                        ch.forEach(function (y) {
		                            var pi = new hlimpl.ASTPropImpl(y, aNode, range, p);
		                            res.push(pi);
		                        });
		                    }
		                    else {
		                        if (p.isInherited()) {
		                            aNode.setComputed(p.nameId(), x.value());
		                        }
		                        res.push(new hlimpl.ASTPropImpl(x, aNode, range, p));
		                    }
		                    //}
		                    return;
		                }
		                else {
		                    var rs = [];
		                    //now we need determine actual type
		                    aNode._children = res;
		                    if (!p.isMerged()) {
		                        if (multyValue) {
		                            if (p.getAdapter(services.RAMLPropertyService).isEmbedMap()) {
		                                var chld = x.children();
		                                if (chld.length == 0) {
		                                    if (x.value()) {
		                                        var bnode = new hlimpl.BasicASTNode(x, aNode);
		                                        bnode.knownProperty = p;
		                                        res.push(bnode);
		                                    }
		                                }
		                                chld.forEach(function (y) {
		                                    //TODO TRACK GROUP KEY
		                                    var cld = y.children();
		                                    if (!y.key() && cld.length == 1) {
		                                        var node = new hlimpl.ASTNodeImpl(cld[0], aNode, range, p);
		                                        node._allowQuestion = allowsQuestion;
		                                        rs.push(node);
		                                    }
		                                    else {
		                                        if (aNode.universe().version() == "RAML10") {
		                                            var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
		                                            node._allowQuestion = allowsQuestion;
		                                            rs.push(node);
		                                        }
		                                        else {
		                                            var bnode = new hlimpl.BasicASTNode(y, aNode);
		                                            res.push(bnode);
		                                            if (y.key()) {
		                                                bnode.needSequence = true;
		                                            }
		                                        }
		                                    }
		                                });
		                            }
		                            else {
		                                var filter = {};
		                                var inherited = [];
		                                if (range instanceof defs.NodeClass) {
		                                    var nc = range;
		                                    if (nc.getAdapter(services.RAMLService).getCanInherit().length > 0) {
		                                        nc.getAdapter(services.RAMLService).getCanInherit().forEach(function (v) {
		                                            var vl = aNode.computedValue(v);
		                                            if (vl && p.nameId() == universes.Universe10.Response.properties.body.name) {
		                                                if (!_.find(x.children(), function (x) { return x.key() == vl; })) {
		                                                    //we can create inherited node;
		                                                    var pc = aNode.parent().definition().key();
		                                                    var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
		                                                    if (pc == universes.Universe10.MethodBase || pc == universes.Universe08.MethodBase) {
		                                                        node.setComputed("form", "true"); //FIXME
		                                                    }
		                                                    var t = descriminate(p, aNode, node);
		                                                    if (t) {
		                                                        node.patchType(t);
		                                                    }
		                                                    var ch = node.children();
		                                                    //this are false unknowns actual unknowns will be reported by parent node
		                                                    node._children = ch.filter(function (x) { return !x.isUnknown(); });
		                                                    node._allowQuestion = allowsQuestion;
		                                                    inherited.push(node);
		                                                    node.children().forEach(function (x) {
		                                                        if (x.property().getAdapter(services.RAMLPropertyService).isKey()) {
		                                                            var atr = x;
		                                                            atr._computed = true;
		                                                            return;
		                                                        }
		                                                        if (x.isElement()) {
		                                                            if (!x.property().getAdapter(services.RAMLPropertyService).isMerged()) {
		                                                                filter[x.property().nameId()] = true;
		                                                            }
		                                                        }
		                                                        if (x.property().isAnnotation()) {
		                                                            var atr = x;
		                                                            var vl = atr.value();
		                                                            var strVal = "";
		                                                            if (vl instanceof hlimpl.StructuredValue) {
		                                                                strVal = vl.valueName();
		                                                            }
		                                                            else {
		                                                                strVal = "" + vl;
		                                                            }
		                                                            filter["(" + strVal + ")"] = true;
		                                                        }
		                                                        else {
		                                                            filter[x.name()] = true;
		                                                        }
		                                                    });
		                                                    node._computed = true;
		                                                }
		                                            }
		                                        });
		                                    }
		                                }
		                                var parsed = [];
		                                x.children().forEach(function (y) {
		                                    if (filter[y.key()]) {
		                                        return;
		                                    }
		                                    var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
		                                    var dc = p.domain().key();
		                                    if (p.nameId() == "body" && (dc == universes.Universe08.MethodBase || dc == universes.Universe10.MethodBase)) {
		                                        node.setComputed("form", "true"); //FIXME
		                                    }
		                                    node._allowQuestion = allowsQuestion;
		                                    parsed.push(node);
		                                });
		                                if (parsed.length > 0) {
		                                    parsed.forEach(function (x) { return rs.push(x); });
		                                }
		                                else {
		                                    inherited.forEach(function (x) { return rs.push(x); });
		                                }
		                            }
		                        }
		                        else {
		                            //var y=x.children()[0];
		                            rs.push(new hlimpl.ASTNodeImpl(x, aNode, range, p));
		                        }
		                    }
		                    else {
		                        var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
		                        node._allowQuestion = allowsQuestion;
		                        rs.push(node);
		                    }
		                    aNode._children = aNode._children.concat(rs);
		                    res = res.concat(rs);
		                    rs.forEach(function (x) {
		                        var rt = descriminate(p, aNode, x);
		                        if (rt && rt != x.definition()) {
		                            x.patchType(rt);
		                        }
		                        x._associatedDef = null;
		                        p.childRestrictions().forEach(function (y) {
		                            x.setComputed(y.name, y.value);
		                        });
		                        var def = x.definition();
		                    });
		                }
		            }
		            else {
		                res.push(new hlimpl.BasicASTNode(x, aNode));
		            }
		        });
		        return res;
		    };
		    return BasicNodeBuilder;
		})();
		exports.BasicNodeBuilder = BasicNodeBuilder;
		function desc1(p, parent, x) {
		    var tp = x.attr("type");
		    var value = "";
		    if (tp) {
		        var mn = {};
		        var c = new def.NodeClass(x.name(), x.definition().universe(), "");
		        c.getAdapter(services.RAMLService).setDeclaringNode(x);
		        c._superTypes.push(x.definition().universe().type(universes.Universe10.TypeDeclaration.name));
		        mn[tp.value()] = c;
		        var newType = typeExpression.getType(parent ? parent : x, tp.value(), mn);
		        if (newType instanceof def.Array) {
		            newType.getAdapter(services.RAMLService).setDeclaringNode(x);
		        }
		        return newType;
		    }
		    else {
		        if (p) {
		            if (p.nameId() == "body" || _.find(x.lowLevel().children(), function (x) { return x.key() == "properties"; })) {
		                return x.definition().universe().type(universes.Universe10.ObjectTypeDeclaration.name);
		            }
		        }
		        return x.definition().universe().type(universes.Universe10.StringTypeDeclaration.name);
		    }
		    return null;
		}
		function doDescrimination(node) {
		    return descriminate(node.property(), node.parent(), node);
		}
		exports.doDescrimination = doDescrimination;
		function descriminate(p, parent, x) {
		    var n = x.lowLevel();
		    if (p) {
		        if (p.nameId() == universes.Universe10.LibraryBase.properties.uses.name && p.range().nameId() == universes.Universe10.Library.name) {
		        }
		    }
		    var range = p ? p.range().nameId() : x.definition().nameId();
		    if (n._node && n._node['descriminate']) {
		        return null;
		    }
		    if (n._node) {
		        n._node['descriminate'] = 1;
		    }
		    try {
		        if (range == universes.Universe10.TypeDeclaration.name) {
		            var res = desc1(p, parent, x);
		            //FIXME (think about it later)
		            if (p) {
		                if (res != null && ((p.nameId() == universes.Universe10.MethodBase.properties.body.name || p.nameId() == universes.Universe10.Response.properties.headers.name) || p.nameId() == universes.Universe10.Method.properties.queryParameters.name)) {
		                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
		                    ares._superTypes.push(res);
		                    return ares;
		                }
		                if (res != null && (p.nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name)) {
		                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
		                    ares._superTypes.push(p.range().universe().type(universes.Universe10.AnnotationTypeDeclaration.name));
		                    ares._superTypes.push(res);
		                    return ares;
		                }
		            }
		            if (res) {
		                return res;
		            }
		        }
		        //generic case;
		        var rt = null;
		        if (p && parent) {
		            var types = search.findAllSubTypes(p, parent);
		            if (types.length > 0) {
		                types.forEach(function (y) {
		                    if (!rt) {
		                        if (y.getAdapter(services.RAMLService).match(x, rt)) {
		                            rt = y;
		                        }
		                    }
		                });
		            }
		            return rt;
		        }
		    }
		    finally {
		        if (n._node) {
		            delete n._node['descriminate'];
		        }
		    }
		}
		;


	/***/ },
	/* 120 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var jsyaml = __webpack_require__(15);
		var ll = __webpack_require__(10);
		var _ = __webpack_require__(4);
		var hlimpl = __webpack_require__(5);
		var services = __webpack_require__(49);
		function findLastAttributeIndex(n) {
		    var last = -1;
		    var children = n.lowLevel().children();
		    for (var i = 0; i < children.length; i++) {
		        var node = children[i];
		        if (!node.isMapping())
		            continue;
		        var name = node.asMapping().key.value;
		        var property = n.definition().property(name);
		        if (!property)
		            continue;
		        //console.log(property.name() + ': isval: ' + property.isValue() + '; multi: ' + property.isMultiValue() + '; range val: ' + property.range().isValueType());
		        //if((property.isValue() || /*property.isMultiValue()) ||*/ property.range().isValueType()) {
		        if (property.isFromParentValue() || property.range().isValueType()) {
		            last = i;
		        }
		    }
		    //console.log('last attr index1: ' + last);
		    return last;
		}
		function findInsertionPointLowLevel(node, llnode, property, attr) {
		    //console.log('LL find insertion: node is attr: ' + attr);
		    var insertionPoint = null;
		    var embed = property && property.getAdapter(services.RAMLPropertyService).isEmbedMap();
		    if (embed && _.find(node.lowLevel().children(), function (x) { return x.key() == property.nameId(); })) {
		        embed = false;
		    }
		    if (attr || embed) {
		        var last = findLastAttribute(node);
		        if (!last) {
		            //insertionPoint = new jsyaml.InsertionPoint(jsyaml.InsertionPointType.START);
		            insertionPoint = jsyaml.InsertionPoint.atStart();
		        }
		        else {
		            insertionPoint = last;
		        }
		    }
		    return insertionPoint;
		}
		function findInsertionPoint(where, node) {
		    //console.log('find insertion point for node (HL): ' + node.property().name() + '; attr: ' + node.isAttr());
		    //console.log('node1: ' + node.lowLevel().text());
		    //always insert attributes at start
		    if (!where.isStub()) {
		        where.clearChildrenCache();
		    }
		    var ch = where.children();
		    var embed = node.property() && node.property().getAdapter(services.RAMLPropertyService).isEmbedMap();
		    if (embed && _.find(where.lowLevel().children(), function (x) { return x.key() == node.property().nameId(); })) {
		        embed = false;
		    }
		    //console.log('node2: ' + node.lowLevel().text());
		    if (node.isAttr() || embed) {
		        var toRet = null;
		        for (var i = 0; i < ch.length; i++) {
		            if (!ch[i].isAttr()) {
		                break;
		            }
		            else {
		                toRet = ch[i].lowLevel();
		            }
		        }
		        if (toRet == null) {
		            toRet = where.lowLevel();
		        }
		        return toRet;
		    }
		    else {
		        var pname = node.property().nameId();
		        var cls = where.definition();
		        var props = cls.allProperties();
		        //console.log('class: ' + cls.name());
		        //props.forEach(x=> console.log('  prop: ' + x.name()));
		        var pindex = cls.propertyIndex(pname);
		        if (pindex < 0) {
		            return null;
		        }
		        var llchilds = where.lowLevel().children();
		        for (var i = 0; i < llchilds.length; i++) {
		            var llch = llchilds[i];
		            //console.log('  child: ' + llch.kindName());
		            if (!llch.isMapping())
		                continue;
		            var cpnme = llch.asMapping().key.value;
		            var pi = cls.propertyIndex(cpnme);
		            //console.log('  property: ' + cpnme + ' index: ' + pi + ' at pos: ' + i);
		            if (pi > pindex) {
		                //console.log('  property: ' + cpnme + ' - found');
		                var lastok = i - 1;
		                //console.log('lastok: ' + lastok);
		                if (lastok < 0) {
		                    //TODO insert at the very beginning
		                    //console.log('insert to very beginning');
		                    return null;
		                }
		                else {
		                    console.log('insert to node: ' + lastok);
		                    return llchilds[lastok];
		                }
		            }
		            else {
		            }
		        }
		        return null;
		    }
		    //console.log('HL insertion: ' + toRet);
		    //return toRet;
		}
		function removeNodeFrom(source, node) {
		    if (source.isStub()) {
		        if (node instanceof hlimpl.ASTNodeImpl) {
		            var cm = node;
		            if (cm.isInEdit) {
		                return;
		            }
		        }
		        if (!source._children) {
		            return;
		        }
		        source._children = source._children.filter(function (x) { return x != node; });
		        return;
		    }
		    var command = new ll.CompositeCommand();
		    if (node instanceof hlimpl.ASTNodeImpl) {
		        var aNode = node;
		        if (!aNode.property().getAdapter(services.RAMLPropertyService).isMerged()) {
		            if (source.elementsOfKind(aNode.property().nameId()).length == 1) {
		                command.commands.push(ll.removeNode(source.lowLevel(), aNode.lowLevel().parent().parent()));
		            }
		            else {
		                command.commands.push(ll.removeNode(source.lowLevel(), aNode.lowLevel()));
		            }
		        }
		        else {
		            command.commands.push(ll.removeNode(source.lowLevel(), aNode.lowLevel()));
		        }
		    }
		    else {
		        command.commands.push(ll.removeNode(source.lowLevel(), node.lowLevel()));
		    }
		    source.lowLevel().execute(command);
		}
		exports.removeNodeFrom = removeNodeFrom;
		function initEmptyRAMLFile(node) {
		    var llroot = node.lowLevel().root();
		    var command = new ll.CompositeCommand();
		    var newroot = jsyaml.createMap([]);
		    command.commands.push(ll.initRamlFile(node.lowLevel(), newroot));
		    node.lowLevel().execute(command);
		    var root = node.root();
		    //console.log('root: ' + root);
		    root._node = newroot;
		    root.clearChildrenCache();
		}
		exports.initEmptyRAMLFile = initEmptyRAMLFile;
		function setValue(node, value) {
		    if (value == node.value())
		        return;
		    var c = new ll.CompositeCommand();
		    if (typeof value === 'string') {
		        var val = value;
		        //FIXME actually isFromParentKey should be enough in future does not changing it now for safety reasons
		        if (node.property().isFromParentKey() || node.property().isAnnotation()) {
		            if (node.property().isAnnotation()) {
		                val = '(' + val + ')';
		            }
		            c.commands.push(ll.setKey(node.lowLevel(), val));
		        }
		        else {
		            if ((!val || val.length == 0) && !node.isEmbedded()) {
		                c.commands.push(ll.removeNode(node.lowLevel().parent(), node.lowLevel()));
		                node.parent().clearChildrenCache();
		            }
		            else {
		                if (!val)
		                    val = '';
		                c.commands.push(ll.setAttr(node.lowLevel(), val));
		            }
		        }
		    }
		    else {
		        if (node.property().isFromParentKey()) {
		            throw new Error("couldn't set structured value to a key: " + node.property().nameId());
		        }
		        var sval = value;
		        c.commands.push(ll.setAttrStructured(node.lowLevel(), sval));
		    }
		    node.lowLevel().execute(c);
		}
		exports.setValue = setValue;
		function addStringValue(attr, value) {
		    var sc = jsyaml.createScalar(value);
		    var target = attr.lowLevel();
		    //console.log('add to target: ' + target.kindName());
		    if (target.isScalar()) {
		        target = target.parent();
		    }
		    else if (target.isMapping()) {
		    }
		    var command = new ll.CompositeCommand();
		    command.commands.push(ll.insertNode(target, sc, null, true));
		    attr.lowLevel().execute(command);
		    attr.parent().clearChildrenCache();
		}
		exports.addStringValue = addStringValue;
		function addStructuredValue(attr, sv) {
		    //var sc = jsyaml.createScalar(value);
		    var target = attr.lowLevel();
		    //console.log('add to target: ' + target.kindName());
		    if (target.isScalar()) {
		        target = target.parent();
		    }
		    else if (target.isMapping()) {
		        var ln = attr.lowLevel();
		    }
		    var command = new ll.CompositeCommand();
		    command.commands.push(ll.insertNode(target, sv.lowLevel(), null, true));
		    attr.lowLevel().execute(command);
		    attr.parent().clearChildrenCache();
		}
		exports.addStructuredValue = addStructuredValue;
		function removeAttr(attr) {
		    var llparent = attr.lowLevel().parent();
		    if (!attr.property().isMultiValue() && attr.isEmbedded()) {
		        // it's embedded value, need to clean scalar instead
		        //console.log('embedded!');
		        attr.setValue('');
		    }
		    else {
		        var command = new ll.CompositeCommand();
		        command.commands.push(ll.removeNode(llparent, attr.lowLevel()));
		        attr.lowLevel().execute(command);
		        attr.parent().clearChildrenCache();
		    }
		}
		exports.removeAttr = removeAttr;
		function setValues(attr, values) {
		    if (!attr.property().isMultiValue())
		        throw new Error("setValue(string[]) only apply to multi-values properties");
		    var node = attr.parent();
		    if (attr.isEmpty()) {
		    }
		    else {
		        var llnode = node.lowLevel();
		        var attrs = node.attributes(attr.name());
		        attrs.forEach(function (attr) { return attr.remove(); });
		    }
		    values.forEach(function (val) { return node.attrOrCreate(attr.name()).addValue(val); });
		}
		exports.setValues = setValues;
		function setKey(node, value) {
		    if (value == node.name())
		        return;
		    var c = new ll.CompositeCommand();
		    c.commands.push(ll.setKey(node.lowLevel(), value));
		    node.lowLevel().execute(c);
		}
		exports.setKey = setKey;
		function createAttr(node, n, v) {
		    var mapping = jsyaml.createMapping(n, v);
		    //console.log('create attribute: ' + n);
		    if (node.isStub()) {
		        //console.log('create-attr: stub case');
		        var insertionIndex = findLastAttributeIndex(node);
		        //console.log('stub insertion index: ' + insertionIndex);
		        node.lowLevel().addChild(mapping, insertionIndex + 1);
		    }
		    else {
		        //console.log('root: ' + llroot.kindName());
		        if (node.isEmptyRamlFile()) {
		            node.initRamlFile();
		        }
		        //console.log('create-attr: real node case');
		        //node._node.addChild(mapping);
		        //node.clearChildrenCache();
		        var command = new ll.CompositeCommand();
		        var insertionPoint = findInsertionPointLowLevel(node, mapping, node.definition().property(n), true);
		        //command.commands.push(ll.insertNode(node.lowLevel(), mapping, null));
		        //var toseq = node.property().isMultiValue();
		        command.commands.push(ll.insertNode(node.lowLevel(), mapping, insertionPoint));
		        node.lowLevel().execute(command);
		    }
		    node.clearChildrenCache();
		}
		exports.createAttr = createAttr;
		function findLastAttribute(node) {
		    var childs = node.lowLevel().children();
		    var index = findLastAttributeIndex(node);
		    //console.log('last attr index2: ' + index);
		    return (index < 0) ? null : childs[index];
		}
		function addToNode(target, node) {
		    if (!target.isStub() && target.isEmptyRamlFile()) {
		        target.initRamlFile();
		    }
		    var llnode = node.lowLevel();
		    if (!target._children) {
		        target._children = [];
		    }
		    if (!node.property()) {
		        //now we should find correct property;
		        var an = node;
		        var allProps = target.definition().allProperties();
		        var cp = null;
		        allProps.forEach(function (x) {
		            var r = x.range();
		            if (r == an.definition()) {
		                cp = x;
		            }
		            var isOk = _.find(an.definition().allSuperTypes(), function (x) { return x == r; });
		            if (isOk) {
		                cp = x;
		            }
		        });
		        if (!cp) {
		            throw new Error("Unable to find correct child");
		        }
		        else {
		            an.patchProp(cp);
		        }
		    }
		    var insertionPoint = findInsertionPoint(target, node);
		    //console.log('high level op: ' + target.property() + '.add ' + node.property().name());
		    if (insertionPoint) {
		    }
		    //var newLowLevel:ll.ILowLevelASTNode=null;
		    var command = new ll.CompositeCommand();
		    //now we need to understand to which low level node it should go
		    //command.commands.push(ll.insertNode(target.lowLevel(), node.lowLevel()))
		    var insertionTarget = null;
		    if (node.property().getAdapter(services.RAMLPropertyService).isMerged() || node.property().range().isValueType()) {
		        //console.log('CASE 1');
		        //newLowLevel = node.lowLevel();
		        command.commands.push(ll.insertNode(target.lowLevel(), node.lowLevel(), insertionPoint));
		        insertionTarget = target.lowLevel();
		    }
		    else {
		        //console.log('CASE 2');
		        var name = node.property().nameId();
		        var target2 = target.lowLevel();
		        //target.show('TARGET:');
		        //llnode.show('NODE:');
		        var found = target.lowLevel().find(name);
		        insertionTarget = found;
		        if (!found) {
		            //console.log('node not found');
		            var nn = null;
		            //var nn: jsyaml.ASTNode = jsyaml.createSeqNode(name);
		            //var mapping = <yaml.YAMLMapping>nn._actualNode();
		            //var seq: yaml.YAMLSequence = <yaml.YAMLSequence>mapping.value;
		            //if(!seq.items) seq.items = [];
		            //seq.items.push((<jsyaml.ASTNode>node.lowLevel())._actualNode());
		            if (node.property().getAdapter(services.RAMLPropertyService).isEmbedMap()) {
		                var v10 = target.definition().universe().version() == 'RAML10';
		                if (llnode.isValueMap() && v10)
		                    nn = jsyaml.createMapNode(name);
		                else
		                    nn = jsyaml.createSeqNode(name);
		                //console.log('NN: ' + yaml.Kind[nn._actualNode().kind]);
		                nn.addChild(node.lowLevel());
		            }
		            else {
		                nn = jsyaml.createNode(name);
		                nn.addChild(node.lowLevel());
		            }
		            //nn.show('WRAPPED NODE:');
		            //target.show('INSERT WRAPPED NODE TO:');
		            command.commands.push(ll.insertNode(target2, nn, insertionPoint));
		            insertionTarget = target2;
		        }
		        else {
		            //console.log('node found');
		            //found.show('INSERT2: ');
		            if (node.property().getAdapter(services.RAMLPropertyService).isEmbedMap()) {
		                //newLowLevel=node.lowLevel();
		                command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, true));
		            }
		            else {
		                //newLowLevel=node.lowLevel();
		                command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, false));
		            }
		        }
		    }
		    if (target.isStub()) {
		        var insertionIndex = findLastAttributeIndex(target);
		        if (insertionIndex < 0) {
		            target._children.push(node);
		        }
		        else {
		            //TODO behavior should be smarter we are ignoring insertion points now
		            target._children.splice(insertionIndex, 0, node);
		        }
		        command.commands.forEach(function (x) { return insertionTarget.addChild(x.value); });
		        return;
		    }
		    target.lowLevel().execute(command);
		    target._children.push(node);
		    //now we need to add new child to our children;
		    node.setParent(target);
		}
		exports.addToNode = addToNode;


	/***/ },
	/* 121 */
	/***/ function(module, exports, __webpack_require__) {

		var factory10 = __webpack_require__(122);
		var factory08 = __webpack_require__(123);
		function buildWrapperNode(node) {
		    var ramlVersion = node.definition().universe().version();
		    if (ramlVersion == 'RAML10') {
		        return factory10.buildWrapperNode(node);
		    }
		    else if (ramlVersion == 'RAML08') {
		        return factory08.buildWrapperNode(node);
		    }
		    return null;
		}
		exports.buildWrapperNode = buildWrapperNode;


	/***/ },
	/* 122 */
	/***/ function(module, exports, __webpack_require__) {

		var RamlWrapper = __webpack_require__(1);
		/**
		 * @hidden
		 * Build Wrapper node corresponding to the High Level node
		 **/
		function buildWrapperNode(node) {
		    var nodeClassName = node.definition().nameId();
		    var wrapperConstructor = classMap[nodeClassName];
		    if (!wrapperConstructor) {
		        var m = node.definition().allSuperTypes();
		        var wr = null;
		        for (var i = 0; i < m.length; i++) {
		            var nm = m[i].nameId();
		            wrapperConstructor = classMap[nm];
		            if (nm == "DataElement") {
		                wr = nm;
		                continue;
		            }
		            if (nm == "RAMLLanguageElement") {
		                continue;
		            }
		            if (wrapperConstructor) {
		                break;
		            }
		        }
		        if (!wrapperConstructor) {
		            wr = nm;
		        }
		    }
		    if (!wrapperConstructor) {
		        wrapperConstructor = classMap["RAMLLanguageElement"];
		    }
		    return wrapperConstructor(node);
		}
		exports.buildWrapperNode = buildWrapperNode;
		var classMap = {
		    "AbstractSecurityScheme": function (x) {
		        return new RamlWrapper.AbstractSecuritySchemeImpl(x);
		    },
		    "AnnotationRef": function (x) {
		        return new RamlWrapper.AnnotationRefImpl(x);
		    },
		    "AnnotationTarget": function (x) {
		        return new RamlWrapper.AnnotationTargetImpl(x);
		    },
		    "AnnotationTypeDeclaration": function (x) {
		        return new RamlWrapper.AnnotationTypeDeclarationImpl(x);
		    },
		    "Api": function (x) {
		        return new RamlWrapper.ApiImpl(x);
		    },
		    "ApiDescription": function (x) {
		        return new RamlWrapper.ApiDescriptionImpl(x);
		    },
		    "ArrayTypeDeclaration": function (x) {
		        return new RamlWrapper.ArrayTypeDeclarationImpl(x);
		    },
		    "BasicSecurityScheme": function (x) {
		        return new RamlWrapper.BasicSecuritySchemeImpl(x);
		    },
		    "BooleanType": function (x) {
		        return new RamlWrapper.BooleanTypeImpl(x);
		    },
		    "BooleanTypeDeclaration": function (x) {
		        return new RamlWrapper.BooleanTypeDeclarationImpl(x);
		    },
		    "CallbackAPIDescription": function (x) {
		        return new RamlWrapper.CallbackAPIDescriptionImpl(x);
		    },
		    "ContentType": function (x) {
		        return new RamlWrapper.ContentTypeImpl(x);
		    },
		    "CustomSecurityScheme": function (x) {
		        return new RamlWrapper.CustomSecuritySchemeImpl(x);
		    },
		    "DataElementRef": function (x) {
		        return new RamlWrapper.DataElementRefImpl(x);
		    },
		    "DateFormatSpec": function (x) {
		        return new RamlWrapper.DateFormatSpecImpl(x);
		    },
		    "DateTypeDeclaration": function (x) {
		        return new RamlWrapper.DateTypeDeclarationImpl(x);
		    },
		    "DigestSecurityScheme": function (x) {
		        return new RamlWrapper.DigestSecuritySchemeImpl(x);
		    },
		    "DocumentationItem": function (x) {
		        return new RamlWrapper.DocumentationItemImpl(x);
		    },
		    "ExampleSpec": function (x) {
		        return new RamlWrapper.ExampleSpecImpl(x);
		    },
		    "ExampleString": function (x) {
		        return new RamlWrapper.ExampleStringImpl(x);
		    },
		    "Extension": function (x) {
		        return new RamlWrapper.ExtensionImpl(x);
		    },
		    "FileTypeDeclaration": function (x) {
		        return new RamlWrapper.FileTypeDeclarationImpl(x);
		    },
		    "FixedUriString": function (x) {
		        return new RamlWrapper.FixedUriStringImpl(x);
		    },
		    "FullUriTemplateString": function (x) {
		        return new RamlWrapper.FullUriTemplateStringImpl(x);
		    },
		    "FunctionalInterface": function (x) {
		        return new RamlWrapper.FunctionalInterfaceImpl(x);
		    },
		    "GlobalSchema": function (x) {
		        return new RamlWrapper.GlobalSchemaImpl(x);
		    },
		    "HasNormalParameters": function (x) {
		        return new RamlWrapper.HasNormalParametersImpl(x);
		    },
		    "ImportDeclaration": function (x) {
		        return new RamlWrapper.ImportDeclarationImpl(x);
		    },
		    "IntegerTypeDeclaration": function (x) {
		        return new RamlWrapper.IntegerTypeDeclarationImpl(x);
		    },
		    "JSonSchemaString": function (x) {
		        return new RamlWrapper.JSonSchemaStringImpl(x);
		    },
		    "Library": function (x) {
		        return new RamlWrapper.LibraryImpl(x);
		    },
		    "LibraryBase": function (x) {
		        return new RamlWrapper.LibraryBaseImpl(x);
		    },
		    "LocationKind": function (x) {
		        return new RamlWrapper.LocationKindImpl(x);
		    },
		    "MarkdownString": function (x) {
		        return new RamlWrapper.MarkdownStringImpl(x);
		    },
		    "Method": function (x) {
		        return new RamlWrapper.MethodImpl(x);
		    },
		    "MethodBase": function (x) {
		        return new RamlWrapper.MethodBaseImpl(x);
		    },
		    "MimeType": function (x) {
		        return new RamlWrapper.MimeTypeImpl(x);
		    },
		    "ModelLocation": function (x) {
		        return new RamlWrapper.ModelLocationImpl(x);
		    },
		    "NumberType": function (x) {
		        return new RamlWrapper.NumberTypeImpl(x);
		    },
		    "NumberTypeDeclaration": function (x) {
		        return new RamlWrapper.NumberTypeDeclarationImpl(x);
		    },
		    "OAuth1SecurityScheme": function (x) {
		        return new RamlWrapper.OAuth1SecuritySchemeImpl(x);
		    },
		    "OAuth1SecuritySchemeSettings": function (x) {
		        return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x);
		    },
		    "OAuth2SecurityScheme": function (x) {
		        return new RamlWrapper.OAuth2SecuritySchemeImpl(x);
		    },
		    "OAuth2SecuritySchemeSettings": function (x) {
		        return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x);
		    },
		    "ObjectTypeDeclaration": function (x) {
		        return new RamlWrapper.ObjectTypeDeclarationImpl(x);
		    },
		    "Overlay": function (x) {
		        return new RamlWrapper.OverlayImpl(x);
		    },
		    "PassThroughSecurityScheme": function (x) {
		        return new RamlWrapper.PassThroughSecuritySchemeImpl(x);
		    },
		    "PassThroughSecuritySchemeSettings": function (x) {
		        return new RamlWrapper.PassThroughSecuritySchemeSettingsImpl(x);
		    },
		    "RAMLExpression": function (x) {
		        return new RamlWrapper.RAMLExpressionImpl(x);
		    },
		    "RAMLLanguageElement": function (x) {
		        return new RamlWrapper.RAMLLanguageElementImpl(x);
		    },
		    "RAMLPointer": function (x) {
		        return new RamlWrapper.RAMLPointerImpl(x);
		    },
		    "RAMLPointerElement": function (x) {
		        return new RamlWrapper.RAMLPointerElementImpl(x);
		    },
		    "RAMLProject": function (x) {
		        return new RamlWrapper.RAMLProjectImpl(x);
		    },
		    "RAMLSelector": function (x) {
		        return new RamlWrapper.RAMLSelectorImpl(x);
		    },
		    "RAMLSimpleElement": function (x) {
		        return new RamlWrapper.RAMLSimpleElementImpl(x);
		    },
		    "Reference": function (x) {
		        return new RamlWrapper.ReferenceImpl(x);
		    },
		    "RelativeUriString": function (x) {
		        return new RamlWrapper.RelativeUriStringImpl(x);
		    },
		    "Resource": function (x) {
		        return new RamlWrapper.ResourceImpl(x);
		    },
		    "ResourceBase": function (x) {
		        return new RamlWrapper.ResourceBaseImpl(x);
		    },
		    "ResourceType": function (x) {
		        return new RamlWrapper.ResourceTypeImpl(x);
		    },
		    "ResourceTypeRef": function (x) {
		        return new RamlWrapper.ResourceTypeRefImpl(x);
		    },
		    "Response": function (x) {
		        return new RamlWrapper.ResponseImpl(x);
		    },
		    "SchemaElement": function (x) {
		        return new RamlWrapper.SchemaElementImpl(x);
		    },
		    "SchemaString": function (x) {
		        return new RamlWrapper.SchemaStringImpl(x);
		    },
		    "ScriptHookElement": function (x) {
		        return new RamlWrapper.ScriptHookElementImpl(x);
		    },
		    "ScriptSpec": function (x) {
		        return new RamlWrapper.ScriptSpecImpl(x);
		    },
		    "SecuritySchemaType": function (x) {
		        return new RamlWrapper.SecuritySchemaTypeImpl(x);
		    },
		    "SecuritySchemePart": function (x) {
		        return new RamlWrapper.SecuritySchemePartImpl(x);
		    },
		    "SecuritySchemeRef": function (x) {
		        return new RamlWrapper.SecuritySchemeRefImpl(x);
		    },
		    "SecuritySchemeSettings": function (x) {
		        return new RamlWrapper.SecuritySchemeSettingsImpl(x);
		    },
		    "StatusCodeString": function (x) {
		        return new RamlWrapper.StatusCodeStringImpl(x);
		    },
		    "StringType": function (x) {
		        return new RamlWrapper.StringTypeImpl(x);
		    },
		    "StringTypeDeclaration": function (x) {
		        return new RamlWrapper.StringTypeDeclarationImpl(x);
		    },
		    "Trait": function (x) {
		        return new RamlWrapper.TraitImpl(x);
		    },
		    "TraitRef": function (x) {
		        return new RamlWrapper.TraitRefImpl(x);
		    },
		    "TypeDeclaration": function (x) {
		        return new RamlWrapper.TypeDeclarationImpl(x);
		    },
		    "UnionTypeDeclaration": function (x) {
		        return new RamlWrapper.UnionTypeDeclarationImpl(x);
		    },
		    "UriTemplate": function (x) {
		        return new RamlWrapper.UriTemplateImpl(x);
		    },
		    "ValidityExpression": function (x) {
		        return new RamlWrapper.ValidityExpressionImpl(x);
		    },
		    "ValueType": function (x) {
		        return new RamlWrapper.ValueTypeImpl(x);
		    },
		    "ValueTypeDeclaration": function (x) {
		        return new RamlWrapper.ValueTypeDeclarationImpl(x);
		    },
		    "XMLSchemaString": function (x) {
		        return new RamlWrapper.XMLSchemaStringImpl(x);
		    },
		    "pointer": function (x) {
		        return new RamlWrapper.pointerImpl(x);
		    }
		};


	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {

		var RamlWrapper = __webpack_require__(74);
		/**
		 * @hidden
		 * Build Wrapper node corresponding to the High Level node
		 **/
		function buildWrapperNode(node) {
		    var nodeClassName = node.definition().nameId();
		    var wrapperConstructor = classMap[nodeClassName];
		    if (!wrapperConstructor) {
		        var m = node.definition().allSuperTypes();
		        var wr = null;
		        for (var i = 0; i < m.length; i++) {
		            var nm = m[i].nameId();
		            wrapperConstructor = classMap[nm];
		            if (nm == "DataElement") {
		                wr = nm;
		                continue;
		            }
		            if (nm == "RAMLLanguageElement") {
		                continue;
		            }
		            if (wrapperConstructor) {
		                break;
		            }
		        }
		        if (!wrapperConstructor) {
		            wr = nm;
		        }
		    }
		    if (!wrapperConstructor) {
		        wrapperConstructor = classMap["RAMLLanguageElement"];
		    }
		    return wrapperConstructor(node);
		}
		exports.buildWrapperNode = buildWrapperNode;
		var classMap = {
		    "Api": function (x) {
		        return new RamlWrapper.ApiImpl(x);
		    },
		    "BodyLike": function (x) {
		        return new RamlWrapper.BodyLikeImpl(x);
		    },
		    "BooleanType": function (x) {
		        return new RamlWrapper.BooleanTypeImpl(x);
		    },
		    "BooleanTypeDeclaration": function (x) {
		        return new RamlWrapper.BooleanTypeDeclarationImpl(x);
		    },
		    "DateTypeDeclaration": function (x) {
		        return new RamlWrapper.DateTypeDeclarationImpl(x);
		    },
		    "DocumentationItem": function (x) {
		        return new RamlWrapper.DocumentationItemImpl(x);
		    },
		    "ExampleString": function (x) {
		        return new RamlWrapper.ExampleStringImpl(x);
		    },
		    "FileTypeDeclaration": function (x) {
		        return new RamlWrapper.FileTypeDeclarationImpl(x);
		    },
		    "FixedUri": function (x) {
		        return new RamlWrapper.FixedUriImpl(x);
		    },
		    "FullUriTemplateString": function (x) {
		        return new RamlWrapper.FullUriTemplateStringImpl(x);
		    },
		    "GlobalSchema": function (x) {
		        return new RamlWrapper.GlobalSchemaImpl(x);
		    },
		    "HasNormalParameters": function (x) {
		        return new RamlWrapper.HasNormalParametersImpl(x);
		    },
		    "IntegerTypeDeclaration": function (x) {
		        return new RamlWrapper.IntegerTypeDeclarationImpl(x);
		    },
		    "JSONBody": function (x) {
		        return new RamlWrapper.JSONBodyImpl(x);
		    },
		    "JSONExample": function (x) {
		        return new RamlWrapper.JSONExampleImpl(x);
		    },
		    "JSonSchemaString": function (x) {
		        return new RamlWrapper.JSonSchemaStringImpl(x);
		    },
		    "MarkdownString": function (x) {
		        return new RamlWrapper.MarkdownStringImpl(x);
		    },
		    "Method": function (x) {
		        return new RamlWrapper.MethodImpl(x);
		    },
		    "MethodBase": function (x) {
		        return new RamlWrapper.MethodBaseImpl(x);
		    },
		    "MimeType": function (x) {
		        return new RamlWrapper.MimeTypeImpl(x);
		    },
		    "NumberType": function (x) {
		        return new RamlWrapper.NumberTypeImpl(x);
		    },
		    "NumberTypeDeclaration": function (x) {
		        return new RamlWrapper.NumberTypeDeclarationImpl(x);
		    },
		    "OAuth1SecuritySchemeSettings": function (x) {
		        return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x);
		    },
		    "OAuth2SecuritySchemeSettings": function (x) {
		        return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x);
		    },
		    "Parameter": function (x) {
		        return new RamlWrapper.ParameterImpl(x);
		    },
		    "ParameterLocation": function (x) {
		        return new RamlWrapper.ParameterLocationImpl(x);
		    },
		    "RAMLLanguageElement": function (x) {
		        return new RamlWrapper.RAMLLanguageElementImpl(x);
		    },
		    "RAMLSimpleElement": function (x) {
		        return new RamlWrapper.RAMLSimpleElementImpl(x);
		    },
		    "Reference": function (x) {
		        return new RamlWrapper.ReferenceImpl(x);
		    },
		    "RelativeUriString": function (x) {
		        return new RamlWrapper.RelativeUriStringImpl(x);
		    },
		    "Resource": function (x) {
		        return new RamlWrapper.ResourceImpl(x);
		    },
		    "ResourceType": function (x) {
		        return new RamlWrapper.ResourceTypeImpl(x);
		    },
		    "ResourceTypeRef": function (x) {
		        return new RamlWrapper.ResourceTypeRefImpl(x);
		    },
		    "Response": function (x) {
		        return new RamlWrapper.ResponseImpl(x);
		    },
		    "SchemaString": function (x) {
		        return new RamlWrapper.SchemaStringImpl(x);
		    },
		    "SecuritySchema": function (x) {
		        return new RamlWrapper.SecuritySchemaImpl(x);
		    },
		    "SecuritySchemaPart": function (x) {
		        return new RamlWrapper.SecuritySchemaPartImpl(x);
		    },
		    "SecuritySchemaRef": function (x) {
		        return new RamlWrapper.SecuritySchemaRefImpl(x);
		    },
		    "SecuritySchemaSettings": function (x) {
		        return new RamlWrapper.SecuritySchemaSettingsImpl(x);
		    },
		    "StatusCodeString": function (x) {
		        return new RamlWrapper.StatusCodeStringImpl(x);
		    },
		    "StringType": function (x) {
		        return new RamlWrapper.StringTypeImpl(x);
		    },
		    "StringTypeDeclaration": function (x) {
		        return new RamlWrapper.StringTypeDeclarationImpl(x);
		    },
		    "Trait": function (x) {
		        return new RamlWrapper.TraitImpl(x);
		    },
		    "TraitRef": function (x) {
		        return new RamlWrapper.TraitRefImpl(x);
		    },
		    "UriTemplate": function (x) {
		        return new RamlWrapper.UriTemplateImpl(x);
		    },
		    "ValueType": function (x) {
		        return new RamlWrapper.ValueTypeImpl(x);
		    },
		    "XMLBody": function (x) {
		        return new RamlWrapper.XMLBodyImpl(x);
		    },
		    "XMLExample": function (x) {
		        return new RamlWrapper.XMLExampleImpl(x);
		    },
		    "XMLSchemaString": function (x) {
		        return new RamlWrapper.XMLSchemaStringImpl(x);
		    }
		};


	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {

		/// <reference path="../../../typings/tsd.d.ts" />
		var __extends = this.__extends || function (d, b) {
		    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
		    function __() { this.constructor = d; }
		    __.prototype = b.prototype;
		    d.prototype = new __();
		};
		var _ = __webpack_require__(4);
		var sel = __webpack_require__(125);
		var Selector = (function () {
		    function Selector() {
		    }
		    Selector.prototype.candidates = function (context) {
		        return context;
		    };
		    Selector.prototype.apply = function (h) {
		        return this.candidates([h]);
		    };
		    return Selector;
		})();
		exports.Selector = Selector;
		var OrMatch = (function (_super) {
		    __extends(OrMatch, _super);
		    function OrMatch(left, right) {
		        _super.call(this);
		        this.left = left;
		        this.right = right;
		    }
		    OrMatch.prototype.candidates = function (context) {
		        var l = this.left.candidates(context);
		        l = l.concat(this.right.candidates(context));
		        return _.unique(l);
		    };
		    return OrMatch;
		})(Selector);
		exports.OrMatch = OrMatch;
		var DotMatch = (function (_super) {
		    __extends(DotMatch, _super);
		    function DotMatch(left, right) {
		        _super.call(this);
		        this.left = left;
		        this.right = right;
		    }
		    DotMatch.prototype.candidates = function (context) {
		        var l = this.left.candidates(context);
		        if (this.left instanceof AnyParentMatch) {
		            l = this.right.candidates(new AnyChildMatch().candidates(l));
		            return _.unique(l);
		        }
		        if (this.left instanceof ParentMatch) {
		            l = this.right.candidates(new AnyChildMatch().candidates(l));
		            return _.unique(l);
		        }
		        l = this.right.candidates(l);
		        return _.unique(l);
		    };
		    return DotMatch;
		})(Selector);
		exports.DotMatch = DotMatch;
		function resolveSelector(s, n) {
		    if (s.type == "or") {
		        var b = s;
		        var l = resolveSelector(b.left, n);
		        var r = resolveSelector(b.right, n);
		        return new OrMatch(l, r);
		    }
		    if (s.type == "dot") {
		        var b = s;
		        var l = resolveSelector(b.left, n);
		        var r = resolveSelector(b.right, n);
		        return new DotMatch(l, r);
		    }
		    if (s.type == 'classLiteral') {
		        var literal = s;
		        var tp = n.definition().universe().type(literal.name);
		        if (tp == null || tp.isValueType()) {
		            throw new Error("Referencing unknown type:" + literal.name);
		        }
		        return new IdMatch(literal.name);
		    }
		    if (s.type == 'parent') {
		        return new ParentMatch();
		    }
		    if (s.type == 'ancestor') {
		        return new AnyParentMatch();
		    }
		    if (s.type == 'descendant') {
		        return new AnyChildMatch();
		    }
		    if (s.type == 'child') {
		        return new ChildMatch();
		    }
		}
		exports.resolveSelector = resolveSelector;
		var IdMatch = (function (_super) {
		    __extends(IdMatch, _super);
		    function IdMatch(name) {
		        _super.call(this);
		        this.name = name;
		    }
		    IdMatch.prototype.candidates = function (context) {
		        var _this = this;
		        return context.filter(function (x) {
		            if (!x) {
		                return false;
		            }
		            if (x.definition().nameId() == _this.name) {
		                return true;
		            }
		            var superTypes = x.definition().allSuperTypes();
		            if (_.find(superTypes, function (x) { return x.nameId() == _this.name; })) {
		                return true;
		            }
		            return false;
		        });
		    };
		    return IdMatch;
		})(Selector);
		exports.IdMatch = IdMatch;
		var AnyParentMatch = (function (_super) {
		    __extends(AnyParentMatch, _super);
		    function AnyParentMatch() {
		        _super.apply(this, arguments);
		    }
		    AnyParentMatch.prototype.candidates = function (context) {
		        var res = [];
		        context.forEach(function (x) {
		            if (x) {
		                var z = x.parent();
		                while (z) {
		                    res.push(z);
		                    z = z.parent();
		                }
		            }
		        });
		        return _.unique(res);
		    };
		    return AnyParentMatch;
		})(Selector);
		exports.AnyParentMatch = AnyParentMatch;
		function addChildren(x, r) {
		    r.push(x);
		    x.elements().forEach(function (y) { return addChildren(y, r); });
		}
		var AnyChildMatch = (function (_super) {
		    __extends(AnyChildMatch, _super);
		    function AnyChildMatch() {
		        _super.apply(this, arguments);
		    }
		    AnyChildMatch.prototype.candidates = function (context) {
		        var res = [];
		        context.forEach(function (x) {
		            if (x) {
		                addChildren(x, res);
		            }
		        });
		        return _.unique(res);
		    };
		    return AnyChildMatch;
		})(Selector);
		exports.AnyChildMatch = AnyChildMatch;
		var ParentMatch = (function (_super) {
		    __extends(ParentMatch, _super);
		    function ParentMatch() {
		        _super.apply(this, arguments);
		    }
		    ParentMatch.prototype.candidates = function (context) {
		        return context.map(function (x) { return x.parent(); });
		    };
		    return ParentMatch;
		})(Selector);
		exports.ParentMatch = ParentMatch;
		var ChildMatch = (function (_super) {
		    __extends(ChildMatch, _super);
		    function ChildMatch() {
		        _super.apply(this, arguments);
		    }
		    ChildMatch.prototype.candidates = function (context) {
		        var res = [];
		        context.forEach(function (x) {
		            if (x) {
		                res = res.concat(x.elements());
		            }
		        });
		        return res;
		    };
		    return ChildMatch;
		})(Selector);
		exports.ChildMatch = ChildMatch;
		function parse(h, path) {
		    return resolveSelector(sel.parse(path), h);
		}
		exports.parse = parse;


	/***/ },
	/* 125 */
	/***/ function(module, exports) {

		var mod = (function () {
		    /*
		     * Generated by PEG.js 0.8.0.
		     *
		     * http://pegjs.majda.cz/
		     */
		    function peg$subclass(child, parent) {
		        function ctor() {
		            this.constructor = child;
		        }
		        ctor.prototype = parent.prototype;
		        child.prototype = new ctor();
		    }
		    function SyntaxError(message, expected, found, offset, line, column) {
		        this.message = message;
		        this.expected = expected;
		        this.found = found;
		        this.offset = offset;
		        this.line = line;
		        this.column = column;
		        this.name = "SyntaxError";
		    }
		    peg$subclass(SyntaxError, Error);
		    function parse(input) {
		        var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = peg$FAILED, peg$c1 = "|", peg$c2 = { type: "literal", value: "|", description: "\"|\"" }, peg$c3 = function (left, r) {
		            return { 'type': 'or', 'left': left, 'right': r ? r : null };
		        }, peg$c4 = ".", peg$c5 = { type: "literal", value: ".", description: "\".\"" }, peg$c6 = function (left, r) {
		            return { 'type': 'dot', 'left': left, 'right': r };
		        }, peg$c7 = "$", peg$c8 = { type: "literal", value: "$", description: "\"$\"" }, peg$c9 = function () {
		            return { 'type': 'parent' };
		        }, peg$c10 = "$$", peg$c11 = { type: "literal", value: "$$", description: "\"$$\"" }, peg$c12 = function () {
		            return { 'type': 'ancestor' };
		        }, peg$c13 = "**", peg$c14 = { type: "literal", value: "**", description: "\"**\"" }, peg$c15 = function () {
		            return { 'type': 'descendant' };
		        }, peg$c16 = "*", peg$c17 = { type: "literal", value: "*", description: "\"*\"" }, peg$c18 = function () {
		            return { 'type': 'child' };
		        }, peg$c19 = [], peg$c20 = /^[A-z]/, peg$c21 = { type: "class", value: "[A-z]", description: "[A-z]" }, peg$c22 = function (chars) {
		            return { 'type': 'classLiteral', "name": chars.join("") };
		        }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
		        if ("startRule" in options) {
		            if (!(options.startRule in peg$startRuleFunctions)) {
		                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
		            }
		            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
		        }
		        function text() {
		            return input.substring(peg$reportedPos, peg$currPos);
		        }
		        function offset() {
		            return peg$reportedPos;
		        }
		        function line() {
		            return peg$computePosDetails(peg$reportedPos).line;
		        }
		        function column() {
		            return peg$computePosDetails(peg$reportedPos).column;
		        }
		        function expected(description) {
		            throw peg$buildException(null, [{ type: "other", description: description }], peg$reportedPos);
		        }
		        function error(message) {
		            throw peg$buildException(message, null, peg$reportedPos);
		        }
		        function peg$computePosDetails(pos) {
		            function advance(details, startPos, endPos) {
		                var p, ch;
		                for (p = startPos; p < endPos; p++) {
		                    ch = input.charAt(p);
		                    if (ch === "\n") {
		                        if (!details.seenCR) {
		                            details.line++;
		                        }
		                        details.column = 1;
		                        details.seenCR = false;
		                    }
		                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
		                        details.line++;
		                        details.column = 1;
		                        details.seenCR = true;
		                    }
		                    else {
		                        details.column++;
		                        details.seenCR = false;
		                    }
		                }
		            }
		            if (peg$cachedPos !== pos) {
		                if (peg$cachedPos > pos) {
		                    peg$cachedPos = 0;
		                    peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
		                }
		                advance(peg$cachedPosDetails, peg$cachedPos, pos);
		                peg$cachedPos = pos;
		            }
		            return peg$cachedPosDetails;
		        }
		        function peg$fail(expected) {
		            if (peg$currPos < peg$maxFailPos) {
		                return;
		            }
		            if (peg$currPos > peg$maxFailPos) {
		                peg$maxFailPos = peg$currPos;
		                peg$maxFailExpected = [];
		            }
		            peg$maxFailExpected.push(expected);
		        }
		        function peg$buildException(message, expected, pos) {
		            function cleanupExpected(expected) {
		                var i = 1;
		                expected.sort(function (a, b) {
		                    if (a.description < b.description) {
		                        return -1;
		                    }
		                    else if (a.description > b.description) {
		                        return 1;
		                    }
		                    else {
		                        return 0;
		                    }
		                });
		                while (i < expected.length) {
		                    if (expected[i - 1] === expected[i]) {
		                        expected.splice(i, 1);
		                    }
		                    else {
		                        i++;
		                    }
		                }
		            }
		            function buildMessage(expected, found) {
		                function stringEscape(s) {
		                    function hex(ch) {
		                        return ch.charCodeAt(0).toString(16).toUpperCase();
		                    }
		                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
		                        return '\\x0' + hex(ch);
		                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
		                        return '\\x' + hex(ch);
		                    }).replace(/[\u0180-\u0FFF]/g, function (ch) {
		                        return '\\u0' + hex(ch);
		                    }).replace(/[\u1080-\uFFFF]/g, function (ch) {
		                        return '\\u' + hex(ch);
		                    });
		                }
		                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
		                for (i = 0; i < expected.length; i++) {
		                    expectedDescs[i] = expected[i].description;
		                }
		                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
		                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
		                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
		            }
		            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
		            if (expected !== null) {
		                cleanupExpected(expected);
		            }
		            return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
		        }
		        function peg$parsestart() {
		            var s0;
		            s0 = peg$parseor();
		            return s0;
		        }
		        function peg$parseor() {
		            var s0, s1, s2, s3;
		            s0 = peg$currPos;
		            s1 = peg$parsesequence();
		            if (s1 !== peg$FAILED) {
		                if (input.charCodeAt(peg$currPos) === 124) {
		                    s2 = peg$c1;
		                    peg$currPos++;
		                }
		                else {
		                    s2 = peg$FAILED;
		                    if (peg$silentFails === 0) {
		                        peg$fail(peg$c2);
		                    }
		                }
		                if (s2 !== peg$FAILED) {
		                    s3 = peg$parseor();
		                    if (s3 !== peg$FAILED) {
		                        peg$reportedPos = s0;
		                        s1 = peg$c3(s1, s3);
		                        s0 = s1;
		                    }
		                    else {
		                        peg$currPos = s0;
		                        s0 = peg$c0;
		                    }
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$c0;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$c0;
		            }
		            if (s0 === peg$FAILED) {
		                s0 = peg$parsesequence();
		            }
		            return s0;
		        }
		        function peg$parsesequence() {
		            var s0, s1, s2, s3;
		            s0 = peg$currPos;
		            s1 = peg$parseprimary();
		            if (s1 !== peg$FAILED) {
		                if (input.charCodeAt(peg$currPos) === 46) {
		                    s2 = peg$c4;
		                    peg$currPos++;
		                }
		                else {
		                    s2 = peg$FAILED;
		                    if (peg$silentFails === 0) {
		                        peg$fail(peg$c5);
		                    }
		                }
		                if (s2 !== peg$FAILED) {
		                    s3 = peg$parsesequence();
		                    if (s3 !== peg$FAILED) {
		                        peg$reportedPos = s0;
		                        s1 = peg$c6(s1, s3);
		                        s0 = s1;
		                    }
		                    else {
		                        peg$currPos = s0;
		                        s0 = peg$c0;
		                    }
		                }
		                else {
		                    peg$currPos = s0;
		                    s0 = peg$c0;
		                }
		            }
		            else {
		                peg$currPos = s0;
		                s0 = peg$c0;
		            }
		            if (s0 === peg$FAILED) {
		                s0 = peg$parseprimary();
		            }
		            return s0;
		        }
		        function peg$parseprimary() {
		            var s0;
		            s0 = peg$parsechildRef();
		            if (s0 === peg$FAILED) {
		                s0 = peg$parsedoubleStar();
		                if (s0 === peg$FAILED) {
		                    s0 = peg$parsestar();
		                    if (s0 === peg$FAILED) {
		                        s0 = peg$parsedoubleDollar();
		                        if (s0 === peg$FAILED) {
		                            s0 = peg$parsedollar();
		                        }
		                    }
		                }
		            }
		            return s0;
		        }
		        function peg$parsedollar() {
		            var s0, s1;
		            s0 = peg$currPos;
		            if (input.charCodeAt(peg$currPos) === 36) {
		                s1 = peg$c7;
		                peg$currPos++;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c8);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                peg$reportedPos = s0;
		                s1 = peg$c9();
		            }
		            s0 = s1;
		            return s0;
		        }
		        function peg$parsedoubleDollar() {
		            var s0, s1;
		            s0 = peg$currPos;
		            if (input.substr(peg$currPos, 2) === peg$c10) {
		                s1 = peg$c10;
		                peg$currPos += 2;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c11);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                peg$reportedPos = s0;
		                s1 = peg$c12();
		            }
		            s0 = s1;
		            return s0;
		        }
		        function peg$parsedoubleStar() {
		            var s0, s1;
		            s0 = peg$currPos;
		            if (input.substr(peg$currPos, 2) === peg$c13) {
		                s1 = peg$c13;
		                peg$currPos += 2;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c14);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                peg$reportedPos = s0;
		                s1 = peg$c15();
		            }
		            s0 = s1;
		            return s0;
		        }
		        function peg$parsestar() {
		            var s0, s1;
		            s0 = peg$currPos;
		            if (input.charCodeAt(peg$currPos) === 42) {
		                s1 = peg$c16;
		                peg$currPos++;
		            }
		            else {
		                s1 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c17);
		                }
		            }
		            if (s1 !== peg$FAILED) {
		                peg$reportedPos = s0;
		                s1 = peg$c18();
		            }
		            s0 = s1;
		            return s0;
		        }
		        function peg$parsechildRef() {
		            var s0, s1, s2;
		            s0 = peg$currPos;
		            s1 = [];
		            if (peg$c20.test(input.charAt(peg$currPos))) {
		                s2 = input.charAt(peg$currPos);
		                peg$currPos++;
		            }
		            else {
		                s2 = peg$FAILED;
		                if (peg$silentFails === 0) {
		                    peg$fail(peg$c21);
		                }
		            }
		            if (s2 !== peg$FAILED) {
		                while (s2 !== peg$FAILED) {
		                    s1.push(s2);
		                    if (peg$c20.test(input.charAt(peg$currPos))) {
		                        s2 = input.charAt(peg$currPos);
		                        peg$currPos++;
		                    }
		                    else {
		                        s2 = peg$FAILED;
		                        if (peg$silentFails === 0) {
		                            peg$fail(peg$c21);
		                        }
		                    }
		                }
		            }
		            else {
		                s1 = peg$c0;
		            }
		            if (s1 !== peg$FAILED) {
		                peg$reportedPos = s0;
		                s1 = peg$c22(s1);
		            }
		            s0 = s1;
		            return s0;
		        }
		        peg$result = peg$startRuleFunction();
		        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
		            return peg$result;
		        }
		        else {
		            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
		                peg$fail({ type: "end", description: "end of input" });
		            }
		            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
		        }
		    }
		    return {
		        SyntaxError: SyntaxError,
		        parse: parse
		    };
		})();
		module.exports = mod;


	/***/ }
	/******/ ]);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result — either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 4 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 5 */
/***/ function(module, exports) {

	function readFileSync(filePath) {
	    return null;
	}
	exports.readFileSync = readFileSync;
	function writeFileSync(filePath, content) {
	}
	exports.writeFileSync = writeFileSync;
	function existsSync(filePath) {
	    return false;
	}
	exports.existsSync = existsSync;
	function mkdirSync(dir) {
	}
	exports.mkdirSync = mkdirSync;
	function readdirSync(filePath) {
	}
	exports.readdirSync = readdirSync;
	function statSync(filePath) {
	    return {
	        isDirectory: function () {
	            return false;
	        },
	        isSymbolicLink: function () {
	            return false;
	        },
	        isFile: function () {
	            return false;
	        }
	    };
	}
	exports.statSync = statSync;
	function lstatSync(filePath) {
	    return this.statSync(filePath);
	}
	exports.lstatSync = lstatSync;
	function list(file, parent) {
	    return [];
	}
	exports.list = list;
	function onChange(callback) {
	}
	exports.onChange = onChange;
	//# sourceMappingURL=emptyFS.js.map

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	var base64 = __webpack_require__(7)
	var ieee754 = __webpack_require__(8)
	var isArray = __webpack_require__(9)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).Buffer, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 8 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.

	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';

	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PlaceHolders,
	        Messages,
	        Regex,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        hasLineTerminator,
	        lastIndex,
	        lastLineNumber,
	        lastLineStart,
	        startIndex,
	        startLineNumber,
	        startLineStart,
	        scanning,
	        length,
	        lookahead,
	        state,
	        extra,
	        isBindingElement,
	        isAssignmentTarget,
	        firstCoverInitializedNameError;

	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9,
	        Template: 10
	    };

	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';
	    TokenName[Token.Template] = 'Template';

	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];

	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForOfStatement: 'ForOfStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchCase: 'SwitchCase',
	        SwitchStatement: 'SwitchStatement',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };

	    PlaceHolders = {
	        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
	    };

	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken: 'Unexpected token %0',
	        UnexpectedNumber: 'Unexpected number',
	        UnexpectedString: 'Unexpected string',
	        UnexpectedIdentifier: 'Unexpected identifier',
	        UnexpectedReserved: 'Unexpected reserved word',
	        UnexpectedTemplate: 'Unexpected quasi %0',
	        UnexpectedEOS: 'Unexpected end of input',
	        NewlineAfterThrow: 'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp: 'Invalid regular expression: missing /',
	        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally: 'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith: 'Strict mode code may not include a with statement',
	        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord: 'Use of future reserved word in strict mode',
	        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	        DefaultRestParameter: 'Unexpected token =',
	        ObjectPatternAsRestParameter: 'Unexpected token {',
	        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	        DuplicateConstructor: 'A class may only have one constructor',
	        StaticPrototype: 'Classes may not have static property named prototype',
	        MissingFromClause: 'Unexpected token',
	        NoAsAfterImportNamespace: 'Unexpected token',
	        InvalidModuleSpecifier: 'Unexpected token',
	        IllegalImportDeclaration: 'Unexpected token',
	        IllegalExportDeclaration: 'Unexpected token',
	        DuplicateBinding: 'Duplicate binding %0'
	    };

	    // See also tools/generate-unicode-regex.js.
	    Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };

	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.

	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }

	    function isDecimalDigit(ch) {
	        return (ch >= 0x30 && ch <= 0x39);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }

	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }

	    function octalToDecimal(ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

	        if (index < length && isOctalDigit(source[index])) {
	            octal = true;
	            code = code * 8 + '01234567'.indexOf(source[index++]);

	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 &&
	                    index < length &&
	                    isOctalDigit(source[index])) {
	                code = code * 8 + '01234567'.indexOf(source[index++]);
	            }
	        }

	        return {
	            code: code,
	            octal: octal
	        };
	    }

	    // ECMA-262 11.2 White Space

	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }

	    // ECMA-262 11.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // ECMA-262 11.6 Identifier Names and Identifiers

	    function fromCodePoint(cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    }

	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
	    }

	    // ECMA-262 11.6.2.2 Future Reserved Words

	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'enum':
	        case 'export':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    // ECMA-262 11.6.2.1 Keywords

	    function isKeyword(id) {
	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    // ECMA-262 11.4 Comments

	    function addComment(type, value, start, end, loc) {
	        var comment;

	        assert(typeof start === 'number', 'Comment must have valid position');

	        state.lastCommentStart = start;

	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	        if (extra.tokenize) {
	            comment.type = comment.type + 'Comment';
	            if (extra.delegate) {
	                comment = extra.delegate(comment);
	            }
	            extra.tokens.push(comment);
	        }
	    }

	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;

	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }

	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }

	    function skipMultiLineComment() {
	        var start, loc, ch, comment;

	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                hasLineTerminator = true;
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }

	        // Ran off the end of the file - the whole thing is a comment
	        if (extra.comments) {
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            comment = source.slice(start + 2, index);
	            addComment('Block', comment, start, index, loc);
	        }
	        tolerateUnexpectedToken();
	    }

	    function skipComment() {
	        var ch, start;
	        hasLineTerminator = false;

	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);

	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function scanUnicodeCodePointEscape() {
	        var ch, code;

	        ch = source[index];
	        code = 0;

	        // At least, one hex digit is required.
	        if (ch === '}') {
	            throwUnexpectedToken();
	        }

	        while (index < length) {
	            ch = source[index++];
	            if (!isHexDigit(ch)) {
	                break;
	            }
	            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	        }

	        if (code > 0x10FFFF || ch !== '}') {
	            throwUnexpectedToken();
	        }

	        return fromCodePoint(code);
	    }

	    function codePointAt(i) {
	        var cp, first, second;

	        cp = source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            second = source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }

	        return cp;
	    }

	    function getComplexIdentifier() {
	        var cp, ch, id;

	        cp = codePointAt(index);
	        id = fromCodePoint(cp);
	        index += id.length;

	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (cp === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwUnexpectedToken();
	            }
	            ++index;
	            if (source[index] === '{') {
	                ++index;
	                ch = scanUnicodeCodePointEscape();
	            } else {
	                ch = scanHexEscape('u');
	                cp = ch.charCodeAt(0);
	                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
	                    throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }

	        while (index < length) {
	            cp = codePointAt(index);
	            if (!isIdentifierPart(cp)) {
	                break;
	            }
	            ch = fromCodePoint(cp);
	            id += ch;
	            index += ch.length;

	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwUnexpectedToken();
	                }
	                ++index;
	                if (source[index] === '{') {
	                    ++index;
	                    ch = scanUnicodeCodePointEscape();
	                } else {
	                    ch = scanHexEscape('u');
	                    cp = ch.charCodeAt(0);
	                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
	                        throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }

	        return id;
	    }

	    function getIdentifier() {
	        var start, ch;

	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getComplexIdentifier();
	            } else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                index = start;
	                return getComplexIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }

	        return source.slice(start, index);
	    }

	    function scanIdentifier() {
	        var start, id, type;

	        start = index;

	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }

	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }


	    // ECMA-262 11.7 Punctuators

	    function scanPunctuator() {
	        var token, str;

	        token = {
	            type: Token.Punctuator,
	            value: '',
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: index,
	            end: index
	        };

	        // Check for most common single-character punctuators.
	        str = source[index];
	        switch (str) {

	        case '(':
	            if (extra.tokenize) {
	                extra.openParenToken = extra.tokenValues.length;
	            }
	            ++index;
	            break;

	        case '{':
	            if (extra.tokenize) {
	                extra.openCurlyToken = extra.tokenValues.length;
	            }
	            state.curlyStack.push('{');
	            ++index;
	            break;

	        case '.':
	            ++index;
	            if (source[index] === '.' && source[index + 1] === '.') {
	                // Spread operator: ...
	                index += 2;
	                str = '...';
	            }
	            break;

	        case '}':
	            ++index;
	            state.curlyStack.pop();
	            break;
	        case ')':
	        case ';':
	        case ',':
	        case '[':
	        case ']':
	        case ':':
	        case '?':
	        case '~':
	            ++index;
	            break;

	        default:
	            // 4-character punctuator.
	            str = source.substr(index, 4);
	            if (str === '>>>=') {
	                index += 4;
	            } else {

	                // 3-character punctuators.
	                str = str.substr(0, 3);
	                if (str === '===' || str === '!==' || str === '>>>' ||
	                    str === '<<=' || str === '>>=') {
	                    index += 3;
	                } else {

	                    // 2-character punctuators.
	                    str = str.substr(0, 2);
	                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                        str === '<=' || str === '>=' || str === '=>') {
	                        index += 2;
	                    } else {

	                        // 1-character punctuators.
	                        str = source[index];
	                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                            ++index;
	                        }
	                    }
	                }
	            }
	        }

	        if (index === token.start) {
	            throwUnexpectedToken();
	        }

	        token.end = index;
	        token.value = str;
	        return token;
	    }

	    // ECMA-262 11.8.3 Numeric Literals

	    function scanHexLiteral(start) {
	        var number = '';

	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            throwUnexpectedToken();
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanBinaryLiteral(start) {
	        var ch, number;

	        number = '';

	        while (index < length) {
	            ch = source[index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            // only 0b or 0B
	            throwUnexpectedToken();
	        }

	        if (index < length) {
	            ch = source.charCodeAt(index);
	            /* istanbul ignore else */
	            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
	                throwUnexpectedToken();
	            }
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 2),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanOctalLiteral(prefix, start) {
	        var number, octal;

	        if (isOctalDigit(prefix)) {
	            octal = true;
	            number = '0' + source[index++];
	        } else {
	            octal = false;
	            ++index;
	            number = '';
	        }

	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (!octal && number.length === 0) {
	            // only 0o or 0O
	            throwUnexpectedToken();
	        }

	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function isImplicitOctalLiteral() {
	        var i, ch;

	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }

	        return true;
	    }

	    function scanNumericLiteral() {
	        var number, start, ch;

	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');

	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];

	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return scanOctalLiteral(ch, start);
	                }

	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(ch, start);
	                    }
	                }
	            }

	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];

	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwUnexpectedToken();
	            }
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // ECMA-262 11.8.4 String Literals

	    function scanStringLiteral() {
	        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');

	        start = index;
	        ++index;

	        while (index < length) {
	            ch = source[index++];

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            str += scanUnicodeCodePointEscape();
	                        } else {
	                            unescaped = scanHexEscape(ch);
	                            if (!unescaped) {
	                                throw throwUnexpectedToken();
	                            }
	                            str += unescaped;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;
	                    case '8':
	                    case '9':
	                        str += ch;
	                        tolerateUnexpectedToken();
	                        break;

	                    default:
	                        if (isOctalDigit(ch)) {
	                            octToDec = octalToDecimal(ch);

	                            octal = octToDec.octal || octal;
	                            str += String.fromCharCode(octToDec.code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            lineNumber: startLineNumber,
	            lineStart: startLineStart,
	            start: start,
	            end: index
	        };
	    }

	    // ECMA-262 11.8.6 Template Literal Lexical Components

	    function scanTemplate() {
	        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

	        terminated = false;
	        tail = false;
	        start = index;
	        head = (source[index] === '`');
	        rawOffset = 2;

	        ++index;

	        while (index < length) {
	            ch = source[index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            } else if (ch === '$') {
	                if (source[index] === '{') {
	                    state.curlyStack.push('${');
	                    ++index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        cooked += '\n';
	                        break;
	                    case 'r':
	                        cooked += '\r';
	                        break;
	                    case 't':
	                        cooked += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            cooked += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                cooked += unescaped;
	                            } else {
	                                index = restore;
	                                cooked += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        cooked += '\b';
	                        break;
	                    case 'f':
	                        cooked += '\f';
	                        break;
	                    case 'v':
	                        cooked += '\v';
	                        break;

	                    default:
	                        if (ch === '0') {
	                            if (isDecimalDigit(source.charCodeAt(index))) {
	                                // Illegal: \01 \02 and so on
	                                throwError(Messages.TemplateOctalLiteral);
	                            }
	                            cooked += '\0';
	                        } else if (isOctalDigit(ch)) {
	                            // Illegal: \1 \2
	                            throwError(Messages.TemplateOctalLiteral);
	                        } else {
	                            cooked += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                }
	                lineStart = index;
	                cooked += '\n';
	            } else {
	                cooked += ch;
	            }
	        }

	        if (!terminated) {
	            throwUnexpectedToken();
	        }

	        if (!head) {
	            state.curlyStack.pop();
	        }

	        return {
	            type: Token.Template,
	            value: {
	                cooked: cooked,
	                raw: source.slice(start + 1, index - rawOffset)
	            },
	            head: head,
	            tail: tail,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // ECMA-262 11.8.5 Regular Expression Literals

	    function testRegExp(pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF',
	            tmp = pattern;

	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                // Replace every Unicode escape sequence with the equivalent
	                // BMP character or a constant ASCII code point in the case of
	                // astral symbols. (See the above note on `astralSubstitute`
	                // for more information.)
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                    var codePoint = parseInt($1 || $2, 16);
	                    if (codePoint > 0x10FFFF) {
	                        throwUnexpectedToken(null, Messages.InvalidRegExp);
	                    }
	                    if (codePoint <= 0xFFFF) {
	                        return String.fromCharCode(codePoint);
	                    }
	                    return astralSubstitute;
	                })
	                // Replace each paired surrogate with a single ASCII symbol to
	                // avoid throwing on regular expressions that are only valid in
	                // combination with the "u" flag.
	                .replace(
	                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	                    astralSubstitute
	                );
	        }

	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        } catch (e) {
	            throwUnexpectedToken(null, Messages.InvalidRegExp);
	        }

	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        } catch (exception) {
	            return null;
	        }
	    }

	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;

	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];

	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }

	        if (!terminated) {
	            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	        }

	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }

	    function scanRegExpFlags() {
	        var ch, str, flags, restore;

	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }

	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    tolerateUnexpectedToken();
	                } else {
	                    str += '\\';
	                    tolerateUnexpectedToken();
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }

	        return {
	            value: flags,
	            literal: str
	        };
	    }

	    function scanRegExp() {
	        var start, body, flags, value;
	        scanning = true;

	        lookahead = null;
	        skipComment();
	        start = index;

	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);
	        scanning = false;
	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                regex: {
	                    pattern: body.value,
	                    flags: flags.value
	                },
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            start: start,
	            end: index
	        };
	    }

	    function collectRegex() {
	        var pos, loc, regex, token;

	        skipComment();

	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        regex = scanRegExp();

	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }

	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                regex: regex.regex,
	                range: [pos, index],
	                loc: loc
	            });
	        }

	        return regex;
	    }

	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }

	    // Using the following algorithm:
	    // https://github.com/mozilla/sweet.js/wiki/design

	    function advanceSlash() {
	        var regex, previous, check;

	        function testKeyword(value) {
	            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
	        }

	        previous = extra.tokenValues[extra.tokens.length - 1];
	        regex = (previous !== null);

	        switch (previous) {
	        case 'this':
	        case ']':
	            regex = false;
	            break;

	        case ')':
	            check = extra.tokenValues[extra.openParenToken - 1];
	            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
	            break;

	        case '}':
	            // Dividing a function by anything makes little sense,
	            // but we have to check for that.
	            regex = false;
	            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
	                // Anonymous function, e.g. function(){} /42
	                check = extra.tokenValues[extra.openCurlyToken - 4];
	                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
	            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
	                // Named function, e.g. function f(){} /42/
	                check = extra.tokenValues[extra.openCurlyToken - 5];
	                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
	            }
	        }

	        return regex ? collectRegex() : scanPunctuator();
	    }

	    function advance() {
	        var cp, token;

	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }

	        cp = source.charCodeAt(index);

	        if (isIdentifierStart(cp)) {
	            token = scanIdentifier();
	            if (strict && isStrictModeReservedWord(token.value)) {
	                token.type = Token.Keyword;
	            }
	            return token;
	        }

	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return scanStringLiteral();
	        }

	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }

	        if (isDecimalDigit(cp)) {
	            return scanNumericLiteral();
	        }

	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && cp === 0x2F) {
	            return advanceSlash();
	        }

	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
	            return scanTemplate();
	        }

	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            cp = codePointAt(index);
	            if (isIdentifierStart(cp)) {
	                return scanIdentifier();
	            }
	        }

	        return scanPunctuator();
	    }

	    function collectToken() {
	        var loc, token, value, entry;

	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            entry = {
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            };
	            if (token.regex) {
	                entry.regex = {
	                    pattern: token.regex.pattern,
	                    flags: token.regex.flags
	                };
	            }
	            if (extra.tokenValues) {
	                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
	            }
	            if (extra.tokenize) {
	                if (!extra.range) {
	                    delete entry.range;
	                }
	                if (!extra.loc) {
	                    delete entry.loc;
	                }
	                if (extra.delegate) {
	                    entry = extra.delegate(entry);
	                }
	            }
	            extra.tokens.push(entry);
	        }

	        return token;
	    }

	    function lex() {
	        var token;
	        scanning = true;

	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;

	        skipComment();

	        token = lookahead;

	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	        return token;
	    }

	    function peek() {
	        scanning = true;

	        skipComment();

	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;

	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	    }

	    function Position() {
	        this.line = startLineNumber;
	        this.column = startIndex - startLineStart;
	    }

	    function SourceLocation() {
	        this.start = new Position();
	        this.end = null;
	    }

	    function WrappingSourceLocation(startToken) {
	        this.start = {
	            line: startToken.lineNumber,
	            column: startToken.start - startToken.lineStart
	        };
	        this.end = null;
	    }

	    function Node() {
	        if (extra.range) {
	            this.range = [startIndex, 0];
	        }
	        if (extra.loc) {
	            this.loc = new SourceLocation();
	        }
	    }

	    function WrappingNode(startToken) {
	        if (extra.range) {
	            this.range = [startToken.start, 0];
	        }
	        if (extra.loc) {
	            this.loc = new WrappingSourceLocation(startToken);
	        }
	    }

	    WrappingNode.prototype = Node.prototype = {

	        processComment: function () {
	            var lastChild,
	                innerComments,
	                leadingComments,
	                trailingComments,
	                bottomRight = extra.bottomRightStack,
	                i,
	                comment,
	                last = bottomRight[bottomRight.length - 1];

	            if (this.type === Syntax.Program) {
	                if (this.body.length > 0) {
	                    return;
	                }
	            }
	            /**
	             * patch innnerComments for properties empty block
	             * `function a() {/** comments **\/}`
	             */

	            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
	                innerComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (this.range[1] >= comment.range[1]) {
	                        innerComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                if (innerComments.length) {
	                    this.innerComments = innerComments;
	                    //bottomRight.push(this);
	                    return;
	                }
	            }

	            if (extra.trailingComments.length > 0) {
	                trailingComments = [];
	                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
	                    comment = extra.trailingComments[i];
	                    if (comment.range[0] >= this.range[1]) {
	                        trailingComments.unshift(comment);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                extra.trailingComments = [];
	            } else {
	                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
	                    trailingComments = last.trailingComments;
	                    delete last.trailingComments;
	                }
	            }

	            // Eating the stack.
	            while (last && last.range[0] >= this.range[0]) {
	                lastChild = bottomRight.pop();
	                last = bottomRight[bottomRight.length - 1];
	            }

	            if (lastChild) {
	                if (lastChild.leadingComments) {
	                    leadingComments = [];
	                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
	                        comment = lastChild.leadingComments[i];
	                        if (comment.range[1] <= this.range[0]) {
	                            leadingComments.unshift(comment);
	                            lastChild.leadingComments.splice(i, 1);
	                        }
	                    }

	                    if (!lastChild.leadingComments.length) {
	                        lastChild.leadingComments = undefined;
	                    }
	                }
	            } else if (extra.leadingComments.length > 0) {
	                leadingComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (comment.range[1] <= this.range[0]) {
	                        leadingComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                    }
	                }
	            }


	            if (leadingComments && leadingComments.length > 0) {
	                this.leadingComments = leadingComments;
	            }
	            if (trailingComments && trailingComments.length > 0) {
	                this.trailingComments = trailingComments;
	            }

	            bottomRight.push(this);
	        },

	        finish: function () {
	            if (extra.range) {
	                this.range[1] = lastIndex;
	            }
	            if (extra.loc) {
	                this.loc.end = {
	                    line: lastLineNumber,
	                    column: lastIndex - lastLineStart
	                };
	                if (extra.source) {
	                    this.loc.source = extra.source;
	                }
	            }

	            if (extra.attachComment) {
	                this.processComment();
	            }
	        },

	        finishArrayExpression: function (elements) {
	            this.type = Syntax.ArrayExpression;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },

	        finishArrayPattern: function (elements) {
	            this.type = Syntax.ArrayPattern;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },

	        finishArrowFunctionExpression: function (params, defaults, body, expression) {
	            this.type = Syntax.ArrowFunctionExpression;
	            this.id = null;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },

	        finishAssignmentExpression: function (operator, left, right) {
	            this.type = Syntax.AssignmentExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishAssignmentPattern: function (left, right) {
	            this.type = Syntax.AssignmentPattern;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishBinaryExpression: function (operator, left, right) {
	            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishBlockStatement: function (body) {
	            this.type = Syntax.BlockStatement;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishBreakStatement: function (label) {
	            this.type = Syntax.BreakStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },

	        finishCallExpression: function (callee, args) {
	            this.type = Syntax.CallExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },

	        finishCatchClause: function (param, body) {
	            this.type = Syntax.CatchClause;
	            this.param = param;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassBody: function (body) {
	            this.type = Syntax.ClassBody;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassDeclaration: function (id, superClass, body) {
	            this.type = Syntax.ClassDeclaration;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassExpression: function (id, superClass, body) {
	            this.type = Syntax.ClassExpression;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishConditionalExpression: function (test, consequent, alternate) {
	            this.type = Syntax.ConditionalExpression;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },

	        finishContinueStatement: function (label) {
	            this.type = Syntax.ContinueStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },

	        finishDebuggerStatement: function () {
	            this.type = Syntax.DebuggerStatement;
	            this.finish();
	            return this;
	        },

	        finishDoWhileStatement: function (body, test) {
	            this.type = Syntax.DoWhileStatement;
	            this.body = body;
	            this.test = test;
	            this.finish();
	            return this;
	        },

	        finishEmptyStatement: function () {
	            this.type = Syntax.EmptyStatement;
	            this.finish();
	            return this;
	        },

	        finishExpressionStatement: function (expression) {
	            this.type = Syntax.ExpressionStatement;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },

	        finishForStatement: function (init, test, update, body) {
	            this.type = Syntax.ForStatement;
	            this.init = init;
	            this.test = test;
	            this.update = update;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishForOfStatement: function (left, right, body) {
	            this.type = Syntax.ForOfStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishForInStatement: function (left, right, body) {
	            this.type = Syntax.ForInStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.each = false;
	            this.finish();
	            return this;
	        },

	        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionDeclaration;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },

	        finishFunctionExpression: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionExpression;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },

	        finishIdentifier: function (name) {
	            this.type = Syntax.Identifier;
	            this.name = name;
	            this.finish();
	            return this;
	        },

	        finishIfStatement: function (test, consequent, alternate) {
	            this.type = Syntax.IfStatement;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },

	        finishLabeledStatement: function (label, body) {
	            this.type = Syntax.LabeledStatement;
	            this.label = label;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishLiteral: function (token) {
	            this.type = Syntax.Literal;
	            this.value = token.value;
	            this.raw = source.slice(token.start, token.end);
	            if (token.regex) {
	                this.regex = token.regex;
	            }
	            this.finish();
	            return this;
	        },

	        finishMemberExpression: function (accessor, object, property) {
	            this.type = Syntax.MemberExpression;
	            this.computed = accessor === '[';
	            this.object = object;
	            this.property = property;
	            this.finish();
	            return this;
	        },

	        finishMetaProperty: function (meta, property) {
	            this.type = Syntax.MetaProperty;
	            this.meta = meta;
	            this.property = property;
	            this.finish();
	            return this;
	        },

	        finishNewExpression: function (callee, args) {
	            this.type = Syntax.NewExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },

	        finishObjectExpression: function (properties) {
	            this.type = Syntax.ObjectExpression;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },

	        finishObjectPattern: function (properties) {
	            this.type = Syntax.ObjectPattern;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },

	        finishPostfixExpression: function (operator, argument) {
	            this.type = Syntax.UpdateExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = false;
	            this.finish();
	            return this;
	        },

	        finishProgram: function (body, sourceType) {
	            this.type = Syntax.Program;
	            this.body = body;
	            this.sourceType = sourceType;
	            this.finish();
	            return this;
	        },

	        finishProperty: function (kind, key, computed, value, method, shorthand) {
	            this.type = Syntax.Property;
	            this.key = key;
	            this.computed = computed;
	            this.value = value;
	            this.kind = kind;
	            this.method = method;
	            this.shorthand = shorthand;
	            this.finish();
	            return this;
	        },

	        finishRestElement: function (argument) {
	            this.type = Syntax.RestElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishReturnStatement: function (argument) {
	            this.type = Syntax.ReturnStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishSequenceExpression: function (expressions) {
	            this.type = Syntax.SequenceExpression;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },

	        finishSpreadElement: function (argument) {
	            this.type = Syntax.SpreadElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishSwitchCase: function (test, consequent) {
	            this.type = Syntax.SwitchCase;
	            this.test = test;
	            this.consequent = consequent;
	            this.finish();
	            return this;
	        },

	        finishSuper: function () {
	            this.type = Syntax.Super;
	            this.finish();
	            return this;
	        },

	        finishSwitchStatement: function (discriminant, cases) {
	            this.type = Syntax.SwitchStatement;
	            this.discriminant = discriminant;
	            this.cases = cases;
	            this.finish();
	            return this;
	        },

	        finishTaggedTemplateExpression: function (tag, quasi) {
	            this.type = Syntax.TaggedTemplateExpression;
	            this.tag = tag;
	            this.quasi = quasi;
	            this.finish();
	            return this;
	        },

	        finishTemplateElement: function (value, tail) {
	            this.type = Syntax.TemplateElement;
	            this.value = value;
	            this.tail = tail;
	            this.finish();
	            return this;
	        },

	        finishTemplateLiteral: function (quasis, expressions) {
	            this.type = Syntax.TemplateLiteral;
	            this.quasis = quasis;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },

	        finishThisExpression: function () {
	            this.type = Syntax.ThisExpression;
	            this.finish();
	            return this;
	        },

	        finishThrowStatement: function (argument) {
	            this.type = Syntax.ThrowStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishTryStatement: function (block, handler, finalizer) {
	            this.type = Syntax.TryStatement;
	            this.block = block;
	            this.guardedHandlers = [];
	            this.handlers = handler ? [handler] : [];
	            this.handler = handler;
	            this.finalizer = finalizer;
	            this.finish();
	            return this;
	        },

	        finishUnaryExpression: function (operator, argument) {
	            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = true;
	            this.finish();
	            return this;
	        },

	        finishVariableDeclaration: function (declarations) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = 'var';
	            this.finish();
	            return this;
	        },

	        finishLexicalDeclaration: function (declarations, kind) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = kind;
	            this.finish();
	            return this;
	        },

	        finishVariableDeclarator: function (id, init) {
	            this.type = Syntax.VariableDeclarator;
	            this.id = id;
	            this.init = init;
	            this.finish();
	            return this;
	        },

	        finishWhileStatement: function (test, body) {
	            this.type = Syntax.WhileStatement;
	            this.test = test;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishWithStatement: function (object, body) {
	            this.type = Syntax.WithStatement;
	            this.object = object;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishExportSpecifier: function (local, exported) {
	            this.type = Syntax.ExportSpecifier;
	            this.exported = exported || local;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishImportDefaultSpecifier: function (local) {
	            this.type = Syntax.ImportDefaultSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishImportNamespaceSpecifier: function (local) {
	            this.type = Syntax.ImportNamespaceSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishExportNamedDeclaration: function (declaration, specifiers, src) {
	            this.type = Syntax.ExportNamedDeclaration;
	            this.declaration = declaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishExportDefaultDeclaration: function (declaration) {
	            this.type = Syntax.ExportDefaultDeclaration;
	            this.declaration = declaration;
	            this.finish();
	            return this;
	        },

	        finishExportAllDeclaration: function (src) {
	            this.type = Syntax.ExportAllDeclaration;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishImportSpecifier: function (local, imported) {
	            this.type = Syntax.ImportSpecifier;
	            this.local = local || imported;
	            this.imported = imported;
	            this.finish();
	            return this;
	        },

	        finishImportDeclaration: function (specifiers, src) {
	            this.type = Syntax.ImportDeclaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishYieldExpression: function (argument, delegate) {
	            this.type = Syntax.YieldExpression;
	            this.argument = argument;
	            this.delegate = delegate;
	            this.finish();
	            return this;
	        }
	    };


	    function recordError(error) {
	        var e, existing;

	        for (e = 0; e < extra.errors.length; e++) {
	            existing = extra.errors[e];
	            // Prevent duplicated error.
	            /* istanbul ignore next */
	            if (existing.index === error.index && existing.message === error.message) {
	                return;
	            }
	        }

	        extra.errors.push(error);
	    }

	    function constructError(msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        } catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        } finally {
	            return error;
	        }
	    }

	    function createError(line, pos, description) {
	        var msg, column, error;

	        msg = 'Line ' + line + ': ' + description;
	        column = pos - (scanning ? lineStart : lastLineStart) + 1;
	        error = constructError(msg, column);
	        error.lineNumber = line;
	        error.description = description;
	        error.index = pos;
	        return error;
	    }

	    // Throw an exception

	    function throwError(messageFormat) {
	        var args, msg;

	        args = Array.prototype.slice.call(arguments, 1);
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );

	        throw createError(lastLineNumber, lastIndex, msg);
	    }

	    function tolerateError(messageFormat) {
	        var args, msg, error;

	        args = Array.prototype.slice.call(arguments, 1);
	        /* istanbul ignore next */
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );

	        error = createError(lineNumber, lastIndex, msg);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }

	    // Throw an exception because of the token.

	    function unexpectedTokenError(token, message) {
	        var value, msg = message || Messages.UnexpectedToken;

	        if (token) {
	            if (!message) {
	                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
	                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
	                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
	                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
	                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
	                    Messages.UnexpectedToken;

	                if (token.type === Token.Keyword) {
	                    if (isFutureReservedWord(token.value)) {
	                        msg = Messages.UnexpectedReserved;
	                    } else if (strict && isStrictModeReservedWord(token.value)) {
	                        msg = Messages.StrictReservedWord;
	                    }
	                }
	            }

	            value = (token.type === Token.Template) ? token.value.raw : token.value;
	        } else {
	            value = 'ILLEGAL';
	        }

	        msg = msg.replace('%0', value);

	        return (token && typeof token.lineNumber === 'number') ?
	            createError(token.lineNumber, token.start, msg) :
	            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
	    }

	    function throwUnexpectedToken(token, message) {
	        throw unexpectedTokenError(token, message);
	    }

	    function tolerateUnexpectedToken(token, message) {
	        var error = unexpectedTokenError(token, message);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }

	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.

	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpectedToken(token);
	        }
	    }

	    /**
	     * @name expectCommaSeparator
	     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
	     * to <code>expect(value)</code>
	     * @since 2.0
	     */
	    function expectCommaSeparator() {
	        var token;

	        if (extra.errors) {
	            token = lookahead;
	            if (token.type === Token.Punctuator && token.value === ',') {
	                lex();
	            } else if (token.type === Token.Punctuator && token.value === ';') {
	                lex();
	                tolerateUnexpectedToken(token);
	            } else {
	                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
	            }
	        } else {
	            expect(',');
	        }
	    }

	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.

	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpectedToken(token);
	        }
	    }

	    // Return true if the next token matches the specified punctuator.

	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }

	    // Return true if the next token matches the specified keyword

	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }

	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)

	    function matchContextualKeyword(keyword) {
	        return lookahead.type === Token.Identifier && lookahead.value === keyword;
	    }

	    // Return true if the next token is an assignment operator

	    function matchAssign() {
	        var op;

	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }

	    function consumeSemicolon() {
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
	            lex();
	            return;
	        }

	        if (hasLineTerminator) {
	            return;
	        }

	        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
	        lastIndex = startIndex;
	        lastLineNumber = startLineNumber;
	        lastLineStart = startLineStart;

	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpectedToken(lookahead);
	        }
	    }

	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    function isolateCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        if (firstCoverInitializedNameError !== null) {
	            throwUnexpectedToken(firstCoverInitializedNameError);
	        }
	        isBindingElement = oldIsBindingElement;
	        isAssignmentTarget = oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
	        return result;
	    }

	    function inheritCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        isBindingElement = isBindingElement && oldIsBindingElement;
	        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
	        return result;
	    }

	    // ECMA-262 13.3.3 Destructuring Binding Patterns

	    function parseArrayPattern(params, kind) {
	        var node = new Node(), elements = [], rest, restNode;
	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                if (match('...')) {
	                    restNode = new Node();
	                    lex();
	                    params.push(lookahead);
	                    rest = parseVariableIdentifier(kind);
	                    elements.push(restNode.finishRestElement(rest));
	                    break;
	                } else {
	                    elements.push(parsePatternWithDefault(params, kind));
	                }
	                if (!match(']')) {
	                    expect(',');
	                }
	            }

	        }

	        expect(']');

	        return node.finishArrayPattern(elements);
	    }

	    function parsePropertyPattern(params, kind) {
	        var node = new Node(), key, keyToken, computed = match('['), init;
	        if (lookahead.type === Token.Identifier) {
	            keyToken = lookahead;
	            key = parseVariableIdentifier();
	            if (match('=')) {
	                params.push(keyToken);
	                lex();
	                init = parseAssignmentExpression();

	                return node.finishProperty(
	                    'init', key, false,
	                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, false);
	            } else if (!match(':')) {
	                params.push(keyToken);
	                return node.finishProperty('init', key, false, key, false, true);
	            }
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        expect(':');
	        init = parsePatternWithDefault(params, kind);
	        return node.finishProperty('init', key, computed, init, false, false);
	    }

	    function parseObjectPattern(params, kind) {
	        var node = new Node(), properties = [];

	        expect('{');

	        while (!match('}')) {
	            properties.push(parsePropertyPattern(params, kind));
	            if (!match('}')) {
	                expect(',');
	            }
	        }

	        lex();

	        return node.finishObjectPattern(properties);
	    }

	    function parsePattern(params, kind) {
	        if (match('[')) {
	            return parseArrayPattern(params, kind);
	        } else if (match('{')) {
	            return parseObjectPattern(params, kind);
	        } else if (matchKeyword('let')) {
	            if (kind === 'const' || kind === 'let') {
	                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
	            }
	        }

	        params.push(lookahead);
	        return parseVariableIdentifier(kind);
	    }

	    function parsePatternWithDefault(params, kind) {
	        var startToken = lookahead, pattern, previousAllowYield, right;
	        pattern = parsePattern(params, kind);
	        if (match('=')) {
	            lex();
	            previousAllowYield = state.allowYield;
	            state.allowYield = true;
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowYield = previousAllowYield;
	            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
	        }
	        return pattern;
	    }

	    // ECMA-262 12.2.5 Array Initializer

	    function parseArrayInitializer() {
	        var elements = [], node = new Node(), restSpread;

	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else if (match('...')) {
	                restSpread = new Node();
	                lex();
	                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

	                if (!match(']')) {
	                    isAssignmentTarget = isBindingElement = false;
	                    expect(',');
	                }
	                elements.push(restSpread);
	            } else {
	                elements.push(inheritCoverGrammar(parseAssignmentExpression));

	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }

	        lex();

	        return node.finishArrayExpression(elements);
	    }

	    // ECMA-262 12.2.6 Object Initializer

	    function parsePropertyFunction(node, paramInfo, isGenerator) {
	        var previousStrict, body;

	        isAssignmentTarget = isBindingElement = false;

	        previousStrict = strict;
	        body = isolateCoverGrammar(parseFunctionSourceElements);

	        if (strict && paramInfo.firstRestricted) {
	            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
	        }
	        if (strict && paramInfo.stricted) {
	            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
	        }

	        strict = previousStrict;
	        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
	    }

	    function parsePropertyMethodFunction() {
	        var params, method, node = new Node(),
	            previousAllowYield = state.allowYield;

	        state.allowYield = false;
	        params = parseParams();
	        state.allowYield = previousAllowYield;

	        state.allowYield = false;
	        method = parsePropertyFunction(node, params, false);
	        state.allowYield = previousAllowYield;

	        return method;
	    }

	    function parseObjectPropertyKey() {
	        var token, node = new Node(), expr;

	        token = lex();

	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.

	        switch (token.type) {
	        case Token.StringLiteral:
	        case Token.NumericLiteral:
	            if (strict && token.octal) {
	                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
	            }
	            return node.finishLiteral(token);
	        case Token.Identifier:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.Keyword:
	            return node.finishIdentifier(token.value);
	        case Token.Punctuator:
	            if (token.value === '[') {
	                expr = isolateCoverGrammar(parseAssignmentExpression);
	                expect(']');
	                return expr;
	            }
	            break;
	        }
	        throwUnexpectedToken(token);
	    }

	    function lookaheadPropertyName() {
	        switch (lookahead.type) {
	        case Token.Identifier:
	        case Token.StringLiteral:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.NumericLiteral:
	        case Token.Keyword:
	            return true;
	        case Token.Punctuator:
	            return lookahead.value === '[';
	        }
	        return false;
	    }

	    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	    // This can only be determined after we consumed up to the left parentheses.
	    //
	    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	    // is responsible to visit other options.
	    function tryParseMethodDefinition(token, key, computed, node) {
	        var value, options, methodNode, params,
	            previousAllowYield = state.allowYield;

	        if (token.type === Token.Identifier) {
	            // check for `get` and `set`;

	            if (token.value === 'get' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	                expect(')');

	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, {
	                    params: [],
	                    defaults: [],
	                    stricted: null,
	                    firstRestricted: null,
	                    message: null
	                }, false);
	                state.allowYield = previousAllowYield;

	                return node.finishProperty('get', key, computed, value, false, false);
	            } else if (token.value === 'set' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');

	                options = {
	                    params: [],
	                    defaultCount: 0,
	                    defaults: [],
	                    firstRestricted: null,
	                    paramSet: {}
	                };
	                if (match(')')) {
	                    tolerateUnexpectedToken(lookahead);
	                } else {
	                    state.allowYield = false;
	                    parseParam(options);
	                    state.allowYield = previousAllowYield;
	                    if (options.defaultCount === 0) {
	                        options.defaults = [];
	                    }
	                }
	                expect(')');

	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, options, false);
	                state.allowYield = previousAllowYield;

	                return node.finishProperty('set', key, computed, value, false, false);
	            }
	        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
	            computed = match('[');
	            key = parseObjectPropertyKey();
	            methodNode = new Node();

	            state.allowYield = true;
	            params = parseParams();
	            state.allowYield = previousAllowYield;

	            state.allowYield = false;
	            value = parsePropertyFunction(methodNode, params, true);
	            state.allowYield = previousAllowYield;

	            return node.finishProperty('init', key, computed, value, true, false);
	        }

	        if (key && match('(')) {
	            value = parsePropertyMethodFunction();
	            return node.finishProperty('init', key, computed, value, true, false);
	        }

	        // Not a MethodDefinition.
	        return null;
	    }

	    function parseObjectProperty(hasProto) {
	        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

	        computed = match('[');
	        if (match('*')) {
	            lex();
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
	        if (maybeMethod) {
	            return maybeMethod;
	        }

	        if (!key) {
	            throwUnexpectedToken(lookahead);
	        }

	        // Check for duplicated __proto__
	        if (!computed) {
	            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
	                (key.type === Syntax.Literal && key.value === '__proto__');
	            if (hasProto.value && proto) {
	                tolerateError(Messages.DuplicateProtoProperty);
	            }
	            hasProto.value |= proto;
	        }

	        if (match(':')) {
	            lex();
	            value = inheritCoverGrammar(parseAssignmentExpression);
	            return node.finishProperty('init', key, computed, value, false, false);
	        }

	        if (token.type === Token.Identifier) {
	            if (match('=')) {
	                firstCoverInitializedNameError = lookahead;
	                lex();
	                value = isolateCoverGrammar(parseAssignmentExpression);
	                return node.finishProperty('init', key, computed,
	                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
	            }
	            return node.finishProperty('init', key, computed, key, false, true);
	        }

	        throwUnexpectedToken(lookahead);
	    }

	    function parseObjectInitializer() {
	        var properties = [], hasProto = {value: false}, node = new Node();

	        expect('{');

	        while (!match('}')) {
	            properties.push(parseObjectProperty(hasProto));

	            if (!match('}')) {
	                expectCommaSeparator();
	            }
	        }

	        expect('}');

	        return node.finishObjectExpression(properties);
	    }

	    function reinterpretExpressionAsPattern(expr) {
	        var i;
	        switch (expr.type) {
	        case Syntax.Identifier:
	        case Syntax.MemberExpression:
	        case Syntax.RestElement:
	        case Syntax.AssignmentPattern:
	            break;
	        case Syntax.SpreadElement:
	            expr.type = Syntax.RestElement;
	            reinterpretExpressionAsPattern(expr.argument);
	            break;
	        case Syntax.ArrayExpression:
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0; i < expr.elements.length; i++) {
	                if (expr.elements[i] !== null) {
	                    reinterpretExpressionAsPattern(expr.elements[i]);
	                }
	            }
	            break;
	        case Syntax.ObjectExpression:
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0; i < expr.properties.length; i++) {
	                reinterpretExpressionAsPattern(expr.properties[i].value);
	            }
	            break;
	        case Syntax.AssignmentExpression:
	            expr.type = Syntax.AssignmentPattern;
	            reinterpretExpressionAsPattern(expr.left);
	            break;
	        default:
	            // Allow other node type for tolerant parsing.
	            break;
	        }
	    }

	    // ECMA-262 12.2.9 Template Literals

	    function parseTemplateElement(option) {
	        var node, token;

	        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	            throwUnexpectedToken();
	        }

	        node = new Node();
	        token = lex();

	        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
	    }

	    function parseTemplateLiteral() {
	        var quasi, quasis, expressions, node = new Node();

	        quasi = parseTemplateElement({ head: true });
	        quasis = [quasi];
	        expressions = [];

	        while (!quasi.tail) {
	            expressions.push(parseExpression());
	            quasi = parseTemplateElement({ head: false });
	            quasis.push(quasi);
	        }

	        return node.finishTemplateLiteral(quasis, expressions);
	    }

	    // ECMA-262 12.2.10 The Grouping Operator

	    function parseGroupExpression() {
	        var expr, expressions, startToken, i, params = [];

	        expect('(');

	        if (match(')')) {
	            lex();
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [],
	                rawParams: []
	            };
	        }

	        startToken = lookahead;
	        if (match('...')) {
	            expr = parseRestElement(params);
	            expect(')');
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [expr]
	            };
	        }

	        isBindingElement = true;
	        expr = inheritCoverGrammar(parseAssignmentExpression);

	        if (match(',')) {
	            isAssignmentTarget = false;
	            expressions = [expr];

	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();

	                if (match('...')) {
	                    if (!isBindingElement) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    expressions.push(parseRestElement(params));
	                    expect(')');
	                    if (!match('=>')) {
	                        expect('=>');
	                    }
	                    isBindingElement = false;
	                    for (i = 0; i < expressions.length; i++) {
	                        reinterpretExpressionAsPattern(expressions[i]);
	                    }
	                    return {
	                        type: PlaceHolders.ArrowParameterPlaceHolder,
	                        params: expressions
	                    };
	                }

	                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
	            }

	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }


	        expect(')');

	        if (match('=>')) {
	            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
	                return {
	                    type: PlaceHolders.ArrowParameterPlaceHolder,
	                    params: [expr]
	                };
	            }

	            if (!isBindingElement) {
	                throwUnexpectedToken(lookahead);
	            }

	            if (expr.type === Syntax.SequenceExpression) {
	                for (i = 0; i < expr.expressions.length; i++) {
	                    reinterpretExpressionAsPattern(expr.expressions[i]);
	                }
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }

	            expr = {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
	            };
	        }
	        isBindingElement = false;
	        return expr;
	    }


	    // ECMA-262 12.2 Primary Expressions

	    function parsePrimaryExpression() {
	        var type, token, expr, node;

	        if (match('(')) {
	            isBindingElement = false;
	            return inheritCoverGrammar(parseGroupExpression);
	        }

	        if (match('[')) {
	            return inheritCoverGrammar(parseArrayInitializer);
	        }

	        if (match('{')) {
	            return inheritCoverGrammar(parseObjectInitializer);
	        }

	        type = lookahead.type;
	        node = new Node();

	        if (type === Token.Identifier) {
	            if (state.sourceType === 'module' && lookahead.value === 'await') {
	                tolerateUnexpectedToken(lookahead);
	            }
	            expr = node.finishIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            if (strict && lookahead.octal) {
	                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = node.finishLiteral(lex());
	        } else if (type === Token.Keyword) {
	            if (!strict && state.allowYield && matchKeyword('yield')) {
	                return parseNonComputedProperty();
	            }
	            if (!strict && matchKeyword('let')) {
	                return node.finishIdentifier(lex().value);
	            }
	            isAssignmentTarget = isBindingElement = false;
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                return node.finishThisExpression();
	            }
	            if (matchKeyword('class')) {
	                return parseClassExpression();
	            }
	            throwUnexpectedToken(lex());
	        } else if (type === Token.BooleanLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = node.finishLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = null;
	            expr = node.finishLiteral(token);
	        } else if (match('/') || match('/=')) {
	            isAssignmentTarget = isBindingElement = false;
	            index = startIndex;

	            if (typeof extra.tokens !== 'undefined') {
	                token = collectRegex();
	            } else {
	                token = scanRegExp();
	            }
	            lex();
	            expr = node.finishLiteral(token);
	        } else if (type === Token.Template) {
	            expr = parseTemplateLiteral();
	        } else {
	            throwUnexpectedToken(lex());
	        }

	        return expr;
	    }

	    // ECMA-262 12.3 Left-Hand-Side Expressions

	    function parseArguments() {
	        var args = [], expr;

	        expect('(');

	        if (!match(')')) {
	            while (startIndex < length) {
	                if (match('...')) {
	                    expr = new Node();
	                    lex();
	                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
	                } else {
	                    expr = isolateCoverGrammar(parseAssignmentExpression);
	                }
	                args.push(expr);
	                if (match(')')) {
	                    break;
	                }
	                expectCommaSeparator();
	            }
	        }

	        expect(')');

	        return args;
	    }

	    function parseNonComputedProperty() {
	        var token, node = new Node();

	        token = lex();

	        if (!isIdentifierName(token)) {
	            throwUnexpectedToken(token);
	        }

	        return node.finishIdentifier(token.value);
	    }

	    function parseNonComputedMember() {
	        expect('.');

	        return parseNonComputedProperty();
	    }

	    function parseComputedMember() {
	        var expr;

	        expect('[');

	        expr = isolateCoverGrammar(parseExpression);

	        expect(']');

	        return expr;
	    }

	    // ECMA-262 12.3.3 The new Operator

	    function parseNewExpression() {
	        var callee, args, node = new Node();

	        expectKeyword('new');

	        if (match('.')) {
	            lex();
	            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
	                if (state.inFunctionBody) {
	                    lex();
	                    return node.finishMetaProperty('new', 'target');
	                }
	            }
	            throwUnexpectedToken(lookahead);
	        }

	        callee = isolateCoverGrammar(parseLeftHandSideExpression);
	        args = match('(') ? parseArguments() : [];

	        isAssignmentTarget = isBindingElement = false;

	        return node.finishNewExpression(callee, args);
	    }

	    // ECMA-262 12.3.4 Function Calls

	    function parseLeftHandSideExpressionAllowCall() {
	        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

	        startToken = lookahead;
	        state.allowIn = true;

	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('(') && !match('.') && !match('[')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }

	        for (;;) {
	            if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                isBindingElement = false;
	                isAssignmentTarget = false;
	                args = parseArguments();
	                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
	            } else if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        state.allowIn = previousAllowIn;

	        return expr;
	    }

	    // ECMA-262 12.3 Left-Hand-Side Expressions

	    function parseLeftHandSideExpression() {
	        var quasi, expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');

	        startToken = lookahead;

	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('[') && !match('.')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }

	        for (;;) {
	            if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        return expr;
	    }

	    // ECMA-262 12.4 Postfix Expressions

	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;

	        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

	        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
	            if (match('++') || match('--')) {
	                // ECMA-262 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    tolerateError(Messages.StrictLHSPostfix);
	                }

	                if (!isAssignmentTarget) {
	                    tolerateError(Messages.InvalidLHSInAssignment);
	                }

	                isAssignmentTarget = isBindingElement = false;

	                token = lex();
	                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
	            }
	        }

	        return expr;
	    }

	    // ECMA-262 12.5 Unary Operators

	    function parseUnaryExpression() {
	        var token, expr, startToken;

	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            // ECMA-262 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                tolerateError(Messages.StrictLHSPrefix);
	            }

	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                tolerateError(Messages.StrictDelete);
	            }
	            isAssignmentTarget = isBindingElement = false;
	        } else {
	            expr = parsePostfixExpression();
	        }

	        return expr;
	    }

	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;

	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }

	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;

	        case '&&':
	            prec = 2;
	            break;

	        case '|':
	            prec = 3;
	            break;

	        case '^':
	            prec = 4;
	            break;

	        case '&':
	            prec = 5;
	            break;

	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;

	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;

	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;

	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;

	        case '+':
	        case '-':
	            prec = 9;
	            break;

	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;

	        default:
	            break;
	        }

	        return prec;
	    }

	    // ECMA-262 12.6 Multiplicative Operators
	    // ECMA-262 12.7 Additive Operators
	    // ECMA-262 12.8 Bitwise Shift Operators
	    // ECMA-262 12.9 Relational Operators
	    // ECMA-262 12.10 Equality Operators
	    // ECMA-262 12.11 Binary Bitwise Operators
	    // ECMA-262 12.12 Binary Logical Operators

	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;

	        marker = lookahead;
	        left = inheritCoverGrammar(parseUnaryExpression);

	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        isAssignmentTarget = isBindingElement = false;
	        token.prec = prec;
	        lex();

	        markers = [marker, lookahead];
	        right = isolateCoverGrammar(parseUnaryExpression);

	        stack = [left, token, right];

	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                markers.pop();
	                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
	                stack.push(expr);
	            }

	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = isolateCoverGrammar(parseUnaryExpression);
	            stack.push(expr);
	        }

	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	        }

	        return expr;
	    }


	    // ECMA-262 12.13 Conditional Operator

	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;

	        startToken = lookahead;

	        expr = inheritCoverGrammar(parseBinaryExpression);
	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = isolateCoverGrammar(parseAssignmentExpression);

	            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
	            isAssignmentTarget = isBindingElement = false;
	        }

	        return expr;
	    }

	    // ECMA-262 14.2 Arrow Function Definitions

	    function parseConciseBody() {
	        if (match('{')) {
	            return parseFunctionSourceElements();
	        }
	        return isolateCoverGrammar(parseAssignmentExpression);
	    }

	    function checkPatternParam(options, param) {
	        var i;
	        switch (param.type) {
	        case Syntax.Identifier:
	            validateParam(options, param, param.name);
	            break;
	        case Syntax.RestElement:
	            checkPatternParam(options, param.argument);
	            break;
	        case Syntax.AssignmentPattern:
	            checkPatternParam(options, param.left);
	            break;
	        case Syntax.ArrayPattern:
	            for (i = 0; i < param.elements.length; i++) {
	                if (param.elements[i] !== null) {
	                    checkPatternParam(options, param.elements[i]);
	                }
	            }
	            break;
	        case Syntax.YieldExpression:
	            break;
	        default:
	            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
	            for (i = 0; i < param.properties.length; i++) {
	                checkPatternParam(options, param.properties[i].value);
	            }
	            break;
	        }
	    }
	    function reinterpretAsCoverFormalsList(expr) {
	        var i, len, param, params, defaults, defaultCount, options, token;

	        defaults = [];
	        defaultCount = 0;
	        params = [expr];

	        switch (expr.type) {
	        case Syntax.Identifier:
	            break;
	        case PlaceHolders.ArrowParameterPlaceHolder:
	            params = expr.params;
	            break;
	        default:
	            return null;
	        }

	        options = {
	            paramSet: {}
	        };

	        for (i = 0, len = params.length; i < len; i += 1) {
	            param = params[i];
	            switch (param.type) {
	            case Syntax.AssignmentPattern:
	                params[i] = param.left;
	                if (param.right.type === Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    param.right.type = Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	                defaults.push(param.right);
	                ++defaultCount;
	                checkPatternParam(options, param.left);
	                break;
	            default:
	                checkPatternParam(options, param);
	                params[i] = param;
	                defaults.push(null);
	                break;
	            }
	        }

	        if (strict || !state.allowYield) {
	            for (i = 0, len = params.length; i < len; i += 1) {
	                param = params[i];
	                if (param.type === Syntax.YieldExpression) {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }

	        if (options.message === Messages.StrictParamDupe) {
	            token = strict ? options.stricted : options.firstRestricted;
	            throwUnexpectedToken(token, options.message);
	        }

	        if (defaultCount === 0) {
	            defaults = [];
	        }

	        return {
	            params: params,
	            defaults: defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseArrowFunctionExpression(options, node) {
	        var previousStrict, previousAllowYield, body;

	        if (hasLineTerminator) {
	            tolerateUnexpectedToken(lookahead);
	        }
	        expect('=>');

	        previousStrict = strict;
	        previousAllowYield = state.allowYield;
	        state.allowYield = true;

	        body = parseConciseBody();

	        if (strict && options.firstRestricted) {
	            throwUnexpectedToken(options.firstRestricted, options.message);
	        }
	        if (strict && options.stricted) {
	            tolerateUnexpectedToken(options.stricted, options.message);
	        }

	        strict = previousStrict;
	        state.allowYield = previousAllowYield;

	        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
	    }

	    // ECMA-262 14.4 Yield expression

	    function parseYieldExpression() {
	        var argument, expr, delegate, previousAllowYield;

	        argument = null;
	        expr = new Node();
	        delegate = false;

	        expectKeyword('yield');

	        if (!hasLineTerminator) {
	            previousAllowYield = state.allowYield;
	            state.allowYield = false;
	            delegate = match('*');
	            if (delegate) {
	                lex();
	                argument = parseAssignmentExpression();
	            } else {
	                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
	                    argument = parseAssignmentExpression();
	                }
	            }
	            state.allowYield = previousAllowYield;
	        }

	        return expr.finishYieldExpression(argument, delegate);
	    }

	    // ECMA-262 12.14 Assignment Operators

	    function parseAssignmentExpression() {
	        var token, expr, right, list, startToken;

	        startToken = lookahead;
	        token = lookahead;

	        if (!state.allowYield && matchKeyword('yield')) {
	            return parseYieldExpression();
	        }

	        expr = parseConditionalExpression();

	        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
	            isAssignmentTarget = isBindingElement = false;
	            list = reinterpretAsCoverFormalsList(expr);

	            if (list) {
	                firstCoverInitializedNameError = null;
	                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
	            }

	            return expr;
	        }

	        if (matchAssign()) {
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }

	            // ECMA-262 12.1.1
	            if (strict && expr.type === Syntax.Identifier) {
	                if (isRestrictedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
	                }
	                if (isStrictModeReservedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	                }
	            }

	            if (!match('=')) {
	                isAssignmentTarget = isBindingElement = false;
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }

	            token = lex();
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
	            firstCoverInitializedNameError = null;
	        }

	        return expr;
	    }

	    // ECMA-262 12.15 Comma Operator

	    function parseExpression() {
	        var expr, startToken = lookahead, expressions;

	        expr = isolateCoverGrammar(parseAssignmentExpression);

	        if (match(',')) {
	            expressions = [expr];

	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
	            }

	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }

	        return expr;
	    }

	    // ECMA-262 13.2 Block

	    function parseStatementListItem() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'export':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
	                }
	                return parseExportDeclaration();
	            case 'import':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
	                }
	                return parseImportDeclaration();
	            case 'const':
	                return parseLexicalDeclaration({inFor: false});
	            case 'function':
	                return parseFunctionDeclaration(new Node());
	            case 'class':
	                return parseClassDeclaration();
	            }
	        }

	        if (matchKeyword('let') && isLexicalDeclaration()) {
	            return parseLexicalDeclaration({inFor: false});
	        }

	        return parseStatement();
	    }

	    function parseStatementList() {
	        var list = [];
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            list.push(parseStatementListItem());
	        }

	        return list;
	    }

	    function parseBlock() {
	        var block, node = new Node();

	        expect('{');

	        block = parseStatementList();

	        expect('}');

	        return node.finishBlockStatement(block);
	    }

	    // ECMA-262 13.3.2 Variable Statement

	    function parseVariableIdentifier(kind) {
	        var token, node = new Node();

	        token = lex();

	        if (token.type === Token.Keyword && token.value === 'yield') {
	            if (strict) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } if (!state.allowYield) {
	                throwUnexpectedToken(token);
	            }
	        } else if (token.type !== Token.Identifier) {
	            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } else {
	                if (strict || token.value !== 'let' || kind !== 'var') {
	                    throwUnexpectedToken(token);
	                }
	            }
	        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
	            tolerateUnexpectedToken(token);
	        }

	        return node.finishIdentifier(token.value);
	    }

	    function parseVariableDeclaration(options) {
	        var init = null, id, node = new Node(), params = [];

	        id = parsePattern(params, 'var');

	        // ECMA-262 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }

	        if (match('=')) {
	            lex();
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        } else if (id.type !== Syntax.Identifier && !options.inFor) {
	            expect('=');
	        }

	        return node.finishVariableDeclarator(id, init);
	    }

	    function parseVariableDeclarationList(options) {
	        var opt, list;

	        opt = { inFor: options.inFor };
	        list = [parseVariableDeclaration(opt)];

	        while (match(',')) {
	            lex();
	            list.push(parseVariableDeclaration(opt));
	        }

	        return list;
	    }

	    function parseVariableStatement(node) {
	        var declarations;

	        expectKeyword('var');

	        declarations = parseVariableDeclarationList({ inFor: false });

	        consumeSemicolon();

	        return node.finishVariableDeclaration(declarations);
	    }

	    // ECMA-262 13.3.1 Let and Const Declarations

	    function parseLexicalBinding(kind, options) {
	        var init = null, id, node = new Node(), params = [];

	        id = parsePattern(params, kind);

	        // ECMA-262 12.2.1
	        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }

	        if (kind === 'const') {
	            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
	                expect('=');
	                init = isolateCoverGrammar(parseAssignmentExpression);
	            }
	        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
	            expect('=');
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        }

	        return node.finishVariableDeclarator(id, init);
	    }

	    function parseBindingList(kind, options) {
	        var list = [parseLexicalBinding(kind, options)];

	        while (match(',')) {
	            lex();
	            list.push(parseLexicalBinding(kind, options));
	        }

	        return list;
	    }


	    function tokenizerState() {
	        return {
	            index: index,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            hasLineTerminator: hasLineTerminator,
	            lastIndex: lastIndex,
	            lastLineNumber: lastLineNumber,
	            lastLineStart: lastLineStart,
	            startIndex: startIndex,
	            startLineNumber: startLineNumber,
	            startLineStart: startLineStart,
	            lookahead: lookahead,
	            tokenCount: extra.tokens ? extra.tokens.length : 0
	        };
	    }

	    function resetTokenizerState(ts) {
	        index = ts.index;
	        lineNumber = ts.lineNumber;
	        lineStart = ts.lineStart;
	        hasLineTerminator = ts.hasLineTerminator;
	        lastIndex = ts.lastIndex;
	        lastLineNumber = ts.lastLineNumber;
	        lastLineStart = ts.lastLineStart;
	        startIndex = ts.startIndex;
	        startLineNumber = ts.startLineNumber;
	        startLineStart = ts.startLineStart;
	        lookahead = ts.lookahead;
	        if (extra.tokens) {
	            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
	        }
	    }

	    function isLexicalDeclaration() {
	        var lexical, ts;

	        ts = tokenizerState();

	        lex();
	        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
	            matchKeyword('let') || matchKeyword('yield');

	        resetTokenizerState(ts);

	        return lexical;
	    }

	    function parseLexicalDeclaration(options) {
	        var kind, declarations, node = new Node();

	        kind = lex().value;
	        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

	        declarations = parseBindingList(kind, options);

	        consumeSemicolon();

	        return node.finishLexicalDeclaration(declarations, kind);
	    }

	    function parseRestElement(params) {
	        var param, node = new Node();

	        lex();

	        if (match('{')) {
	            throwError(Messages.ObjectPatternAsRestParameter);
	        }

	        params.push(lookahead);

	        param = parseVariableIdentifier();

	        if (match('=')) {
	            throwError(Messages.DefaultRestParameter);
	        }

	        if (!match(')')) {
	            throwError(Messages.ParameterAfterRestParameter);
	        }

	        return node.finishRestElement(param);
	    }

	    // ECMA-262 13.4 Empty Statement

	    function parseEmptyStatement(node) {
	        expect(';');
	        return node.finishEmptyStatement();
	    }

	    // ECMA-262 12.4 Expression Statement

	    function parseExpressionStatement(node) {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return node.finishExpressionStatement(expr);
	    }

	    // ECMA-262 13.6 If statement

	    function parseIfStatement(node) {
	        var test, consequent, alternate;

	        expectKeyword('if');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        consequent = parseStatement();

	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }

	        return node.finishIfStatement(test, consequent, alternate);
	    }

	    // ECMA-262 13.7 Iteration Statements

	    function parseDoWhileStatement(node) {
	        var body, test, oldInIteration;

	        expectKeyword('do');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        if (match(';')) {
	            lex();
	        }

	        return node.finishDoWhileStatement(body, test);
	    }

	    function parseWhileStatement(node) {
	        var test, body, oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return node.finishWhileStatement(test, body);
	    }

	    function parseForStatement(node) {
	        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
	            body, oldInIteration, previousAllowIn = state.allowIn;

	        init = test = update = null;
	        forIn = true;

	        expectKeyword('for');

	        expect('(');

	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var')) {
	                init = new Node();
	                lex();

	                state.allowIn = false;
	                declarations = parseVariableDeclarationList({ inFor: true });
	                state.allowIn = previousAllowIn;

	                if (declarations.length === 1 && matchKeyword('in')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    init = init.finishVariableDeclaration(declarations);
	                    expect(';');
	                }
	            } else if (matchKeyword('const') || matchKeyword('let')) {
	                init = new Node();
	                kind = lex().value;

	                if (!strict && lookahead.value === 'in') {
	                    init = init.finishIdentifier(kind);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else {
	                    state.allowIn = false;
	                    declarations = parseBindingList(kind, {inFor: true});
	                    state.allowIn = previousAllowIn;

	                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                        lex();
	                        left = init;
	                        right = parseExpression();
	                        init = null;
	                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                        lex();
	                        left = init;
	                        right = parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    } else {
	                        consumeSemicolon();
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                    }
	                }
	            } else {
	                initStartToken = lookahead;
	                state.allowIn = false;
	                init = inheritCoverGrammar(parseAssignmentExpression);
	                state.allowIn = previousAllowIn;

	                if (matchKeyword('in')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForIn);
	                    }

	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (matchContextualKeyword('of')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForLoop);
	                    }

	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    if (match(',')) {
	                        initSeq = [init];
	                        while (match(',')) {
	                            lex();
	                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
	                        }
	                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
	                    }
	                    expect(';');
	                }
	            }
	        }

	        if (typeof left === 'undefined') {

	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');

	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = isolateCoverGrammar(parseStatement);

	        state.inIteration = oldInIteration;

	        return (typeof left === 'undefined') ?
	                node.finishForStatement(init, test, update, body) :
	                forIn ? node.finishForInStatement(left, right, body) :
	                    node.finishForOfStatement(left, right, body);
	    }

	    // ECMA-262 13.8 The continue statement

	    function parseContinueStatement(node) {
	        var label = null, key;

	        expectKeyword('continue');

	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(startIndex) === 0x3B) {
	            lex();

	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }

	            return node.finishContinueStatement(null);
	        }

	        if (hasLineTerminator) {
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }

	            return node.finishContinueStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !state.inIteration) {
	            throwError(Messages.IllegalContinue);
	        }

	        return node.finishContinueStatement(label);
	    }

	    // ECMA-262 13.9 The break statement

	    function parseBreakStatement(node) {
	        var label = null, key;

	        expectKeyword('break');

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(lastIndex) === 0x3B) {
	            lex();

	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }

	            return node.finishBreakStatement(null);
	        }

	        if (hasLineTerminator) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }
	        } else if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError(Messages.IllegalBreak);
	        }

	        return node.finishBreakStatement(label);
	    }

	    // ECMA-262 13.10 The return statement

	    function parseReturnStatement(node) {
	        var argument = null;

	        expectKeyword('return');

	        if (!state.inFunctionBody) {
	            tolerateError(Messages.IllegalReturn);
	        }

	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(lastIndex) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return node.finishReturnStatement(argument);
	            }
	        }

	        if (hasLineTerminator) {
	            // HACK
	            return node.finishReturnStatement(null);
	        }

	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }

	        consumeSemicolon();

	        return node.finishReturnStatement(argument);
	    }

	    // ECMA-262 13.11 The with statement

	    function parseWithStatement(node) {
	        var object, body;

	        if (strict) {
	            tolerateError(Messages.StrictModeWith);
	        }

	        expectKeyword('with');

	        expect('(');

	        object = parseExpression();

	        expect(')');

	        body = parseStatement();

	        return node.finishWithStatement(object, body);
	    }

	    // ECMA-262 13.12 The switch statement

	    function parseSwitchCase() {
	        var test, consequent = [], statement, node = new Node();

	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');

	        while (startIndex < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatementListItem();
	            consequent.push(statement);
	        }

	        return node.finishSwitchCase(test, consequent);
	    }

	    function parseSwitchStatement(node) {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;

	        expectKeyword('switch');

	        expect('(');

	        discriminant = parseExpression();

	        expect(')');

	        expect('{');

	        cases = [];

	        if (match('}')) {
	            lex();
	            return node.finishSwitchStatement(discriminant, cases);
	        }

	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;

	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError(Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }

	        state.inSwitch = oldInSwitch;

	        expect('}');

	        return node.finishSwitchStatement(discriminant, cases);
	    }

	    // ECMA-262 13.14 The throw statement

	    function parseThrowStatement(node) {
	        var argument;

	        expectKeyword('throw');

	        if (hasLineTerminator) {
	            throwError(Messages.NewlineAfterThrow);
	        }

	        argument = parseExpression();

	        consumeSemicolon();

	        return node.finishThrowStatement(argument);
	    }

	    // ECMA-262 13.15 The try statement

	    function parseCatchClause() {
	        var param, params = [], paramMap = {}, key, i, body, node = new Node();

	        expectKeyword('catch');

	        expect('(');
	        if (match(')')) {
	            throwUnexpectedToken(lookahead);
	        }

	        param = parsePattern(params);
	        for (i = 0; i < params.length; i++) {
	            key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                tolerateError(Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }

	        // ECMA-262 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            tolerateError(Messages.StrictCatchVariable);
	        }

	        expect(')');
	        body = parseBlock();
	        return node.finishCatchClause(param, body);
	    }

	    function parseTryStatement(node) {
	        var block, handler = null, finalizer = null;

	        expectKeyword('try');

	        block = parseBlock();

	        if (matchKeyword('catch')) {
	            handler = parseCatchClause();
	        }

	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }

	        if (!handler && !finalizer) {
	            throwError(Messages.NoCatchOrFinally);
	        }

	        return node.finishTryStatement(block, handler, finalizer);
	    }

	    // ECMA-262 13.16 The debugger statement

	    function parseDebuggerStatement(node) {
	        expectKeyword('debugger');

	        consumeSemicolon();

	        return node.finishDebuggerStatement();
	    }

	    // 13 Statements

	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            node;

	        if (type === Token.EOF) {
	            throwUnexpectedToken(lookahead);
	        }

	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }
	        isAssignmentTarget = isBindingElement = true;
	        node = new Node();

	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return parseEmptyStatement(node);
	            case '(':
	                return parseExpressionStatement(node);
	            default:
	                break;
	            }
	        } else if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return parseBreakStatement(node);
	            case 'continue':
	                return parseContinueStatement(node);
	            case 'debugger':
	                return parseDebuggerStatement(node);
	            case 'do':
	                return parseDoWhileStatement(node);
	            case 'for':
	                return parseForStatement(node);
	            case 'function':
	                return parseFunctionDeclaration(node);
	            case 'if':
	                return parseIfStatement(node);
	            case 'return':
	                return parseReturnStatement(node);
	            case 'switch':
	                return parseSwitchStatement(node);
	            case 'throw':
	                return parseThrowStatement(node);
	            case 'try':
	                return parseTryStatement(node);
	            case 'var':
	                return parseVariableStatement(node);
	            case 'while':
	                return parseWhileStatement(node);
	            case 'with':
	                return parseWithStatement(node);
	            default:
	                break;
	            }
	        }

	        expr = parseExpression();

	        // ECMA-262 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();

	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.Redeclaration, 'Label', expr.name);
	            }

	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return node.finishLabeledStatement(expr, labeledBody);
	        }

	        consumeSemicolon();

	        return node.finishExpressionStatement(expr);
	    }

	    // ECMA-262 14.1 Function Definition

	    function parseFunctionSourceElements() {
	        var statement, body = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,
	            node = new Node();

	        expect('{');

	        while (startIndex < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;

	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;
	        oldParenthesisCount = state.parenthesizedCount;

	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;
	        state.parenthesizedCount = 0;

	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            body.push(parseStatementListItem());
	        }

	        expect('}');

	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;
	        state.parenthesizedCount = oldParenthesisCount;

	        return node.finishBlockStatement(body);
	    }

	    function validateParam(options, param, name) {
	        var key = '$' + name;
	        if (strict) {
	            if (isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        } else if (!options.firstRestricted) {
	            if (isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamName;
	            } else if (isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictReservedWord;
	            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        }
	        options.paramSet[key] = true;
	    }

	    function parseParam(options) {
	        var token, param, params = [], i, def;

	        token = lookahead;
	        if (token.value === '...') {
	            param = parseRestElement(params);
	            validateParam(options, param.argument, param.argument.name);
	            options.params.push(param);
	            options.defaults.push(null);
	            return false;
	        }

	        param = parsePatternWithDefault(params);
	        for (i = 0; i < params.length; i++) {
	            validateParam(options, params[i], params[i].value);
	        }

	        if (param.type === Syntax.AssignmentPattern) {
	            def = param.right;
	            param = param.left;
	            ++options.defaultCount;
	        }

	        options.params.push(param);
	        options.defaults.push(def);

	        return !match(')');
	    }

	    function parseParams(firstRestricted) {
	        var options;

	        options = {
	            params: [],
	            defaultCount: 0,
	            defaults: [],
	            firstRestricted: firstRestricted
	        };

	        expect('(');

	        if (!match(')')) {
	            options.paramSet = {};
	            while (startIndex < length) {
	                if (!parseParam(options)) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        if (options.defaultCount === 0) {
	            options.defaults = [];
	        }

	        return {
	            params: options.params,
	            defaults: options.defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseFunctionDeclaration(node, identifierIsOptional) {
	        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
	            isGenerator, previousAllowYield;

	        previousAllowYield = state.allowYield;

	        expectKeyword('function');

	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }

	        if (!identifierIsOptional || !match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        state.allowYield = !isGenerator;
	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }


	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }

	        strict = previousStrict;
	        state.allowYield = previousAllowYield;

	        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
	    }

	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp,
	            params = [], defaults = [], body, previousStrict, node = new Node(),
	            isGenerator, previousAllowYield;

	        previousAllowYield = state.allowYield;

	        expectKeyword('function');

	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }

	        state.allowYield = !isGenerator;
	        if (!match('(')) {
	            token = lookahead;
	            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;

	        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
	    }

	    // ECMA-262 14.5 Class Definitions

	    function parseClassBody() {
	        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

	        classBody = new Node();

	        expect('{');
	        body = [];
	        while (!match('}')) {
	            if (match(';')) {
	                lex();
	            } else {
	                method = new Node();
	                token = lookahead;
	                isStatic = false;
	                computed = match('[');
	                if (match('*')) {
	                    lex();
	                } else {
	                    key = parseObjectPropertyKey();
	                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
	                        token = lookahead;
	                        isStatic = true;
	                        computed = match('[');
	                        if (match('*')) {
	                            lex();
	                        } else {
	                            key = parseObjectPropertyKey();
	                        }
	                    }
	                }
	                method = tryParseMethodDefinition(token, key, computed, method);
	                if (method) {
	                    method['static'] = isStatic; // jscs:ignore requireDotNotation
	                    if (method.kind === 'init') {
	                        method.kind = 'method';
	                    }
	                    if (!isStatic) {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
	                            if (method.kind !== 'method' || !method.method || method.value.generator) {
	                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
	                            }
	                            if (hasConstructor) {
	                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
	                            } else {
	                                hasConstructor = true;
	                            }
	                            method.kind = 'constructor';
	                        }
	                    } else {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
	                            throwUnexpectedToken(token, Messages.StaticPrototype);
	                        }
	                    }
	                    method.type = Syntax.MethodDefinition;
	                    delete method.method;
	                    delete method.shorthand;
	                    body.push(method);
	                } else {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	        lex();
	        return classBody.finishClassBody(body);
	    }

	    function parseClassDeclaration(identifierIsOptional) {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;

	        expectKeyword('class');

	        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;

	        return classNode.finishClassDeclaration(id, superClass, classBody);
	    }

	    function parseClassExpression() {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;

	        expectKeyword('class');

	        if (lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;

	        return classNode.finishClassExpression(id, superClass, classBody);
	    }

	    // ECMA-262 15.2 Modules

	    function parseModuleSpecifier() {
	        var node = new Node();

	        if (lookahead.type !== Token.StringLiteral) {
	            throwError(Messages.InvalidModuleSpecifier);
	        }
	        return node.finishLiteral(lex());
	    }

	    // ECMA-262 15.2.3 Exports

	    function parseExportSpecifier() {
	        var exported, local, node = new Node(), def;
	        if (matchKeyword('default')) {
	            // export {default} from 'something';
	            def = new Node();
	            lex();
	            local = def.finishIdentifier('default');
	        } else {
	            local = parseVariableIdentifier();
	        }
	        if (matchContextualKeyword('as')) {
	            lex();
	            exported = parseNonComputedProperty();
	        }
	        return node.finishExportSpecifier(local, exported);
	    }

	    function parseExportNamedDeclaration(node) {
	        var declaration = null,
	            isExportFromIdentifier,
	            src = null, specifiers = [];

	        // non-default export
	        if (lookahead.type === Token.Keyword) {
	            // covers:
	            // export var f = 1;
	            switch (lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = parseLexicalDeclaration({inFor: false});
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = parseStatementListItem();
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	            }
	        }

	        expect('{');
	        while (!match('}')) {
	            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
	            specifiers.push(parseExportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');

	        if (matchContextualKeyword('from')) {
	            // covering:
	            // export {default} from 'foo';
	            // export {foo} from 'foo';
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	        } else if (isExportFromIdentifier) {
	            // covering:
	            // export {default}; // missing fromClause
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        } else {
	            // cover
	            // export {foo};
	            consumeSemicolon();
	        }
	        return node.finishExportNamedDeclaration(declaration, specifiers, src);
	    }

	    function parseExportDefaultDeclaration(node) {
	        var declaration = null,
	            expression = null;

	        // covers:
	        // export default ...
	        expectKeyword('default');

	        if (matchKeyword('function')) {
	            // covers:
	            // export default function foo () {}
	            // export default function () {}
	            declaration = parseFunctionDeclaration(new Node(), true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	        if (matchKeyword('class')) {
	            declaration = parseClassDeclaration(true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }

	        if (matchContextualKeyword('from')) {
	            throwError(Messages.UnexpectedToken, lookahead.value);
	        }

	        // covers:
	        // export default {};
	        // export default [];
	        // export default (1 + 2);
	        if (match('{')) {
	            expression = parseObjectInitializer();
	        } else if (match('[')) {
	            expression = parseArrayInitializer();
	        } else {
	            expression = parseAssignmentExpression();
	        }
	        consumeSemicolon();
	        return node.finishExportDefaultDeclaration(expression);
	    }

	    function parseExportAllDeclaration(node) {
	        var src;

	        // covers:
	        // export * from 'foo';
	        expect('*');
	        if (!matchContextualKeyword('from')) {
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();

	        return node.finishExportAllDeclaration(src);
	    }

	    function parseExportDeclaration() {
	        var node = new Node();
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalExportDeclaration);
	        }

	        expectKeyword('export');

	        if (matchKeyword('default')) {
	            return parseExportDefaultDeclaration(node);
	        }
	        if (match('*')) {
	            return parseExportAllDeclaration(node);
	        }
	        return parseExportNamedDeclaration(node);
	    }

	    // ECMA-262 15.2.2 Imports

	    function parseImportSpecifier() {
	        // import {<foo as bar>} ...;
	        var local, imported, node = new Node();

	        imported = parseNonComputedProperty();
	        if (matchContextualKeyword('as')) {
	            lex();
	            local = parseVariableIdentifier();
	        }

	        return node.finishImportSpecifier(local, imported);
	    }

	    function parseNamedImports() {
	        var specifiers = [];
	        // {foo, bar as bas}
	        expect('{');
	        while (!match('}')) {
	            specifiers.push(parseImportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');
	        return specifiers;
	    }

	    function parseImportDefaultSpecifier() {
	        // import <foo> ...;
	        var local, node = new Node();

	        local = parseNonComputedProperty();

	        return node.finishImportDefaultSpecifier(local);
	    }

	    function parseImportNamespaceSpecifier() {
	        // import <* as foo> ...;
	        var local, node = new Node();

	        expect('*');
	        if (!matchContextualKeyword('as')) {
	            throwError(Messages.NoAsAfterImportNamespace);
	        }
	        lex();
	        local = parseNonComputedProperty();

	        return node.finishImportNamespaceSpecifier(local);
	    }

	    function parseImportDeclaration() {
	        var specifiers = [], src, node = new Node();

	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalImportDeclaration);
	        }

	        expectKeyword('import');

	        if (lookahead.type === Token.StringLiteral) {
	            // import 'foo';
	            src = parseModuleSpecifier();
	        } else {

	            if (match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(parseNamedImports());
	            } else if (match('*')) {
	                // import * as foo
	                specifiers.push(parseImportNamespaceSpecifier());
	            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
	                // import foo
	                specifiers.push(parseImportDefaultSpecifier());
	                if (match(',')) {
	                    lex();
	                    if (match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(parseImportNamespaceSpecifier());
	                    } else if (match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(parseNamedImports());
	                    } else {
	                        throwUnexpectedToken(lookahead);
	                    }
	                }
	            } else {
	                throwUnexpectedToken(lex());
	            }

	            if (!matchContextualKeyword('from')) {
	                throwError(lookahead.value ?
	                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	            }
	            lex();
	            src = parseModuleSpecifier();
	        }

	        consumeSemicolon();
	        return node.finishImportDeclaration(specifiers, src);
	    }

	    // ECMA-262 15.1 Scripts

	    function parseScriptBody() {
	        var statement, body = [], token, directive, firstRestricted;

	        while (startIndex < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }

	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        while (startIndex < length) {
	            statement = parseStatementListItem();
	            /* istanbul ignore if */
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            body.push(statement);
	        }
	        return body;
	    }

	    function parseProgram() {
	        var body, node;

	        peek();
	        node = new Node();

	        body = parseScriptBody();
	        return node.finishProgram(body, state.sourceType);
	    }

	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];

	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (entry.regex) {
	                token.regex = {
	                    pattern: entry.regex.pattern,
	                    flags: entry.regex.flags
	                };
	            }
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }

	        extra.tokens = tokens;
	    }

	    function tokenize(code, options, delegate) {
	        var toString,
	            tokens;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: []
	        };

	        extra = {};

	        // Options matching.
	        options = options || {};

	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenValues = [];
	        extra.tokenize = true;
	        extra.delegate = delegate;

	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;

	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;

	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }

	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }

	            lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    lex();
	                } catch (lexError) {
	                    if (extra.errors) {
	                        recordError(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }

	            tokens = extra.tokens;
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }

	    function parse(code, options) {
	        var program, toString;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: [],
	            sourceType: 'script'
	        };
	        strict = false;

	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }

	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	            if (options.sourceType === 'module') {
	                // very restrictive condition for now
	                state.sourceType = options.sourceType;
	                strict = true;
	            }
	        }

	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }

	        return program;
	    }

	    // Sync with *.json manifests.
	    exports.version = '2.7.1';

	    exports.tokenize = tokenize;

	    exports.parse = parse;

	    // Deep copy.
	    /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};

	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }

	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }

	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }

	        return types;
	    }());

	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	function DOMParser(options){
		this.options = options ||{locator:{}};
		
	}
	DOMParser.prototype.parseFromString = function(source,mimeType){	
		var options = this.options;
		var sax =  new XMLReader();
		var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
		var errorHandler = options.errorHandler;
		var locator = options.locator;
		var defaultNSMap = options.xmlns||{};
		var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
		if(locator){
			domBuilder.setDocumentLocator(locator)
		}
		
		sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
		sax.domBuilder = options.domBuilder || domBuilder;
		if(/\/x?html?$/.test(mimeType)){
			entityMap.nbsp = '\xa0';
			entityMap.copy = '\xa9';
			defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
		}
		if(source){
			sax.parse(source,defaultNSMap,entityMap);
		}else{
			sax.errorHandler.error("invalid document source");
		}
		return domBuilder.document;
	}
	function buildErrorHandler(errorImpl,domBuilder,locator){
		if(!errorImpl){
			if(domBuilder instanceof DOMHandler){
				return domBuilder;
			}
			errorImpl = domBuilder ;
		}
		var errorHandler = {}
		var isCallback = errorImpl instanceof Function;
		locator = locator||{}
		function build(key){
			var fn = errorImpl[key];
			if(!fn){
				if(isCallback){
					fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
				}else{
					var i=arguments.length;
					while(--i){
						if(fn = errorImpl[arguments[i]]){
							break;
						}
					}
				}
			}
			errorHandler[key] = fn && function(msg){
				fn(msg+_locator(locator));
			}||function(){};
		}
		build('warning','warn');
		build('error','warn','warning');
		build('fatalError','warn','warning','error');
		return errorHandler;
	}
	/**
	 * +ContentHandler+ErrorHandler
	 * +LexicalHandler+EntityResolver2
	 * -DeclHandler-DTDHandler 
	 * 
	 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
	 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
	 */
	function DOMHandler() {
	    this.cdata = false;
	}
	function position(locator,node){
		node.lineNumber = locator.lineNumber;
		node.columnNumber = locator.columnNumber;
	}
	/**
	 * @see org.xml.sax.ContentHandler#startDocument
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */ 
	DOMHandler.prototype = {
		startDocument : function() {
	    	this.document = new DOMImplementation().createDocument(null, null, null);
	    	if (this.locator) {
	        	this.document.documentURI = this.locator.systemId;
	    	}
		},
		startElement:function(namespaceURI, localName, qName, attrs) {
			var doc = this.document;
		    var el = doc.createElementNS(namespaceURI, qName||localName);
		    var len = attrs.length;
		    appendElement(this, el);
		    this.currentElement = el;
		    
			this.locator && position(this.locator,el)
		    for (var i = 0 ; i < len; i++) {
		        var namespaceURI = attrs.getURI(i);
		        var value = attrs.getValue(i);
		        var qName = attrs.getQName(i);
				var attr = doc.createAttributeNS(namespaceURI, qName);
				if( attr.getOffset){
					position(attr.getOffset(1),attr)
				}
				attr.value = attr.nodeValue = value;
				el.setAttributeNode(attr)
		    }
		},
		endElement:function(namespaceURI, localName, qName) {
			var current = this.currentElement
		    var tagName = current.tagName;
		    this.currentElement = current.parentNode;
		},
		startPrefixMapping:function(prefix, uri) {
		},
		endPrefixMapping:function(prefix) {
		},
		processingInstruction:function(target, data) {
		    var ins = this.document.createProcessingInstruction(target, data);
		    this.locator && position(this.locator,ins)
		    appendElement(this, ins);
		},
		ignorableWhitespace:function(ch, start, length) {
		},
		characters:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
			//console.log(chars)
			if(this.currentElement && chars){
				if (this.cdata) {
					var charNode = this.document.createCDATASection(chars);
					this.currentElement.appendChild(charNode);
				} else {
					var charNode = this.document.createTextNode(chars);
					this.currentElement.appendChild(charNode);
				}
				this.locator && position(this.locator,charNode)
			}
		},
		skippedEntity:function(name) {
		},
		endDocument:function() {
			this.document.normalize();
		},
		setDocumentLocator:function (locator) {
		    if(this.locator = locator){// && !('lineNumber' in locator)){
		    	locator.lineNumber = 0;
		    }
		},
		//LexicalHandler
		comment:function(chars, start, length) {
			chars = _toString.apply(this,arguments)
		    var comm = this.document.createComment(chars);
		    this.locator && position(this.locator,comm)
		    appendElement(this, comm);
		},
		
		startCDATA:function() {
		    //used in characters() methods
		    this.cdata = true;
		},
		endCDATA:function() {
		    this.cdata = false;
		},
		
		startDTD:function(name, publicId, systemId) {
			var impl = this.document.implementation;
		    if (impl && impl.createDocumentType) {
		        var dt = impl.createDocumentType(name, publicId, systemId);
		        this.locator && position(this.locator,dt)
		        appendElement(this, dt);
		    }
		},
		/**
		 * @see org.xml.sax.ErrorHandler
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
		 */
		warning:function(error) {
			console.warn(error,_locator(this.locator));
		},
		error:function(error) {
			console.error(error,_locator(this.locator));
		},
		fatalError:function(error) {
			console.error(error,_locator(this.locator));
		    throw error;
		}
	}
	function _locator(l){
		if(l){
			return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
		}
	}
	function _toString(chars,start,length){
		if(typeof chars == 'string'){
			return chars.substr(start,length)
		}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
			if(chars.length >= start+length || start){
				return new java.lang.String(chars,start,length)+'';
			}
			return chars;
		}
	}

	/*
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
	 * used method of org.xml.sax.ext.LexicalHandler:
	 *  #comment(chars, start, length)
	 *  #startCDATA()
	 *  #endCDATA()
	 *  #startDTD(name, publicId, systemId)
	 *
	 *
	 * IGNORED method of org.xml.sax.ext.LexicalHandler:
	 *  #endDTD()
	 *  #startEntity(name)
	 *  #endEntity(name)
	 *
	 *
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
	 * IGNORED method of org.xml.sax.ext.DeclHandler
	 * 	#attributeDecl(eName, aName, type, mode, value)
	 *  #elementDecl(name, model)
	 *  #externalEntityDecl(name, publicId, systemId)
	 *  #internalEntityDecl(name, value)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
	 * IGNORED method of org.xml.sax.EntityResolver2
	 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
	 *  #resolveEntity(publicId, systemId)
	 *  #getExternalSubset(name, baseURI)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
	 * IGNORED method of org.xml.sax.DTDHandler
	 *  #notationDecl(name, publicId, systemId) {};
	 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
	 */
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
		DOMHandler.prototype[key] = function(){return null}
	})

	/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
	function appendElement (hander,node) {
	    if (!hander.currentElement) {
	        hander.document.appendChild(node);
	    } else {
	        hander.currentElement.appendChild(node);
	    }
	}//appendChild and setAttributeNS are preformance key

	if(true){
		var XMLReader = __webpack_require__(12).XMLReader;
		var DOMImplementation = exports.DOMImplementation = __webpack_require__(13).DOMImplementation;
		exports.XMLSerializer = __webpack_require__(13).XMLSerializer ;
		exports.DOMParser = DOMParser;
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
	//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
	//[5]   	Name	   ::=   	NameStartChar (NameChar)*
	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
	var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\u00B7\u0300-\u036F\\ux203F-\u2040]");
	var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
	//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
	//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
	var S_TAG = 0;//tag name offerring
	var S_ATTR = 1;//attr name offerring 
	var S_ATTR_S=2;//attr name end and space offer
	var S_EQ = 3;//=space?
	var S_V = 4;//attr value(no quot value only)
	var S_E = 5;//attr value end and no space(quot end)
	var S_S = 6;//(attr value end || tag end ) && (space offer)
	var S_C = 7;//closed el<el />

	function XMLReader(){
		
	}

	XMLReader.prototype = {
		parse:function(source,defaultNSMap,entityMap){
			var domBuilder = this.domBuilder;
			domBuilder.startDocument();
			_copy(defaultNSMap ,defaultNSMap = {})
			parse(source,defaultNSMap,entityMap,
					domBuilder,this.errorHandler);
			domBuilder.endDocument();
		}
	}
	function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	  function fixedFromCharCode(code) {
			// String.prototype.fromCharCode does not supports
			// > 2 bytes unicode chars directly
			if (code > 0xffff) {
				code -= 0x10000;
				var surrogate1 = 0xd800 + (code >> 10)
					, surrogate2 = 0xdc00 + (code & 0x3ff);

				return String.fromCharCode(surrogate1, surrogate2);
			} else {
				return String.fromCharCode(code);
			}
		}
		function entityReplacer(a){
			var k = a.slice(1,-1);
			if(k in entityMap){
				return entityMap[k]; 
			}else if(k.charAt(0) === '#'){
				return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
			}else{
				errorHandler.error('entity not found:'+a);
				return a;
			}
		}
		function appendText(end){//has some bugs
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
		function position(start,m){
			while(start>=endPos && (m = linePattern.exec(source))){
				startPos = m.index;
				endPos = startPos + m[0].length;
				locator.lineNumber++;
				//console.log('line++:',locator,startPos,endPos)
			}
			locator.columnNumber = start-startPos+1;
		}
		var startPos = 0;
		var endPos = 0;
		var linePattern = /.+(?:\r\n?|\n)|.*$/g
		var locator = domBuilder.locator;
		
		var parseStack = [{currentNSMap:defaultNSMapCopy}]
		var closeMap = {};
		var start = 0;
		while(true){
			var i = source.indexOf('<',start);
			if(i<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.document;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(i>start){
				appendText(i);
			}
			switch(source.charAt(i+1)){
			case '/':
				var end = source.indexOf('>',i+3);
				var tagName = source.substring(i+2,end);
				var config = parseStack.pop();
				var localNSMap = config.localNSMap;
				
		        if(config.tagName != tagName){
		            errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
		        }
				domBuilder.endElement(config.uri,config.localName,tagName);
				if(localNSMap){
					for(var prefix in localNSMap){
						domBuilder.endPrefixMapping(prefix) ;
					}
				}
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(i);
				end = parseInstruction(source,i,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(i);
				end = parseDCC(source,i,domBuilder,errorHandler);
				break;
			default:
				try{
					locator&&position(i);
					
					var el = new ElementAttributes();
					
					//elStartEnd
					var end = parseElementStartPart(source,i,el,entityReplacer,errorHandler);
					var len = el.length;
					//position fixed
					if(len && locator){
						var backup = copyLocator(locator,{});
						for(var i = 0;i<len;i++){
							var a = el[i];
							position(a.offset);
							a.offset = copyLocator(locator,{});
						}
						copyLocator(backup,locator);
					}
					if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
						el.closed = true;
						if(!entityMap.nbsp){
							errorHandler.warning('unclosed xml attribute');
						}
					}
					appendElement(el,domBuilder,parseStack);
					
					
					if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
						end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
					}else{
						end++;
					}
				}catch(e){
					errorHandler.error('element parse error: '+e);
					end = -1;
				}

			}
			if(end<0){
				//TODO: 这里有可能sax回退，有位置错误风险
				appendText(i+1);
			}else{
				start = end;
			}
		}
	}
	function copyLocator(f,t){
		t.lineNumber = f.lineNumber;
		t.columnNumber = f.columnNumber;
		return t;
		
	}

	/**
	 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function parseElementStartPart(source,start,el,entityReplacer,errorHandler){
		var attrName;
		var value;
		var p = ++start;
		var s = S_TAG;//status
		while(true){
			var c = source.charAt(p);
			switch(c){
			case '=':
				if(s === S_ATTR){//attrName
					attrName = source.slice(start,p);
					s = S_EQ;
				}else if(s === S_ATTR_S){
					s = S_EQ;
				}else{
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName');
				}
				break;
			case '\'':
			case '"':
				if(s === S_EQ){//equal
					start = p+1;
					p = source.indexOf(c,start)
					if(p>0){
						value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						el.add(attrName,value,start-1);
						s = S_E;
					}else{
						//fatalError: no end quot match
						throw new Error('attribute value no end \''+c+'\' match');
					}
				}else if(s == S_V){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					//console.log(attrName,value,start,p)
					el.add(attrName,value,start);
					//console.dir(el)
					errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
					start = p+1;
					s = S_E
				}else{
					//fatalError: no equal before
					throw new Error('attribute value must after "="');
				}
				break;
			case '/':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					s = S_C;
					el.closed = true;
				case S_V:
				case S_ATTR:
				case S_ATTR_S:
					break;
				//case S_EQ:
				default:
					throw new Error("attribute invalid close char('/')")
				}
				break;
			case ''://end document
				//throw new Error('unexpected end of input')
				errorHandler.error('unexpected end of input');
			case '>':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_E:
				case S_S:
				case S_C:
					break;//normal
				case S_V://Compatible state
				case S_ATTR:
					value = source.slice(start,p);
					if(value.slice(-1) === '/'){
						el.closed  = true;
						value = value.slice(0,-1)
					}
				case S_ATTR_S:
					if(s === S_ATTR_S){
						value = attrName;
					}
					if(s == S_V){
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
					}else{
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
						el.add(value,value,start)
					}
					break;
				case S_EQ:
					throw new Error('attribute value missed!!');
				}
	//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if(c<= ' '){//space
					switch(s){
					case S_TAG:
						el.setTagName(source.slice(start,p));//tagName
						s = S_S;
						break;
					case S_ATTR:
						attrName = source.slice(start,p)
						s = S_ATTR_S;
						break;
					case S_V:
						var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						el.add(attrName,value,start)
					case S_E:
						s = S_S;
						break;
					//case S_S:
					//case S_EQ:
					//case S_ATTR_S:
					//	void();break;
					//case S_C:
						//ignore warning
					}
				}else{//not space
	//S_TAG,	S_ATTR,	S_EQ,	S_V
	//S_ATTR_S,	S_E,	S_S,	S_C
					switch(s){
					//case S_TAG:void();break;
					//case S_ATTR:void();break;
					//case S_V:void();break;
					case S_ATTR_S:
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead!!')
						el.add(attrName,attrName,start);
						start = p;
						s = S_ATTR;
						break;
					case S_E:
						errorHandler.warning('attribute space is required"'+attrName+'"!!')
					case S_S:
						s = S_ATTR;
						start = p;
						break;
					case S_EQ:
						s = S_V;
						start = p;
						break;
					case S_C:
						throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
			}
			p++;
		}
	}
	/**
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function appendElement(el,domBuilder,parseStack){
		var tagName = el.tagName;
		var localNSMap = null;
		var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
		var i = el.length;
		while(i--){
			var a = el[i];
			var qName = a.qName;
			var value = a.value;
			var nsp = qName.indexOf(':');
			if(nsp>0){
				var prefix = a.prefix = qName.slice(0,nsp);
				var localName = qName.slice(nsp+1);
				var nsPrefix = prefix === 'xmlns' && localName
			}else{
				localName = qName;
				prefix = null
				nsPrefix = qName === 'xmlns' && ''
			}
			//can not set prefix,because prefix !== ''
			a.localName = localName ;
			//prefix == null for no ns prefix attribute 
			if(nsPrefix !== false){//hack!!
				if(localNSMap == null){
					localNSMap = {}
					//console.log(currentNSMap,0)
					_copy(currentNSMap,currentNSMap={})
					//console.log(currentNSMap,1)
				}
				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
				a.uri = 'http://www.w3.org/2000/xmlns/'
				domBuilder.startPrefixMapping(nsPrefix, value) 
			}
		}
		var i = el.length;
		while(i--){
			a = el[i];
			var prefix = a.prefix;
			if(prefix){//no prefix attribute has no namespace
				if(prefix === 'xml'){
					a.uri = 'http://www.w3.org/XML/1998/namespace';
				}if(prefix !== 'xmlns'){
					a.uri = currentNSMap[prefix]
					
					//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
				}
			}
		}
		var nsp = tagName.indexOf(':');
		if(nsp>0){
			prefix = el.prefix = tagName.slice(0,nsp);
			localName = el.localName = tagName.slice(nsp+1);
		}else{
			prefix = null;//important!!
			localName = el.localName = tagName;
		}
		//no prefix element has default namespace
		var ns = el.uri = currentNSMap[prefix || ''];
		domBuilder.startElement(ns,localName,tagName,el);
		//endPrefixMapping and startPrefixMapping have not any help for dom builder
		//localNSMap = null
		if(el.closed){
			domBuilder.endElement(ns,localName,tagName);
			if(localNSMap){
				for(prefix in localNSMap){
					domBuilder.endPrefixMapping(prefix) 
				}
			}
		}else{
			el.currentNSMap = currentNSMap;
			el.localNSMap = localNSMap;
			parseStack.push(el);
		}
	}
	function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
		if(/^(?:script|textarea)$/i.test(tagName)){
			var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
			var text = source.substring(elStartEnd+1,elEndStart);
			if(/[&<]/.test(text)){
				if(/^script$/i.test(tagName)){
					//if(!/\]\]>/.test(text)){
						//lexHandler.startCDATA();
						domBuilder.characters(text,0,text.length);
						//lexHandler.endCDATA();
						return elEndStart;
					//}
				}//}else{//text area
					text = text.replace(/&#?\w+;/g,entityReplacer);
					domBuilder.characters(text,0,text.length);
					return elEndStart;
				//}
				
			}
		}
		return elStartEnd+1;
	}
	function fixSelfClosed(source,elStartEnd,tagName,closeMap){
		//if(tagName in closeMap){
		var pos = closeMap[tagName];
		if(pos == null){
			//console.log(tagName)
			pos = closeMap[tagName] = source.lastIndexOf('</'+tagName+'>')
		}
		return pos<elStartEnd;
		//} 
	}
	function _copy(source,target){
		for(var n in source){target[n] = source[n]}
	}
	function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
		var next= source.charAt(start+2)
		switch(next){
		case '-':
			if(source.charAt(start + 3) === '-'){
				var end = source.indexOf('-->',start+4);
				//append comment source.substring(4,end)//<!--
				if(end>start){
					domBuilder.comment(source,start+4,end-start-4);
					return end+3;
				}else{
					errorHandler.error("Unclosed comment");
					return -1;
				}
			}else{
				//error
				return -1;
			}
		default:
			if(source.substr(start+3,6) == 'CDATA['){
				var end = source.indexOf(']]>',start+9);
				domBuilder.startCDATA();
				domBuilder.characters(source,start+9,end-start-9);
				domBuilder.endCDATA() 
				return end+3;
			}
			//<!DOCTYPE
			//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
			var matchs = split(source,start);
			var len = matchs.length;
			if(len>1 && /!doctype/i.test(matchs[0][0])){
				var name = matchs[1][0];
				var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
				var sysid = len>4 && matchs[4][0];
				var lastMatch = matchs[len-1]
				domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
						sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
				domBuilder.endDTD();
				
				return lastMatch.index+lastMatch[0].length
			}
		}
		return -1;
	}



	function parseInstruction(source,start,domBuilder){
		var end = source.indexOf('?>',start);
		if(end){
			var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
			if(match){
				var len = match[0].length;
				domBuilder.processingInstruction(match[1], match[2]) ;
				return end+2;
			}else{//error
				return -1;
			}
		}
		return -1;
	}

	/**
	 * @param source
	 */
	function ElementAttributes(source){
		
	}
	ElementAttributes.prototype = {
		setTagName:function(tagName){
			if(!tagNamePattern.test(tagName)){
				throw new Error('invalid tagName:'+tagName)
			}
			this.tagName = tagName
		},
		add:function(qName,value,offset){
			if(!tagNamePattern.test(qName)){
				throw new Error('invalid attribute:'+qName)
			}
			this[this.length++] = {qName:qName,value:value,offset:offset}
		},
		length:0,
		getLocalName:function(i){return this[i].localName},
		getOffset:function(i){return this[i].offset},
		getQName:function(i){return this[i].qName},
		getURI:function(i){return this[i].uri},
		getValue:function(i){return this[i].value}
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//			
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
	}




	function _set_proto_(thiz,parent){
		thiz.__proto__ = parent;
		return thiz;
	}
	if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
		_set_proto_ = function(thiz,parent){
			function p(){};
			p.prototype = parent;
			p = new p();
			for(parent in thiz){
				p[parent] = thiz[parent];
			}
			return p;
		}
	}

	function split(source,start){
		var match;
		var buf = [];
		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
		reg.lastIndex = start;
		reg.exec(source);//skip <
		while(match = reg.exec(source)){
			buf.push(match);
			if(match[1])return buf;
		}
	}

	if(true){
		exports.XMLReader = XMLReader;
	}



/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * DOM Level 2
	 * Object DOMException
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
	 */

	function copy(src,dest){
		for(var p in src){
			dest[p] = src[p];
		}
	}
	/**
	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
	 */
	function _extends(Class,Super){
		var pt = Class.prototype;
		if(Object.create){
			var ppt = Object.create(Super.prototype)
			pt.__proto__ = ppt;
		}
		if(!(pt instanceof Super)){
			function t(){};
			t.prototype = Super.prototype;
			t = new t();
			copy(pt,t);
			Class.prototype = pt = t;
		}
		if(pt.constructor != Class){
			if(typeof Class != 'function'){
				console.error("unknow Class:"+Class)
			}
			pt.constructor = Class
		}
	}
	var htmlns = 'http://www.w3.org/1999/xhtml' ;
	// Node Types
	var NodeType = {}
	var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
	var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
	var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
	var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
	var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
	var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
	var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
	var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
	var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
	var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
	var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

	// ExceptionCode
	var ExceptionCode = {}
	var ExceptionMessage = {};
	var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
	var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
	var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
	var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
	var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
	var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
	var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
	var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
	var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
	var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
	//level2
	var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
	var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
	var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
	var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
	var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


	function DOMException(code, message) {
		if(message instanceof Error){
			var error = message;
		}else{
			error = this;
			Error.call(this, ExceptionMessage[code]);
			this.message = ExceptionMessage[code];
			if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
		}
		error.code = code;
		if(message) this.message = this.message + ": " + message;
		return error;
	};
	DOMException.prototype = Error.prototype;
	copy(ExceptionCode,DOMException)
	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
	 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
	 * The items in the NodeList are accessible via an integral index, starting from 0.
	 */
	function NodeList() {
	};
	NodeList.prototype = {
		/**
		 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
		 * @standard level1
		 */
		length:0, 
		/**
		 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
		 * @standard level1
		 * @param index  unsigned long 
		 *   Index into the collection.
		 * @return Node
		 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
		 */
		item: function(index) {
			return this[index] || null;
		}
	};
	function LiveNodeList(node,refresh){
		this._node = node;
		this._refresh = refresh
		_updateLiveList(this);
	}
	function _updateLiveList(list){
		var inc = list._node._inc || list._node.ownerDocument._inc;
		if(list._inc != inc){
			var ls = list._refresh(list._node);
			//console.log(ls.length)
			__set__(list,'length',ls.length);
			copy(ls,list);
			list._inc = inc;
		}
	}
	LiveNodeList.prototype.item = function(i){
		_updateLiveList(this);
		return this[i];
	}

	_extends(LiveNodeList,NodeList);
	/**
	 * 
	 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
	 * NamedNodeMap objects in the DOM are live.
	 * used for attributes or DocumentType entities 
	 */
	function NamedNodeMap() {
	};

	function _findNodeIndex(list,node){
		var i = list.length;
		while(i--){
			if(list[i] === node){return i}
		}
	}

	function _addNamedNode(el,list,newAttr,oldAttr){
		if(oldAttr){
			list[_findNodeIndex(list,oldAttr)] = newAttr;
		}else{
			list[list.length++] = newAttr;
		}
		if(el){
			newAttr.ownerElement = el;
			var doc = el.ownerDocument;
			if(doc){
				oldAttr && _onRemoveAttribute(doc,el,oldAttr);
				_onAddAttribute(doc,el,newAttr);
			}
		}
	}
	function _removeNamedNode(el,list,attr){
		var i = _findNodeIndex(list,attr);
		if(i>=0){
			var lastIndex = list.length-1
			while(i<lastIndex){
				list[i] = list[++i]
			}
			list.length = lastIndex;
			if(el){
				var doc = el.ownerDocument;
				if(doc){
					_onRemoveAttribute(doc,el,attr);
					attr.ownerElement = null;
				}
			}
		}else{
			throw DOMException(NOT_FOUND_ERR,new Error())
		}
	}
	NamedNodeMap.prototype = {
		length:0,
		item:NodeList.prototype.item,
		getNamedItem: function(key) {
	//		if(key.indexOf(':')>0 || key == 'xmlns'){
	//			return null;
	//		}
			var i = this.length;
			while(i--){
				var attr = this[i];
				if(attr.nodeName == key){
					return attr;
				}
			}
		},
		setNamedItem: function(attr) {
			var el = attr.ownerElement;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			var oldAttr = this.getNamedItem(attr.nodeName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},
		/* returns Node */
		setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
			var el = attr.ownerElement, oldAttr;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},

		/* returns Node */
		removeNamedItem: function(key) {
			var attr = this.getNamedItem(key);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
			
			
		},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
		
		//for level2
		removeNamedItemNS:function(namespaceURI,localName){
			var attr = this.getNamedItemNS(namespaceURI,localName);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
		},
		getNamedItemNS: function(namespaceURI, localName) {
			var i = this.length;
			while(i--){
				var node = this[i];
				if(node.localName == localName && node.namespaceURI == namespaceURI){
					return node;
				}
			}
			return null;
		}
	};
	/**
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
	 */
	function DOMImplementation(/* Object */ features) {
		this._features = {};
		if (features) {
			for (var feature in features) {
				 this._features = features[feature];
			}
		}
	};

	DOMImplementation.prototype = {
		hasFeature: function(/* string */ feature, /* string */ version) {
			var versions = this._features[feature.toLowerCase()];
			if (versions && (!version || version in versions)) {
				return true;
			} else {
				return false;
			}
		},
		// Introduced in DOM Level 2:
		createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
			var doc = new Document();
			doc.doctype = doctype;
			if(doctype){
				doc.appendChild(doctype);
			}
			doc.implementation = this;
			doc.childNodes = new NodeList();
			if(qualifiedName){
				var root = doc.createElementNS(namespaceURI,qualifiedName);
				doc.appendChild(root);
			}
			return doc;
		},
		// Introduced in DOM Level 2:
		createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
			var node = new DocumentType();
			node.name = qualifiedName;
			node.nodeName = qualifiedName;
			node.publicId = publicId;
			node.systemId = systemId;
			// Introduced in DOM Level 2:
			//readonly attribute DOMString        internalSubset;
			
			//TODO:..
			//  readonly attribute NamedNodeMap     entities;
			//  readonly attribute NamedNodeMap     notations;
			return node;
		}
	};


	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
	 */

	function Node() {
	};

	Node.prototype = {
		firstChild : null,
		lastChild : null,
		previousSibling : null,
		nextSibling : null,
		attributes : null,
		parentNode : null,
		childNodes : null,
		ownerDocument : null,
		nodeValue : null,
		namespaceURI : null,
		prefix : null,
		localName : null,
		// Modified in DOM Level 2:
		insertBefore:function(newChild, refChild){//raises 
			return _insertBefore(this,newChild,refChild);
		},
		replaceChild:function(newChild, oldChild){//raises 
			this.insertBefore(newChild,oldChild);
			if(oldChild){
				this.removeChild(oldChild);
			}
		},
		removeChild:function(oldChild){
			return _removeChild(this,oldChild);
		},
		appendChild:function(newChild){
			return this.insertBefore(newChild,null);
		},
		hasChildNodes:function(){
			return this.firstChild != null;
		},
		cloneNode:function(deep){
			return cloneNode(this.ownerDocument||this,this,deep);
		},
		// Modified in DOM Level 2:
		normalize:function(){
			var child = this.firstChild;
			while(child){
				var next = child.nextSibling;
				if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
					this.removeChild(next);
					child.appendData(next.data);
				}else{
					child.normalize();
					child = next;
				}
			}
		},
	  	// Introduced in DOM Level 2:
		isSupported:function(feature, version){
			return this.ownerDocument.implementation.hasFeature(feature,version);
		},
	    // Introduced in DOM Level 2:
	    hasAttributes:function(){
	    	return this.attributes.length>0;
	    },
	    lookupPrefix:function(namespaceURI){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			for(var n in map){
	    				if(map[n] == namespaceURI){
	    					return n;
	    				}
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    lookupNamespaceURI:function(prefix){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			if(prefix in map){
	    				return map[prefix] ;
	    			}
	    		}
	    		el = el.nodeType == 2?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    isDefaultNamespace:function(namespaceURI){
	    	var prefix = this.lookupPrefix(namespaceURI);
	    	return prefix == null;
	    }
	};


	function _xmlEncoder(c){
		return c == '<' && '&lt;' ||
	         c == '>' && '&gt;' ||
	         c == '&' && '&amp;' ||
	         c == '"' && '&quot;' ||
	         '&#'+c.charCodeAt()+';'
	}


	copy(NodeType,Node);
	copy(NodeType,Node.prototype);

	/**
	 * @param callback return true for continue,false for break
	 * @return boolean true: break visit;
	 */
	function _visitNode(node,callback){
		if(callback(node)){
			return true;
		}
		if(node = node.firstChild){
			do{
				if(_visitNode(node,callback)){return true}
	        }while(node=node.nextSibling)
	    }
	}



	function Document(){
	}
	function _onAddAttribute(doc,el,newAttr){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
		}
	}
	function _onRemoveAttribute(doc,el,newAttr,remove){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns == 'http://www.w3.org/2000/xmlns/'){
			//update namespace
			delete el._nsMap[newAttr.prefix?newAttr.localName:'']
		}
	}
	function _onUpdateChild(doc,el,newChild){
		if(doc && doc._inc){
			doc._inc++;
			//update childNodes
			var cs = el.childNodes;
			if(newChild){
				cs[cs.length++] = newChild;
			}else{
				//console.log(1)
				var child = el.firstChild;
				var i = 0;
				while(child){
					cs[i++] = child;
					child =child.nextSibling;
				}
				cs.length = i;
			}
		}
	}

	/**
	 * attributes;
	 * children;
	 * 
	 * writeable properties:
	 * nodeValue,Attr:value,CharacterData:data
	 * prefix
	 */
	function _removeChild(parentNode,child){
		var previous = child.previousSibling;
		var next = child.nextSibling;
		if(previous){
			previous.nextSibling = next;
		}else{
			parentNode.firstChild = next
		}
		if(next){
			next.previousSibling = previous;
		}else{
			parentNode.lastChild = previous;
		}
		_onUpdateChild(parentNode.ownerDocument,parentNode);
		return child;
	}
	/**
	 * preformance key(refChild == null)
	 */
	function _insertBefore(parentNode,newChild,nextChild){
		var cp = newChild.parentNode;
		if(cp){
			cp.removeChild(newChild);//remove and update
		}
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			var newFirst = newChild.firstChild;
			if (newFirst == null) {
				return newChild;
			}
			var newLast = newChild.lastChild;
		}else{
			newFirst = newLast = newChild;
		}
		var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

		newFirst.previousSibling = pre;
		newLast.nextSibling = nextChild;
		
		
		if(pre){
			pre.nextSibling = newFirst;
		}else{
			parentNode.firstChild = newFirst;
		}
		if(nextChild == null){
			parentNode.lastChild = newLast;
		}else{
			nextChild.previousSibling = newLast;
		}
		do{
			newFirst.parentNode = parentNode;
		}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
		_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
		//console.log(parentNode.lastChild.nextSibling == null)
		if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
			newChild.firstChild = newChild.lastChild = null;
		}
		return newChild;
	}
	function _appendSingleChild(parentNode,newChild){
		var cp = newChild.parentNode;
		if(cp){
			var pre = parentNode.lastChild;
			cp.removeChild(newChild);//remove and update
			var pre = parentNode.lastChild;
		}
		var pre = parentNode.lastChild;
		newChild.parentNode = parentNode;
		newChild.previousSibling = pre;
		newChild.nextSibling = null;
		if(pre){
			pre.nextSibling = newChild;
		}else{
			parentNode.firstChild = newChild;
		}
		parentNode.lastChild = newChild;
		_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
		return newChild;
		//console.log("__aa",parentNode.lastChild.nextSibling == null)
	}
	Document.prototype = {
		//implementation : null,
		nodeName :  '#document',
		nodeType :  DOCUMENT_NODE,
		doctype :  null,
		documentElement :  null,
		_inc : 1,
		
		insertBefore :  function(newChild, refChild){//raises 
			if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
				var child = newChild.firstChild;
				while(child){
					var next = child.nextSibling;
					this.insertBefore(child,refChild);
					child = next;
				}
				return newChild;
			}
			if(this.documentElement == null && newChild.nodeType == 1){
				this.documentElement = newChild;
			}
			
			return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
		},
		removeChild :  function(oldChild){
			if(this.documentElement == oldChild){
				this.documentElement = null;
			}
			return _removeChild(this,oldChild);
		},
		// Introduced in DOM Level 2:
		importNode : function(importedNode,deep){
			return importNode(this,importedNode,deep);
		},
		// Introduced in DOM Level 2:
		getElementById :	function(id){
			var rtv = null;
			_visitNode(this.documentElement,function(node){
				if(node.nodeType == 1){
					if(node.getAttribute('id') == id){
						rtv = node;
						return true;
					}
				}
			})
			return rtv;
		},
		
		//document factory method:
		createElement :	function(tagName){
			var node = new Element();
			node.ownerDocument = this;
			node.nodeName = tagName;
			node.tagName = tagName;
			node.childNodes = new NodeList();
			var attrs	= node.attributes = new NamedNodeMap();
			attrs._ownerElement = node;
			return node;
		},
		createDocumentFragment :	function(){
			var node = new DocumentFragment();
			node.ownerDocument = this;
			node.childNodes = new NodeList();
			return node;
		},
		createTextNode :	function(data){
			var node = new Text();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createComment :	function(data){
			var node = new Comment();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createCDATASection :	function(data){
			var node = new CDATASection();
			node.ownerDocument = this;
			node.appendData(data)
			return node;
		},
		createProcessingInstruction :	function(target,data){
			var node = new ProcessingInstruction();
			node.ownerDocument = this;
			node.tagName = node.target = target;
			node.nodeValue= node.data = data;
			return node;
		},
		createAttribute :	function(name){
			var node = new Attr();
			node.ownerDocument	= this;
			node.name = name;
			node.nodeName	= name;
			node.localName = name;
			node.specified = true;
			return node;
		},
		createEntityReference :	function(name){
			var node = new EntityReference();
			node.ownerDocument	= this;
			node.nodeName	= name;
			return node;
		},
		// Introduced in DOM Level 2:
		createElementNS :	function(namespaceURI,qualifiedName){
			var node = new Element();
			var pl = qualifiedName.split(':');
			var attrs	= node.attributes = new NamedNodeMap();
			node.childNodes = new NodeList();
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.tagName = qualifiedName;
			node.namespaceURI = namespaceURI;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			attrs._ownerElement = node;
			return node;
		},
		// Introduced in DOM Level 2:
		createAttributeNS :	function(namespaceURI,qualifiedName){
			var node = new Attr();
			var pl = qualifiedName.split(':');
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.name = qualifiedName;
			node.namespaceURI = namespaceURI;
			node.specified = true;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else{
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			return node;
		}
	};
	_extends(Document,Node);


	function Element() {
		this._nsMap = {};
	};
	Element.prototype = {
		nodeType : ELEMENT_NODE,
		hasAttribute : function(name){
			return this.getAttributeNode(name)!=null;
		},
		getAttribute : function(name){
			var attr = this.getAttributeNode(name);
			return attr && attr.value || '';
		},
		getAttributeNode : function(name){
			return this.attributes.getNamedItem(name);
		},
		setAttribute : function(name, value){
			var attr = this.ownerDocument.createAttribute(name);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr)
		},
		removeAttribute : function(name){
			var attr = this.getAttributeNode(name)
			attr && this.removeAttributeNode(attr);
		},
		
		//four real opeartion method
		appendChild:function(newChild){
			if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
				return this.insertBefore(newChild,null);
			}else{
				return _appendSingleChild(this,newChild);
			}
		},
		setAttributeNode : function(newAttr){
			return this.attributes.setNamedItem(newAttr);
		},
		setAttributeNodeNS : function(newAttr){
			return this.attributes.setNamedItemNS(newAttr);
		},
		removeAttributeNode : function(oldAttr){
			return this.attributes.removeNamedItem(oldAttr.nodeName);
		},
		//get real attribute name,and remove it by removeAttributeNode
		removeAttributeNS : function(namespaceURI, localName){
			var old = this.getAttributeNodeNS(namespaceURI, localName);
			old && this.removeAttributeNode(old);
		},
		
		hasAttributeNS : function(namespaceURI, localName){
			return this.getAttributeNodeNS(namespaceURI, localName)!=null;
		},
		getAttributeNS : function(namespaceURI, localName){
			var attr = this.getAttributeNodeNS(namespaceURI, localName);
			return attr && attr.value || '';
		},
		setAttributeNS : function(namespaceURI, qualifiedName, value){
			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = value;
			this.setAttributeNode(attr)
		},
		getAttributeNodeNS : function(namespaceURI, localName){
			return this.attributes.getNamedItemNS(namespaceURI, localName);
		},
		
		getElementsByTagName : function(tagName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
						ls.push(node);
					}
				});
				return ls;
			});
		},
		getElementsByTagNameNS : function(namespaceURI, localName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)){
						ls.push(node);
					}
				});
				return ls;
			});
		}
	};
	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


	_extends(Element,Node);
	function Attr() {
	};
	Attr.prototype.nodeType = ATTRIBUTE_NODE;
	_extends(Attr,Node);


	function CharacterData() {
	};
	CharacterData.prototype = {
		data : '',
		substringData : function(offset, count) {
			return this.data.substring(offset, offset+count);
		},
		appendData: function(text) {
			text = this.data+text;
			this.nodeValue = this.data = text;
			this.length = text.length;
		},
		insertData: function(offset,text) {
			this.replaceData(offset,0,text);
		
		},
		appendChild:function(newChild){
			//if(!(newChild instanceof CharacterData)){
				throw new Error(ExceptionMessage[3])
			//}
			return Node.prototype.appendChild.apply(this,arguments)
		},
		deleteData: function(offset, count) {
			this.replaceData(offset,count,"");
		},
		replaceData: function(offset, count, text) {
			var start = this.data.substring(0,offset);
			var end = this.data.substring(offset+count);
			text = start + text + end;
			this.nodeValue = this.data = text;
			this.length = text.length;
		}
	}
	_extends(CharacterData,Node);
	function Text() {
	};
	Text.prototype = {
		nodeName : "#text",
		nodeType : TEXT_NODE,
		splitText : function(offset) {
			var text = this.data;
			var newText = text.substring(offset);
			text = text.substring(0, offset);
			this.data = this.nodeValue = text;
			this.length = text.length;
			var newNode = this.ownerDocument.createTextNode(newText);
			if(this.parentNode){
				this.parentNode.insertBefore(newNode, this.nextSibling);
			}
			return newNode;
		}
	}
	_extends(Text,CharacterData);
	function Comment() {
	};
	Comment.prototype = {
		nodeName : "#comment",
		nodeType : COMMENT_NODE
	}
	_extends(Comment,CharacterData);

	function CDATASection() {
	};
	CDATASection.prototype = {
		nodeName : "#cdata-section",
		nodeType : CDATA_SECTION_NODE
	}
	_extends(CDATASection,CharacterData);


	function DocumentType() {
	};
	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
	_extends(DocumentType,Node);

	function Notation() {
	};
	Notation.prototype.nodeType = NOTATION_NODE;
	_extends(Notation,Node);

	function Entity() {
	};
	Entity.prototype.nodeType = ENTITY_NODE;
	_extends(Entity,Node);

	function EntityReference() {
	};
	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
	_extends(EntityReference,Node);

	function DocumentFragment() {
	};
	DocumentFragment.prototype.nodeName =	"#document-fragment";
	DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
	_extends(DocumentFragment,Node);


	function ProcessingInstruction() {
	}
	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
	_extends(ProcessingInstruction,Node);
	function XMLSerializer(){}
	XMLSerializer.prototype.serializeToString = function(node){
		var buf = [];
		serializeToString(node,buf);
		return buf.join('');
	}
	Node.prototype.toString =function(){
		return XMLSerializer.prototype.serializeToString(this);
	}
	function serializeToString(node,buf){
		switch(node.nodeType){
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;
			var isHTML = htmlns === node.namespaceURI
			buf.push('<',nodeName);
			for(var i=0;i<len;i++){
				serializeToString(attrs.item(i),buf,isHTML);
			}
			if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
				buf.push('>');
				//if is cdata child node
				if(isHTML && /^script$/i.test(nodeName)){
					if(child){
						buf.push(child.data);
					}
				}else{
					while(child){
						serializeToString(child,buf);
						child = child.nextSibling;
					}
				}
				buf.push('</',nodeName,'>');
			}else{
				buf.push('/>');
			}
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while(child){
				serializeToString(child,buf);
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
		case TEXT_NODE:
			return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
		case CDATA_SECTION_NODE:
			return buf.push( '<![CDATA[',node.data,']]>');
		case COMMENT_NODE:
			return buf.push( "<!--",node.data,"-->");
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push('<!DOCTYPE ',node.name);
			if(pubid){
				buf.push(' PUBLIC "',pubid);
				if (sysid && sysid!='.') {
					buf.push( '" "',sysid);
				}
				buf.push('">');
			}else if(sysid && sysid!='.'){
				buf.push(' SYSTEM "',sysid,'">');
			}else{
				var sub = node.internalSubset;
				if(sub){
					buf.push(" [",sub,"]");
				}
				buf.push(">");
			}
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push( "<?",node.target," ",node.data,"?>");
		case ENTITY_REFERENCE_NODE:
			return buf.push( '&',node.nodeName,';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??',node.nodeName);
		}
	}
	function importNode(doc,node,deep){
		var node2;
		switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
			//var attrs = node2.attributes;
			//var len = attrs.length;
			//for(var i=0;i<len;i++){
				//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
			//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE：
		//can not hit in level3
		//default:throw e;
		}
		if(!node2){
			node2 = node.cloneNode(false);//false
		}
		node2.ownerDocument = doc;
		node2.parentNode = null;
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(importNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	//
	//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
	//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
	function cloneNode(doc,node,deep){
		var node2 = new node.constructor();
		for(var n in node){
			var v = node[n];
			if(typeof v != 'object' ){
				if(v != node2[n]){
					node2[n] = v;
				}
			}
		}
		if(node.childNodes){
			node2.childNodes = new NodeList();
		}
		node2.ownerDocument = doc;
		switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs	= node.attributes;
			var attrs2	= node2.attributes = new NamedNodeMap();
			var len = attrs.length
			attrs2._ownerElement = node2;
			for(var i=0;i<len;i++){
				node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
			}
			break;;
		case ATTRIBUTE_NODE:
			deep = true;
		}
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(cloneNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}

	function __set__(object,key,value){
		object[key] = value
	}
	//do dynamic
	try{
		if(Object.defineProperty){
			Object.defineProperty(LiveNodeList.prototype,'length',{
				get:function(){
					_updateLiveList(this);
					return this.$$length;
				}
			});
			Object.defineProperty(Node.prototype,'textContent',{
				get:function(){
					return getTextContent(this);
				},
				set:function(data){
					switch(this.nodeType){
					case 1:
					case 11:
						while(this.firstChild){
							this.removeChild(this.firstChild);
						}
						if(data || String(data)){
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;
					default:
						//TODO:
						this.data = data;
						this.value = value;
						this.nodeValue = data;
					}
				}
			})
			
			function getTextContent(node){
				switch(node.nodeType){
				case 1:
				case 11:
					var buf = [];
					node = node.firstChild;
					while(node){
						if(node.nodeType!==7 && node.nodeType !==8){
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
				}
			}
			__set__ = function(object,key,value){
				//console.log(value)
				object['$$'+key] = value
			}
		}
	}catch(e){//ie8
	}

	if(true){
		exports.DOMImplementation = DOMImplementation;
		exports.XMLSerializer = XMLSerializer;
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// **Github:** https://github.com/zensh/lrucache
	//
	// **License:** MIT

	/* global module, define */
	;(function (root, factory) {
	  'use strict'

	  if (typeof module === 'object' && typeof module.exports === 'object') {
	    module.exports = factory()
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  } else {
	    root.LRUCache = factory()
	  }
	}(typeof window === 'object' ? window : this, function () {
	  'use strict'

	  var undef = void 0

	  function LRUCache (capacity) {
	    if (!(this instanceof LRUCache)) return new LRUCache(capacity)
	    this._LRUCacheState = new CacheState(capacity)
	  }

	  var proto = LRUCache.prototype

	  proto.get = function (key) {
	    var state = this._LRUCacheState
	    var lruEntry = state.hash[key]
	    if (!lruEntry) return
	    refresh(state.linkedList, lruEntry)
	    return state.data[key]
	  }

	  proto.set = function (key, value) {
	    var state = this._LRUCacheState
	    var lruEntry = state.hash[key]
	    if (value === undef) return this
	    if (!lruEntry) {
	      state.hash[key] = new LRUEntry(key)
	      state.linkedList.length += 1
	      lruEntry = state.hash[key]
	    }
	    refresh(state.linkedList, lruEntry)
	    state.data[key] = value
	    if (state.linkedList.length > state.capacity) this.remove(state.linkedList.end.key)
	    return this
	  }

	  proto.update = function (key, parseFn) {
	    if (this.has(key)) this.set(key, parseFn(this.get(key)))
	    return this
	  }

	  proto.remove = function (key) {
	    var state = this._LRUCacheState
	    var lruEntry = state.hash[key]
	    if (!lruEntry) return this
	    if (lruEntry === state.linkedList.head) state.linkedList.head = lruEntry.p
	    if (lruEntry === state.linkedList.end) state.linkedList.end = lruEntry.n
	    link(lruEntry.n, lruEntry.p)
	    delete state.hash[key]
	    delete state.data[key]
	    state.linkedList.length -= 1
	    return this
	  }

	  proto.removeAll = function () {
	    this._LRUCacheState = new CacheState(this._LRUCacheState.capacity)
	    return this
	  }

	  proto.info = function () {
	    var state = this._LRUCacheState
	    return {
	      capacity: state.capacity,
	      length: state.linkedList.length
	    }
	  }

	  proto.keys = function () {
	    var keys = []
	    var lruEntry = this._LRUCacheState.linkedList.head
	    while (lruEntry) {
	      keys.push(lruEntry.key)
	      lruEntry = lruEntry.p
	    }
	    return keys
	  }

	  proto.has = function (key) {
	    return !!this._LRUCacheState.hash[key]
	  }

	  proto.staleKey = function () {
	    return this._LRUCacheState.linkedList.end && this._LRUCacheState.linkedList.end.key
	  }

	  proto.popStale = function () {
	    var staleKey = this.staleKey()
	    if (!staleKey) return null
	    var stale = [staleKey, this._LRUCacheState.data[staleKey]]
	    this.remove(staleKey)
	    return stale
	  }

	  function CacheState (capacity) {
	    this.capacity = capacity > 0 ? +capacity : Number.MAX_VALUE
	    this.data = Object.create ? Object.create(null) : {}
	    this.hash = Object.create ? Object.create(null) : {}
	    this.linkedList = new LinkedList()
	  }

	  function LinkedList () {
	    this.length = 0
	    this.head = null
	    this.end = null
	  }

	  function LRUEntry (key) {
	    this.key = key
	    this.p = null
	    this.n = null
	  }

	  // 更新链表，把get或put方法操作的key提到链表head，即表示最新
	  function refresh (linkedList, entry) {
	    if (entry === linkedList.head) return
	    if (!linkedList.end) {
	      linkedList.end = entry
	    } else if (linkedList.end === entry) {
	      linkedList.end = entry.n
	    }

	    link(entry.n, entry.p)
	    link(entry, linkedList.head)
	    linkedList.head = entry
	    linkedList.head.n = null
	  }

	  // 对两个链表对象建立链接，形成一条链
	  function link (nextEntry, prevEntry) {
	    if (nextEntry === prevEntry) return
	    if (nextEntry) nextEntry.p = prevEntry
	    if (prevEntry) prevEntry.n = nextEntry
	  }

	  LRUCache.NAME = 'LRUCache'
	  LRUCache.VERSION = 'v0.3.0'
	  return LRUCache
	}))


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	__webpack_require__(16);
	var get               = __webpack_require__(17);
	var Report            = __webpack_require__(21);
	var FormatValidators  = __webpack_require__(24);
	var JsonValidation    = __webpack_require__(26);
	var SchemaCache       = __webpack_require__(27);
	var SchemaCompilation = __webpack_require__(28);
	var SchemaValidation  = __webpack_require__(29);
	var Utils             = __webpack_require__(23);
	var Draft4Schema      = __webpack_require__(30);
	var Draft4HyperSchema = __webpack_require__(31);

	/*
	    default options
	*/
	var defaultOptions = {
	    // default timeout for all async tasks
	    asyncTimeout: 2000,
	    // force additionalProperties and additionalItems to be defined on "object" and "array" types
	    forceAdditional: false,
	    // assume additionalProperties and additionalItems are defined as "false" where appropriate
	    assumeAdditional: false,
	    // force items to be defined on "array" types
	    forceItems: false,
	    // force minItems to be defined on "array" types
	    forceMinItems: false,
	    // force maxItems to be defined on "array" types
	    forceMaxItems: false,
	    // force minLength to be defined on "string" types
	    forceMinLength: false,
	    // force maxLength to be defined on "string" types
	    forceMaxLength: false,
	    // force properties or patternProperties to be defined on "object" types
	    forceProperties: false,
	    // ignore references that cannot be resolved (remote schemas) // TODO: make sure this is only for remote schemas, not local ones
	    ignoreUnresolvableReferences: false,
	    // disallow usage of keywords that this validator can't handle
	    noExtraKeywords: false,
	    // disallow usage of schema's without "type" defined
	    noTypeless: false,
	    // disallow zero length strings in validated objects
	    noEmptyStrings: false,
	    // disallow zero length arrays in validated objects
	    noEmptyArrays: false,
	    // forces "uri" format to be in fully rfc3986 compliant
	    strictUris: false,
	    // turn on some of the above
	    strictMode: false,
	    // report error paths as an array of path segments to get to the offending node
	    reportPathAsArray: false,
	    // stops validation as soon as an error is found, true by default but can be turned off
	    breakOnFirstError: true,
	    // check if schema follow best practices and common sence
	    pedanticCheck: false,
	    // ignore unknown formats (do not report them as an error)
	    ignoreUnknownFormats: false
	};

	/*
	    constructor
	*/
	function ZSchema(options) {
	    this.cache = {};
	    this.referenceCache = [];

	    this.setRemoteReference("http://json-schema.org/draft-04/schema", Draft4Schema);
	    this.setRemoteReference("http://json-schema.org/draft-04/hyper-schema", Draft4HyperSchema);

	    // options
	    if (typeof options === "object") {
	        var keys = Object.keys(options),
	            idx = keys.length,
	            key;

	        // check that the options are correctly configured
	        while (idx--) {
	            key = keys[idx];
	            if (defaultOptions[key] === undefined) {
	                throw new Error("Unexpected option passed to constructor: " + key);
	            }
	        }

	        // copy the default options into passed options
	        keys = Object.keys(defaultOptions);
	        idx = keys.length;
	        while (idx--) {
	            key = keys[idx];
	            if (options[key] === undefined) {
	                options[key] = Utils.clone(defaultOptions[key]);
	            }
	        }

	        this.options = options;
	    } else {
	        this.options = Utils.clone(defaultOptions);
	    }

	    if (this.options.strictMode === true) {
	        this.options.forceAdditional  = true;
	        this.options.forceItems       = true;
	        this.options.forceMaxLength   = true;
	        this.options.forceProperties  = true;
	        this.options.noExtraKeywords  = true;
	        this.options.noTypeless       = true;
	        this.options.noEmptyStrings   = true;
	        this.options.noEmptyArrays    = true;
	    }

	}

	/*
	    instance methods
	*/
	ZSchema.prototype.compileSchema = function (schema) {
	    var report = new Report(this.options);

	    schema = SchemaCache.getSchema.call(this, report, schema);

	    SchemaCompilation.compileSchema.call(this, report, schema);

	    this.lastReport = report;
	    return report.isValid();
	};
	ZSchema.prototype.validateSchema = function (schema) {
	    if (Array.isArray(schema) && schema.length === 0) {
	        throw new Error(".validateSchema was called with an empty array");
	    }

	    var report = new Report(this.options);

	    schema = SchemaCache.getSchema.call(this, report, schema);

	    var compiled = SchemaCompilation.compileSchema.call(this, report, schema);
	    if (compiled) { SchemaValidation.validateSchema.call(this, report, schema); }

	    this.lastReport = report;
	    return report.isValid();
	};
	ZSchema.prototype.validate = function (json, schema, options, callback) {

	    if (Utils.whatIs(options) === "function") {
	        callback = options;
	        options = {};
	    }
	    if (!options) { options = {}; }

	    var whatIs = Utils.whatIs(schema);
	    if (whatIs !== "string" && whatIs !== "object") {
	        var e = new Error("Invalid .validate call - schema must be an string or object but " + whatIs + " was passed!");
	        if (callback) {
	            process.nextTick(function () {
	                callback(e, false);
	            });
	            return;
	        }
	        throw e;
	    }

	    var foundError = false;
	    var report = new Report(this.options);

	    if (typeof schema === "string") {
	        var schemaName = schema;
	        schema = SchemaCache.getSchema.call(this, report, schemaName);
	        if (!schema) {
	            throw new Error("Schema with id '" + schemaName + "' wasn't found in the validator cache!");
	        }
	    } else {
	        schema = SchemaCache.getSchema.call(this, report, schema);
	    }

	    var compiled = false;
	    if (!foundError) {
	        compiled = SchemaCompilation.compileSchema.call(this, report, schema);
	    }
	    if (!compiled) {
	        this.lastReport = report;
	        foundError = true;
	    }

	    var validated = false;
	    if (!foundError) {
	        validated = SchemaValidation.validateSchema.call(this, report, schema);
	    }
	    if (!validated) {
	        this.lastReport = report;
	        foundError = true;
	    }

	    if (options.schemaPath) {
	        report.rootSchema = schema;
	        schema = get(schema, options.schemaPath);
	        if (!schema) {
	            throw new Error("Schema path '" + options.schemaPath + "' wasn't found in the schema!");
	        }
	    }

	    if (!foundError) {
	        JsonValidation.validate.call(this, report, schema, json);
	    }

	    if (callback) {
	        report.processAsyncTasks(this.options.asyncTimeout, callback);
	        return;
	    } else if (report.asyncTasks.length > 0) {
	        throw new Error("This validation has async tasks and cannot be done in sync mode, please provide callback argument.");
	    }

	    // assign lastReport so errors are retrievable in sync mode
	    this.lastReport = report;
	    return report.isValid();
	};
	ZSchema.prototype.getLastError = function () {
	    if (this.lastReport.errors.length === 0) {
	        return null;
	    }
	    var e = new Error();
	    e.name = "z-schema validation error";
	    e.message = this.lastReport.commonErrorMessage;
	    e.details = this.lastReport.errors;
	    return e;
	};
	ZSchema.prototype.getLastErrors = function () {
	    return this.lastReport && this.lastReport.errors.length > 0 ? this.lastReport.errors : undefined;
	};
	ZSchema.prototype.getMissingReferences = function (arr) {
	    arr = arr || this.lastReport.errors;
	    var res = [],
	        idx = arr.length;
	    while (idx--) {
	        var error = arr[idx];
	        if (error.code === "UNRESOLVABLE_REFERENCE") {
	            var reference = error.params[0];
	            if (res.indexOf(reference) === -1) {
	                res.push(reference);
	            }
	        }
	        if (error.inner) {
	            res = res.concat(this.getMissingReferences(error.inner));
	        }
	    }
	    return res;
	};
	ZSchema.prototype.getMissingRemoteReferences = function () {
	    var missingReferences = this.getMissingReferences(),
	        missingRemoteReferences = [],
	        idx = missingReferences.length;
	    while (idx--) {
	        var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);
	        if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {
	            missingRemoteReferences.push(remoteReference);
	        }
	    }
	    return missingRemoteReferences;
	};
	ZSchema.prototype.setRemoteReference = function (uri, schema) {
	    if (typeof schema === "string") {
	        schema = JSON.parse(schema);
	    } else {
	        schema = Utils.cloneDeep(schema);
	    }
	    SchemaCache.cacheSchemaByUri.call(this, uri, schema);
	};
	ZSchema.prototype.getResolvedSchema = function (schema) {
	    var report = new Report(this.options);
	    schema = SchemaCache.getSchema.call(this, report, schema);

	    // clone before making any modifications
	    schema = Utils.cloneDeep(schema);

	    var visited = [];

	    // clean-up the schema and resolve references
	    var cleanup = function (schema) {
	        var key,
	            typeOf = Utils.whatIs(schema);
	        if (typeOf !== "object" && typeOf !== "array") {
	            return;
	        }

	        if (schema.___$visited) {
	            return;
	        }

	        schema.___$visited = true;
	        visited.push(schema);

	        if (schema.$ref && schema.__$refResolved) {
	            var from = schema.__$refResolved;
	            var to = schema;
	            delete schema.$ref;
	            delete schema.__$refResolved;
	            for (key in from) {
	                if (from.hasOwnProperty(key)) {
	                    to[key] = from[key];
	                }
	            }
	        }
	        for (key in schema) {
	            if (schema.hasOwnProperty(key)) {
	                if (key.indexOf("__$") === 0) {
	                    delete schema[key];
	                } else {
	                    cleanup(schema[key]);
	                }
	            }
	        }
	    };

	    cleanup(schema);
	    visited.forEach(function (s) {
	        delete s.___$visited;
	    });

	    this.lastReport = report;
	    if (report.isValid()) {
	        return schema;
	    } else {
	        throw this.getLastError();
	    }
	};
	ZSchema.prototype.setSchemaReader = function (schemaReader) {
	    return ZSchema.setSchemaReader(schemaReader);
	};
	ZSchema.prototype.getSchemaReader = function () {
	    return ZSchema.schemaReader;
	};

	/*
	    static methods
	*/
	ZSchema.setSchemaReader = function (schemaReader) {
	    ZSchema.schemaReader = schemaReader;
	};
	ZSchema.registerFormat = function (formatName, validatorFunction) {
	    FormatValidators[formatName] = validatorFunction;
	};
	ZSchema.unregisterFormat = function (formatName) {
	    delete FormatValidators[formatName];
	};
	ZSchema.getRegisteredFormats = function () {
	    return Object.keys(FormatValidators);
	};
	ZSchema.getDefaultOptions = function () {
	    return Utils.cloneDeep(defaultOptions);
	};

	module.exports = ZSchema;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	// Number.isFinite polyfill
	// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite
	if (typeof Number.isFinite !== "function") {
	    Number.isFinite = function isFinite(value) {
	        // 1. If Type(number) is not Number, return false.
	        if (typeof value !== "number") {
	            return false;
	        }
	        // 2. If number is NaN, +∞, or −∞, return false.
	        if (value !== value || value === Infinity || value === -Infinity) {
	            return false;
	        }
	        // 3. Otherwise, return true.
	        return true;
	    };
	}


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.7.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseGet = __webpack_require__(18),
	    toPath = __webpack_require__(19);

	/**
	 * Gets the property value of `path` on `object`. If the resolved value is
	 * `undefined` the `defaultValue` is used in its place.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
	  return result === undefined ? defaultValue : result;
	}

	module.exports = get;


/***/ },
/* 18 */
/***/ function(module, exports) {

	/**
	 * lodash 3.7.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * The base implementation of `get` without support for string paths
	 * and default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path of the property to get.
	 * @param {string} [pathKey] The key representation of path.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path, pathKey) {
	  if (object == null) {
	    return;
	  }
	  if (pathKey !== undefined && pathKey in toObject(object)) {
	    path = [pathKey];
	  }
	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[path[index++]];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Converts `value` to an object if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Object} Returns the object.
	 */
	function toObject(value) {
	  return isObject(value) ? value : Object(value);
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = baseGet;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.8.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var isArray = __webpack_require__(20);

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}

	/**
	 * Converts `value` to property path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {Array} Returns the property path array.
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return value;
	  }
	  var result = [];
	  baseToString(value).replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	}

	module.exports = toPath;


/***/ },
/* 20 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = isArray;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	var get    = __webpack_require__(17);
	var Errors = __webpack_require__(22);
	var Utils  = __webpack_require__(23);

	function Report(parentOrOptions, reportOptions) {
	    this.parentReport = parentOrOptions instanceof Report ?
	                            parentOrOptions :
	                            undefined;

	    this.options = parentOrOptions instanceof Report ?
	                       parentOrOptions.options :
	                       parentOrOptions || {};

	    this.reportOptions = reportOptions || {};

	    this.errors = [];
	    this.path = [];
	    this.asyncTasks = [];
	}

	Report.prototype.isValid = function () {
	    if (this.asyncTasks.length > 0) {
	        throw new Error("Async tasks pending, can't answer isValid");
	    }
	    return this.errors.length === 0;
	};

	Report.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {
	    this.asyncTasks.push([fn, args, asyncTaskResultProcessFn]);
	};

	Report.prototype.processAsyncTasks = function (timeout, callback) {

	    var validationTimeout = timeout || 2000,
	        tasksCount        = this.asyncTasks.length,
	        idx               = tasksCount,
	        timedOut          = false,
	        self              = this;

	    function finish() {
	        process.nextTick(function () {
	            var valid = self.errors.length === 0,
	                err   = valid ? undefined : self.errors;
	            callback(err, valid);
	        });
	    }

	    function respond(asyncTaskResultProcessFn) {
	        return function (asyncTaskResult) {
	            if (timedOut) { return; }
	            asyncTaskResultProcessFn(asyncTaskResult);
	            if (--tasksCount === 0) {
	                finish();
	            }
	        };
	    }

	    if (tasksCount === 0 || this.errors.length > 0) {
	        finish();
	        return;
	    }

	    while (idx--) {
	        var task = this.asyncTasks[idx];
	        task[0].apply(null, task[1].concat(respond(task[2])));
	    }

	    setTimeout(function () {
	        if (tasksCount > 0) {
	            timedOut = true;
	            self.addError("ASYNC_TIMEOUT", [tasksCount, validationTimeout]);
	            callback(self.errors, false);
	        }
	    }, validationTimeout);

	};

	Report.prototype.getPath = function () {
	    var path = [];
	    if (this.parentReport) {
	        path = path.concat(this.parentReport.path);
	    }
	    path = path.concat(this.path);

	    if (this.options.reportPathAsArray !== true) {
	        // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)
	        path = "#/" + path.map(function (segment) {

	            if (Utils.isAbsoluteUri(segment)) {
	                return "uri(" + segment + ")";
	            }

	            return segment.replace(/\~/g, "~0").replace(/\//g, "~1");
	        }).join("/");
	    }
	    return path;
	};

	Report.prototype.getSchemaId = function () {

	    if (!this.rootSchema) {
	        return null;
	    }

	    // get the error path as an array
	    var path = [];
	    if (this.parentReport) {
	        path = path.concat(this.parentReport.path);
	    }
	    path = path.concat(this.path);

	    // try to find id in the error path
	    while (path.length > 0) {
	        var obj = get(this.rootSchema, path);
	        if (obj && obj.id) { return obj.id; }
	        path.pop();
	    }

	    // return id of the root
	    return this.rootSchema.id;
	};

	Report.prototype.hasError = function (errorCode, params) {
	    var idx = this.errors.length;
	    while (idx--) {
	        if (this.errors[idx].code === errorCode) {
	            // assume match
	            var match = true;

	            // check the params too
	            var idx2 = this.errors[idx].params.length;
	            while (idx2--) {
	                if (this.errors[idx].params[idx2] !== params[idx2]) {
	                    match = false;
	                }
	            }

	            // if match, return true
	            if (match) { return match; }
	        }
	    }
	    return false;
	};

	Report.prototype.addError = function (errorCode, params, subReports, schemaDescription) {
	    if (this.errors.length >= this.reportOptions.maxErrors) {
	        return;
	    }

	    if (!errorCode) { throw new Error("No errorCode passed into addError()"); }
	    if (!Errors[errorCode]) { throw new Error("No errorMessage known for code " + errorCode); }

	    params = params || [];

	    var idx = params.length,
	        errorMessage = Errors[errorCode];
	    while (idx--) {
	        var whatIs = Utils.whatIs(params[idx]);
	        var param = (whatIs === "object" || whatIs === "null") ? JSON.stringify(params[idx]) : params[idx];
	        errorMessage = errorMessage.replace("{" + idx + "}", param);
	    }

	    var err = {
	        code: errorCode,
	        params: params,
	        message: errorMessage,
	        path: this.getPath(),
	        schemaId: this.getSchemaId()
	    };

	    if (schemaDescription) {
	        err.description = schemaDescription;
	    }

	    if (subReports != null) {
	        if (!Array.isArray(subReports)) {
	            subReports = [subReports];
	        }
	        err.inner = [];
	        idx = subReports.length;
	        while (idx--) {
	            var subReport = subReports[idx],
	                idx2 = subReport.errors.length;
	            while (idx2--) {
	                err.inner.push(subReport.errors[idx2]);
	            }
	        }
	        if (err.inner.length === 0) {
	            err.inner = undefined;
	        }
	    }

	    this.errors.push(err);
	};

	module.exports = Report;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {

	    INVALID_TYPE:                           "Expected type {0} but found type {1}",
	    INVALID_FORMAT:                         "Object didn't pass validation for format {0}: {1}",
	    ENUM_MISMATCH:                          "No enum match for: {0}",
	    ANY_OF_MISSING:                         "Data does not match any schemas from 'anyOf'",
	    ONE_OF_MISSING:                         "Data does not match any schemas from 'oneOf'",
	    ONE_OF_MULTIPLE:                        "Data is valid against more than one schema from 'oneOf'",
	    NOT_PASSED:                             "Data matches schema from 'not'",

	    // Array errors
	    ARRAY_LENGTH_SHORT:                     "Array is too short ({0}), minimum {1}",
	    ARRAY_LENGTH_LONG:                      "Array is too long ({0}), maximum {1}",
	    ARRAY_UNIQUE:                           "Array items are not unique (indexes {0} and {1})",
	    ARRAY_ADDITIONAL_ITEMS:                 "Additional items not allowed",

	    // Numeric errors
	    MULTIPLE_OF:                            "Value {0} is not a multiple of {1}",
	    MINIMUM:                                "Value {0} is less than minimum {1}",
	    MINIMUM_EXCLUSIVE:                      "Value {0} is equal or less than exclusive minimum {1}",
	    MAXIMUM:                                "Value {0} is greater than maximum {1}",
	    MAXIMUM_EXCLUSIVE:                      "Value {0} is equal or greater than exclusive maximum {1}",

	    // Object errors
	    OBJECT_PROPERTIES_MINIMUM:              "Too few properties defined ({0}), minimum {1}",
	    OBJECT_PROPERTIES_MAXIMUM:              "Too many properties defined ({0}), maximum {1}",
	    OBJECT_MISSING_REQUIRED_PROPERTY:       "Missing required property: {0}",
	    OBJECT_ADDITIONAL_PROPERTIES:           "Additional properties not allowed: {0}",
	    OBJECT_DEPENDENCY_KEY:                  "Dependency failed - key must exist: {0} (due to key: {1})",

	    // String errors
	    MIN_LENGTH:                             "String is too short ({0} chars), minimum {1}",
	    MAX_LENGTH:                             "String is too long ({0} chars), maximum {1}",
	    PATTERN:                                "String does not match pattern {0}: {1}",

	    // Schema validation errors
	    KEYWORD_TYPE_EXPECTED:                  "Keyword '{0}' is expected to be of type '{1}'",
	    KEYWORD_UNDEFINED_STRICT:               "Keyword '{0}' must be defined in strict mode",
	    KEYWORD_UNEXPECTED:                     "Keyword '{0}' is not expected to appear in the schema",
	    KEYWORD_MUST_BE:                        "Keyword '{0}' must be {1}",
	    KEYWORD_DEPENDENCY:                     "Keyword '{0}' requires keyword '{1}'",
	    KEYWORD_PATTERN:                        "Keyword '{0}' is not a valid RegExp pattern: {1}",
	    KEYWORD_VALUE_TYPE:                     "Each element of keyword '{0}' array must be a '{1}'",
	    UNKNOWN_FORMAT:                         "There is no validation function for format '{0}'",
	    CUSTOM_MODE_FORCE_PROPERTIES:           "{0} must define at least one property if present",

	    // Remote errors
	    REF_UNRESOLVED:                         "Reference has not been resolved during compilation: {0}",
	    UNRESOLVABLE_REFERENCE:                 "Reference could not be resolved: {0}",
	    SCHEMA_NOT_REACHABLE:                   "Validator was not able to read schema with uri: {0}",
	    SCHEMA_TYPE_EXPECTED:                   "Schema is expected to be of type 'object'",
	    SCHEMA_NOT_AN_OBJECT:                   "Schema is not an object: {0}",
	    ASYNC_TIMEOUT:                          "{0} asynchronous task(s) have timed out after {1} ms",
	    PARENT_SCHEMA_VALIDATION_FAILED:        "Schema failed to validate against its parent schema, see inner errors for details.",
	    REMOTE_NOT_VALID:                       "Remote reference didn't compile successfully: {0}"

	};


/***/ },
/* 23 */
/***/ function(module, exports) {

	"use strict";

	exports.isAbsoluteUri = function (uri) {
	    return /^https?:\/\//.test(uri);
	};

	exports.isRelativeUri = function (uri) {
	    // relative URIs that end with a hash sign, issue #56
	    return /.+#/.test(uri);
	};

	exports.whatIs = function (what) {

	    var to = typeof what;

	    if (to === "object") {
	        if (what === null) {
	            return "null";
	        }
	        if (Array.isArray(what)) {
	            return "array";
	        }
	        return "object"; // typeof what === 'object' && what === Object(what) && !Array.isArray(what);
	    }

	    if (to === "number") {
	        if (Number.isFinite(what)) {
	            if (what % 1 === 0) {
	                return "integer";
	            } else {
	                return "number";
	            }
	        }
	        if (Number.isNaN(what)) {
	            return "not-a-number";
	        }
	        return "unknown-number";
	    }

	    return to; // undefined, boolean, string, function

	};

	exports.areEqual = function areEqual(json1, json2) {
	    // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6

	    // Two JSON values are said to be equal if and only if:
	    // both are nulls; or
	    // both are booleans, and have the same value; or
	    // both are strings, and have the same value; or
	    // both are numbers, and have the same mathematical value; or
	    if (json1 === json2) {
	        return true;
	    }

	    var i, len;

	    // both are arrays, and:
	    if (Array.isArray(json1) && Array.isArray(json2)) {
	        // have the same number of items; and
	        if (json1.length !== json2.length) {
	            return false;
	        }
	        // items at the same index are equal according to this definition; or
	        len = json1.length;
	        for (i = 0; i < len; i++) {
	            if (!areEqual(json1[i], json2[i])) {
	                return false;
	            }
	        }
	        return true;
	    }

	    // both are objects, and:
	    if (exports.whatIs(json1) === "object" && exports.whatIs(json2) === "object") {
	        // have the same set of property names; and
	        var keys1 = Object.keys(json1);
	        var keys2 = Object.keys(json2);
	        if (!areEqual(keys1, keys2)) {
	            return false;
	        }
	        // values for a same property name are equal according to this definition.
	        len = keys1.length;
	        for (i = 0; i < len; i++) {
	            if (!areEqual(json1[keys1[i]], json2[keys1[i]])) {
	                return false;
	            }
	        }
	        return true;
	    }

	    return false;
	};

	exports.isUniqueArray = function (arr, indexes) {
	    var i, j, l = arr.length;
	    for (i = 0; i < l; i++) {
	        for (j = i + 1; j < l; j++) {
	            if (exports.areEqual(arr[i], arr[j])) {
	                if (indexes) { indexes.push(i, j); }
	                return false;
	            }
	        }
	    }
	    return true;
	};

	exports.difference = function (bigSet, subSet) {
	    var arr = [],
	        idx = bigSet.length;
	    while (idx--) {
	        if (subSet.indexOf(bigSet[idx]) === -1) {
	            arr.push(bigSet[idx]);
	        }
	    }
	    return arr;
	};

	// NOT a deep version of clone
	exports.clone = function (src) {
	    if (typeof src === "undefined") { return void 0; }
	    if (typeof src !== "object" || src === null) { return src; }
	    var res, idx;
	    if (Array.isArray(src)) {
	        res = [];
	        idx = src.length;
	        while (idx--) {
	            res[idx] = src[idx];
	        }
	    } else {
	        res = {};
	        var keys = Object.keys(src);
	        idx = keys.length;
	        while (idx--) {
	            var key = keys[idx];
	            res[key] = src[key];
	        }
	    }
	    return res;
	};

	exports.cloneDeep = function (src) {
	    var visited = [], cloned = [];
	    function cloneDeep(src) {
	        if (typeof src !== "object" || src === null) { return src; }
	        var res, idx, cidx;

	        cidx = visited.indexOf(src);
	        if (cidx !== -1) { return cloned[cidx]; }

	        visited.push(src);
	        if (Array.isArray(src)) {
	            res = [];
	            cloned.push(res);
	            idx = src.length;
	            while (idx--) {
	                res[idx] = cloneDeep(src[idx]);
	            }
	        } else {
	            res = {};
	            cloned.push(res);
	            var keys = Object.keys(src);
	            idx = keys.length;
	            while (idx--) {
	                var key = keys[idx];
	                res[key] = cloneDeep(src[key]);
	            }
	        }
	        return res;
	    }
	    return cloneDeep(src);
	};

	/*
	  following function comes from punycode.js library
	  see: https://github.com/bestiejs/punycode.js
	*/
	/*jshint -W016*/
	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	exports.ucs2decode = function (string) {
	    var output = [],
	        counter = 0,
	        length = string.length,
	        value,
	        extra;
	    while (counter < length) {
	        value = string.charCodeAt(counter++);
	        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	            // high surrogate, and there is a next character
	            extra = string.charCodeAt(counter++);
	            if ((extra & 0xFC00) == 0xDC00) { // low surrogate
	                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	            } else {
	                // unmatched surrogate; only append this code unit, in case the next
	                // code unit is the high surrogate of a surrogate pair
	                output.push(value);
	                counter--;
	            }
	        } else {
	            output.push(value);
	        }
	    }
	    return output;
	};
	/*jshint +W016*/


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint maxlen: false*/

	var validator = __webpack_require__(25);

	var FormatValidators = {
	    "date": function (date) {
	        if (typeof date !== "string") {
	            return true;
	        }
	        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
	        var matches = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/.exec(date);
	        if (matches === null) {
	            return false;
	        }
	        // var year = matches[1];
	        // var month = matches[2];
	        // var day = matches[3];
	        if (matches[2] < "01" || matches[2] > "12" || matches[3] < "01" || matches[3] > "31") {
	            return false;
	        }
	        return true;
	    },
	    "date-time": function (dateTime) {
	        if (typeof dateTime !== "string") {
	            return true;
	        }
	        // date-time from http://tools.ietf.org/html/rfc3339#section-5.6
	        var s = dateTime.toLowerCase().split("t");
	        if (!FormatValidators.date(s[0])) {
	            return false;
	        }
	        var matches = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/.exec(s[1]);
	        if (matches === null) {
	            return false;
	        }
	        // var hour = matches[1];
	        // var minute = matches[2];
	        // var second = matches[3];
	        // var fraction = matches[4];
	        // var timezone = matches[5];
	        if (matches[1] > "23" || matches[2] > "59" || matches[3] > "59") {
	            return false;
	        }
	        return true;
	    },
	    "email": function (email) {
	        if (typeof email !== "string") {
	            return true;
	        }
	        return validator.isEmail(email, { "require_tld": true });
	    },
	    "hostname": function (hostname) {
	        if (typeof hostname !== "string") {
	            return true;
	        }
	        /*
	            http://json-schema.org/latest/json-schema-validation.html#anchor114
	            A string instance is valid against this attribute if it is a valid
	            representation for an Internet host name, as defined by RFC 1034, section 3.1 [RFC1034].

	            http://tools.ietf.org/html/rfc1034#section-3.5

	            <digit> ::= any one of the ten digits 0 through 9
	            var digit = /[0-9]/;

	            <letter> ::= any one of the 52 alphabetic characters A through Z in upper case and a through z in lower case
	            var letter = /[a-zA-Z]/;

	            <let-dig> ::= <letter> | <digit>
	            var letDig = /[0-9a-zA-Z]/;

	            <let-dig-hyp> ::= <let-dig> | "-"
	            var letDigHyp = /[-0-9a-zA-Z]/;

	            <ldh-str> ::= <let-dig-hyp> | <let-dig-hyp> <ldh-str>
	            var ldhStr = /[-0-9a-zA-Z]+/;

	            <label> ::= <letter> [ [ <ldh-str> ] <let-dig> ]
	            var label = /[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?/;

	            <subdomain> ::= <label> | <subdomain> "." <label>
	            var subdomain = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/;

	            <domain> ::= <subdomain> | " "
	            var domain = null;
	        */
	        var valid = /^[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?(\.[a-zA-Z](([-0-9a-zA-Z]+)?[0-9a-zA-Z])?)*$/.test(hostname);
	        if (valid) {
	            // the sum of all label octets and label lengths is limited to 255.
	            if (hostname.length > 255) { return false; }
	            // Each node has a label, which is zero to 63 octets in length
	            var labels = hostname.split(".");
	            for (var i = 0; i < labels.length; i++) { if (labels[i].length > 63) { return false; } }
	        }
	        return valid;
	    },
	    "host-name": function (hostname) {
	        return FormatValidators.hostname.call(this, hostname);
	    },
	    "ipv4": function (ipv4) {
	        if (typeof ipv4 !== "string") { return true; }
	        return validator.isIP(ipv4, 4);
	    },
	    "ipv6": function (ipv6) {
	        if (typeof ipv6 !== "string") { return true; }
	        return validator.isIP(ipv6, 6);
	    },
	    "regex": function (str) {
	        try {
	            RegExp(str);
	            return true;
	        } catch (e) {
	            return false;
	        }
	    },
	    "uri": function (uri) {
	        if (this.options.strictUris) {
	            return FormatValidators["strict-uri"].apply(this, arguments);
	        }
	        // https://github.com/zaggino/z-schema/issues/18
	        // RegExp from http://tools.ietf.org/html/rfc3986#appendix-B
	        return typeof uri !== "string" || RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?").test(uri);
	    },
	    "strict-uri": function (uri) {
	        return typeof uri !== "string" || validator.isURL(uri);
	    }
	};

	module.exports = FormatValidators;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Copyright (c) 2015 Chris O'Hara <cohara87@gmail.com>
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining
	 * a copy of this software and associated documentation files (the
	 * "Software"), to deal in the Software without restriction, including
	 * without limitation the rights to use, copy, modify, merge, publish,
	 * distribute, sublicense, and/or sell copies of the Software, and to
	 * permit persons to whom the Software is furnished to do so, subject to
	 * the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be
	 * included in all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	 */

	(function (name, definition) {
	    if (true) {
	        module.exports = definition();
	    } else if (typeof define === 'function' && typeof define.amd === 'object') {
	        define(definition);
	    } else if (typeof define === 'function' && typeof define.petal === 'object') {
	        define(name, [], definition);
	    } else {
	        this[name] = definition();
	    }
	})('validator', function (validator) {

	    'use strict';

	    validator = { version: '4.4.0' };

	    var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
	    var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;

	    var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
	    var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;

	    var displayName = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\.\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\s]*<(.+)>$/i;

	    var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/;

	    var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

	    var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/
	      , isbn13Maybe = /^(?:[0-9]{13})$/;

	    var macAddress = /^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/;

	    var ipv4Maybe = /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/
	      , ipv6Block = /^[0-9A-F]{1,4}$/i;

	    var uuid = {
	        '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i
	      , '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
	      , '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i
	      , all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
	    };

	    var alpha = /^[A-Z]+$/i
	      , alphanumeric = /^[0-9A-Z]+$/i
	      , numeric = /^[-+]?[0-9]+$/
	      , int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/
	      , float = /^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/
	      , hexadecimal = /^[0-9A-F]+$/i
	      , decimal = /^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/
	      , hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;

	    var ascii = /^[\x00-\x7F]+$/
	      , multibyte = /[^\x00-\x7F]/
	      , fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/
	      , halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;

	    var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

	    var base64 = /^(?:[A-Z0-9+\/]{4})*(?:[A-Z0-9+\/]{2}==|[A-Z0-9+\/]{3}=|[A-Z0-9+\/]{4})$/i;

	    var phones = {
	      'zh-CN': /^(\+?0?86\-?)?1[345789]\d{9}$/,
	      'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
	      'en-ZA': /^(\+?27|0)\d{9}$/,
	      'en-AU': /^(\+?61|0)4\d{8}$/,
	      'en-HK': /^(\+?852\-?)?[569]\d{3}\-?\d{4}$/,
	      'fr-FR': /^(\+?33|0)[67]\d{8}$/,
	      'pt-PT': /^(\+351)?9[1236]\d{7}$/,
	      'el-GR': /^(\+30)?((2\d{9})|(69\d{8}))$/,
	      'en-GB': /^(\+?44|0)7\d{9}$/,
	      'en-US': /^(\+?1)?[2-9]\d{2}[2-9](?!11)\d{6}$/,
	      'en-ZM': /^(\+26)?09[567]\d{7}$/,
	      'ru-RU': /^(\+?7|8)?9\d{9}$/,
	      'nb-NO': /^(\+?47)?[49]\d{7}$/,
	      'nn-NO': /^(\+?47)?[49]\d{7}$/,
	      'vi-VN': /^(0|\+?84)?((1(2([0-9])|6([2-9])|88|99))|(9((?!5)[0-9])))([0-9]{7})$/,
	      'en-NZ': /^(\+?64|0)2\d{7,9}$/
	    };

	    // from http://goo.gl/0ejHHW
	    var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;

	    validator.extend = function (name, fn) {
	        validator[name] = function () {
	            var args = Array.prototype.slice.call(arguments);
	            args[0] = validator.toString(args[0]);
	            return fn.apply(validator, args);
	        };
	    };

	    //Right before exporting the validator object, pass each of the builtins
	    //through extend() so that their first argument is coerced to a string
	    validator.init = function () {
	        for (var name in validator) {
	            if (typeof validator[name] !== 'function' || name === 'toString' ||
	                    name === 'toDate' || name === 'extend' || name === 'init') {
	                continue;
	            }
	            validator.extend(name, validator[name]);
	        }
	    };

	    validator.toString = function (input) {
	        if (typeof input === 'object' && input !== null && input.toString) {
	            input = input.toString();
	        } else if (input === null || typeof input === 'undefined' || (isNaN(input) && !input.length)) {
	            input = '';
	        }
	        return '' + input;
	    };

	    validator.toDate = function (date) {
	        if (Object.prototype.toString.call(date) === '[object Date]') {
	            return date;
	        }
	        date = Date.parse(date);
	        return !isNaN(date) ? new Date(date) : null;
	    };

	    validator.toFloat = function (str) {
	        return parseFloat(str);
	    };

	    validator.toInt = function (str, radix) {
	        return parseInt(str, radix || 10);
	    };

	    validator.toBoolean = function (str, strict) {
	        if (strict) {
	            return str === '1' || str === 'true';
	        }
	        return str !== '0' && str !== 'false' && str !== '';
	    };

	    validator.equals = function (str, comparison) {
	        return str === validator.toString(comparison);
	    };

	    validator.contains = function (str, elem) {
	        return str.indexOf(validator.toString(elem)) >= 0;
	    };

	    validator.matches = function (str, pattern, modifiers) {
	        if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
	            pattern = new RegExp(pattern, modifiers);
	        }
	        return pattern.test(str);
	    };

	    var default_email_options = {
	        allow_display_name: false,
	        allow_utf8_local_part: true,
	        require_tld: true
	    };

	    validator.isEmail = function (str, options) {
	        options = merge(options, default_email_options);

	        if (options.allow_display_name) {
	            var display_email = str.match(displayName);
	            if (display_email) {
	                str = display_email[1];
	            }
	        }

	        var parts = str.split('@')
	          , domain = parts.pop()
	          , user = parts.join('@');

	        var lower_domain = domain.toLowerCase();
	        if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {
	            user = user.replace(/\./g, '').toLowerCase();
	        }

	        if (!validator.isByteLength(user, 0, 64) ||
	                !validator.isByteLength(domain, 0, 256)) {
	            return false;
	        }

	        if (!validator.isFQDN(domain, {require_tld: options.require_tld})) {
	            return false;
	        }

	        if (user[0] === '"') {
	            user = user.slice(1, user.length - 1);
	            return options.allow_utf8_local_part ?
	                quotedEmailUserUtf8.test(user) :
	                quotedEmailUser.test(user);
	        }

	        var pattern = options.allow_utf8_local_part ?
	            emailUserUtf8Part : emailUserPart;

	        var user_parts = user.split('.');
	        for (var i = 0; i < user_parts.length; i++) {
	            if (!pattern.test(user_parts[i])) {
	                return false;
	            }
	        }

	        return true;
	    };

	    var default_url_options = {
	        protocols: [ 'http', 'https', 'ftp' ]
	      , require_tld: true
	      , require_protocol: false
	      , require_valid_protocol: true
	      , allow_underscores: false
	      , allow_trailing_dot: false
	      , allow_protocol_relative_urls: false
	    };

	    validator.isURL = function (url, options) {
	        if (!url || url.length >= 2083 || /\s/.test(url)) {
	            return false;
	        }
	        if (url.indexOf('mailto:') === 0) {
	            return false;
	        }
	        options = merge(options, default_url_options);
	        var protocol, auth, host, hostname, port,
	            port_str, split;
	        split = url.split('://');
	        if (split.length > 1) {
	            protocol = split.shift();
	            if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
	                return false;
	            }
	        } else if (options.require_protocol) {
	            return false;
	        }  else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {
	            split[0] = url.substr(2);
	        }
	        url = split.join('://');
	        split = url.split('#');
	        url = split.shift();

	        split = url.split('?');
	        url = split.shift();

	        split = url.split('/');
	        url = split.shift();
	        split = url.split('@');
	        if (split.length > 1) {
	            auth = split.shift();
	            if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
	                return false;
	            }
	        }
	        hostname = split.join('@');
	        split = hostname.split(':');
	        host = split.shift();
	        if (split.length) {
	            port_str = split.join(':');
	            port = parseInt(port_str, 10);
	            if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
	                return false;
	            }
	        }
	        if (!validator.isIP(host) && !validator.isFQDN(host, options) &&
	                host !== 'localhost') {
	            return false;
	        }
	        if (options.host_whitelist &&
	                options.host_whitelist.indexOf(host) === -1) {
	            return false;
	        }
	        if (options.host_blacklist &&
	                options.host_blacklist.indexOf(host) !== -1) {
	            return false;
	        }
	        return true;
	    };

	    validator.isMACAddress = function (str) {
	        return macAddress.test(str);
	    };

	    validator.isIP = function (str, version) {
	        version = validator.toString(version);
	        if (!version) {
	            return validator.isIP(str, 4) || validator.isIP(str, 6);
	        } else if (version === '4') {
	            if (!ipv4Maybe.test(str)) {
	                return false;
	            }
	            var parts = str.split('.').sort(function (a, b) {
	                return a - b;
	            });
	            return parts[3] <= 255;
	        } else if (version === '6') {
	            var blocks = str.split(':');
	            var foundOmissionBlock = false; // marker to indicate ::

	            // At least some OS accept the last 32 bits of an IPv6 address
	            // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says
	            // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,
	            // and '::a.b.c.d' is deprecated, but also valid.
	            var foundIPv4TransitionBlock = validator.isIP(blocks[blocks.length - 1], 4);
	            var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;

	            if (blocks.length > expectedNumberOfBlocks)
	                return false;

	            // initial or final ::
	            if (str === '::') {
	                return true;
	            } else if (str.substr(0, 2) === '::') {
	                blocks.shift();
	                blocks.shift();
	                foundOmissionBlock = true;
	            } else if (str.substr(str.length - 2) === '::') {
	                blocks.pop();
	                blocks.pop();
	                foundOmissionBlock = true;
	            }

	            for (var i = 0; i < blocks.length; ++i) {
	                // test for a :: which can not be at the string start/end
	                // since those cases have been handled above
	                if (blocks[i] === '' && i > 0 && i < blocks.length -1) {
	                    if (foundOmissionBlock)
	                        return false; // multiple :: in address
	                    foundOmissionBlock = true;
	                } else if (foundIPv4TransitionBlock && i == blocks.length - 1) {
	                    // it has been checked before that the last
	                    // block is a valid IPv4 address
	                } else if (!ipv6Block.test(blocks[i])) {
	                    return false;
	                }
	            }

	            if (foundOmissionBlock) {
	                return blocks.length >= 1;
	            } else {
	                return blocks.length === expectedNumberOfBlocks;
	            }
	        }
	        return false;
	    };

	    var default_fqdn_options = {
	        require_tld: true
	      , allow_underscores: false
	      , allow_trailing_dot: false
	    };

	    validator.isFQDN = function (str, options) {
	        options = merge(options, default_fqdn_options);

	        /* Remove the optional trailing dot before checking validity */
	        if (options.allow_trailing_dot && str[str.length - 1] === '.') {
	            str = str.substring(0, str.length - 1);
	        }
	        var parts = str.split('.');
	        if (options.require_tld) {
	            var tld = parts.pop();
	            if (!parts.length || !/^([a-z\u00a1-\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
	                return false;
	            }
	        }
	        for (var part, i = 0; i < parts.length; i++) {
	            part = parts[i];
	            if (options.allow_underscores) {
	                if (part.indexOf('__') >= 0) {
	                    return false;
	                }
	                part = part.replace(/_/g, '');
	            }
	            if (!/^[a-z\u00a1-\uffff0-9-]+$/i.test(part)) {
	                return false;
	            }
	            if (/[\uff01-\uff5e]/.test(part)) {
	                // disallow full-width chars
	                return false;
	            }
	            if (part[0] === '-' || part[part.length - 1] === '-' ||
	                    part.indexOf('---') >= 0) {
	                return false;
	            }
	        }
	        return true;
	    };

	    validator.isBoolean = function(str) {
	        return (['true', 'false', '1', '0'].indexOf(str) >= 0);
	    };

	    validator.isAlpha = function (str) {
	        return alpha.test(str);
	    };

	    validator.isAlphanumeric = function (str) {
	        return alphanumeric.test(str);
	    };

	    validator.isNumeric = function (str) {
	        return numeric.test(str);
	    };

	    validator.isDecimal = function (str) {
	        return str !== '' && decimal.test(str);
	    };

	    validator.isHexadecimal = function (str) {
	        return hexadecimal.test(str);
	    };

	    validator.isHexColor = function (str) {
	        return hexcolor.test(str);
	    };

	    validator.isLowercase = function (str) {
	        return str === str.toLowerCase();
	    };

	    validator.isUppercase = function (str) {
	        return str === str.toUpperCase();
	    };

	    validator.isInt = function (str, options) {
	        options = options || {};
	        return int.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
	    };

	    validator.isFloat = function (str, options) {
	        options = options || {};
	        if (str === '' || str === '.') {
	            return false;
	        }
	        return float.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);
	    };

	    validator.isDivisibleBy = function (str, num) {
	        return validator.toFloat(str) % validator.toInt(num) === 0;
	    };

	    validator.isNull = function (str) {
	        return str.length === 0;
	    };

	    validator.isLength = function (str, min, max) {
	        var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
	        var len = str.length - surrogatePairs.length;
	        return len >= min && (typeof max === 'undefined' || len <= max);
	    };

	    validator.isByteLength = function (str, min, max) {
	        var len = encodeURI(str).split(/%..|./).length - 1;
	        return len >= min && (typeof max === 'undefined' || len <= max);
	    };

	    validator.isUUID = function (str, version) {
	        var pattern = uuid[version ? version : 'all'];
	        return pattern && pattern.test(str);
	    };

	    function getTimezoneOffset(str) {
	        var iso8601Parts = str.match(iso8601)
	          , timezone, sign, hours, minutes;
	        if (!iso8601Parts) {
	            str = str.toLowerCase();
	            timezone = str.match(/(?:\s|gmt\s*)(-|\+)(\d{1,4})(\s|$)/);
	            if (!timezone) {
	                return str.indexOf('gmt') !== -1 ? 0 : null;
	            }
	            sign = timezone[1];
	            var offset = timezone[2];
	            if (offset.length === 3) {
	                offset = '0' + offset;
	            }
	            if (offset.length <= 2) {
	                hours = 0;
	                minutes = parseInt(offset);
	            } else {
	                hours = parseInt(offset.slice(0, 2));
	                minutes = parseInt(offset.slice(2, 4));
	            }
	        } else {
	            timezone = iso8601Parts[21];
	            if (!timezone || timezone === 'z' || timezone === 'Z') {
	                return 0;
	            }
	            sign = iso8601Parts[22];
	            if (timezone.indexOf(':') !== -1) {
	                hours = parseInt(iso8601Parts[23]);
	                minutes = parseInt(iso8601Parts[24]);
	            } else {
	                hours = 0;
	                minutes = parseInt(iso8601Parts[23]);
	            }
	        }
	        return (hours * 60 + minutes) * (sign === '-' ? 1 : -1);
	    }

	    validator.isDate = function (str) {
	        var normalizedDate = new Date(Date.parse(str));
	        if (isNaN(normalizedDate)) {
	            return false;
	        }
	        // normalizedDate is in the user's timezone. Apply the input
	        // timezone offset to the date so that the year and day match
	        // the input
	        var timezoneOffset = getTimezoneOffset(str);
	        if (timezoneOffset !== null) {
	            var timezoneDifference = normalizedDate.getTimezoneOffset() -
	                timezoneOffset;
	            normalizedDate = new Date(normalizedDate.getTime() +
	                60000 * timezoneDifference);
	        }
	        var day = String(normalizedDate.getDate());
	        var dayOrYear, dayOrYearMatches, year;
	        //check for valid double digits that could be late days
	        //check for all matches since a string like '12/23' is a valid date
	        //ignore everything with nearby colons
	        dayOrYearMatches = str.match(/(^|[^:\d])[23]\d([^:\d]|$)/g);
	        if (!dayOrYearMatches) {
	            return true;
	        }
	        dayOrYear = dayOrYearMatches.map(function(digitString) {
	            return digitString.match(/\d+/g)[0];
	        }).join('/');
	        year = String(normalizedDate.getFullYear()).slice(-2);
	        if (dayOrYear === day || dayOrYear === year) {
	            return true;
	        } else if ((dayOrYear === (day + '/' + year)) || (dayOrYear === (year + '/' + day))) {
	            return true;
	        }
	        return false;
	    };

	    validator.isAfter = function (str, date) {
	        var comparison = validator.toDate(date || new Date())
	          , original = validator.toDate(str);
	        return !!(original && comparison && original > comparison);
	    };

	    validator.isBefore = function (str, date) {
	        var comparison = validator.toDate(date || new Date())
	          , original = validator.toDate(str);
	        return !!(original && comparison && original < comparison);
	    };

	    validator.isIn = function (str, options) {
	        var i;
	        if (Object.prototype.toString.call(options) === '[object Array]') {
	            var array = [];
	            for (i in options) {
	                array[i] = validator.toString(options[i]);
	            }
	            return array.indexOf(str) >= 0;
	        } else if (typeof options === 'object') {
	            return options.hasOwnProperty(str);
	        } else if (options && typeof options.indexOf === 'function') {
	            return options.indexOf(str) >= 0;
	        }
	        return false;
	    };

	    validator.isWhitelisted = function (str, chars) {
	        for (var i = str.length - 1; i >= 0; i--) {
	            if (chars.indexOf(str[i]) === -1) {
	                return false;
	            }
	        }

	        return true;
	    };

	    validator.isCreditCard = function (str) {
	        var sanitized = str.replace(/[^0-9]+/g, '');
	        if (!creditCard.test(sanitized)) {
	            return false;
	        }
	        var sum = 0, digit, tmpNum, shouldDouble;
	        for (var i = sanitized.length - 1; i >= 0; i--) {
	            digit = sanitized.substring(i, (i + 1));
	            tmpNum = parseInt(digit, 10);
	            if (shouldDouble) {
	                tmpNum *= 2;
	                if (tmpNum >= 10) {
	                    sum += ((tmpNum % 10) + 1);
	                } else {
	                    sum += tmpNum;
	                }
	            } else {
	                sum += tmpNum;
	            }
	            shouldDouble = !shouldDouble;
	        }
	        return !!((sum % 10) === 0 ? sanitized : false);
	    };

	    validator.isISIN = function (str) {
	        if (!isin.test(str)) {
	            return false;
	        }

	        var checksumStr = str.replace(/[A-Z]/g, function(character) {
	            return parseInt(character, 36);
	        });

	        var sum = 0, digit, tmpNum, shouldDouble = true;
	        for (var i = checksumStr.length - 2; i >= 0; i--) {
	            digit = checksumStr.substring(i, (i + 1));
	            tmpNum = parseInt(digit, 10);
	            if (shouldDouble) {
	                tmpNum *= 2;
	                if (tmpNum >= 10) {
	                    sum += tmpNum + 1;
	                } else {
	                    sum += tmpNum;
	                }
	            } else {
	                sum += tmpNum;
	            }
	            shouldDouble = !shouldDouble;
	        }

	        return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;
	    };

	    validator.isISBN = function (str, version) {
	        version = validator.toString(version);
	        if (!version) {
	            return validator.isISBN(str, 10) || validator.isISBN(str, 13);
	        }
	        var sanitized = str.replace(/[\s-]+/g, '')
	          , checksum = 0, i;
	        if (version === '10') {
	            if (!isbn10Maybe.test(sanitized)) {
	                return false;
	            }
	            for (i = 0; i < 9; i++) {
	                checksum += (i + 1) * sanitized.charAt(i);
	            }
	            if (sanitized.charAt(9) === 'X') {
	                checksum += 10 * 10;
	            } else {
	                checksum += 10 * sanitized.charAt(9);
	            }
	            if ((checksum % 11) === 0) {
	                return !!sanitized;
	            }
	        } else  if (version === '13') {
	            if (!isbn13Maybe.test(sanitized)) {
	                return false;
	            }
	            var factor = [ 1, 3 ];
	            for (i = 0; i < 12; i++) {
	                checksum += factor[i % 2] * sanitized.charAt(i);
	            }
	            if (sanitized.charAt(12) - ((10 - (checksum % 10)) % 10) === 0) {
	                return !!sanitized;
	            }
	        }
	        return false;
	    };

	    validator.isMobilePhone = function(str, locale) {
	        if (locale in phones) {
	            return phones[locale].test(str);
	        }
	        return false;
	    };

	    var default_currency_options = {
	        symbol: '$'
	      , require_symbol: false
	      , allow_space_after_symbol: false
	      , symbol_after_digits: false
	      , allow_negatives: true
	      , parens_for_negatives: false
	      , negative_sign_before_digits: false
	      , negative_sign_after_digits: false
	      , allow_negative_sign_placeholder: false
	      , thousands_separator: ','
	      , decimal_separator: '.'
	      , allow_space_after_digits: false
	    };

	    validator.isCurrency = function (str, options) {
	        options = merge(options, default_currency_options);

	        return currencyRegex(options).test(str);
	    };

	    validator.isJSON = function (str) {
	        try {
	            var obj = JSON.parse(str);
	            return !!obj && typeof obj === 'object';
	        } catch (e) {}
	        return false;
	    };

	    validator.isMultibyte = function (str) {
	        return multibyte.test(str);
	    };

	    validator.isAscii = function (str) {
	        return ascii.test(str);
	    };

	    validator.isFullWidth = function (str) {
	        return fullWidth.test(str);
	    };

	    validator.isHalfWidth = function (str) {
	        return halfWidth.test(str);
	    };

	    validator.isVariableWidth = function (str) {
	        return fullWidth.test(str) && halfWidth.test(str);
	    };

	    validator.isSurrogatePair = function (str) {
	        return surrogatePair.test(str);
	    };

	    validator.isBase64 = function (str) {
	        return base64.test(str);
	    };

	    validator.isMongoId = function (str) {
	        return validator.isHexadecimal(str) && str.length === 24;
	    };

	    validator.isISO8601 = function (str) {
	        return iso8601.test(str);
	    };

	    validator.ltrim = function (str, chars) {
	        var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\s+/g;
	        return str.replace(pattern, '');
	    };

	    validator.rtrim = function (str, chars) {
	        var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\s+$/g;
	        return str.replace(pattern, '');
	    };

	    validator.trim = function (str, chars) {
	        var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\s+|\s+$/g;
	        return str.replace(pattern, '');
	    };

	    validator.escape = function (str) {
	        return (str.replace(/&/g, '&amp;')
	            .replace(/"/g, '&quot;')
	            .replace(/'/g, '&#x27;')
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;')
	            .replace(/\//g, '&#x2F;')
	            .replace(/\`/g, '&#96;'));
	    };

	    validator.stripLow = function (str, keep_new_lines) {
	        var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
	        return validator.blacklist(str, chars);
	    };

	    validator.whitelist = function (str, chars) {
	        return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');
	    };

	    validator.blacklist = function (str, chars) {
	        return str.replace(new RegExp('[' + chars + ']+', 'g'), '');
	    };

	    var default_normalize_email_options = {
	        lowercase: true,
	        remove_dots: true,
	        remove_extension: true
	    };

	    validator.normalizeEmail = function (email, options) {
	        options = merge(options, default_normalize_email_options);
	        if (!validator.isEmail(email)) {
	            return false;
	        }
	        var parts = email.split('@', 2);
	        parts[1] = parts[1].toLowerCase();
	        if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
	            if (options.remove_extension) {
	                parts[0] = parts[0].split('+')[0];
	            }
	            if (options.remove_dots) {
	                parts[0] = parts[0].replace(/\./g, '');
	            }
	            if (!parts[0].length) {
	                return false;
	            }
	            parts[0] = parts[0].toLowerCase();
	            parts[1] = 'gmail.com';
	        } else if (options.lowercase) {
	            parts[0] = parts[0].toLowerCase();
	        }
	        return parts.join('@');
	    };

	    function merge(obj, defaults) {
	        obj = obj || {};
	        for (var key in defaults) {
	            if (typeof obj[key] === 'undefined') {
	                obj[key] = defaults[key];
	            }
	        }
	        return obj;
	    }

	    function currencyRegex(options) {
	        var symbol = '(\\' + options.symbol.replace(/\./g, '\\.') + ')' + (options.require_symbol ? '' : '?')
	            , negative = '-?'
	            , whole_dollar_amount_without_sep = '[1-9]\\d*'
	            , whole_dollar_amount_with_sep = '[1-9]\\d{0,2}(\\' + options.thousands_separator + '\\d{3})*'
	            , valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep]
	            , whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?'
	            , decimal_amount = '(\\' + options.decimal_separator + '\\d{2})?';
	        var pattern = whole_dollar_amount + decimal_amount;
	        // default is negative sign before symbol, but there are two other options (besides parens)
	        if (options.allow_negatives && !options.parens_for_negatives) {
	            if (options.negative_sign_after_digits) {
	                pattern += negative;
	            }
	            else if (options.negative_sign_before_digits) {
	                pattern = negative + pattern;
	            }
	        }
	        // South African Rand, for example, uses R 123 (space) and R-123 (no space)
	        if (options.allow_negative_sign_placeholder) {
	            pattern = '( (?!\\-))?' + pattern;
	        }
	        else if (options.allow_space_after_symbol) {
	            pattern = ' ?' + pattern;
	        }
	        else if (options.allow_space_after_digits) {
	            pattern += '( (?!$))?';
	        }
	        if (options.symbol_after_digits) {
	            pattern += symbol;
	        } else {
	            pattern = symbol + pattern;
	        }
	        if (options.allow_negatives) {
	            if (options.parens_for_negatives) {
	                pattern = '(\\(' + pattern + '\\)|' + pattern + ')';
	            }
	            else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
	                pattern = negative + pattern;
	            }
	        }
	        return new RegExp(
	            '^' +
	            // ensure there's a dollar and/or decimal amount, and that it doesn't start with a space or a negative sign followed by a space
	            '(?!-? )(?=.*\\d)' +
	            pattern +
	            '$'
	        );
	    }

	    validator.init();

	    return validator;

	});


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var FormatValidators  = __webpack_require__(24),
	    Report            = __webpack_require__(21),
	    Utils             = __webpack_require__(23);

	var JsonValidators = {
	    multipleOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2
	        if (typeof json !== "number") {
	            return;
	        }
	        if (Utils.whatIs(json / schema.multipleOf) !== "integer") {
	            report.addError("MULTIPLE_OF", [json, schema.multipleOf], null, schema.description);
	        }
	    },
	    maximum: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2
	        if (typeof json !== "number") {
	            return;
	        }
	        if (schema.exclusiveMaximum !== true) {
	            if (json > schema.maximum) {
	                report.addError("MAXIMUM", [json, schema.maximum], null, schema.description);
	            }
	        } else {
	            if (json >= schema.maximum) {
	                report.addError("MAXIMUM_EXCLUSIVE", [json, schema.maximum], null, schema.description);
	            }
	        }
	    },
	    exclusiveMaximum: function () {
	        // covered in maximum
	    },
	    minimum: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2
	        if (typeof json !== "number") {
	            return;
	        }
	        if (schema.exclusiveMinimum !== true) {
	            if (json < schema.minimum) {
	                report.addError("MINIMUM", [json, schema.minimum], null, schema.description);
	            }
	        } else {
	            if (json <= schema.minimum) {
	                report.addError("MINIMUM_EXCLUSIVE", [json, schema.minimum], null, schema.description);
	            }
	        }
	    },
	    exclusiveMinimum: function () {
	        // covered in minimum
	    },
	    maxLength: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2
	        if (typeof json !== "string") {
	            return;
	        }
	        if (Utils.ucs2decode(json).length > schema.maxLength) {
	            report.addError("MAX_LENGTH", [json.length, schema.maxLength], null, schema.description);
	        }
	    },
	    minLength: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2
	        if (typeof json !== "string") {
	            return;
	        }
	        if (Utils.ucs2decode(json).length < schema.minLength) {
	            report.addError("MIN_LENGTH", [json.length, schema.minLength], null, schema.description);
	        }
	    },
	    pattern: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2
	        if (typeof json !== "string") {
	            return;
	        }
	        if (RegExp(schema.pattern).test(json) === false) {
	            report.addError("PATTERN", [schema.pattern, json], null, schema.description);
	        }
	    },
	    additionalItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        // if the value of "additionalItems" is boolean value false and the value of "items" is an array,
	        // the json is valid if its size is less than, or equal to, the size of "items".
	        if (schema.additionalItems === false && Array.isArray(schema.items)) {
	            if (json.length > schema.items.length) {
	                report.addError("ARRAY_ADDITIONAL_ITEMS", null, null, schema.description);
	            }
	        }
	    },
	    items: function () { /*report, schema, json*/
	        // covered in additionalItems
	    },
	    maxItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        if (json.length > schema.maxItems) {
	            report.addError("ARRAY_LENGTH_LONG", [json.length, schema.maxItems], null, schema.description);
	        }
	    },
	    minItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        if (json.length < schema.minItems) {
	            report.addError("ARRAY_LENGTH_SHORT", [json.length, schema.minItems], null, schema.description);
	        }
	    },
	    uniqueItems: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2
	        if (!Array.isArray(json)) {
	            return;
	        }
	        if (schema.uniqueItems === true) {
	            var matches = [];
	            if (Utils.isUniqueArray(json, matches) === false) {
	                report.addError("ARRAY_UNIQUE", matches, null, schema.description);
	            }
	        }
	    },
	    maxProperties: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var keysCount = Object.keys(json).length;
	        if (keysCount > schema.maxProperties) {
	            report.addError("OBJECT_PROPERTIES_MAXIMUM", [keysCount, schema.maxProperties], null, schema.description);
	        }
	    },
	    minProperties: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var keysCount = Object.keys(json).length;
	        if (keysCount < schema.minProperties) {
	            report.addError("OBJECT_PROPERTIES_MINIMUM", [keysCount, schema.minProperties], null, schema.description);
	        }
	    },
	    required: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var idx = schema.required.length;
	        while (idx--) {
	            var requiredPropertyName = schema.required[idx];
	            if (json[requiredPropertyName] === undefined) {
	                report.addError("OBJECT_MISSING_REQUIRED_PROPERTY", [requiredPropertyName], null, schema.description);
	            }
	        }
	    },
	    additionalProperties: function (report, schema, json) {
	        // covered in properties and patternProperties
	        if (schema.properties === undefined && schema.patternProperties === undefined) {
	            return JsonValidators.properties.call(this, report, schema, json);
	        }
	    },
	    patternProperties: function (report, schema, json) {
	        // covered in properties
	        if (schema.properties === undefined) {
	            return JsonValidators.properties.call(this, report, schema, json);
	        }
	    },
	    properties: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }
	        var properties = schema.properties !== undefined ? schema.properties : {};
	        var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};
	        if (schema.additionalProperties === false) {
	            // The property set of the json to validate.
	            var s = Object.keys(json);
	            // The property set from "properties".
	            var p = Object.keys(properties);
	            // The property set from "patternProperties".
	            var pp = Object.keys(patternProperties);
	            // remove from "s" all elements of "p", if any;
	            s = Utils.difference(s, p);
	            // for each regex in "pp", remove all elements of "s" which this regex matches.
	            var idx = pp.length;
	            while (idx--) {
	                var regExp = RegExp(pp[idx]),
	                    idx2 = s.length;
	                while (idx2--) {
	                    if (regExp.test(s[idx2]) === true) {
	                        s.splice(idx2, 1);
	                    }
	                }
	            }
	            // Validation of the json succeeds if, after these two steps, set "s" is empty.
	            if (s.length > 0) {
	                // assumeAdditional can be an array of allowed properties
	                var idx3 = this.options.assumeAdditional.length;
	                if (idx3) {
	                    while (idx3--) {
	                        var io = s.indexOf(this.options.assumeAdditional[idx3]);
	                        if (io !== -1) {
	                            s.splice(io, 1);
	                        }
	                    }
	                }
	                if (s.length > 0) {
	                    report.addError("OBJECT_ADDITIONAL_PROPERTIES", [s], null, schema.description);
	                }
	            }
	        }
	    },
	    dependencies: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2
	        if (Utils.whatIs(json) !== "object") {
	            return;
	        }

	        var keys = Object.keys(schema.dependencies),
	            idx = keys.length;

	        while (idx--) {
	            // iterate all dependencies
	            var dependencyName = keys[idx];
	            if (json[dependencyName]) {
	                var dependencyDefinition = schema.dependencies[dependencyName];
	                if (Utils.whatIs(dependencyDefinition) === "object") {
	                    // if dependency is a schema, validate against this schema
	                    exports.validate.call(this, report, dependencyDefinition, json);
	                } else { // Array
	                    // if dependency is an array, object needs to have all properties in this array
	                    var idx2 = dependencyDefinition.length;
	                    while (idx2--) {
	                        var requiredPropertyName = dependencyDefinition[idx2];
	                        if (json[requiredPropertyName] === undefined) {
	                            report.addError("OBJECT_DEPENDENCY_KEY", [requiredPropertyName, dependencyName], null, schema.description);
	                        }
	                    }
	                }
	            }
	        }
	    },
	    enum: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2
	        var match = false,
	            idx = schema.enum.length;
	        while (idx--) {
	            if (Utils.areEqual(json, schema.enum[idx])) {
	                match = true;
	                break;
	            }
	        }
	        if (match === false) {
	            report.addError("ENUM_MISMATCH", [json], null, schema.description);
	        }
	    },
	    /*
	    type: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
	        // type is handled before this is called so ignore
	    },
	    */
	    allOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2
	        var idx = schema.allOf.length;
	        while (idx--) {
	            var validateResult = exports.validate.call(this, report, schema.allOf[idx], json);
	            if (this.options.breakOnFirstError && validateResult === false) {
	                break;
	            }
	        }
	    },
	    anyOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2
	        var subReports = [],
	            passed = false,
	            idx = schema.anyOf.length;

	        while (idx-- && passed === false) {
	            var subReport = new Report(report);
	            subReports.push(subReport);
	            passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);
	        }

	        if (passed === false) {
	            report.addError("ANY_OF_MISSING", undefined, subReports, schema.description);
	        }
	    },
	    oneOf: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2
	        var passes = 0,
	            subReports = [],
	            idx = schema.oneOf.length;

	        while (idx--) {
	            var subReport = new Report(report, { maxErrors: 1 });
	            subReports.push(subReport);
	            if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {
	                passes++;
	            }
	        }

	        if (passes === 0) {
	            report.addError("ONE_OF_MISSING", undefined, subReports, schema.description);
	        } else if (passes > 1) {
	            report.addError("ONE_OF_MULTIPLE", null, null, schema.description);
	        }
	    },
	    not: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2
	        var subReport = new Report(report);
	        if (exports.validate.call(this, subReport, schema.not, json) === true) {
	            report.addError("NOT_PASSED", null, null, schema.description);
	        }
	    },
	    definitions: function () { /*report, schema, json*/
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.2
	        // nothing to do here
	    },
	    format: function (report, schema, json) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2
	        var formatValidatorFn = FormatValidators[schema.format];
	        if (typeof formatValidatorFn === "function") {
	            if (formatValidatorFn.length === 2) {
	                // async
	                report.addAsyncTask(formatValidatorFn, [json], function (result) {
	                    if (result !== true) {
	                        report.addError("INVALID_FORMAT", [schema.format, json], null, schema.description);
	                    }
	                });
	            } else {
	                // sync
	                if (formatValidatorFn.call(this, json) !== true) {
	                    report.addError("INVALID_FORMAT", [schema.format, json], null, schema.description);
	                }
	            }
	        } else if (this.options.ignoreUnknownFormats !== true) {
	            report.addError("UNKNOWN_FORMAT", [schema.format], null, schema.description);
	        }
	    }
	};

	var recurseArray = function (report, schema, json) {
	    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2

	    var idx = json.length;

	    // If "items" is an array, this situation, the schema depends on the index:
	    // if the index is less than, or equal to, the size of "items",
	    // the child instance must be valid against the corresponding schema in the "items" array;
	    // otherwise, it must be valid against the schema defined by "additionalItems".
	    if (Array.isArray(schema.items)) {

	        while (idx--) {
	            // equal to doesnt make sense here
	            if (idx < schema.items.length) {
	                report.path.push(idx.toString());
	                exports.validate.call(this, report, schema.items[idx], json[idx]);
	                report.path.pop();
	            } else {
	                // might be boolean, so check that it's an object
	                if (typeof schema.additionalItems === "object") {
	                    report.path.push(idx.toString());
	                    exports.validate.call(this, report, schema.additionalItems, json[idx]);
	                    report.path.pop();
	                }
	            }
	        }

	    } else if (typeof schema.items === "object") {

	        // If items is a schema, then the child instance must be valid against this schema,
	        // regardless of its index, and regardless of the value of "additionalItems".
	        while (idx--) {
	            report.path.push(idx.toString());
	            exports.validate.call(this, report, schema.items, json[idx]);
	            report.path.pop();
	        }

	    }
	};

	var recurseObject = function (report, schema, json) {
	    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3

	    // If "additionalProperties" is absent, it is considered present with an empty schema as a value.
	    // In addition, boolean value true is considered equivalent to an empty schema.
	    var additionalProperties = schema.additionalProperties;
	    if (additionalProperties === true || additionalProperties === undefined) {
	        additionalProperties = {};
	    }

	    // p - The property set from "properties".
	    var p = schema.properties ? Object.keys(schema.properties) : [];

	    // pp - The property set from "patternProperties". Elements of this set will be called regexes for convenience.
	    var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];

	    // m - The property name of the child.
	    var keys = Object.keys(json),
	        idx = keys.length;

	    while (idx--) {
	        var m = keys[idx],
	            propertyValue = json[m];

	        // s - The set of schemas for the child instance.
	        var s = [];

	        // 1. If set "p" contains value "m", then the corresponding schema in "properties" is added to "s".
	        if (p.indexOf(m) !== -1) {
	            s.push(schema.properties[m]);
	        }

	        // 2. For each regex in "pp", if it matches "m" successfully, the corresponding schema in "patternProperties" is added to "s".
	        var idx2 = pp.length;
	        while (idx2--) {
	            var regexString = pp[idx2];
	            if (RegExp(regexString).test(m) === true) {
	                s.push(schema.patternProperties[regexString]);
	            }
	        }

	        // 3. The schema defined by "additionalProperties" is added to "s" if and only if, at this stage, "s" is empty.
	        if (s.length === 0 && additionalProperties !== false) {
	            s.push(additionalProperties);
	        }

	        // we are passing tests even without this assert because this is covered by properties check
	        // if s is empty in this stage, no additionalProperties are allowed
	        // report.expect(s.length !== 0, 'E001', m);

	        // Instance property value must pass all schemas from s
	        idx2 = s.length;
	        while (idx2--) {
	            report.path.push(m);
	            exports.validate.call(this, report, s[idx2], propertyValue);
	            report.path.pop();
	        }
	    }
	};

	exports.validate = function (report, schema, json) {

	    report.commonErrorMessage = "JSON_OBJECT_VALIDATION_FAILED";

	    // check if schema is an object
	    var to = Utils.whatIs(schema);
	    if (to !== "object") {
	        report.addError("SCHEMA_NOT_AN_OBJECT", [to], null, schema.description);
	        return false;
	    }

	    // check if schema is empty, everything is valid against empty schema
	    var keys = Object.keys(schema);
	    if (keys.length === 0) {
	        return true;
	    }

	    // this method can be called recursively, so we need to remember our root
	    var isRoot = false;
	    if (!report.rootSchema) {
	        report.rootSchema = schema;
	        isRoot = true;
	    }

	    // follow schema.$ref keys
	    if (schema.$ref !== undefined) {
	        // avoid infinite loop with maxRefs
	        var maxRefs = 99;
	        while (schema.$ref && maxRefs > 0) {
	            if (!schema.__$refResolved) {
	                report.addError("REF_UNRESOLVED", [schema.$ref], null, schema.description);
	                break;
	            } else if (schema.__$refResolved === schema) {
	                break;
	            } else {
	                schema = schema.__$refResolved;
	                keys = Object.keys(schema);
	            }
	            maxRefs--;
	        }
	        if (maxRefs === 0) {
	            throw new Error("Circular dependency by $ref references!");
	        }
	    }

	    // type checking first
	    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2
	    var jsonType = Utils.whatIs(json);
	    if (schema.type) {
	        if (typeof schema.type === "string") {
	            if (jsonType !== schema.type && (jsonType !== "integer" || schema.type !== "number")) {
	                report.addError("INVALID_TYPE", [schema.type, jsonType], null, schema.description);
	                if (this.options.breakOnFirstError) {
	                    return false;
	                }
	            }
	        } else {
	            if (schema.type.indexOf(jsonType) === -1 && (jsonType !== "integer" || schema.type.indexOf("number") === -1)) {
	                report.addError("INVALID_TYPE", [schema.type, jsonType], null, schema.description);
	                if (this.options.breakOnFirstError) {
	                    return false;
	                }
	            }
	        }
	    }

	    // now iterate all the keys in schema and execute validation methods
	    var idx = keys.length;
	    while (idx--) {
	        if (JsonValidators[keys[idx]]) {
	            JsonValidators[keys[idx]].call(this, report, schema, json);
	            if (report.errors.length && this.options.breakOnFirstError) { break; }
	        }
	    }

	    if (report.errors.length === 0 || this.options.breakOnFirstError === false) {
	        if (jsonType === "array") {
	            recurseArray.call(this, report, schema, json);
	        } else if (jsonType === "object") {
	            recurseObject.call(this, report, schema, json);
	        }
	    }

	    // we don't need the root pointer anymore
	    if (isRoot) {
	        report.rootSchema = undefined;
	    }

	    // return valid just to be able to break at some code points
	    return report.errors.length === 0;

	};


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Report              = __webpack_require__(21);
	var SchemaCompilation   = __webpack_require__(28);
	var SchemaValidation    = __webpack_require__(29);
	var Utils               = __webpack_require__(23);

	function decodeJSONPointer(str) {
	    // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3
	    return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {
	        return x === "~1" ? "/" : "~";
	    });
	}

	function getRemotePath(uri) {
	    var io = uri.indexOf("#");
	    return io === -1 ? uri : uri.slice(0, io);
	}

	function getQueryPath(uri) {
	    var io = uri.indexOf("#");
	    var res = io === -1 ? undefined : uri.slice(io + 1);
	    // WARN: do not slice slash, #/ means take root and go down from it
	    // if (res && res[0] === "/") { res = res.slice(1); }
	    return res;
	}

	function findId(schema, id) {
	    // process only arrays and objects
	    if (typeof schema !== "object" || schema === null) {
	        return;
	    }

	    // no id means root so return itself
	    if (!id) {
	        return schema;
	    }

	    if (schema.id) {
	        if (schema.id === id || schema.id[0] === "#" && schema.id.substring(1) === id) {
	            return schema;
	        }
	    }

	    var idx, result;
	    if (Array.isArray(schema)) {
	        idx = schema.length;
	        while (idx--) {
	            result = findId(schema[idx], id);
	            if (result) { return result; }
	        }
	    } else {
	        var keys = Object.keys(schema);
	        idx = keys.length;
	        while (idx--) {
	            var k = keys[idx];
	            if (k.indexOf("__$") === 0) {
	                continue;
	            }
	            result = findId(schema[k], id);
	            if (result) { return result; }
	        }
	    }
	}

	exports.cacheSchemaByUri = function (uri, schema) {
	    var remotePath = getRemotePath(uri);
	    if (remotePath) {
	        this.cache[remotePath] = schema;
	    }
	};

	exports.removeFromCacheByUri = function (uri) {
	    var remotePath = getRemotePath(uri);
	    if (remotePath) {
	        delete this.cache[remotePath];
	    }
	};

	exports.checkCacheForUri = function (uri) {
	    var remotePath = getRemotePath(uri);
	    return remotePath ? this.cache[remotePath] != null : false;
	};

	exports.getSchema = function (report, schema) {
	    if (typeof schema === "object") {
	        schema = exports.getSchemaByReference.call(this, report, schema);
	    }
	    if (typeof schema === "string") {
	        schema = exports.getSchemaByUri.call(this, report, schema);
	    }
	    return schema;
	};

	exports.getSchemaByReference = function (report, key) {
	    var i = this.referenceCache.length;
	    while (i--) {
	        if (this.referenceCache[i][0] === key) {
	            return this.referenceCache[i][1];
	        }
	    }
	    // not found
	    var schema = Utils.cloneDeep(key);
	    this.referenceCache.push([key, schema]);
	    return schema;
	};

	exports.getSchemaByUri = function (report, uri, root) {
	    var remotePath = getRemotePath(uri),
	        queryPath = getQueryPath(uri),
	        result = remotePath ? this.cache[remotePath] : root;

	    if (result && remotePath) {
	        // we need to avoid compiling schemas in a recursive loop
	        var compileRemote = result !== root;
	        // now we need to compile and validate resolved schema (in case it's not already)
	        if (compileRemote) {

	            report.path.push(remotePath);

	            var remoteReport = new Report(report);
	            if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {
	                SchemaValidation.validateSchema.call(this, remoteReport, result);
	            }
	            var remoteReportIsValid = remoteReport.isValid();
	            if (!remoteReportIsValid) {
	                report.addError("REMOTE_NOT_VALID", [uri], remoteReport);
	            }

	            report.path.pop();

	            if (!remoteReportIsValid) {
	                return undefined;
	            }
	        }
	    }

	    if (result && queryPath) {
	        var parts = queryPath.split("/");
	        for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {
	            var key = decodeJSONPointer(parts[idx]);
	            if (idx === 0) { // it's an id
	                result = findId(result, key);
	            } else { // it's a path behind id
	                result = result[key];
	            }
	        }
	    }

	    return result;
	};

	exports.getRemotePath = getRemotePath;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var Report      = __webpack_require__(21);
	var SchemaCache = __webpack_require__(27);
	var Utils       = __webpack_require__(23);

	function mergeReference(scope, ref) {
	    if (Utils.isAbsoluteUri(ref)) {
	        return ref;
	    }

	    var joinedScope = scope.join(""),
	        isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),
	        isScopeRelative = Utils.isRelativeUri(joinedScope),
	        isRefRelative = Utils.isRelativeUri(ref),
	        toRemove;

	    if (isScopeAbsolute && isRefRelative) {
	        toRemove = joinedScope.match(/\/[^\/]*$/);
	        if (toRemove) {
	            joinedScope = joinedScope.slice(0, toRemove.index + 1);
	        }
	    } else if (isScopeRelative && isRefRelative) {
	        joinedScope = "";
	    } else {
	        toRemove = joinedScope.match(/[^#/]+$/);
	        if (toRemove) {
	            joinedScope = joinedScope.slice(0, toRemove.index);
	        }
	    }

	    var res = joinedScope + ref;
	    res = res.replace(/##/, "#");
	    return res;
	}

	function collectReferences(obj, results, scope, path) {
	    results = results || [];
	    scope = scope || [];
	    path = path || [];

	    if (typeof obj !== "object" || obj === null) {
	        return results;
	    }

	    if (typeof obj.id === "string") {
	        scope.push(obj.id);
	    }

	    if (typeof obj.$ref === "string" && typeof obj.__$refResolved === "undefined") {
	        results.push({
	            ref: mergeReference(scope, obj.$ref),
	            key: "$ref",
	            obj: obj,
	            path: path.slice(0)
	        });
	    }
	    if (typeof obj.$schema === "string" && typeof obj.__$schemaResolved === "undefined") {
	        results.push({
	            ref: mergeReference(scope, obj.$schema),
	            key: "$schema",
	            obj: obj,
	            path: path.slice(0)
	        });
	    }

	    var idx;
	    if (Array.isArray(obj)) {
	        idx = obj.length;
	        while (idx--) {
	            path.push(idx.toString());
	            collectReferences(obj[idx], results, scope, path);
	            path.pop();
	        }
	    } else {
	        var keys = Object.keys(obj);
	        idx = keys.length;
	        while (idx--) {
	            // do not recurse through resolved references and other z-schema props
	            if (keys[idx].indexOf("__$") === 0) { continue; }
	            path.push(keys[idx]);
	            collectReferences(obj[keys[idx]], results, scope, path);
	            path.pop();
	        }
	    }

	    if (typeof obj.id === "string") {
	        scope.pop();
	    }

	    return results;
	}

	var compileArrayOfSchemasLoop = function (mainReport, arr) {
	    var idx = arr.length,
	        compiledCount = 0;

	    while (idx--) {

	        // try to compile each schema separately
	        var report = new Report(mainReport);
	        var isValid = exports.compileSchema.call(this, report, arr[idx]);
	        if (isValid) { compiledCount++; }

	        // copy errors to report
	        mainReport.errors = mainReport.errors.concat(report.errors);

	    }

	    return compiledCount;
	};

	function findId(arr, id) {
	    var idx = arr.length;
	    while (idx--) {
	        if (arr[idx].id === id) {
	            return arr[idx];
	        }
	    }
	    return null;
	}

	var compileArrayOfSchemas = function (report, arr) {

	    var compiled = 0,
	        lastLoopCompiled;

	    do {

	        // remove all UNRESOLVABLE_REFERENCE errors before compiling array again
	        var idx = report.errors.length;
	        while (idx--) {
	            if (report.errors[idx].code === "UNRESOLVABLE_REFERENCE") {
	                report.errors.splice(idx, 1);
	            }
	        }

	        // remember how many were compiled in the last loop
	        lastLoopCompiled = compiled;

	        // count how many are compiled now
	        compiled = compileArrayOfSchemasLoop.call(this, report, arr);

	        // fix __$missingReferences if possible
	        idx = arr.length;
	        while (idx--) {
	            var sch = arr[idx];
	            if (sch.__$missingReferences) {
	                var idx2 = sch.__$missingReferences.length;
	                while (idx2--) {
	                    var refObj = sch.__$missingReferences[idx2];
	                    var response = findId(arr, refObj.ref);
	                    if (response) {
	                        // this might create circular references
	                        refObj.obj["__" + refObj.key + "Resolved"] = response;
	                        // it's resolved now so delete it
	                        sch.__$missingReferences.splice(idx2, 1);
	                    }
	                }
	                if (sch.__$missingReferences.length === 0) {
	                    delete sch.__$missingReferences;
	                }
	            }
	        }

	        // keep repeating if not all compiled and at least one more was compiled in the last loop
	    } while (compiled !== arr.length && compiled !== lastLoopCompiled);

	    return report.isValid();

	};

	exports.compileSchema = function (report, schema) {

	    report.commonErrorMessage = "SCHEMA_COMPILATION_FAILED";

	    // if schema is a string, assume it's a uri
	    if (typeof schema === "string") {
	        var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);
	        if (!loadedSchema) {
	            report.addError("SCHEMA_NOT_REACHABLE", [schema]);
	            return false;
	        }
	        schema = loadedSchema;
	    }

	    // if schema is an array, assume it's an array of schemas
	    if (Array.isArray(schema)) {
	        return compileArrayOfSchemas.call(this, report, schema);
	    }

	    // if we have an id than it should be cached already (if this instance has compiled it)
	    if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {
	        schema.__$compiled = undefined;
	    }

	    // do not re-compile schemas
	    if (schema.__$compiled) {
	        return true;
	    }

	    if (schema.id && typeof schema.id === "string") {
	        // add this to our schemaCache (before compilation in case we have references including id)
	        SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);
	    }

	    // this method can be called recursively, so we need to remember our root
	    var isRoot = false;
	    if (!report.rootSchema) {
	        report.rootSchema = schema;
	        isRoot = true;
	    }

	    // delete all __$missingReferences from previous compilation attempts
	    var isValidExceptReferences = report.isValid();
	    delete schema.__$missingReferences;

	    // collect all references that need to be resolved - $ref and $schema
	    var refs = collectReferences.call(this, schema),
	        idx = refs.length;
	    while (idx--) {
	        // resolve all the collected references into __xxxResolved pointer
	        var refObj = refs[idx];
	        var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);

	        // we can try to use custom schemaReader if available
	        if (!response) {
	            var schemaReader = this.getSchemaReader();
	            if (schemaReader) {
	                // it's supposed to return a valid schema
	                var s = schemaReader(refObj.ref);
	                if (s) {
	                    // it needs to have the id
	                    s.id = refObj.ref;
	                    // try to compile the schema
	                    var subreport = new Report(report);
	                    if (!exports.compileSchema.call(this, subreport, s)) {
	                        // copy errors to report
	                        report.errors = report.errors.concat(subreport.errors);
	                    } else {
	                        response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);
	                    }
	                }
	            }
	        }

	        if (!response) {

	            var hasNotValid = report.hasError("REMOTE_NOT_VALID", [refObj.ref]);
	            var isAbsolute = Utils.isAbsoluteUri(refObj.ref);
	            var isDownloaded = false;
	            var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;

	            if (isAbsolute) {
	                // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded
	                // and set through setRemoteReference method
	                isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);
	            }

	            if (hasNotValid) {
	                // already has REMOTE_NOT_VALID error for this one
	            } else if (ignoreUnresolvableRemotes && isAbsolute) {
	                // ignoreUnresolvableRemotes is on and remote isAbsolute
	            } else if (isDownloaded) {
	                // remote is downloaded, so no UNRESOLVABLE_REFERENCE
	            } else {
	                Array.prototype.push.apply(report.path, refObj.path);
	                report.addError("UNRESOLVABLE_REFERENCE", [refObj.ref]);
	                report.path = report.path.slice(0, -refObj.path.length);

	                // pusblish unresolved references out
	                if (isValidExceptReferences) {
	                    schema.__$missingReferences = schema.__$missingReferences || [];
	                    schema.__$missingReferences.push(refObj);
	                }
	            }
	        }
	        // this might create circular references
	        refObj.obj["__" + refObj.key + "Resolved"] = response;
	    }

	    var isValid = report.isValid();
	    if (isValid) {
	        schema.__$compiled = true;
	    } else {
	        if (schema.id && typeof schema.id === "string") {
	            // remove this schema from schemaCache because it failed to compile
	            SchemaCache.removeFromCacheByUri.call(this, schema.id);
	        }
	    }

	    // we don't need the root pointer anymore
	    if (isRoot) {
	        report.rootSchema = undefined;
	    }

	    return isValid;

	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var FormatValidators = __webpack_require__(24),
	    JsonValidation   = __webpack_require__(26),
	    Report           = __webpack_require__(21),
	    Utils            = __webpack_require__(23);

	var SchemaValidators = {
	    $ref: function (report, schema) {
	        // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07
	        // http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03
	        if (typeof schema.$ref !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["$ref", "string"]);
	        }
	    },
	    $schema: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-core.html#rfc.section.6
	        if (typeof schema.$schema !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["$schema", "string"]);
	        }
	    },
	    multipleOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.1
	        if (typeof schema.multipleOf !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["multipleOf", "number"]);
	        } else if (schema.multipleOf <= 0) {
	            report.addError("KEYWORD_MUST_BE", ["multipleOf", "strictly greater than 0"]);
	        }
	    },
	    maximum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
	        if (typeof schema.maximum !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maximum", "number"]);
	        }
	    },
	    exclusiveMaximum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.1
	        if (typeof schema.exclusiveMaximum !== "boolean") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMaximum", "boolean"]);
	        } else if (schema.maximum === undefined) {
	            report.addError("KEYWORD_DEPENDENCY", ["exclusiveMaximum", "maximum"]);
	        }
	    },
	    minimum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
	        if (typeof schema.minimum !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minimum", "number"]);
	        }
	    },
	    exclusiveMinimum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.1
	        if (typeof schema.exclusiveMinimum !== "boolean") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["exclusiveMinimum", "boolean"]);
	        } else if (schema.minimum === undefined) {
	            report.addError("KEYWORD_DEPENDENCY", ["exclusiveMinimum", "minimum"]);
	        }
	    },
	    maxLength: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.1
	        if (Utils.whatIs(schema.maxLength) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maxLength", "integer"]);
	        } else if (schema.maxLength < 0) {
	            report.addError("KEYWORD_MUST_BE", ["maxLength", "greater than, or equal to 0"]);
	        }
	    },
	    minLength: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.1
	        if (Utils.whatIs(schema.minLength) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minLength", "integer"]);
	        } else if (schema.minLength < 0) {
	            report.addError("KEYWORD_MUST_BE", ["minLength", "greater than, or equal to 0"]);
	        }
	    },
	    pattern: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.1
	        if (typeof schema.pattern !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["pattern", "string"]);
	        } else {
	            try {
	                RegExp(schema.pattern);
	            } catch (e) {
	                report.addError("KEYWORD_PATTERN", ["pattern", schema.pattern]);
	            }
	        }
	    },
	    additionalItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
	        var type = Utils.whatIs(schema.additionalItems);
	        if (type !== "boolean" && type !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["additionalItems", ["boolean", "object"]]);
	        } else if (type === "object") {
	            report.path.push("additionalItems");
	            exports.validateSchema.call(this, report, schema.additionalItems);
	            report.path.pop();
	        }
	    },
	    items: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.1
	        var type = Utils.whatIs(schema.items);

	        if (type === "object") {
	            report.path.push("items");
	            exports.validateSchema.call(this, report, schema.items);
	            report.path.pop();
	        } else if (type === "array") {
	            var idx = schema.items.length;
	            while (idx--) {
	                report.path.push("items");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.items[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        } else {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["items", ["array", "object"]]);
	        }

	        // custom - strict mode
	        if (this.options.forceAdditional === true && schema.additionalItems === undefined && Array.isArray(schema.items)) {
	            report.addError("KEYWORD_UNDEFINED_STRICT", ["additionalItems"]);
	        }
	        // custome - assume defined false mode
	        if (this.options.assumeAdditional && schema.additionalItems === undefined && Array.isArray(schema.items)) {
	            schema.additionalItems = false;
	        }
	    },
	    maxItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.1
	        if (typeof schema.maxItems !== "number") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maxItems", "integer"]);
	        } else if (schema.maxItems < 0) {
	            report.addError("KEYWORD_MUST_BE", ["maxItems", "greater than, or equal to 0"]);
	        }
	    },
	    minItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.1
	        if (Utils.whatIs(schema.minItems) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minItems", "integer"]);
	        } else if (schema.minItems < 0) {
	            report.addError("KEYWORD_MUST_BE", ["minItems", "greater than, or equal to 0"]);
	        }
	    },
	    uniqueItems: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.1
	        if (typeof schema.uniqueItems !== "boolean") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["uniqueItems", "boolean"]);
	        }
	    },
	    maxProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.1
	        if (Utils.whatIs(schema.maxProperties) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["maxProperties", "integer"]);
	        } else if (schema.maxProperties < 0) {
	            report.addError("KEYWORD_MUST_BE", ["maxProperties", "greater than, or equal to 0"]);
	        }
	    },
	    minProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.1
	        if (Utils.whatIs(schema.minProperties) !== "integer") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["minProperties", "integer"]);
	        } else if (schema.minProperties < 0) {
	            report.addError("KEYWORD_MUST_BE", ["minProperties", "greater than, or equal to 0"]);
	        }
	    },
	    required: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.1
	        if (Utils.whatIs(schema.required) !== "array") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["required", "array"]);
	        } else if (schema.required.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["required", "an array with at least one element"]);
	        } else {
	            var idx = schema.required.length;
	            while (idx--) {
	                if (typeof schema.required[idx] !== "string") {
	                    report.addError("KEYWORD_VALUE_TYPE", ["required", "string"]);
	                }
	            }
	            if (Utils.isUniqueArray(schema.required) === false) {
	                report.addError("KEYWORD_MUST_BE", ["required", "an array with unique items"]);
	            }
	        }
	    },
	    additionalProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
	        var type = Utils.whatIs(schema.additionalProperties);
	        if (type !== "boolean" && type !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["additionalProperties", ["boolean", "object"]]);
	        } else if (type === "object") {
	            report.path.push("additionalProperties");
	            exports.validateSchema.call(this, report, schema.additionalProperties);
	            report.path.pop();
	        }
	    },
	    properties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
	        if (Utils.whatIs(schema.properties) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["properties", "object"]);
	            return;
	        }

	        var keys = Object.keys(schema.properties),
	            idx = keys.length;
	        while (idx--) {
	            var key = keys[idx],
	                val = schema.properties[key];
	            report.path.push("properties");
	            report.path.push(key);
	            exports.validateSchema.call(this, report, val);
	            report.path.pop();
	            report.path.pop();
	        }

	        // custom - strict mode
	        if (this.options.forceAdditional === true && schema.additionalProperties === undefined) {
	            report.addError("KEYWORD_UNDEFINED_STRICT", ["additionalProperties"]);
	        }
	        // custome - assume defined false mode
	        if (this.options.assumeAdditional && schema.additionalProperties === undefined) {
	            schema.additionalProperties = false;
	        }
	        // custom - forceProperties
	        if (this.options.forceProperties === true && keys.length === 0) {
	            report.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["properties"]);
	        }
	    },
	    patternProperties: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.1
	        if (Utils.whatIs(schema.patternProperties) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["patternProperties", "object"]);
	            return;
	        }

	        var keys = Object.keys(schema.patternProperties),
	            idx = keys.length;
	        while (idx--) {
	            var key = keys[idx],
	                val = schema.patternProperties[key];
	            try {
	                RegExp(key);
	            } catch (e) {
	                report.addError("KEYWORD_PATTERN", ["patternProperties", key]);
	            }
	            report.path.push("patternProperties");
	            report.path.push(key.toString());
	            exports.validateSchema.call(this, report, val);
	            report.path.pop();
	            report.path.pop();
	        }

	        // custom - forceProperties
	        if (this.options.forceProperties === true && keys.length === 0) {
	            report.addError("CUSTOM_MODE_FORCE_PROPERTIES", ["patternProperties"]);
	        }
	    },
	    dependencies: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.1
	        if (Utils.whatIs(schema.dependencies) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["dependencies", "object"]);
	        } else {
	            var keys = Object.keys(schema.dependencies),
	                idx = keys.length;
	            while (idx--) {
	                var schemaKey = keys[idx],
	                    schemaDependency = schema.dependencies[schemaKey],
	                    type = Utils.whatIs(schemaDependency);

	                if (type === "object") {
	                    report.path.push("dependencies");
	                    report.path.push(schemaKey);
	                    exports.validateSchema.call(this, report, schemaDependency);
	                    report.path.pop();
	                    report.path.pop();
	                } else if (type === "array") {
	                    var idx2 = schemaDependency.length;
	                    if (idx2 === 0) {
	                        report.addError("KEYWORD_MUST_BE", ["dependencies", "not empty array"]);
	                    }
	                    while (idx2--) {
	                        if (typeof schemaDependency[idx2] !== "string") {
	                            report.addError("KEYWORD_VALUE_TYPE", ["dependensices", "string"]);
	                        }
	                    }
	                    if (Utils.isUniqueArray(schemaDependency) === false) {
	                        report.addError("KEYWORD_MUST_BE", ["dependencies", "an array with unique items"]);
	                    }
	                } else {
	                    report.addError("KEYWORD_VALUE_TYPE", ["dependencies", "object or array"]);
	                }
	            }
	        }
	    },
	    enum: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.1
	        if (Array.isArray(schema.enum) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["enum", "array"]);
	        } else if (schema.enum.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["enum", "an array with at least one element"]);
	        } else if (Utils.isUniqueArray(schema.enum) === false) {
	            report.addError("KEYWORD_MUST_BE", ["enum", "an array with unique elements"]);
	        }
	    },
	    type: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.1
	        var primitiveTypes = ["array", "boolean", "integer", "number", "null", "object", "string"],
	            primitiveTypeStr = primitiveTypes.join(","),
	            isArray = Array.isArray(schema.type);

	        if (isArray) {
	            var idx = schema.type.length;
	            while (idx--) {
	                if (primitiveTypes.indexOf(schema.type[idx]) === -1) {
	                    report.addError("KEYWORD_TYPE_EXPECTED", ["type", primitiveTypeStr]);
	                }
	            }
	            if (Utils.isUniqueArray(schema.type) === false) {
	                report.addError("KEYWORD_MUST_BE", ["type", "an object with unique properties"]);
	            }
	        } else if (typeof schema.type === "string") {
	            if (primitiveTypes.indexOf(schema.type) === -1) {
	                report.addError("KEYWORD_TYPE_EXPECTED", ["type", primitiveTypeStr]);
	            }
	        } else {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["type", ["string", "array"]]);
	        }

	        if (this.options.noEmptyStrings === true) {
	            if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
	                if (schema.minLength === undefined &&
	                    schema.enum === undefined &&
	                    schema.format === undefined) {

	                    schema.minLength = 1;
	                }
	            }
	        }
	        if (this.options.noEmptyArrays === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.minItems === undefined) {
	                    schema.minItems = 1;
	                }
	            }
	        }
	        if (this.options.forceProperties === true) {
	            if (schema.type === "object" || isArray && schema.type.indexOf("object") !== -1) {
	                if (schema.properties === undefined && schema.patternProperties === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["properties"]);
	                }
	            }
	        }
	        if (this.options.forceItems === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.items === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["items"]);
	                }
	            }
	        }
	        if (this.options.forceMinItems === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.minItems === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["minItems"]);
	                }
	            }
	        }
	        if (this.options.forceMaxItems === true) {
	            if (schema.type === "array" || isArray && schema.type.indexOf("array") !== -1) {
	                if (schema.maxItems === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["maxItems"]);
	                }
	            }
	        }
	        if (this.options.forceMinLength === true) {
	            if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
	                if (schema.minLength === undefined &&
	                    schema.format === undefined &&
	                    schema.enum === undefined &&
	                    schema.pattern === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["minLength"]);
	                }
	            }
	        }
	        if (this.options.forceMaxLength === true) {
	            if (schema.type === "string" || isArray && schema.type.indexOf("string") !== -1) {
	                if (schema.maxLength === undefined &&
	                    schema.format === undefined &&
	                    schema.enum === undefined &&
	                    schema.pattern === undefined) {
	                    report.addError("KEYWORD_UNDEFINED_STRICT", ["maxLength"]);
	                }
	            }
	        }
	    },
	    allOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.1
	        if (Array.isArray(schema.allOf) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["allOf", "array"]);
	        } else if (schema.allOf.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["allOf", "an array with at least one element"]);
	        } else {
	            var idx = schema.allOf.length;
	            while (idx--) {
	                report.path.push("allOf");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.allOf[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    anyOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.1
	        if (Array.isArray(schema.anyOf) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["anyOf", "array"]);
	        } else if (schema.anyOf.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["anyOf", "an array with at least one element"]);
	        } else {
	            var idx = schema.anyOf.length;
	            while (idx--) {
	                report.path.push("anyOf");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.anyOf[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    oneOf: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.1
	        if (Array.isArray(schema.oneOf) === false) {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["oneOf", "array"]);
	        } else if (schema.oneOf.length === 0) {
	            report.addError("KEYWORD_MUST_BE", ["oneOf", "an array with at least one element"]);
	        } else {
	            var idx = schema.oneOf.length;
	            while (idx--) {
	                report.path.push("oneOf");
	                report.path.push(idx.toString());
	                exports.validateSchema.call(this, report, schema.oneOf[idx]);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    not: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.1
	        if (Utils.whatIs(schema.not) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["not", "object"]);
	        } else {
	            report.path.push("not");
	            exports.validateSchema.call(this, report, schema.not);
	            report.path.pop();
	        }
	    },
	    definitions: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.1
	        if (Utils.whatIs(schema.definitions) !== "object") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["definitions", "object"]);
	        } else {
	            var keys = Object.keys(schema.definitions),
	                idx = keys.length;
	            while (idx--) {
	                var key = keys[idx],
	                    val = schema.definitions[key];
	                report.path.push("definitions");
	                report.path.push(key);
	                exports.validateSchema.call(this, report, val);
	                report.path.pop();
	                report.path.pop();
	            }
	        }
	    },
	    format: function (report, schema) {
	        if (typeof schema.format !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["format", "string"]);
	        } else {
	            if (FormatValidators[schema.format] === undefined && this.options.ignoreUnknownFormats !== true) {
	                report.addError("UNKNOWN_FORMAT", [schema.format]);
	            }
	        }
	    },
	    id: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-core.html#rfc.section.7.2
	        if (typeof schema.id !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["id", "string"]);
	        }
	    },
	    title: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
	        if (typeof schema.title !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["title", "string"]);
	        }
	    },
	    description: function (report, schema) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1
	        if (typeof schema.description !== "string") {
	            report.addError("KEYWORD_TYPE_EXPECTED", ["description", "string"]);
	        }
	    },
	    "default": function (/* report, schema */) {
	        // http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.2
	        // There are no restrictions placed on the value of this keyword.
	    }
	};

	var validateArrayOfSchemas = function (report, arr) {
	    var idx = arr.length;
	    while (idx--) {
	        exports.validateSchema.call(this, report, arr[idx]);
	    }
	    return report.isValid();
	};

	exports.validateSchema = function (report, schema) {

	    report.commonErrorMessage = "SCHEMA_VALIDATION_FAILED";

	    // if schema is an array, assume it's an array of schemas
	    if (Array.isArray(schema)) {
	        return validateArrayOfSchemas.call(this, report, schema);
	    }

	    // do not revalidate schema that has already been validated once
	    if (schema.__$validated) {
	        return true;
	    }

	    // if $schema is present, this schema should validate against that $schema
	    var hasParentSchema = schema.$schema && schema.id !== schema.$schema;
	    if (hasParentSchema) {
	        if (schema.__$schemaResolved && schema.__$schemaResolved !== schema) {
	            var subReport = new Report(report);
	            var valid = JsonValidation.validate.call(this, subReport, schema.__$schemaResolved, schema);
	            if (valid === false) {
	                report.addError("PARENT_SCHEMA_VALIDATION_FAILED", null, subReport);
	            }
	        } else {
	            if (this.options.ignoreUnresolvableReferences !== true) {
	                report.addError("REF_UNRESOLVED", [schema.$schema]);
	            }
	        }
	    }

	    if (this.options.noTypeless === true) {
	        // issue #36 - inherit type to anyOf, oneOf, allOf if noTypeless is defined
	        if (schema.type !== undefined) {
	            var schemas = [];
	            if (Array.isArray(schema.anyOf)) { schemas = schemas.concat(schema.anyOf); }
	            if (Array.isArray(schema.oneOf)) { schemas = schemas.concat(schema.oneOf); }
	            if (Array.isArray(schema.allOf)) { schemas = schemas.concat(schema.allOf); }
	            schemas.forEach(function (sch) {
	                if (!sch.type) { sch.type = schema.type; }
	            });
	        }
	        // end issue #36
	        if (schema.enum === undefined &&
	            schema.type === undefined &&
	            schema.anyOf === undefined &&
	            schema.oneOf === undefined &&
	            schema.not === undefined &&
	            schema.$ref === undefined) {
	            report.addError("KEYWORD_UNDEFINED_STRICT", ["type"]);
	        }
	    }

	    var keys = Object.keys(schema),
	        idx = keys.length;
	    while (idx--) {
	        var key = keys[idx];
	        if (key.indexOf("__") === 0) { continue; }
	        if (SchemaValidators[key] !== undefined) {
	            SchemaValidators[key].call(this, report, schema);
	        } else if (!hasParentSchema) {
	            if (this.options.noExtraKeywords === true) {
	                report.addError("KEYWORD_UNEXPECTED", [key]);
	            }
	        }
	    }

	    if (this.options.pedanticCheck === true) {
	        if (schema.enum) {
	            // break recursion
	            var tmpSchema = Utils.clone(schema);
	            delete tmpSchema.enum;
	            delete tmpSchema.default;

	            report.path.push("enum");
	            idx = schema.enum.length;
	            while (idx--) {
	                report.path.push(idx.toString());
	                JsonValidation.validate.call(this, report, tmpSchema, schema.enum[idx]);
	                report.path.pop();
	            }
	            report.path.pop();
	        }

	        if (schema.default) {
	            report.path.push("default");
	            JsonValidation.validate.call(this, report, schema, schema.default);
	            report.path.pop();
	        }
	    }

	    var isValid = report.isValid();
	    if (isValid) {
	        schema.__$validated = true;
	    }
	    return isValid;
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = {
		"id": "http://json-schema.org/draft-04/schema#",
		"$schema": "http://json-schema.org/draft-04/schema#",
		"description": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": {
					"$ref": "#"
				}
			},
			"positiveInteger": {
				"type": "integer",
				"minimum": 0
			},
			"positiveIntegerDefault0": {
				"allOf": [
					{
						"$ref": "#/definitions/positiveInteger"
					},
					{
						"default": 0
					}
				]
			},
			"simpleTypes": {
				"enum": [
					"array",
					"boolean",
					"integer",
					"null",
					"number",
					"object",
					"string"
				]
			},
			"stringArray": {
				"type": "array",
				"items": {
					"type": "string"
				},
				"minItems": 1,
				"uniqueItems": true
			}
		},
		"type": "object",
		"properties": {
			"id": {
				"type": "string",
				"format": "uri"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"title": {
				"type": "string"
			},
			"description": {
				"type": "string"
			},
			"default": {},
			"multipleOf": {
				"type": "number",
				"minimum": 0,
				"exclusiveMinimum": true
			},
			"maximum": {
				"type": "number"
			},
			"exclusiveMaximum": {
				"type": "boolean",
				"default": false
			},
			"minimum": {
				"type": "number"
			},
			"exclusiveMinimum": {
				"type": "boolean",
				"default": false
			},
			"maxLength": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minLength": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				],
				"default": {}
			},
			"items": {
				"anyOf": [
					{
						"$ref": "#"
					},
					{
						"$ref": "#/definitions/schemaArray"
					}
				],
				"default": {}
			},
			"maxItems": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minItems": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"maxProperties": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minProperties": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"required": {
				"$ref": "#/definitions/stringArray"
			},
			"additionalProperties": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				],
				"default": {}
			},
			"definitions": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": {
					"anyOf": [
						{
							"$ref": "#"
						},
						{
							"$ref": "#/definitions/stringArray"
						}
					]
				}
			},
			"enum": {
				"type": "array",
				"minItems": 1,
				"uniqueItems": true
			},
			"type": {
				"anyOf": [
					{
						"$ref": "#/definitions/simpleTypes"
					},
					{
						"type": "array",
						"items": {
							"$ref": "#/definitions/simpleTypes"
						},
						"minItems": 1,
						"uniqueItems": true
					}
				]
			},
			"format": {
				"type": "string"
			},
			"allOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"anyOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"oneOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"not": {
				"$ref": "#"
			}
		},
		"dependencies": {
			"exclusiveMaximum": [
				"maximum"
			],
			"exclusiveMinimum": [
				"minimum"
			]
		},
		"default": {}
	};

/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = {
		"$schema": "http://json-schema.org/draft-04/hyper-schema#",
		"id": "http://json-schema.org/draft-04/hyper-schema#",
		"title": "JSON Hyper-Schema",
		"allOf": [
			{
				"$ref": "http://json-schema.org/draft-04/schema#"
			}
		],
		"properties": {
			"additionalItems": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				]
			},
			"additionalProperties": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				]
			},
			"dependencies": {
				"additionalProperties": {
					"anyOf": [
						{
							"$ref": "#"
						},
						{
							"type": "array"
						}
					]
				}
			},
			"items": {
				"anyOf": [
					{
						"$ref": "#"
					},
					{
						"$ref": "#/definitions/schemaArray"
					}
				]
			},
			"definitions": {
				"additionalProperties": {
					"$ref": "#"
				}
			},
			"patternProperties": {
				"additionalProperties": {
					"$ref": "#"
				}
			},
			"properties": {
				"additionalProperties": {
					"$ref": "#"
				}
			},
			"allOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"anyOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"oneOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"not": {
				"$ref": "#"
			},
			"links": {
				"type": "array",
				"items": {
					"$ref": "#/definitions/linkDescription"
				}
			},
			"fragmentResolution": {
				"type": "string"
			},
			"media": {
				"type": "object",
				"properties": {
					"type": {
						"description": "A media type, as described in RFC 2046",
						"type": "string"
					},
					"binaryEncoding": {
						"description": "A content encoding scheme, as described in RFC 2045",
						"type": "string"
					}
				}
			},
			"pathStart": {
				"description": "Instances' URIs must start with this value for this schema to apply to them",
				"type": "string",
				"format": "uri"
			}
		},
		"definitions": {
			"schemaArray": {
				"type": "array",
				"items": {
					"$ref": "#"
				}
			},
			"linkDescription": {
				"title": "Link Description Object",
				"type": "object",
				"required": [
					"href",
					"rel"
				],
				"properties": {
					"href": {
						"description": "a URI template, as defined by RFC 6570, with the addition of the $, ( and ) characters for pre-processing",
						"type": "string"
					},
					"rel": {
						"description": "relation to the target resource of the link",
						"type": "string"
					},
					"title": {
						"description": "a title for the link",
						"type": "string"
					},
					"targetSchema": {
						"description": "JSON Schema describing the link target",
						"$ref": "#"
					},
					"mediaType": {
						"description": "media type (as defined by RFC 2046) describing the link target",
						"type": "string"
					},
					"method": {
						"description": "method for requesting the target of the link (e.g. for HTTP this might be \"GET\" or \"DELETE\")",
						"type": "string"
					},
					"encType": {
						"description": "The media type in which to submit data along with the request",
						"type": "string",
						"default": "application/json"
					},
					"schema": {
						"description": "Schema describing the data to submit along with the request",
						"$ref": "#"
					}
				}
			}
		}
	};

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var JsonSchemaCompatability = (function () {

		function convert3to4Type(types, always) {
			if (!Array.isArray(types)) {
				types = [types];
			}
			var needsReplacement = !!always;
			var result = [];
			for (var i = 0; i < types.length; i++) {
				var entry = types[i];
				if (typeof entry === 'object') {
					result.push(entry);
					needsReplacement = true;
				} else {
					result.push({"type": entry});
				}
			}
			return needsReplacement && result;
		}

		function convert3to4(obj) {
			// Old-style "type"
			if (obj.type) {
				if (typeof obj.type !== 'string') {
					var anyOf = convert3to4Type(obj.type);
					if (anyOf) {
						obj.anyOf = anyOf;
						delete obj.type;
					}
				}
				else if (obj.type == 'any') {
					delete obj.type;
				}
			}
			if (obj['extends']) {
				var allOf = obj['extends'];
				if (!Array.isArray(allOf)) {
					allOf = [allOf];
				}
				obj.allOf = allOf;
				delete obj['extends'];
			}
			if (obj.disallow) {
				if (typeof obj.disallow === 'string') {
					obj.not = {"type": obj.disallow};
				} else {
					obj.not = {"anyOf": convert3to4Type(obj.disallow, true)};
				}
				delete obj.disallow;
			}

			// Object concerns
			if (obj.properties) {
				var required = Array.isArray(obj.required) ? obj.required : [];
				for (var key in obj.properties) {
					var subSchema = obj.properties[key];
					if (subSchema && typeof subSchema.required === 'boolean') {
						if (subSchema.required) {
							required.push(key);
						}
						delete subSchema.required;
					}
				}
				if (required.length) {
					obj.required = required;
				}
			}
			if (obj.dependencies) {
				for (var key in obj.dependencies) {
					if (typeof obj.dependencies[key] === 'string') {
						obj.dependencies[key] = [obj.dependencies[key]];
					}
				}
			}
			// This is safe as long as we process our children *after* we collect their "required" properties
			// - otherwise, they'd delete their "required" booleans before we got a chance to see them
			if (typeof obj.required === 'boolean') {
				delete obj.required;
			}
			
			// Numeric concerns
			if (typeof obj.divisibleBy !== 'undefined') {
				obj.multipleOf = obj.divisibleBy;
				delete obj.divisibleBy;
			}
			
			// This MUST happen at the end of the function, otherwise it'll screw up "required" collection
			for (var key in obj) {
				if (key === "properties" || key === "patternProperties" || key === "dependencies") {
					for (var subKey in obj[key]) {
						obj[key][subKey] = convert3to4(obj[key][subKey]);
					}
				} else if (key !== "enum") {
					if (Array.isArray(obj[key])) {
						for (var i = 0; i < obj[key].length; i++) {
							obj[key][i] = convert3to4(obj[key][i]);
						}
					} else if (typeof obj[key] === "object") {
						obj[key] = convert3to4(obj[key]);
					}
				}
			}
			return obj;
		}

		var api = {
			v4: convert3to4
		};
		
		if (true) {
			module.exports = api;
		}
		return api;
	})();

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true*/

	if (false) {
	    var define = require('amdefine')(module);
	}

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	    "use strict";

	    var statusCodes = __webpack_require__(34),
	        statusCodesToPhrases = {},
	        statusPhrasesToCodes = {},
	        methods = __webpack_require__(35),
	        headers = __webpack_require__(36),
	        relations = __webpack_require__(37);

	    statusCodes.forEach(function(item) {
	        var code = parseInt(item.code, 10),
	            phrase;

	        // Ignore codes for classes
	        if (code.toString() !== item.code) {
	            return;
	        }

	        phrase = item.phrase.toUpperCase().replace(/[^A-Z]/g, '_');

	        statusCodesToPhrases[code] = item.phrase;
	        statusPhrasesToCodes[phrase] = item.code;
	    });

	    return {
	        statusCodes: statusCodes,
	        statusCodesToPhrases: statusCodesToPhrases,
	        statusPhrasesToCodes: statusPhrasesToCodes,
	        methods: methods,
	        headers: headers,
	        relations: relations
	    };
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = [
		{
			"code": "1xx",
			"phrase": "**Informational**",
			"description": "\"indicates an interim response for communicating connection status or request progress prior to completing the requested action and sending a final response.\" ~ [sure](http://www.urbandictionary.com/define.php?term=sure)",
			"spec_title": "RFC7231#6.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2"
		},
		{
			"code": "100",
			"phrase": "Continue",
			"description": "\"indicates that the initial part of a request has been received and has not yet been rejected by the server.\"",
			"spec_title": "RFC7231#6.2.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2.1"
		},
		{
			"code": "101",
			"phrase": "Switching Protocols",
			"description": "\"indicates that the server understands and is willing to comply with the client's request, via the Upgrade header field, for a change in the application protocol being used on this connection.\"",
			"spec_title": "RFC7231#6.2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.2.2"
		},
		{
			"code": "2xx",
			"phrase": "**Successful**",
			"description": "\"indicates that the client's request was successfully received, understood, and accepted.\" ~ [cool](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3"
		},
		{
			"code": "200",
			"phrase": "OK",
			"description": "\"indicates that the request has succeeded.\"",
			"spec_title": "RFC7231#6.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.1"
		},
		{
			"code": "201",
			"phrase": "Created",
			"description": "\"indicates that the request has been fulfilled and has resulted in one or more new resources being created.\"",
			"spec_title": "RFC7231#6.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.2"
		},
		{
			"code": "202",
			"phrase": "Accepted",
			"description": "\"indicates that the request has been accepted for processing, but the processing has not been completed.\"",
			"spec_title": "RFC7231#6.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.3"
		},
		{
			"code": "203",
			"phrase": "Non-Authoritative Information",
			"description": "\"indicates that the request was successful but the enclosed payload has been modified from that of the origin server's 200 (OK) response by a transforming proxy.\"",
			"spec_title": "RFC7231#6.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.4"
		},
		{
			"code": "204",
			"phrase": "No Content",
			"description": "\"indicates that the server has successfully fulfilled the request and that there is no additional content to send in the response payload body.\"",
			"spec_title": "RFC7231#6.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.5"
		},
		{
			"code": "205",
			"phrase": "Reset Content",
			"description": "\"indicates that the server has fulfilled the request and desires that the user agent reset the \"document view\", which caused the request to be sent, to its original state as received from the origin server.\"",
			"spec_title": "RFC7231#6.3.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.6"
		},
		{
			"code": "206",
			"phrase": "Partial Content",
			"description": "\"indicates that the server is successfully fulfilling a range request for the target resource by transferring one or more parts of the selected representation that correspond to the satisfiable ranges found in the requests's Range header field.\"",
			"spec_title": "RFC7233#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.1"
		},
		{
			"code": "3xx",
			"phrase": "**Redirection**",
			"description": "\"indicates that further action needs to be taken by the user agent in order to fulfill the request.\" ~ [ask that dude over there](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4"
		},
		{
			"code": "300",
			"phrase": "Multiple Choices",
			"description": "\"indicates that the target resource has more than one representation, each with its own more specific identifier, and information about the alternatives is being provided so that the user (or user agent) can select a preferred representation by redirecting its request to one or more of those identifiers.\"",
			"spec_title": "RFC7231#6.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.1"
		},
		{
			"code": "301",
			"phrase": "Moved Permanently",
			"description": "\"indicates that the target resource has been assigned a new permanent URI and any future references to this resource ought to use one of the enclosed URIs.\"",
			"spec_title": "RFC7231#6.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.2"
		},
		{
			"code": "302",
			"phrase": "Found",
			"description": "\"indicates that the target resource resides temporarily under a different URI.\"",
			"spec_title": "RFC7231#6.4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.3"
		},
		{
			"code": "303",
			"phrase": "See Other",
			"description": "\"indicates that the server is redirecting the user agent to a different resource, as indicated by a URI in the Location header field, that is intended to provide an indirect response to the original request.\"",
			"spec_title": "RFC7231#6.4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.4"
		},
		{
			"code": "304",
			"phrase": "Not Modified",
			"description": "\"indicates that a conditional GET request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition has evaluated to false.\"",
			"spec_title": "RFC7232#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-4.1"
		},
		{
			"code": "305",
			"phrase": "Use Proxy",
			"description": "*deprecated*",
			"spec_title": "RFC7231#6.4.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.5"
		},
		{
			"code": "307",
			"phrase": "Temporary Redirect",
			"description": "\"indicates that the target resource resides temporarily under a different URI and the user agent MUST NOT change the request method if it performs an automatic redirection to that URI.\"",
			"spec_title": "RFC7231#6.4.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.4.7"
		},
		{
			"code": "4xx",
			"phrase": "**Client Error**",
			"description": "\"indicates that the client seems to have erred.\" ~ [*you* fucked up](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5"
		},
		{
			"code": "400",
			"phrase": "Bad Request",
			"description": "\"indicates that the server cannot or will not process the request because the received syntax is invalid, nonsensical, or exceeds some limitation on what the server is willing to process.\"",
			"spec_title": "RFC7231#6.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.1"
		},
		{
			"code": "401",
			"phrase": "Unauthorized",
			"description": "\"indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.\"",
			"spec_title": "RFC7235#6.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-3.1"
		},
		{
			"code": "402",
			"phrase": "Payment Required",
			"description": "*reserved*",
			"spec_title": "RFC7231#6.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.2"
		},
		{
			"code": "403",
			"phrase": "Forbidden",
			"description": "\"indicates that the server understood the request but refuses to authorize it.\"",
			"spec_title": "RFC7231#6.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.3"
		},
		{
			"code": "404",
			"phrase": "Not Found",
			"description": "\"indicates that the origin server did not find a current representation for the target resource or is not willing to disclose that one exists.\"",
			"spec_title": "RFC7231#6.5.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.4"
		},
		{
			"code": "405",
			"phrase": "Method Not Allowed",
			"description": "\"indicates that the method specified in the request-line is known by the origin server but not supported by the target resource.\"",
			"spec_title": "RFC7231#6.5.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.5"
		},
		{
			"code": "406",
			"phrase": "Not Acceptable",
			"description": "\"indicates that the target resource does not have a current representation that would be acceptable to the user agent, according to the proactive negotiation header fields received in the request, and the server is unwilling to supply a default representation.\"",
			"spec_title": "RFC7231#6.5.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.6"
		},
		{
			"code": "407",
			"phrase": "Proxy Authentication Required",
			"description": "\"is similar to 401 (Unauthorized), but indicates that the client needs to authenticate itself in order to use a proxy.\"",
			"spec_title": "RFC7231#6.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.3.2"
		},
		{
			"code": "408",
			"phrase": "Request Timeout",
			"description": "\"indicates that the server did not receive a complete request message within the time that it was prepared to wait.\"",
			"spec_title": "RFC7231#6.5.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.7"
		},
		{
			"code": "409",
			"phrase": "Conflict",
			"description": "\"indicates that the request could not be completed due to a conflict with the current state of the resource.\"",
			"spec_title": "RFC7231#6.5.8",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.8"
		},
		{
			"code": "410",
			"phrase": "Gone",
			"description": "\"indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.\"",
			"spec_title": "RFC7231#6.5.9",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.9"
		},
		{
			"code": "411",
			"phrase": "Length Required",
			"description": "\"indicates that the server refuses to accept the request without a defined Content-Length.\"",
			"spec_title": "RFC7231#6.5.10",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.10"
		},
		{
			"code": "412",
			"phrase": "Precondition Failed",
			"description": "\"indicates that one or more preconditions given in the request header fields evaluated to false when tested on the server.\"",
			"spec_title": "RFC7232#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-4.2"
		},
		{
			"code": "413",
			"phrase": "Payload Too Large",
			"description": "\"indicates that the server is refusing to process a request because the request payload is larger than the server is willing or able to process.\"",
			"spec_title": "RFC7231#6.5.11",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.11"
		},
		{
			"code": "414",
			"phrase": "URI Too Long",
			"description": "\"indicates that the server is refusing to service the request because the request-target is longer than the server is willing to interpret.\"",
			"spec_title": "RFC7231#6.5.12",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.12"
		},
		{
			"code": "415",
			"phrase": "Unsupported Media Type",
			"description": "\"indicates that the origin server is refusing to service the request because the payload is in a format not supported by the target resource for this method.\"",
			"spec_title": "RFC7231#6.5.13",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.13"
		},
		{
			"code": "416",
			"phrase": "Range Not Satisfiable",
			"description": "\"indicates that none of the ranges in the request's Range header field overlap the current extent of the selected resource or that the set of ranges requested has been rejected due to invalid ranges or an excessive request of small or overlapping ranges.\"",
			"spec_title": "RFC7233#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.4"
		},
		{
			"code": "417",
			"phrase": "Expectation Failed",
			"description": "\"indicates that the expectation given in the request's Expect header field could not be met by at least one of the inbound servers.\"",
			"spec_title": "RFC7231#6.5.14",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.14"
		},
		{
			"code": "426",
			"phrase": "Upgrade Required",
			"description": "\"indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.\"",
			"spec_title": "RFC7231#6.5.15",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.5.15"
		},
		{
			"code": "5xx",
			"phrase": "**Server Error**",
			"description": "\"indicates that the server is aware that it has erred or is incapable of performing the requested method.\" ~ [*we* fucked up](https://twitter.com/DanaDanger/status/183316183494311936)",
			"spec_title": "RFC7231#6.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6"
		},
		{
			"code": "500",
			"phrase": "Internal Server Error",
			"description": "\"indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\"",
			"spec_title": "RFC7231#6.6.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.1"
		},
		{
			"code": "501",
			"phrase": "Not Implemented",
			"description": "\"indicates that the server does not support the functionality required to fulfill the request.\"",
			"spec_title": "RFC7231#6.6.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.2"
		},
		{
			"code": "502",
			"phrase": "Bad Gateway",
			"description": "\"indicates that the server, while acting as a gateway or proxy, received an invalid response from an inbound server it accessed while attempting to fulfill the request.\"",
			"spec_title": "RFC7231#6.6.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.3"
		},
		{
			"code": "503",
			"phrase": "Service Unavailable",
			"description": "\"indicates that the server is currently unable to handle the request due to a temporary overload or scheduled maintenance, which will likely be alleviated after some delay.\"",
			"spec_title": "RFC7231#6.6.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.4"
		},
		{
			"code": "504",
			"phrase": "Gateway Time-out",
			"description": "\"indicates that the server, while acting as a gateway or proxy, did not receive a timely response from an upstream server it needed to access in order to complete the request.\"",
			"spec_title": "RFC7231#6.6.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.5"
		},
		{
			"code": "505",
			"phrase": "HTTP Version Not Supported",
			"description": "\"indicates that the server does not support, or refuses to support, the protocol version that was used in the request message.\"",
			"spec_title": "RFC7231#6.6.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-6.6.6"
		},
		{
			"code": "102",
			"phrase": "Processing",
			"description": "\"is an interim response used to inform the client that the server has accepted the complete request, but has not yet completed it.\"",
			"spec_title": "RFC5218#10.1",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.1"
		},
		{
			"code": "207",
			"phrase": "Multi-Status",
			"description": "\"provides status for multiple independent operations.\"",
			"spec_title": "RFC5218#10.2",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.2"
		},
		{
			"code": "226",
			"phrase": "IM Used",
			"description": "\"The server has fulfilled a GET request for the resource, and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\"",
			"spec_title": "RFC3229#10.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.4.1"
		},
		{
			"code": "308",
			"phrase": "Permanent Redirect",
			"description": "\"The target resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. [...] This status code is similar to 301 Moved Permanently (Section 7.3.2 of rfc7231), except that it does not allow rewriting the request method from POST to GET.\"",
			"spec_title": "RFC7238",
			"spec_href": "http://tools.ietf.org/html/rfc7238"
		},
		{
			"code": "422",
			"phrase": "Unprocessable Entity",
			"description": "\"means the server understands the content type of the request entity (hence a 415(Unsupported Media Type) status code is inappropriate), and the syntax of the request entity is correct (thus a 400 (Bad Request) status code is inappropriate) but was unable to process the contained instructions.\"",
			"spec_title": "RFC5218#10.3",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.3"
		},
		{
			"code": "423",
			"phrase": "Locked",
			"description": "\"means the source or destination resource of a method is locked.\"",
			"spec_title": "RFC5218#10.4",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.4"
		},
		{
			"code": "424",
			"phrase": "Failed Dependency",
			"description": "\"means that the method could not be performed on the resource because the requested action depended on another action and that action failed.\"",
			"spec_title": "RFC5218#10.5",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.5"
		},
		{
			"code": "428",
			"phrase": "Precondition Required",
			"description": "\"indicates that the origin server requires the request to be conditional.\"",
			"spec_title": "RFC6585#3",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-3"
		},
		{
			"code": "429",
			"phrase": "Too Many Requests",
			"description": "\"indicates that the user has sent too many requests in a given amount of time (\"rate limiting\").\"",
			"spec_title": "RFC6585#4",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-4"
		},
		{
			"code": "431",
			"phrase": "Request Header Fields Too Large",
			"description": "\"indicates that the server is unwilling to process the request because its header fields are too large.\"",
			"spec_title": "RFC6585#5",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-5"
		},
		{
			"code": "451",
			"phrase": "Unavailable For Legal Reasons",
			"description": "\"This status code indicates that the server is denying access to the resource in response to a legal demand.\"",
			"spec_title": "draft-tbray-http-legally-restricted-status",
			"spec_href": "http://tools.ietf.org/html/draft-tbray-http-legally-restricted-status"
		},
		{
			"code": "506",
			"phrase": "Variant Also Negotiates",
			"description": "\"indicates that the server has an internal configuration error: the chosen variant resource is configured to engage in transparent content negotiation itself, and is therefore not a proper end point in the negotiation process.\"",
			"spec_title": "RFC2295#8.1",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.1"
		},
		{
			"code": "507",
			"phrase": "Insufficient Storage",
			"description": "\"means the method could not be performed on the resource because the server is unable to store the representation needed to successfully complete the request.\"",
			"spec_title": "RFC5218#10.6",
			"spec_href": "http://tools.ietf.org/html/rfc2518#section-10.6"
		},
		{
			"code": "511",
			"phrase": "Network Authentication Required",
			"description": "\"indicates that the client needs to authenticate to gain network access.\"",
			"spec_title": "RFC6585#6",
			"spec_href": "http://tools.ietf.org/html/rfc6585#section-6"
		},
		{
			"code": "7xx",
			"phrase": "**Developer Error**",
			"description": "[err](http://www.urbandictionary.com/define.php?term=err)",
			"spec_title": "7xx-rfc",
			"spec_href": "http://documentup.com/joho/7XX-rfc"
		}
	];

/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = [
		{
			"method": "CONNECT",
			"description": "\"requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the connection is closed.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.6",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.6"
		},
		{
			"method": "DELETE",
			"description": "\"requests that the origin server remove the association between the target resource and its current functionality.\"",
			"safe": false,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.5"
		},
		{
			"method": "GET",
			"description": "\"requests transfer of a current selected representation for the target resource.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": true,
			"spec_title": "RFC7231#4.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.1"
		},
		{
			"method": "HEAD",
			"description": "\"is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header block).\"",
			"safe": true,
			"idempotent": true,
			"cacheable": true,
			"spec_title": "RFC7231#4.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.2"
		},
		{
			"method": "OPTIONS",
			"description": "\"requests information about the communication options available on the request/response chain identified by the effective request URI.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.7",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.7"
		},
		{
			"method": "POST",
			"description": "\"requests that the target resource process the representation enclosed in the request according to the resource's own specific semantics.\"",
			"safe": false,
			"idempotent": false,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.3"
		},
		{
			"method": "PUT",
			"description": "\"requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.\"",
			"safe": false,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.4"
		},
		{
			"method": "TRACE",
			"description": "\"is used to invoke a remote, application-layer loopback of the request message.\"",
			"safe": true,
			"idempotent": true,
			"cacheable": false,
			"spec_title": "RFC7231#4.3.8",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-4.3.8"
		},
		{
			"method": "ACL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3744#8.1",
			"spec_href": "http://tools.ietf.org/html/rfc3744#section-8.1"
		},
		{
			"method": "BASELINE-CONTROL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#12.6",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-12.6"
		},
		{
			"method": "BIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#4",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-4"
		},
		{
			"method": "CHECKIN",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.4"
		},
		{
			"method": "CHECKOUT",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.3"
		},
		{
			"method": "COPY",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.8",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.8"
		},
		{
			"method": "LABEL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#8.2",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-8.2"
		},
		{
			"method": "LINK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC2068#19.6.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc2068#section-19.6.1.2"
		},
		{
			"method": "LOCK",
			"description": "",
			"safe": false,
			"idempotent": false,
			"cacheable": "",
			"spec_title": "RFC4918#9.10",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.10"
		},
		{
			"method": "MERGE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#11.2",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-11.2"
		},
		{
			"method": "MKACTIVITY",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#13.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-13.5"
		},
		{
			"method": "MKCALENDAR",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4791#5.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc4791#section-5.3.1"
		},
		{
			"method": "MKCOL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.3",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.3"
		},
		{
			"method": "MKREDIRECTREF",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4437#6",
			"spec_href": "http://tools.ietf.org/html/rfc4437#section-6"
		},
		{
			"method": "MKWORKSPACE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#6.3",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-6.3"
		},
		{
			"method": "MOVE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.9",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.9"
		},
		{
			"method": "ORDERPATCH",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3648#7",
			"spec_href": "http://tools.ietf.org/html/rfc3648#section-7"
		},
		{
			"method": "PATCH",
			"description": "\"requests that a set of changes described in the request entity be applied to the resource identified by the Request-URI.\"",
			"safe": false,
			"idempotent": false,
			"cacheable": false,
			"spec_title": "RFC5789",
			"spec_href": "http://tools.ietf.org/html/rfc5789#section-2"
		},
		{
			"method": "PROPFIND",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.1",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.1"
		},
		{
			"method": "PROPPATCH",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.2",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.2"
		},
		{
			"method": "REBIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#6",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-6"
		},
		{
			"method": "REPORT",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#3.6",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-3.6"
		},
		{
			"method": "SEARCH",
			"description": "",
			"safe": true,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5323#2",
			"spec_href": "http://tools.ietf.org/html/rfc5323#section-2"
		},
		{
			"method": "UNBIND",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC5842#5",
			"spec_href": "http://tools.ietf.org/html/rfc5842#section-5"
		},
		{
			"method": "UNCHECKOUT",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#4.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-4.5"
		},
		{
			"method": "UNLINK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC2068#19.6.1.3",
			"spec_href": "http://tools.ietf.org/html/rfc2068#section-19.6.1.3"
		},
		{
			"method": "UNLOCK",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4918#9.11",
			"spec_href": "http://tools.ietf.org/html/rfc4918#section-9.11"
		},
		{
			"method": "UPDATE",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#7.1",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-7.1"
		},
		{
			"method": "UPDATEREDIRECTREF",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC4437#7",
			"spec_href": "http://tools.ietf.org/html/rfc4437#section-7"
		},
		{
			"method": "VERSION-CONTROL",
			"description": "",
			"safe": false,
			"idempotent": true,
			"cacheable": "",
			"spec_title": "RFC3253#3.5",
			"spec_href": "http://tools.ietf.org/html/rfc3253#section-3.5"
		}
	];

/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = [
		{
			"header": "Content-Encoding",
			"description": "\"indicates what content codings have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field.\"",
			"spec_title": "RFC7231#3.1.2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.2.2"
		},
		{
			"header": "Content-Language",
			"description": "\"describes the natural language(s) of the intended audience for the representation.\"",
			"spec_title": "RFC7231#3.1.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.3.2"
		},
		{
			"header": "Content-Location",
			"description": "\"references a URI that can be used as an identifier for a specific resource corresponding to the representation in this message's payload.\"",
			"spec_title": "RFC7231#3.1.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.4.2"
		},
		{
			"header": "Content-Type",
			"description": "\"indicates the media type of the associated representation: either the representation enclosed in the message payload or the selected representation, as determined by the message semantics.\"",
			"spec_title": "RFC7231#3.1.1.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-3.1.1.5"
		},
		{
			"header": "Content-Length",
			"description": "\"can provide the anticipated size, as a decimal number of octets, for a potential payload body.\"",
			"spec_title": "RFC7230#3.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-3.3.2"
		},
		{
			"header": "Content-Range",
			"description": "\"is sent in a single part 206 (Partial Content) response to indicate the partial range of the selected representation enclosed as the message payload, sent in each part of a multipart 206 response to indicate the range enclosed within each body part, and sent in 416 (Range Not Satisfiable) responses to provide information about the selected representation.\"",
			"spec_title": "RFC7233#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-4.2"
		},
		{
			"header": "Transfer-Encoding",
			"description": "\"lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body.\"",
			"spec_title": "RFC7230#3.3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-3.3.1"
		},
		{
			"header": "Cache-Control",
			"description": "\"is used to specify directives for caches along the request/response chain.\"",
			"spec_title": "RFC7234#7.2",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.2"
		},
		{
			"header": "Expect",
			"description": "\"is used to indicate that particular server behaviors are required by the client.\"",
			"spec_title": "RFC7231#5.1.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.1.1"
		},
		{
			"header": "Host",
			"description": "\"provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.\"",
			"spec_title": "RFC7230#5.4",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-5.4"
		},
		{
			"header": "Max-Forwards",
			"description": "\"provides a mechanism with the TRACE and OPTIONS methods to limit the number of times that the request is forwarded by proxies.\"",
			"spec_title": "RFC7231#5.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.1.2"
		},
		{
			"header": "Pragma",
			"description": "\"allows backwards compatibility with HTTP/1.0 caches, so that clients can specify a \"no-cache\" request that they will understand (as Cache-Control was not defined until HTTP/1.1).\"",
			"spec_title": "RFC7234#7.4",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.4"
		},
		{
			"header": "Range",
			"description": "\"modifies the method semantics to request transfer of only one or more subranges of the selected representation data, rather than the entire selected representation data.\"",
			"spec_title": "RFC7233#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-3.1"
		},
		{
			"header": "TE",
			"description": "\"indicates what transfer codings, besides chunked, the client is willing to accept in response, and whether or not the client is willing to accept trailer fields in a chunked transfer coding.\"",
			"spec_title": "RFC7230#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-4.3"
		},
		{
			"header": "If-Match",
			"description": "\"can be used to make a request method conditional on the current existence or value of an entity-tag for one or more representations of the target resource.\"",
			"spec_title": "RFC7232#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.1"
		},
		{
			"header": "If-Modified-Since",
			"description": "\"can be used with GET or HEAD to make the method conditional by modification date: if the selected representation has not been modified since the time specified in this field, then do not perform the request method; instead, respond as detailed below.\"",
			"spec_title": "RFC7232#3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.3"
		},
		{
			"header": "If-None-Match",
			"description": "\"can be used to make a request method conditional on not matching any of the current entity-tag values for representations of the target resource.\"",
			"spec_title": "RFC7232#3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.2"
		},
		{
			"header": "If-Range",
			"description": "\"Informally, its meaning is: if the representation is unchanged, send me the part(s) that I am requesting in Range; otherwise, send me the entire representation.\"",
			"spec_title": "RFC7233#3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-3.2"
		},
		{
			"header": "If-Unmodified-Since",
			"description": "\"can be used to make a request method conditional by modification date: if the selected representation has been modified since the time specified in this field, then the server MUST NOT perform the requested operation and MUST instead respond with the 412 (Precondition Failed) status code.\"",
			"spec_title": "RFC7232#3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-3.4"
		},
		{
			"header": "Accept",
			"description": "\"can be used to specify certain media types which are acceptable for the response.\"",
			"spec_title": "RFC7231#5.3.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.2"
		},
		{
			"header": "Accept-Charset",
			"description": "\"can be sent by a user agent to indicate what charsets are acceptable in textual response content.\"",
			"spec_title": "RFC7231#5.3.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.3"
		},
		{
			"header": "Accept-Encoding",
			"description": "\"can be used by user agents to indicate what response content-codings are acceptable in the response.\"",
			"spec_title": "RFC7231#5.3.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.4"
		},
		{
			"header": "Accept-Language",
			"description": "\"can be used by user agents to indicate the set of natural languages that are preferred in the response.\"",
			"spec_title": "RFC7231#5.3.5",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.3.5"
		},
		{
			"header": "Authorization",
			"description": "\"allows a user agent to authenticate itself with a server -- usually, but not necessarily, after receiving a 401 (Unauthorized) response.\"",
			"spec_title": "RFC7235#4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.1"
		},
		{
			"header": "Proxy-Authorization",
			"description": "\"allows the client to identify itself (or its user) to a proxy that requires authentication.\"",
			"spec_title": "RFC7235#4.3",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.3"
		},
		{
			"header": "DNT",
			"description": "\"defined as the means for expressing a user's tracking preference via HTTP.\"",
			"spec_title": "Tracking Preference Expression (DNT)",
			"spec_href": "http://www.w3.org/TR/tracking-dnt/#dnt-header-field"
		},
		{
			"header": "From",
			"description": "\"contains an Internet email address for a human user who controls the requesting user agent.\"",
			"spec_title": "RFC7231#5.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.1"
		},
		{
			"header": "Referer",
			"description": "\"allows the user agent to specify a URI reference for the resource from which the target URI was obtained (i.e., the \"referrer\", though the field name is misspelled).\"",
			"spec_title": "RFC7231#5.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.2"
		},
		{
			"header": "User-Agent",
			"description": "\"contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use.\"",
			"spec_title": "RFC7231#5.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-5.5.3"
		},
		{
			"header": "Age",
			"description": "\"conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server.\"",
			"spec_title": "RFC7234#5.1",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-5.1"
		},
		{
			"header": "Cache-Control",
			"description": "\"is used to specify directives for caches along the request/response chain.\"",
			"spec_title": "RFC7234#7.2",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.2"
		},
		{
			"header": "Expires",
			"description": "\"gives the date/time after which the response is considered stale.\"",
			"spec_title": "RFC7234#7.3",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.3"
		},
		{
			"header": "Date",
			"description": "\"represents the date and time at which the message was originated\"",
			"spec_title": "RFC7231#7.1.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.1.2"
		},
		{
			"header": "Location",
			"description": "\"is used in some responses to refer to a specific resource in relation to the response.\"",
			"spec_title": "RFC7231#7.1.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.2"
		},
		{
			"header": "Retry-After",
			"description": "\"indicates how long the user agent ought to wait before making a follow-up request.\"",
			"spec_title": "RFC7231#7.1.3",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.3"
		},
		{
			"header": "Tk",
			"description": "\"defined as an OPTIONAL means for indicating the tracking status that applied to the corresponding request and as a REQUIRED means for indicating that a state-changing request has resulted in an interactive change to the tracking status. \"",
			"spec_title": "Tracking Preference Expression (DNT)",
			"spec_href": "http://www.w3.org/TR/tracking-dnt/#response-header-field"
		},
		{
			"header": "Vary",
			"description": "\"describes what parts of a request message, aside from the method and request target, might influence the origin server's process for selecting and representing the response.\"",
			"spec_title": "RFC7231#7.1.4",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.1.4"
		},
		{
			"header": "Warning",
			"description": "\"is used to carry additional information about the status or transformation of a message that might not be reflected in the message.\"",
			"spec_title": "RFC7234#7.6",
			"spec_href": "http://tools.ietf.org/html/rfc7234#section-7.6"
		},
		{
			"header": "ETag",
			"description": "\"provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request.\"",
			"spec_title": "RFC7232#2.3",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-2.3"
		},
		{
			"header": "Last-Modified",
			"description": "\"provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.\"",
			"spec_title": "RFC7232#2.2",
			"spec_href": "http://tools.ietf.org/html/rfc7232#section-2.2"
		},
		{
			"header": "WWW-Authenticate",
			"description": "\"consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the effective request URI.\"",
			"spec_title": "RFC7235#4.4",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.4"
		},
		{
			"header": "Proxy-Authenticate",
			"description": "\"consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the proxy for this effective request URI.\"",
			"spec_title": "RFC7235#4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7235#section-4.2"
		},
		{
			"header": "Accept-Ranges",
			"description": "\"allows a server to indicate that it supports range requests for the target resource.\"",
			"spec_title": "RFC7233#2.3",
			"spec_href": "http://tools.ietf.org/html/rfc7233#section-2.3"
		},
		{
			"header": "Allow",
			"description": "\"lists the set of methods advertised as supported by the target resource.\"",
			"spec_title": "RFC7231#7.4.1",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.4.1"
		},
		{
			"header": "Server",
			"description": "\"contains information about the software used by the origin server to handle the request, which is often used by clients to help identify the scope of reported interoperability problems, to work around or tailor requests to avoid particular server limitations, and for analytics regarding server or operating system use.\"",
			"spec_title": "RFC7231#7.4.2",
			"spec_href": "http://tools.ietf.org/html/rfc7231#section-7.4.2"
		},
		{
			"header": "Accept-Patch",
			"description": "\"used to specify the patch document formats accepted by the server.\"",
			"spec_title": "RFC5789#3.1",
			"spec_href": "http://tools.ietf.org/html/rfc5789#section-3.1"
		},
		{
			"header": "Accept-Post",
			"description": "\"indicates server support for specific media types for entity bodies in HTTP POST requests.\"",
			"spec_title": "draft-wilde-accept-post",
			"spec_href": "http://tools.ietf.org/html/draft-wilde-accept-post"
		},
		{
			"header": "Access-Control-Allow-Credentials",
			"description": "\"indicates whether the response to request can be exposed when the omit credentials flag is unset\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-credentials-response-header"
		},
		{
			"header": "Access-Control-Allow-Headers",
			"description": "\"indicates, as part of the response to a preflight request, which header field names can be used during the actual request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-headers-response-header"
		},
		{
			"header": "Access-Control-Allow-Methods",
			"description": "\"indicates, as part of the response to a preflight request, which methods can be used during the actual request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-methods-response-header"
		},
		{
			"header": "Access-Control-Allow-Origin",
			"description": "\"indicates whether a resource can be shared\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-allow-origin-response-header"
		},
		{
			"header": "Access-Control-Expose-Headers",
			"description": "\"indicates which headers are safe to expose to the API of a CORS API specification\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-expose-headers-response-header"
		},
		{
			"header": "Access-Control-Max-Age",
			"description": "\"indicates how long the results of a preflight request can be cached in a preflight result cache\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-max-age-response-header"
		},
		{
			"header": "Access-Control-Request-Headers",
			"description": "\"indicates which headers will be used in the actual request as part of the preflight request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-request-headers-request-header"
		},
		{
			"header": "Access-Control-Request-Method",
			"description": "\"indicates which method will be used in the actual request as part of the preflight request\"",
			"spec_title": "CORS",
			"spec_href": "http://www.w3.org/TR/cors/#access-control-request-method-request-header"
		},
		{
			"header": "Content-Disposition",
			"description": "\"standard\"",
			"spec_title": "RFC6266",
			"spec_href": "http://tools.ietf.org/html/rfc6266"
		},
		{
			"header": "Content-Security-Policy",
			"description": "\"is the preferred mechanism for delivering a CSP policy\"",
			"spec_title": "CSP",
			"spec_href": "http://www.w3.org/TR/CSP/#content-security-policy-header-field"
		},
		{
			"header": "Content-Security-Policy-Report-Only",
			"description": "\"lets servers experiment with policies by monitoring (rather than enforcing) a policy\"",
			"spec_title": "CSP",
			"spec_href": "http://www.w3.org/TR/CSP/#content-security-policy-report-only-header-field"
		},
		{
			"header": "Cookie",
			"description": "\"standard\"",
			"spec_title": "RFC6265",
			"spec_href": "http://tools.ietf.org/html/rfc6265"
		},
		{
			"header": "Forwarded",
			"description": "\"standard\"",
			"spec_title": "RFC7239",
			"spec_href": "http://tools.ietf.org/html/rfc7239"
		},
		{
			"header": "Link",
			"description": "\"provides a means for serialising one or more links in HTTP headers.\"",
			"spec_title": "RFC5988#5",
			"spec_href": "http://tools.ietf.org/html/rfc5988#section-5"
		},
		{
			"header": "Origin",
			"description": "\"standard\"",
			"spec_title": "RFC6454",
			"spec_href": "http://tools.ietf.org/html/rfc6454"
		},
		{
			"header": "Prefer",
			"description": "\"is used to indicate that particular server behaviors are preferred by the client, but not required for successful completion of the request.\"",
			"spec_title": "draft-snell-http-prefer#2",
			"spec_href": "http://tools.ietf.org/html/draft-snell-http-prefer#section-2"
		},
		{
			"header": "Preference-Applied",
			"description": "\"MAY be included within a response message as an indication as to which Prefer tokens were honored by the server and applied to the processing of a request.\"",
			"spec_title": "draft-snell-http-prefer#3",
			"spec_href": "http://tools.ietf.org/html/draft-snell-http-prefer#section-3"
		},
		{
			"header": "Set-Cookie",
			"description": "\"standard\"",
			"spec_title": "RFC6265",
			"spec_href": "http://tools.ietf.org/html/rfc6265"
		},
		{
			"header": "Strict-Transport-Security",
			"description": "\"standard\"",
			"spec_title": "RFC6797",
			"spec_href": "http://tools.ietf.org/html/rfc6797"
		},
		{
			"header": "Via",
			"description": "\"\"",
			"spec_title": "RFC7230#5.7.1",
			"spec_href": "http://tools.ietf.org/html/rfc7230#section-5.7.1"
		},
		{
			"header": "A-IM",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.3",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.3"
		},
		{
			"header": "Accept-Features",
			"description": "\"can be used by a user agent to give information about the presence or absence of certain features in the feature set of the current request.\"",
			"spec_title": "RFC2295#8.2",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.2"
		},
		{
			"header": "Alt-Svc",
			"description": "\"is advertising the availability of alternate services to HTTP/1.1 and HTTP/2.0 clients by adding an Alt-Svc header field to responses.\"",
			"spec_title": "draft-nottingham-httpbis-alt-svc",
			"spec_href": "http://tools.ietf.org/html/draft-nottingham-httpbis-alt-svc"
		},
		{
			"header": "Alternates",
			"description": "\"is used to convey the list of variants bound to a negotiable resource.\"",
			"spec_title": "RFC2295#8.3",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.3"
		},
		{
			"header": "Apply-To-Redirect-Ref",
			"description": "\"\"",
			"spec_title": "RFC4437",
			"spec_href": "http://tools.ietf.org/html/rfc4437"
		},
		{
			"header": "CH",
			"description": "\"describes an example list of client preferences that the server can use to adapt and optimize the resource to satisfy a given request.\"",
			"spec_title": "draft-grigorik-http-client-hints",
			"spec_href": "http://tools.ietf.org/html/draft-grigorik-http-client-hints"
		},
		{
			"header": "Content-Base",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2068",
			"spec_href": "http://tools.ietf.org/html/rfc2068"
		},
		{
			"header": "Cookie2",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2965",
			"spec_href": "http://tools.ietf.org/html/rfc2965"
		},
		{
			"header": "DASL",
			"description": "\"standard\"",
			"spec_title": "RFC5323",
			"spec_href": "http://tools.ietf.org/html/rfc5323"
		},
		{
			"header": "DAV",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Delta-Base",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.1",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.1"
		},
		{
			"header": "Depth",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Destination",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "IM",
			"description": "\"\"",
			"spec_title": "RFC3229#10.5.2",
			"spec_href": "http://tools.ietf.org/html/rfc3229#section-10.5.2"
		},
		{
			"header": "If",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "If-Schedule-Tag-Match",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Last-Event-ID",
			"description": "\"The value of the event source's last event ID string, encoded as UTF-8.\"",
			"spec_title": "Server-Sent Events",
			"spec_href": "http://www.w3.org/TR/eventsource/#last-event-id"
		},
		{
			"header": "Link-Template",
			"description": "\"provides a means for serialising one or more links into HTTP headers.\"",
			"spec_title": "draft-nottingham-link-template",
			"spec_href": "http://tools.ietf.org/html/draft-nottingham-link-template"
		},
		{
			"header": "Lock-Token",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Negotiate",
			"description": "\"can contain directives for any content negotiation process initiated by the request.\"",
			"spec_title": "RFC2295#8.4",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.4"
		},
		{
			"header": "Nice",
			"description": "\"indicates that a request is less important than a request that doesn't bear this header.\"",
			"spec_title": "draft-thomson-http-nice",
			"spec_href": "http://tools.ietf.org/html/draft-thomson-http-nice"
		},
		{
			"header": "Overwrite",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Redirect-Ref",
			"description": "\"\"",
			"spec_title": "RFC4437",
			"spec_href": "http://tools.ietf.org/html/rfc4437"
		},
		{
			"header": "Schedule-Reply",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Schedule-Tag",
			"description": "\"standard\"",
			"spec_title": "RFC6638",
			"spec_href": "http://tools.ietf.org/html/rfc6638"
		},
		{
			"header": "Sec-WebSocket-Accept",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Extensions",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Key",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Protocol",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Sec-WebSocket-Version",
			"description": "\"standard\"",
			"spec_title": "RFC6455",
			"spec_href": "http://tools.ietf.org/html/rfc6455"
		},
		{
			"header": "Set-Cookie2",
			"description": "\"obsoleted\"",
			"spec_title": "RFC2965",
			"spec_href": "http://tools.ietf.org/html/rfc2965"
		},
		{
			"header": "SLUG",
			"description": "\"standard\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"header": "TCN",
			"description": "\"is used by a server to signal that the resource is transparently negotiated.\"",
			"spec_title": "RFC2295#8.5",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.5"
		},
		{
			"header": "Timeout",
			"description": "\"standard\"",
			"spec_title": "RFC4918",
			"spec_href": "http://tools.ietf.org/html/rfc4918"
		},
		{
			"header": "Variant-Vary",
			"description": "\"can be used in a choice response to record any vary information which applies to the variant data (the entity body combined with some of the entity headers) contained in the response, rather than to the response as a whole.\"",
			"spec_title": "RFC2295#8.6",
			"spec_href": "http://tools.ietf.org/html/rfc2295#section-8.6"
		},
		{
			"header": "X-Frame-Options",
			"description": "\"indicates a policy that specifies whether the browser should render the transmitted resource within a <frame> or an <iframe>. Servers can declare this policy in the header of their HTTP responses to prevent clickjacking attacks, which ensures that their content is not embedded into other pages or frames.\"",
			"spec_title": "RFC7034",
			"spec_href": "http://tools.ietf.org/html/rfc7034"
		}
	];

/***/ },
/* 37 */
/***/ function(module, exports) {

	module.exports = [
		{
			"relation": "about",
			"description": "\"Refers to a resource that is the subject of the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "alternate",
			"description": "\"Refers to a substitute for this context\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-alternate"
		},
		{
			"relation": "appendix",
			"description": "\"Refers to an appendix.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "archives",
			"description": "\"Refers to a collection of records, documents, or other materials of historical interest.\"",
			"spec_title": "HTML5linksWD",
			"spec_href": "http://www.w3.org/TR/2011/WD-html5-20110113/links.html#rel-archives"
		},
		{
			"relation": "author",
			"description": "\"Refers to the context's author.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-author"
		},
		{
			"relation": "bookmark",
			"description": "\"Gives a permanent link to use for bookmarking purposes.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-bookmark"
		},
		{
			"relation": "canonical",
			"description": "\"Designates the preferred version of a resource (the IRI and its contents).\"",
			"spec_title": "RFC6596",
			"spec_href": "http://tools.ietf.org/html/rfc6596"
		},
		{
			"relation": "chapter",
			"description": "\"Refers to a chapter in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "collection",
			"description": "\"The target IRI points to a resource which represents the collection resource for the context IRI.\"",
			"spec_title": "RFC6573",
			"spec_href": "http://tools.ietf.org/html/rfc6573"
		},
		{
			"relation": "contents",
			"description": "\"Refers to a table of contents.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "copyright",
			"description": "\"Refers to a copyright statement that applies to the link's context.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "create-form",
			"description": "\"The target IRI points to a resource where a submission form can be obtained.\"",
			"spec_title": "RFC6861",
			"spec_href": "http://tools.ietf.org/html/rfc6861"
		},
		{
			"relation": "current",
			"description": "\"Refers to a resource containing the most recent item(s) in a collection of resources.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "describedby",
			"description": "\"Refers to a resource providing information about the link's context.\"",
			"spec_title": "POWDER",
			"spec_href": "http://www.w3.org/TR/powder-dr/#assoc-linking"
		},
		{
			"relation": "describes",
			"description": "\"The relationship A 'describes' B asserts that resource A provides a description of resource B. There are no constraints on the format or representation of either A or B, neither are there any further constraints on either resource.\"",
			"spec_title": "RFC6892",
			"spec_href": "http://tools.ietf.org/html/rfc6892"
		},
		{
			"relation": "disclosure",
			"description": "\"Refers to a list of patent disclosures made with respect to material for which `disclosure` relation is specified.\"",
			"spec_title": "RFC6579",
			"spec_href": "http://tools.ietf.org/html/rfc6579"
		},
		{
			"relation": "duplicate",
			"description": "\"Refers to a resource whose available representations are byte-for-byte identical with the corresponding representations of the context IRI.\"",
			"spec_title": "RFC6249",
			"spec_href": "http://tools.ietf.org/html/rfc6249"
		},
		{
			"relation": "edit",
			"description": "\"Refers to a resource that can be used to edit the link's context.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "edit-form",
			"description": "\"The target IRI points to a resource where a submission form for editing associated resource can be obtained.\"",
			"spec_title": "RFC6861",
			"spec_href": "http://tools.ietf.org/html/rfc6861"
		},
		{
			"relation": "edit-media",
			"description": "\"Refers to a resource that can be used to edit media associated with the link's context.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "enclosure",
			"description": "\"Identifies a related resource that is potentially large and might require special handling.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "first",
			"description": "\"An IRI that refers to the furthest preceding resource in a series of resources.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "glossary",
			"description": "\"Refers to a glossary of terms.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "help",
			"description": "\"Refers to context-sensitive help.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-help"
		},
		{
			"relation": "hosts",
			"description": "\"Refers to a resource hosted by the server indicated by the link context.\"",
			"spec_title": "RFC6690",
			"spec_href": "http://tools.ietf.org/html/rfc6690"
		},
		{
			"relation": "hub",
			"description": "\"Refers to a hub that enables registration for notification of updates to the context.\"",
			"spec_title": "pubsubhubbub",
			"spec_href": "http://pubsubhubbub.googlecode.com"
		},
		{
			"relation": "icon",
			"description": "\"Refers to an icon representing the link's context.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-icon"
		},
		{
			"relation": "index",
			"description": "\"Refers to an index.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "item",
			"description": "\"The target IRI points to a resource that is a member of the collection represented by the context IRI.\"",
			"spec_title": "RFC6573",
			"spec_href": "http://tools.ietf.org/html/rfc6573"
		},
		{
			"relation": "last",
			"description": "\"An IRI that refers to the furthest following resource in a series of resources.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "latest-version",
			"description": "\"Points to a resource containing the latest (e.g., current) version of the context.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "license",
			"description": "\"Refers to a license associated with this context.\"",
			"spec_title": "RFC4946",
			"spec_href": "http://tools.ietf.org/html/rfc4946"
		},
		{
			"relation": "lrdd",
			"description": "\"Refers to further information about the link's context, expressed as a LRDD (Link-based Resource Descriptor Document) resource. See [RFC6415](http://tools.ietf.org/html/rfc6415) for information about processing this relation type in host-meta documents. When used elsewhere, it refers to additional links and other metadata. Multiple instances indicate additional LRDD resources. LRDD resources MUST have an \"application/xrd+xml\" representation, and MAY have others.\"",
			"spec_title": "RFC6415",
			"spec_href": "http://tools.ietf.org/html/rfc6415"
		},
		{
			"relation": "monitor",
			"description": "\"Refers to a resource that can be used to monitor changes in an HTTP resource.\"",
			"spec_title": "RFC5989",
			"spec_href": "http://tools.ietf.org/html/rfc5989"
		},
		{
			"relation": "monitor-group",
			"description": "\"Refers to a resource that can be used to monitor changes in a specified group of HTTP resources.\"",
			"spec_title": "RFC5989",
			"spec_href": "http://tools.ietf.org/html/rfc5989"
		},
		{
			"relation": "next",
			"description": "\"Indicates that the link's context is a part of a series, and that the next in the series is the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-next"
		},
		{
			"relation": "next-archive",
			"description": "\"Refers to the immediately following archive resource.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "nofollow",
			"description": "\"Indicates that the context’s original author or publisher does not endorse the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-nofollow"
		},
		{
			"relation": "noreferrer",
			"description": "\"Indicates that no referrer information is to be leaked when following the link.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-noreferrer"
		},
		{
			"relation": "payment",
			"description": "\"Indicates a resource where payment is accepted.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "predecessor-version",
			"description": "\"Points to a resource containing the predecessor version in the version history.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "prefetch",
			"description": "\"Indicates that the link target should be preemptively cached.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-prefetch"
		},
		{
			"relation": "prev",
			"description": "\"Indicates that the link's context is a part of a series, and that the previous in the series is the link target.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-prev"
		},
		{
			"relation": "preview",
			"description": "\"Refers to a resource that provides a preview of the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "previous",
			"description": "\"Refers to the previous resource in an ordered series of resources. Synonym for `prev`.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "prev-archive",
			"description": "\"Refers to the immediately preceding archive resource.\"",
			"spec_title": "RFC5005",
			"spec_href": "http://tools.ietf.org/html/rfc5005"
		},
		{
			"relation": "privacy-policy",
			"description": "\"Refers to a privacy policy associated with the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "profile",
			"description": "Identifying that a resource representation conforms to a certain profile, without affecting the non-profile semantics of the resource representation",
			"spec_title": "RFC6906",
			"spec_href": "http://tools.ietf.org/html/rfc6906"
		},
		{
			"relation": "related",
			"description": "\"Identifies a related resource.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "replies",
			"description": "\"Identifies a resource that is a reply to the context of the link.\"",
			"spec_title": "RFC4685",
			"spec_href": "http://tools.ietf.org/html/rfc4685"
		},
		{
			"relation": "search",
			"description": "\"Refers to a resource that can be used to search through the link's context and related resources.\"",
			"spec_title": "OpenSearch",
			"spec_href": "http://www.opensearch.org/Specifications/OpenSearch/1.1"
		},
		{
			"relation": "section",
			"description": "\"Refers to a section in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "self",
			"description": "\"Conveys an identifier for the link's context.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "service",
			"description": "\"Indicates a URI that can be used to retrieve a service document.\"",
			"spec_title": "RFC5023",
			"spec_href": "http://tools.ietf.org/html/rfc5023"
		},
		{
			"relation": "start",
			"description": "\"Refers to the first resource in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "stylesheet",
			"description": "\"Refers to a stylesheet.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-stylesheet"
		},
		{
			"relation": "subsection",
			"description": "\"Refers to a resource serving as a subsection in a collection of resources.\"",
			"spec_title": "HTML401",
			"spec_href": "http://www.w3.org/TR/1999/REC-html401-19991224"
		},
		{
			"relation": "successor-version",
			"description": "\"Points to a resource containing the successor version in the version history.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "tag",
			"description": "\"Gives a tag (identified by the given address) that applies to the current document.\"",
			"spec_title": "HTML5links",
			"spec_href": "http://www.w3.org/TR/html5/links.html#link-type-tag"
		},
		{
			"relation": "terms-of-service",
			"description": "\"Refers to the terms of service associated with the link's context.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "type",
			"description": "\"Refers to a resource identifying the abstract semantic type of which the link's context is considered to be an instance.\"",
			"spec_title": "RFC6903",
			"spec_href": "http://tools.ietf.org/html/rfc6903"
		},
		{
			"relation": "up",
			"description": "\"Refers to a parent document in a hierarchy of documents.\"",
			"spec_title": "RFC5988",
			"spec_href": "http://tools.ietf.org/html/rfc5988"
		},
		{
			"relation": "version-history",
			"description": "\"Points to a resource containing the version history for the context.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "via",
			"description": "\"Identifies a resource that is the source of the information in the link's context.\"",
			"spec_title": "RFC4287",
			"spec_href": "http://tools.ietf.org/html/rfc4287"
		},
		{
			"relation": "working-copy",
			"description": "\"Points to a working copy for this resource.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		},
		{
			"relation": "working-copy-of",
			"description": "\"Points to the versioned resource from which this working copy was obtained.\"",
			"spec_title": "RFC5829",
			"spec_href": "http://tools.ietf.org/html/rfc5829"
		}
	];

/***/ },
/* 38 */
/***/ function(module, exports) {

	/*!
	 * media-typer
	 * Copyright(c) 2014 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * RegExp to match *( ";" parameter ) in RFC 2616 sec 3.7
	 *
	 * parameter     = token "=" ( token | quoted-string )
	 * token         = 1*<any CHAR except CTLs or separators>
	 * separators    = "(" | ")" | "<" | ">" | "@"
	 *               | "," | ";" | ":" | "\" | <">
	 *               | "/" | "[" | "]" | "?" | "="
	 *               | "{" | "}" | SP | HT
	 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
	 * qdtext        = <any TEXT except <">>
	 * quoted-pair   = "\" CHAR
	 * CHAR          = <any US-ASCII character (octets 0 - 127)>
	 * TEXT          = <any OCTET except CTLs, but including LWS>
	 * LWS           = [CRLF] 1*( SP | HT )
	 * CRLF          = CR LF
	 * CR            = <US-ASCII CR, carriage return (13)>
	 * LF            = <US-ASCII LF, linefeed (10)>
	 * SP            = <US-ASCII SP, space (32)>
	 * SHT           = <US-ASCII HT, horizontal-tab (9)>
	 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
	 * OCTET         = <any 8-bit sequence of data>
	 */
	var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
	var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/
	var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/

	/**
	 * RegExp to match quoted-pair in RFC 2616
	 *
	 * quoted-pair = "\" CHAR
	 * CHAR        = <any US-ASCII character (octets 0 - 127)>
	 */
	var qescRegExp = /\\([\u0000-\u007f])/g;

	/**
	 * RegExp to match chars that must be quoted-pair in RFC 2616
	 */
	var quoteRegExp = /([\\"])/g;

	/**
	 * RegExp to match type in RFC 6838
	 *
	 * type-name = restricted-name
	 * subtype-name = restricted-name
	 * restricted-name = restricted-name-first *126restricted-name-chars
	 * restricted-name-first  = ALPHA / DIGIT
	 * restricted-name-chars  = ALPHA / DIGIT / "!" / "#" /
	 *                          "$" / "&" / "-" / "^" / "_"
	 * restricted-name-chars =/ "." ; Characters before first dot always
	 *                              ; specify a facet name
	 * restricted-name-chars =/ "+" ; Characters after last plus always
	 *                              ; specify a structured syntax suffix
	 * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z
	 * DIGIT =  %x30-39             ; 0-9
	 */
	var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/
	var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/
	var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;

	/**
	 * Module exports.
	 */

	exports.format = format
	exports.parse = parse

	/**
	 * Format object to media type.
	 *
	 * @param {object} obj
	 * @return {string}
	 * @api public
	 */

	function format(obj) {
	  if (!obj || typeof obj !== 'object') {
	    throw new TypeError('argument obj is required')
	  }

	  var parameters = obj.parameters
	  var subtype = obj.subtype
	  var suffix = obj.suffix
	  var type = obj.type

	  if (!type || !typeNameRegExp.test(type)) {
	    throw new TypeError('invalid type')
	  }

	  if (!subtype || !subtypeNameRegExp.test(subtype)) {
	    throw new TypeError('invalid subtype')
	  }

	  // format as type/subtype
	  var string = type + '/' + subtype

	  // append +suffix
	  if (suffix) {
	    if (!typeNameRegExp.test(suffix)) {
	      throw new TypeError('invalid suffix')
	    }

	    string += '+' + suffix
	  }

	  // append parameters
	  if (parameters && typeof parameters === 'object') {
	    var param
	    var params = Object.keys(parameters).sort()

	    for (var i = 0; i < params.length; i++) {
	      param = params[i]

	      if (!tokenRegExp.test(param)) {
	        throw new TypeError('invalid parameter name')
	      }

	      string += '; ' + param + '=' + qstring(parameters[param])
	    }
	  }

	  return string
	}

	/**
	 * Parse media type to object.
	 *
	 * @param {string|object} string
	 * @return {Object}
	 * @api public
	 */

	function parse(string) {
	  if (!string) {
	    throw new TypeError('argument string is required')
	  }

	  // support req/res-like objects as argument
	  if (typeof string === 'object') {
	    string = getcontenttype(string)
	  }

	  if (typeof string !== 'string') {
	    throw new TypeError('argument string is required to be a string')
	  }

	  var index = string.indexOf(';')
	  var type = index !== -1
	    ? string.substr(0, index)
	    : string

	  var key
	  var match
	  var obj = splitType(type)
	  var params = {}
	  var value

	  paramRegExp.lastIndex = index

	  while (match = paramRegExp.exec(string)) {
	    if (match.index !== index) {
	      throw new TypeError('invalid parameter format')
	    }

	    index += match[0].length
	    key = match[1].toLowerCase()
	    value = match[2]

	    if (value[0] === '"') {
	      // remove quotes and escapes
	      value = value
	        .substr(1, value.length - 2)
	        .replace(qescRegExp, '$1')
	    }

	    params[key] = value
	  }

	  if (index !== -1 && index !== string.length) {
	    throw new TypeError('invalid parameter format')
	  }

	  obj.parameters = params

	  return obj
	}

	/**
	 * Get content-type from req/res objects.
	 *
	 * @param {object}
	 * @return {Object}
	 * @api private
	 */

	function getcontenttype(obj) {
	  if (typeof obj.getHeader === 'function') {
	    // res-like
	    return obj.getHeader('content-type')
	  }

	  if (typeof obj.headers === 'object') {
	    // req-like
	    return obj.headers && obj.headers['content-type']
	  }
	}

	/**
	 * Quote a string if necessary.
	 *
	 * @param {string} val
	 * @return {string}
	 * @api private
	 */

	function qstring(val) {
	  var str = String(val)

	  // no need to quote tokens
	  if (tokenRegExp.test(str)) {
	    return str
	  }

	  if (str.length > 0 && !textRegExp.test(str)) {
	    throw new TypeError('invalid parameter value')
	  }

	  return '"' + str.replace(quoteRegExp, '\\$1') + '"'
	}

	/**
	 * Simply "type/subtype+siffx" into parts.
	 *
	 * @param {string} string
	 * @return {Object}
	 * @api private
	 */

	function splitType(string) {
	  var match = typeRegExp.exec(string.toLowerCase())

	  if (!match) {
	    throw new TypeError('invalid media type')
	  }

	  var type = match[1]
	  var subtype = match[2]
	  var suffix

	  // suffix after last +
	  var index = subtype.lastIndexOf('+')
	  if (index !== -1) {
	    suffix = subtype.substr(index + 1)
	    subtype = subtype.substr(0, index)
	  }

	  var obj = {
	    type: type,
	    subtype: subtype,
	    suffix: suffix
	  }

	  return obj
	}


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* global define */

	(function (root, pluralize) {
	  /* istanbul ignore else */
	  if (true) {
	    // Node.
	    module.exports = pluralize();
	  } else if (typeof define === 'function' && define.amd) {
	    // AMD, registers as an anonymous module.
	    define(function () {
	      return pluralize();
	    });
	  } else {
	    // Browser global.
	    root.pluralize = pluralize();
	  }
	})(this, function () {
	  // Rule storage - pluralize and singularize need to be run sequentially,
	  // while other rules can be optimized using an object for instant lookups.
	  var pluralRules = [];
	  var singularRules = [];
	  var uncountables = {};
	  var irregularPlurals = {};
	  var irregularSingles = {};

	  /**
	   * Title case a string.
	   *
	   * @param  {string} str
	   * @return {string}
	   */
	  function toTitleCase (str) {
	    return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
	  }

	  /**
	   * Sanitize a pluralization rule to a usable regular expression.
	   *
	   * @param  {(RegExp|string)} rule
	   * @return {RegExp}
	   */
	  function sanitizeRule (rule) {
	    if (typeof rule === 'string') {
	      return new RegExp('^' + rule + '$', 'i');
	    }

	    return rule;
	  }

	  /**
	   * Pass in a word token to produce a function that can replicate the case on
	   * another word.
	   *
	   * @param  {string}   word
	   * @param  {string}   token
	   * @return {Function}
	   */
	  function restoreCase (word, token) {
	    // Upper cased words. E.g. "HELLO".
	    if (word === word.toUpperCase()) {
	      return token.toUpperCase();
	    }

	    // Title cased words. E.g. "Title".
	    if (word[0] === word[0].toUpperCase()) {
	      return toTitleCase(token);
	    }

	    // Lower cased words. E.g. "test".
	    return token.toLowerCase();
	  }

	  /**
	   * Interpolate a regexp string.
	   *
	   * @param  {string} str
	   * @param  {Array}  args
	   * @return {string}
	   */
	  function interpolate (str, args) {
	    return str.replace(/\$(\d{1,2})/g, function (match, index) {
	      return args[index] || '';
	    });
	  }

	  /**
	   * Sanitize a word by passing in the word and sanitization rules.
	   *
	   * @param  {String}   token
	   * @param  {String}   word
	   * @param  {Array}    collection
	   * @return {String}
	   */
	  function sanitizeWord (token, word, collection) {
	    // Empty string or doesn't need fixing.
	    if (!token.length || uncountables.hasOwnProperty(token)) {
	      return word;
	    }

	    var len = collection.length;

	    // Iterate over the sanitization rules and use the first one to match.
	    while (len--) {
	      var rule = collection[len];

	      // If the rule passes, return the replacement.
	      if (rule[0].test(word)) {
	        return word.replace(rule[0], function (match, index, word) {
	          var result = interpolate(rule[1], arguments);

	          if (match === '') {
	            return restoreCase(word[index - 1], result);
	          }

	          return restoreCase(match, result);
	        });
	      }
	    }

	    return word;
	  }

	  /**
	   * Replace a word with the updated word.
	   *
	   * @param  {Object}   replaceMap
	   * @param  {Object}   keepMap
	   * @param  {Array}    rules
	   * @return {Function}
	   */
	  function replaceWord (replaceMap, keepMap, rules) {
	    return function (word) {
	      // Get the correct token and case restoration functions.
	      var token = word.toLowerCase();

	      // Check against the keep object map.
	      if (keepMap.hasOwnProperty(token)) {
	        return restoreCase(word, token);
	      }

	      // Check against the replacement map for a direct word replacement.
	      if (replaceMap.hasOwnProperty(token)) {
	        return restoreCase(word, replaceMap[token]);
	      }

	      // Run all the rules against the word.
	      return sanitizeWord(token, word, rules);
	    };
	  }

	  /**
	   * Pluralize or singularize a word based on the passed in count.
	   *
	   * @param  {String}  word
	   * @param  {Number}  count
	   * @param  {Boolean} inclusive
	   * @return {String}
	   */
	  function pluralize (word, count, inclusive) {
	    var pluralized = count === 1
	      ? pluralize.singular(word) : pluralize.plural(word);

	    return (inclusive ? count + ' ' : '') + pluralized;
	  }

	  /**
	   * Pluralize a word.
	   *
	   * @type {Function}
	   */
	  pluralize.plural = replaceWord(
	    irregularSingles, irregularPlurals, pluralRules
	  );

	  /**
	   * Singularize a word.
	   *
	   * @type {Function}
	   */
	  pluralize.singular = replaceWord(
	    irregularPlurals, irregularSingles, singularRules
	  );

	  /**
	   * Add a pluralization rule to the collection.
	   *
	   * @param {(string|RegExp)} rule
	   * @param {string}          replacement
	   */
	  pluralize.addPluralRule = function (rule, replacement) {
	    pluralRules.push([sanitizeRule(rule), replacement]);
	  };

	  /**
	   * Add a singularization rule to the collection.
	   *
	   * @param {(string|RegExp)} rule
	   * @param {string}          replacement
	   */
	  pluralize.addSingularRule = function (rule, replacement) {
	    singularRules.push([sanitizeRule(rule), replacement]);
	  };

	  /**
	   * Add an uncountable word rule.
	   *
	   * @param {(string|RegExp)} word
	   */
	  pluralize.addUncountableRule = function (word) {
	    if (typeof word === 'string') {
	      uncountables[word.toLowerCase()] = true;
	      return;
	    }

	    // Set singular and plural references for the word.
	    pluralize.addPluralRule(word, '$0');
	    pluralize.addSingularRule(word, '$0');
	  };

	  /**
	   * Add an irregular word definition.
	   *
	   * @param {String} single
	   * @param {String} plural
	   */
	  pluralize.addIrregularRule = function (single, plural) {
	    plural = plural.toLowerCase();
	    single = single.toLowerCase();

	    irregularSingles[single] = plural;
	    irregularPlurals[plural] = single;
	  };

	  /**
	   * Irregular rules.
	   */
	  [
	    // Pronouns.
	    ['I', 'we'],
	    ['me', 'us'],
	    ['he', 'they'],
	    ['she', 'they'],
	    ['them', 'them'],
	    ['myself', 'ourselves'],
	    ['yourself', 'yourselves'],
	    ['itself', 'themselves'],
	    ['herself', 'themselves'],
	    ['himself', 'themselves'],
	    ['themself', 'themselves'],
	    ['is', 'are'],
	    ['this', 'these'],
	    ['that', 'those'],
	    // Words ending in with a consonant and `o`.
	    ['echo', 'echoes'],
	    ['dingo', 'dingoes'],
	    ['volcano', 'volcanoes'],
	    ['tornado', 'tornadoes'],
	    ['torpedo', 'torpedoes'],
	    // Ends with `us`.
	    ['genus', 'genera'],
	    ['viscus', 'viscera'],
	    // Ends with `ma`.
	    ['stigma', 'stigmata'],
	    ['stoma', 'stomata'],
	    ['dogma', 'dogmata'],
	    ['lemma', 'lemmata'],
	    ['schema', 'schemata'],
	    ['anathema', 'anathemata'],
	    // Other irregular rules.
	    ['ox', 'oxen'],
	    ['axe', 'axes'],
	    ['die', 'dice'],
	    ['yes', 'yeses'],
	    ['foot', 'feet'],
	    ['eave', 'eaves'],
	    ['goose', 'geese'],
	    ['tooth', 'teeth'],
	    ['quiz', 'quizzes'],
	    ['human', 'humans'],
	    ['proof', 'proofs'],
	    ['carve', 'carves'],
	    ['valve', 'valves'],
	    ['thief', 'thieves'],
	    ['genie', 'genies'],
	    ['groove', 'grooves'],
	    ['pickaxe', 'pickaxes'],
	    ['whiskey', 'whiskies']
	  ].forEach(function (rule) {
	    return pluralize.addIrregularRule(rule[0], rule[1]);
	  });

	  /**
	   * Pluralization rules.
	   */
	  [
	    [/s?$/i, 's'],
	    [/([^aeiou]ese)$/i, '$1'],
	    [/(ax|test)is$/i, '$1es'],
	    [/(alias|[^aou]us|tlas|gas|ris)$/i, '$1es'],
	    [/(e[mn]u)s?$/i, '$1s'],
	    [/([^l]ias|[aeiou]las|[emjzr]as|[iu]am)$/i, '$1'],
	    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1i'],
	    [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],
	    [/(seraph|cherub)(?:im)?$/i, '$1im'],
	    [/(her|at|gr)o$/i, '$1oes'],
	    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, '$1a'],
	    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, '$1a'],
	    [/sis$/i, 'ses'],
	    [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],
	    [/([^aeiouy]|qu)y$/i, '$1ies'],
	    [/([^ch][ieo][ln])ey$/i, '$1ies'],
	    [/(x|ch|ss|sh|zz)$/i, '$1es'],
	    [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],
	    [/(m|l)(?:ice|ouse)$/i, '$1ice'],
	    [/(pe)(?:rson|ople)$/i, '$1ople'],
	    [/(child)(?:ren)?$/i, '$1ren'],
	    [/eaux$/i, '$0'],
	    [/m[ae]n$/i, 'men'],
	    ['thou', 'you']
	  ].forEach(function (rule) {
	    return pluralize.addPluralRule(rule[0], rule[1]);
	  });

	  /**
	   * Singularization rules.
	   */
	  [
	    [/s$/i, ''],
	    [/(ss)$/i, '$1'],
	    [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(?:sis|ses)$/i, '$1sis'],
	    [/(^analy)(?:sis|ses)$/i, '$1sis'],
	    [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, '$1fe'],
	    [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],
	    [/([^aeiouy]|qu)ies$/i, '$1y'],
	    [/(^[pl]|zomb|^(?:neck)?t|[aeo][lt]|cut)ies$/i, '$1ie'],
	    [/(\b(?:mon|smil))ies$/i, '$1ey'],
	    [/(m|l)ice$/i, '$1ouse'],
	    [/(seraph|cherub)im$/i, '$1'],
	    [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|tlas|gas|(?:her|at|gr)o|ris)(?:es)?$/i, '$1'],
	    [/(e[mn]u)s?$/i, '$1'],
	    [/(movie|twelve)s$/i, '$1'],
	    [/(cris|test|diagnos)(?:is|es)$/i, '$1is'],
	    [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, '$1us'],
	    [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, '$1um'],
	    [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, '$1on'],
	    [/(alumn|alg|vertebr)ae$/i, '$1a'],
	    [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],
	    [/(matr|append)ices$/i, '$1ix'],
	    [/(pe)(rson|ople)$/i, '$1rson'],
	    [/(child)ren$/i, '$1'],
	    [/(eau)x?$/i, '$1'],
	    [/men$/i, 'man']
	  ].forEach(function (rule) {
	    return pluralize.addSingularRule(rule[0], rule[1]);
	  });

	  /**
	   * Uncountable rules.
	   */
	  [
	    // Singular words with no plurals.
	    'advice',
	    'agenda',
	    'bison',
	    'bream',
	    'buffalo',
	    'carp',
	    'chassis',
	    'cod',
	    'cooperation',
	    'corps',
	    'digestion',
	    'debris',
	    'diabetes',
	    'energy',
	    'equipment',
	    'elk',
	    'excretion',
	    'expertise',
	    'flounder',
	    'gallows',
	    'garbage',
	    'graffiti',
	    'headquarters',
	    'health',
	    'herpes',
	    'highjinks',
	    'homework',
	    'information',
	    'jeans',
	    'justice',
	    'kudos',
	    'labour',
	    'machinery',
	    'mackerel',
	    'media',
	    'mews',
	    'moose',
	    'news',
	    'pike',
	    'plankton',
	    'pliers',
	    'pollution',
	    'premises',
	    'rain',
	    'rice',
	    'salmon',
	    'scissors',
	    'series',
	    'sewage',
	    'shambles',
	    'shrimp',
	    'species',
	    'staff',
	    'swine',
	    'trout',
	    'tuna',
	    'whiting',
	    'wildebeest',
	    'wildlife',
	    'you',
	    // Regexes.
	    /pox$/i, // "chickpox", "smallpox"
	    /ois$/i,
	    /deer$/i, // "deer", "reindeer"
	    /fish$/i, // "fish", "blowfish", "angelfish"
	    /sheep$/i,
	    /measles$/i,
	    /[^aeiou]ese$/i // "chinese", "japanese"
	  ].forEach(pluralize.addUncountableRule);

	  return pluralize;
	});


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {(function() {
	  var vm,
	    __slice = [].slice;

	  vm = __webpack_require__(41);

	  exports.allowUnsafeEval = function(fn) {
	    var previousEval;
	    previousEval = global["eval"];
	    try {
	      global["eval"] = function(source) {
	        return vm.runInThisContext(source);
	      };
	      return fn();
	    } finally {
	      global["eval"] = previousEval;
	    }
	  };

	  exports.allowUnsafeNewFunction = function(fn) {
	    var previousFunction;
	    previousFunction = global.Function;
	    try {
	      global.Function = exports.Function;
	      return fn();
	    } finally {
	      global.Function = previousFunction;
	    }
	  };

	  exports.Function = function() {
	    var body, paramList, paramLists, params, _i, _j, _len;
	    paramLists = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), body = arguments[_i++];
	    params = [];
	    for (_j = 0, _len = paramLists.length; _j < _len; _j++) {
	      paramList = paramLists[_j];
	      if (typeof paramList === 'string') {
	        paramList = paramList.split(/\s*,\s*/);
	      }
	      params.push.apply(params, paramList);
	    }
	    return vm.runInThisContext("(function(" + (params.join(', ')) + ") {\n  " + body + "\n})");
	  };

	  exports.Function.prototype = global.Function.prototype;

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(42);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 42 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict';

	module.exports = Response;

	/**
	 * A response from a web request
	 *
	 * @param {Number} statusCode
	 * @param {Object} headers
	 * @param {Buffer} body
	 * @param {String} url
	 */
	function Response(statusCode, headers, body, url) {
	  if (typeof statusCode !== 'number') {
	    throw new TypeError('statusCode must be a number but was ' + (typeof statusCode));
	  }
	  if (headers === null) {
	    throw new TypeError('headers cannot be null');
	  }
	  if (typeof headers !== 'object') {
	    throw new TypeError('headers must be an object but was ' + (typeof headers));
	  }
	  this.statusCode = statusCode;
	  this.headers = {};
	  for (var key in headers) {
	    this.headers[key.toLowerCase()] = headers[key];
	  }
	  this.body = body;
	  this.url = url;
	}

	Response.prototype.getBody = function (encoding) {
	  if (this.statusCode >= 300) {
	    var err = new Error('Server responded with status code '
	                    + this.statusCode + ':\n' + this.body.toString());
	    err.statusCode = this.statusCode;
	    err.headers = this.headers;
	    err.body = this.body;
	    err.url = this.url;
	    throw err;
	  }
	  return encoding ? this.body.toString(encoding) : this.body;
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var Writable = __webpack_require__(45).Writable
	var inherits = __webpack_require__(68)

	if (typeof Uint8Array === 'undefined') {
	  var U8 = __webpack_require__(76).Uint8Array
	} else {
	  var U8 = Uint8Array
	}

	function ConcatStream(opts, cb) {
	  if (!(this instanceof ConcatStream)) return new ConcatStream(opts, cb)

	  if (typeof opts === 'function') {
	    cb = opts
	    opts = {}
	  }
	  if (!opts) opts = {}

	  var encoding = opts.encoding
	  var shouldInferEncoding = false

	  if (!encoding) {
	    shouldInferEncoding = true
	  } else {
	    encoding =  String(encoding).toLowerCase()
	    if (encoding === 'u8' || encoding === 'uint8') {
	      encoding = 'uint8array'
	    }
	  }

	  Writable.call(this, { objectMode: true })

	  this.encoding = encoding
	  this.shouldInferEncoding = shouldInferEncoding

	  if (cb) this.on('finish', function () { cb(this.getBody()) })
	  this.body = []
	}

	module.exports = ConcatStream
	inherits(ConcatStream, Writable)

	ConcatStream.prototype._write = function(chunk, enc, next) {
	  this.body.push(chunk)
	  next()
	}

	ConcatStream.prototype.inferEncoding = function (buff) {
	  var firstBuffer = buff === undefined ? this.body[0] : buff;
	  if (Buffer.isBuffer(firstBuffer)) return 'buffer'
	  if (typeof Uint8Array !== 'undefined' && firstBuffer instanceof Uint8Array) return 'uint8array'
	  if (Array.isArray(firstBuffer)) return 'array'
	  if (typeof firstBuffer === 'string') return 'string'
	  if (Object.prototype.toString.call(firstBuffer) === "[object Object]") return 'object'
	  return 'buffer'
	}

	ConcatStream.prototype.getBody = function () {
	  if (!this.encoding && this.body.length === 0) return []
	  if (this.shouldInferEncoding) this.encoding = this.inferEncoding()
	  if (this.encoding === 'array') return arrayConcat(this.body)
	  if (this.encoding === 'string') return stringConcat(this.body)
	  if (this.encoding === 'buffer') return bufferConcat(this.body)
	  if (this.encoding === 'uint8array') return u8Concat(this.body)
	  return this.body
	}

	var isArray = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]'
	}

	function isArrayish (arr) {
	  return /Array\]$/.test(Object.prototype.toString.call(arr))
	}

	function stringConcat (parts) {
	  var strings = []
	  var needsToString = false
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (typeof p === 'string') {
	      strings.push(p)
	    } else if (Buffer.isBuffer(p)) {
	      strings.push(p)
	    } else {
	      strings.push(Buffer(p))
	    }
	  }
	  if (Buffer.isBuffer(parts[0])) {
	    strings = Buffer.concat(strings)
	    strings = strings.toString('utf8')
	  } else {
	    strings = strings.join('')
	  }
	  return strings
	}

	function bufferConcat (parts) {
	  var bufs = []
	  for (var i = 0; i < parts.length; i++) {
	    var p = parts[i]
	    if (Buffer.isBuffer(p)) {
	      bufs.push(p)
	    } else if (typeof p === 'string' || isArrayish(p)
	    || (p && typeof p.subarray === 'function')) {
	      bufs.push(Buffer(p))
	    } else bufs.push(Buffer(String(p)))
	  }
	  return Buffer.concat(bufs)
	}

	function arrayConcat (parts) {
	  var res = []
	  for (var i = 0; i < parts.length; i++) {
	    res.push.apply(res, parts[i])
	  }
	  return res
	}

	function u8Concat (parts) {
	  var len = 0
	  for (var i = 0; i < parts.length; i++) {
	    if (typeof parts[i] === 'string') {
	      parts[i] = Buffer(parts[i])
	    }
	    len += parts[i].length
	  }
	  var u8 = new U8(len)
	  for (var i = 0, offset = 0; i < parts.length; i++) {
	    var part = parts[i]
	    for (var j = 0; j < part.length; j++) {
	      u8[offset++] = part[j]
	    }
	  }
	  return u8
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).Buffer))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = (function (){
	  try {
	    return __webpack_require__(46); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(64);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(71);
	exports.Duplex = __webpack_require__(70);
	exports.Transform = __webpack_require__(74);
	exports.PassThrough = __webpack_require__(75);


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(47).EventEmitter;
	var inherits = __webpack_require__(48);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(49);
	Stream.Writable = __webpack_require__(60);
	Stream.Duplex = __webpack_require__(61);
	Stream.Transform = __webpack_require__(62);
	Stream.PassThrough = __webpack_require__(63);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 47 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 48 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(50);
	exports.Stream = __webpack_require__(46);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(56);
	exports.Duplex = __webpack_require__(55);
	exports.Transform = __webpack_require__(58);
	exports.PassThrough = __webpack_require__(59);


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(51);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(47).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(46);

	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(53);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(54);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(55);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(57).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(55);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(57).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).Buffer))

/***/ },
/* 53 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 54 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(53);
	/*</replacement>*/

	var Readable = __webpack_require__(50);
	var Writable = __webpack_require__(56);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(53);
	/*</replacement>*/

	var Stream = __webpack_require__(46);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(55);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(55);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(6).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(55);

	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(53);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(58);

	/*<replacement>*/
	var util = __webpack_require__(52);
	util.inherits = __webpack_require__(53);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(56)


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(55)


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(58)


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(59)


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(65);
	/*</replacement>*/


	/*<replacement>*/
	var isArray = __webpack_require__(66);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(47);

	/*<replacement>*/
	var EElistenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/



	/*<replacement>*/
	var Stream;
	(function (){try{
	  Stream = __webpack_require__(46);
	}catch(_){}finally{
	  if (!Stream)
	    Stream = __webpack_require__(47).EventEmitter;
	}}())
	/*</replacement>*/

	var Buffer = __webpack_require__(6).Buffer;

	/*<replacement>*/
	var util = __webpack_require__(67);
	util.inherits = __webpack_require__(68);
	/*</replacement>*/



	/*<replacement>*/
	var debugUtil = __webpack_require__(69);
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(70);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(73).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(70);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function')
	    this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function() {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}


	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(73).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = computeNewHighWaterMark(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else {
	      return state.length;
	    }
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (ret !== null)
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!(Buffer.isBuffer(chunk)) &&
	      typeof chunk !== 'string' &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      processNextTick(emitReadable_, stream);
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    processNextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      if (state.pipesCount === 1 &&
	          state.pipes[0] === dest &&
	          src.listenerCount('data') === 1 &&
	          !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];


	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }; }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};


	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else if (list.length === 1)
	      ret = list[0];
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}

	function nextTick(fn) {
	  var args = new Array(arguments.length - 1);
	  var i = 0;
	  while (i < args.length) {
	    args[i++] = arguments[i];
	  }
	  process.nextTick(function afterTick() {
	    fn.apply(null, args);
	  });
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6).Buffer))

/***/ },
/* 68 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 69 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(65);
	/*</replacement>*/



	/*<replacement>*/
	var util = __webpack_require__(67);
	util.inherits = __webpack_require__(68);
	/*</replacement>*/

	var Readable = __webpack_require__(64);
	var Writable = __webpack_require__(71);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(65);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(6).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(67);
	util.inherits = __webpack_require__(68);
	/*</replacement>*/


	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(72)
	};
	/*</replacement>*/



	/*<replacement>*/
	var Stream;
	(function (){try{
	  Stream = __webpack_require__(46);
	}catch(_){}finally{
	  if (!Stream)
	    Stream = __webpack_require__(47).EventEmitter;
	}}())
	/*</replacement>*/

	var Buffer = __webpack_require__(6).Buffer;

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(70);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	WritableState.prototype.getBuffer = function writableStateGetBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function (){try {
	Object.defineProperty(WritableState.prototype, 'buffer', {
	  get: internalUtil.deprecate(function() {
	    return this.getBuffer();
	  }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' +
	     'instead.')
	});
	}catch(_){}}());


	function Writable(options) {
	  var Duplex = __webpack_require__(70);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function')
	      this._write = options.write;

	    if (typeof options.writev === 'function')
	      this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;

	  if (!(Buffer.isBuffer(chunk)) &&
	      typeof chunk !== 'string' &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = nop;

	  if (state.ended)
	    writeAfterEnd(this, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.bufferedRequest)
	      clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string')
	    encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
	'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
	.indexOf((encoding + '').toLowerCase()) > -1))
	    throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync)
	    processNextTick(cb, er);
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      processNextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var buffer = [];
	    var cbs = [];
	    while (entry) {
	      cbs.push(entry.callback);
	      buffer.push(entry);
	      entry = entry.next;
	    }

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    doWrite(stream, state, true, state.length, buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null)
	      state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined)
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(state) {
	  return (state.ending &&
	          state.length === 0 &&
	          state.bufferedRequest === null &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      processNextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}


/***/ },
/* 72 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(6).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(70);

	/*<replacement>*/
	var util = __webpack_require__(67);
	util.inherits = __webpack_require__(68);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function')
	      this._transform = options.transform;

	    if (typeof options.flush === 'function')
	      this._flush = options.flush;
	  }

	  this.once('prefinish', function() {
	    if (typeof this._flush === 'function')
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(74);

	/*<replacement>*/
	var util = __webpack_require__(67);
	util.inherits = __webpack_require__(68);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 76 */
/***/ function(module, exports) {

	var undefined = (void 0); // Paranoia

	// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to
	// create, and consume so much memory, that the browser appears frozen.
	var MAX_ARRAY_LENGTH = 1e5;

	// Approximations of internal ECMAScript conversion functions
	var ECMAScript = (function() {
	  // Stash a copy in case other scripts modify these
	  var opts = Object.prototype.toString,
	      ophop = Object.prototype.hasOwnProperty;

	  return {
	    // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
	    Class: function(v) { return opts.call(v).replace(/^\[object *|\]$/g, ''); },
	    HasProperty: function(o, p) { return p in o; },
	    HasOwnProperty: function(o, p) { return ophop.call(o, p); },
	    IsCallable: function(o) { return typeof o === 'function'; },
	    ToInt32: function(v) { return v >> 0; },
	    ToUint32: function(v) { return v >>> 0; }
	  };
	}());

	// Snapshot intrinsics
	var LN2 = Math.LN2,
	    abs = Math.abs,
	    floor = Math.floor,
	    log = Math.log,
	    min = Math.min,
	    pow = Math.pow,
	    round = Math.round;

	// ES5: lock down object properties
	function configureProperties(obj) {
	  if (getOwnPropNames && defineProp) {
	    var props = getOwnPropNames(obj), i;
	    for (i = 0; i < props.length; i += 1) {
	      defineProp(obj, props[i], {
	        value: obj[props[i]],
	        writable: false,
	        enumerable: false,
	        configurable: false
	      });
	    }
	  }
	}

	// emulate ES5 getter/setter API using legacy APIs
	// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx
	// (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but
	// note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)
	var defineProp
	if (Object.defineProperty && (function() {
	      try {
	        Object.defineProperty({}, 'x', {});
	        return true;
	      } catch (e) {
	        return false;
	      }
	    })()) {
	  defineProp = Object.defineProperty;
	} else {
	  defineProp = function(o, p, desc) {
	    if (!o === Object(o)) throw new TypeError("Object.defineProperty called on non-object");
	    if (ECMAScript.HasProperty(desc, 'get') && Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
	    if (ECMAScript.HasProperty(desc, 'set') && Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
	    if (ECMAScript.HasProperty(desc, 'value')) { o[p] = desc.value; }
	    return o;
	  };
	}

	var getOwnPropNames = Object.getOwnPropertyNames || function (o) {
	  if (o !== Object(o)) throw new TypeError("Object.getOwnPropertyNames called on non-object");
	  var props = [], p;
	  for (p in o) {
	    if (ECMAScript.HasOwnProperty(o, p)) {
	      props.push(p);
	    }
	  }
	  return props;
	};

	// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)
	// for index in 0 ... obj.length
	function makeArrayAccessors(obj) {
	  if (!defineProp) { return; }

	  if (obj.length > MAX_ARRAY_LENGTH) throw new RangeError("Array too large for polyfill");

	  function makeArrayAccessor(index) {
	    defineProp(obj, index, {
	      'get': function() { return obj._getter(index); },
	      'set': function(v) { obj._setter(index, v); },
	      enumerable: true,
	      configurable: false
	    });
	  }

	  var i;
	  for (i = 0; i < obj.length; i += 1) {
	    makeArrayAccessor(i);
	  }
	}

	// Internal conversion functions:
	//    pack<Type>()   - take a number (interpreted as Type), output a byte array
	//    unpack<Type>() - take a byte array, output a Type-like number

	function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }
	function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }

	function packI8(n) { return [n & 0xff]; }
	function unpackI8(bytes) { return as_signed(bytes[0], 8); }

	function packU8(n) { return [n & 0xff]; }
	function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }

	function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }

	function packI16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackI16(bytes) { return as_signed(bytes[0] << 8 | bytes[1], 16); }

	function packU16(n) { return [(n >> 8) & 0xff, n & 0xff]; }
	function unpackU16(bytes) { return as_unsigned(bytes[0] << 8 | bytes[1], 16); }

	function packI32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackI32(bytes) { return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

	function packU32(n) { return [(n >> 24) & 0xff, (n >> 16) & 0xff, (n >> 8) & 0xff, n & 0xff]; }
	function unpackU32(bytes) { return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32); }

	function packIEEE754(v, ebits, fbits) {

	  var bias = (1 << (ebits - 1)) - 1,
	      s, e, f, ln,
	      i, bits, str, bytes;

	  function roundToEven(n) {
	    var w = floor(n), f = n - w;
	    if (f < 0.5)
	      return w;
	    if (f > 0.5)
	      return w + 1;
	    return w % 2 ? w + 1 : w;
	  }

	  // Compute sign, exponent, fraction
	  if (v !== v) {
	    // NaN
	    // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
	    e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;
	  } else if (v === Infinity || v === -Infinity) {
	    e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;
	  } else if (v === 0) {
	    e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;
	  } else {
	    s = v < 0;
	    v = abs(v);

	    if (v >= pow(2, 1 - bias)) {
	      e = min(floor(log(v) / LN2), 1023);
	      f = roundToEven(v / pow(2, e) * pow(2, fbits));
	      if (f / pow(2, fbits) >= 2) {
	        e = e + 1;
	        f = 1;
	      }
	      if (e > bias) {
	        // Overflow
	        e = (1 << ebits) - 1;
	        f = 0;
	      } else {
	        // Normalized
	        e = e + bias;
	        f = f - pow(2, fbits);
	      }
	    } else {
	      // Denormalized
	      e = 0;
	      f = roundToEven(v / pow(2, 1 - bias - fbits));
	    }
	  }

	  // Pack sign, exponent, fraction
	  bits = [];
	  for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }
	  for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }
	  bits.push(s ? 1 : 0);
	  bits.reverse();
	  str = bits.join('');

	  // Bits to bytes
	  bytes = [];
	  while (str.length) {
	    bytes.push(parseInt(str.substring(0, 8), 2));
	    str = str.substring(8);
	  }
	  return bytes;
	}

	function unpackIEEE754(bytes, ebits, fbits) {

	  // Bytes to bits
	  var bits = [], i, j, b, str,
	      bias, s, e, f;

	  for (i = bytes.length; i; i -= 1) {
	    b = bytes[i - 1];
	    for (j = 8; j; j -= 1) {
	      bits.push(b % 2 ? 1 : 0); b = b >> 1;
	    }
	  }
	  bits.reverse();
	  str = bits.join('');

	  // Unpack sign, exponent, fraction
	  bias = (1 << (ebits - 1)) - 1;
	  s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
	  e = parseInt(str.substring(1, 1 + ebits), 2);
	  f = parseInt(str.substring(1 + ebits), 2);

	  // Produce number
	  if (e === (1 << ebits) - 1) {
	    return f !== 0 ? NaN : s * Infinity;
	  } else if (e > 0) {
	    // Normalized
	    return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
	  } else if (f !== 0) {
	    // Denormalized
	    return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
	  } else {
	    return s < 0 ? -0 : 0;
	  }
	}

	function unpackF64(b) { return unpackIEEE754(b, 11, 52); }
	function packF64(v) { return packIEEE754(v, 11, 52); }
	function unpackF32(b) { return unpackIEEE754(b, 8, 23); }
	function packF32(v) { return packIEEE754(v, 8, 23); }


	//
	// 3 The ArrayBuffer Type
	//

	(function() {

	  /** @constructor */
	  var ArrayBuffer = function ArrayBuffer(length) {
	    length = ECMAScript.ToInt32(length);
	    if (length < 0) throw new RangeError('ArrayBuffer size is not a small enough positive integer');

	    this.byteLength = length;
	    this._bytes = [];
	    this._bytes.length = length;

	    var i;
	    for (i = 0; i < this.byteLength; i += 1) {
	      this._bytes[i] = 0;
	    }

	    configureProperties(this);
	  };

	  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

	  //
	  // 4 The ArrayBufferView Type
	  //

	  // NOTE: this constructor is not exported
	  /** @constructor */
	  var ArrayBufferView = function ArrayBufferView() {
	    //this.buffer = null;
	    //this.byteOffset = 0;
	    //this.byteLength = 0;
	  };

	  //
	  // 5 The Typed Array View Types
	  //

	  function makeConstructor(bytesPerElement, pack, unpack) {
	    // Each TypedArray type requires a distinct constructor instance with
	    // identical logic, which this produces.

	    var ctor;
	    ctor = function(buffer, byteOffset, length) {
	      var array, sequence, i, s;

	      if (!arguments.length || typeof arguments[0] === 'number') {
	        // Constructor(unsigned long length)
	        this.length = ECMAScript.ToInt32(arguments[0]);
	        if (length < 0) throw new RangeError('ArrayBufferView size is not a small enough positive integer');

	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;
	      } else if (typeof arguments[0] === 'object' && arguments[0].constructor === ctor) {
	        // Constructor(TypedArray array)
	        array = arguments[0];

	        this.length = array.length;
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;

	        for (i = 0; i < this.length; i += 1) {
	          this._setter(i, array._getter(i));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 !(arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(sequence<type> array)
	        sequence = arguments[0];

	        this.length = ECMAScript.ToUint32(sequence.length);
	        this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        this.buffer = new ArrayBuffer(this.byteLength);
	        this.byteOffset = 0;

	        for (i = 0; i < this.length; i += 1) {
	          s = sequence[i];
	          this._setter(i, Number(s));
	        }
	      } else if (typeof arguments[0] === 'object' &&
	                 (arguments[0] instanceof ArrayBuffer || ECMAScript.Class(arguments[0]) === 'ArrayBuffer')) {
	        // Constructor(ArrayBuffer buffer,
	        //             optional unsigned long byteOffset, optional unsigned long length)
	        this.buffer = buffer;

	        this.byteOffset = ECMAScript.ToUint32(byteOffset);
	        if (this.byteOffset > this.buffer.byteLength) {
	          throw new RangeError("byteOffset out of range");
	        }

	        if (this.byteOffset % this.BYTES_PER_ELEMENT) {
	          // The given byteOffset must be a multiple of the element
	          // size of the specific type, otherwise an exception is raised.
	          throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
	        }

	        if (arguments.length < 3) {
	          this.byteLength = this.buffer.byteLength - this.byteOffset;

	          if (this.byteLength % this.BYTES_PER_ELEMENT) {
	            throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
	          }
	          this.length = this.byteLength / this.BYTES_PER_ELEMENT;
	        } else {
	          this.length = ECMAScript.ToUint32(length);
	          this.byteLength = this.length * this.BYTES_PER_ELEMENT;
	        }

	        if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }

	      this.constructor = ctor;

	      configureProperties(this);
	      makeArrayAccessors(this);
	    };

	    ctor.prototype = new ArrayBufferView();
	    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
	    ctor.prototype._pack = pack;
	    ctor.prototype._unpack = unpack;
	    ctor.BYTES_PER_ELEMENT = bytesPerElement;

	    // getter type (unsigned long index);
	    ctor.prototype._getter = function(index) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");

	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }

	      var bytes = [], i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        bytes.push(this.buffer._bytes[o]);
	      }
	      return this._unpack(bytes);
	    };

	    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);
	    ctor.prototype.get = ctor.prototype._getter;

	    // setter void (unsigned long index, type value);
	    ctor.prototype._setter = function(index, value) {
	      if (arguments.length < 2) throw new SyntaxError("Not enough arguments");

	      index = ECMAScript.ToUint32(index);
	      if (index >= this.length) {
	        return undefined;
	      }

	      var bytes = this._pack(value), i, o;
	      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;
	           i < this.BYTES_PER_ELEMENT;
	           i += 1, o += 1) {
	        this.buffer._bytes[o] = bytes[i];
	      }
	    };

	    // void set(TypedArray array, optional unsigned long offset);
	    // void set(sequence<type> array, optional unsigned long offset);
	    ctor.prototype.set = function(index, value) {
	      if (arguments.length < 1) throw new SyntaxError("Not enough arguments");
	      var array, sequence, offset, len,
	          i, s, d,
	          byteOffset, byteLength, tmp;

	      if (typeof arguments[0] === 'object' && arguments[0].constructor === this.constructor) {
	        // void set(TypedArray array, optional unsigned long offset);
	        array = arguments[0];
	        offset = ECMAScript.ToUint32(arguments[1]);

	        if (offset + array.length > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }

	        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
	        byteLength = array.length * this.BYTES_PER_ELEMENT;

	        if (array.buffer === this.buffer) {
	          tmp = [];
	          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
	            tmp[i] = array.buffer._bytes[s];
	          }
	          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
	            this.buffer._bytes[d] = tmp[i];
	          }
	        } else {
	          for (i = 0, s = array.byteOffset, d = byteOffset;
	               i < byteLength; i += 1, s += 1, d += 1) {
	            this.buffer._bytes[d] = array.buffer._bytes[s];
	          }
	        }
	      } else if (typeof arguments[0] === 'object' && typeof arguments[0].length !== 'undefined') {
	        // void set(sequence<type> array, optional unsigned long offset);
	        sequence = arguments[0];
	        len = ECMAScript.ToUint32(sequence.length);
	        offset = ECMAScript.ToUint32(arguments[1]);

	        if (offset + len > this.length) {
	          throw new RangeError("Offset plus length of array is out of range");
	        }

	        for (i = 0; i < len; i += 1) {
	          s = sequence[i];
	          this._setter(offset + i, Number(s));
	        }
	      } else {
	        throw new TypeError("Unexpected argument type(s)");
	      }
	    };

	    // TypedArray subarray(long begin, optional long end);
	    ctor.prototype.subarray = function(start, end) {
	      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }

	      start = ECMAScript.ToInt32(start);
	      end = ECMAScript.ToInt32(end);

	      if (arguments.length < 1) { start = 0; }
	      if (arguments.length < 2) { end = this.length; }

	      if (start < 0) { start = this.length + start; }
	      if (end < 0) { end = this.length + end; }

	      start = clamp(start, 0, this.length);
	      end = clamp(end, 0, this.length);

	      var len = end - start;
	      if (len < 0) {
	        len = 0;
	      }

	      return new this.constructor(
	        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
	    };

	    return ctor;
	  }

	  var Int8Array = makeConstructor(1, packI8, unpackI8);
	  var Uint8Array = makeConstructor(1, packU8, unpackU8);
	  var Uint8ClampedArray = makeConstructor(1, packU8Clamped, unpackU8);
	  var Int16Array = makeConstructor(2, packI16, unpackI16);
	  var Uint16Array = makeConstructor(2, packU16, unpackU16);
	  var Int32Array = makeConstructor(4, packI32, unpackI32);
	  var Uint32Array = makeConstructor(4, packU32, unpackU32);
	  var Float32Array = makeConstructor(4, packF32, unpackF32);
	  var Float64Array = makeConstructor(8, packF64, unpackF64);

	  exports.Int8Array = exports.Int8Array || Int8Array;
	  exports.Uint8Array = exports.Uint8Array || Uint8Array;
	  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
	  exports.Int16Array = exports.Int16Array || Int16Array;
	  exports.Uint16Array = exports.Uint16Array || Uint16Array;
	  exports.Int32Array = exports.Int32Array || Int32Array;
	  exports.Uint32Array = exports.Uint32Array || Uint32Array;
	  exports.Float32Array = exports.Float32Array || Float32Array;
	  exports.Float64Array = exports.Float64Array || Float64Array;
	}());

	//
	// 6 The DataView View Type
	//

	(function() {
	  function r(array, index) {
	    return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
	  }

	  var IS_BIG_ENDIAN = (function() {
	    var u16array = new(exports.Uint16Array)([0x1234]),
	        u8array = new(exports.Uint8Array)(u16array.buffer);
	    return r(u8array, 0) === 0x12;
	  }());

	  // Constructor(ArrayBuffer buffer,
	  //             optional unsigned long byteOffset,
	  //             optional unsigned long byteLength)
	  /** @constructor */
	  var DataView = function DataView(buffer, byteOffset, byteLength) {
	    if (arguments.length === 0) {
	      buffer = new exports.ArrayBuffer(0);
	    } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === 'ArrayBuffer')) {
	      throw new TypeError("TypeError");
	    }

	    this.buffer = buffer || new exports.ArrayBuffer(0);

	    this.byteOffset = ECMAScript.ToUint32(byteOffset);
	    if (this.byteOffset > this.buffer.byteLength) {
	      throw new RangeError("byteOffset out of range");
	    }

	    if (arguments.length < 3) {
	      this.byteLength = this.buffer.byteLength - this.byteOffset;
	    } else {
	      this.byteLength = ECMAScript.ToUint32(byteLength);
	    }

	    if ((this.byteOffset + this.byteLength) > this.buffer.byteLength) {
	      throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
	    }

	    configureProperties(this);
	  };

	  function makeGetter(arrayType) {
	    return function(byteOffset, littleEndian) {

	      byteOffset = ECMAScript.ToUint32(byteOffset);

	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }
	      byteOffset += this.byteOffset;

	      var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
	          bytes = [], i;
	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(uint8Array, i));
	      }

	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }

	      return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
	    };
	  }

	  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
	  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
	  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
	  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
	  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
	  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
	  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
	  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

	  function makeSetter(arrayType) {
	    return function(byteOffset, value, littleEndian) {

	      byteOffset = ECMAScript.ToUint32(byteOffset);
	      if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
	        throw new RangeError("Array index out of range");
	      }

	      // Get bytes
	      var typeArray = new arrayType([value]),
	          byteArray = new exports.Uint8Array(typeArray.buffer),
	          bytes = [], i, byteView;

	      for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
	        bytes.push(r(byteArray, i));
	      }

	      // Flip if necessary
	      if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
	        bytes.reverse();
	      }

	      // Write them
	      byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
	      byteView.set(bytes);
	    };
	  }

	  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
	  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
	  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
	  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
	  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
	  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
	  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
	  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

	  exports.DataView = exports.DataView || DataView;

	}());


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(78);
	var Response = __webpack_require__(43);
	var handleQs = __webpack_require__(85);

	module.exports = doRequest;
	function doRequest(method, url, options, callback) {
	  var result = new Promise(function (resolve, reject) {
	    var xhr = new window.XMLHttpRequest();

	    // check types of arguments

	    if (typeof method !== 'string') {
	      throw new TypeError('The method must be a string.');
	    }
	    if (typeof url !== 'string') {
	      throw new TypeError('The URL/path must be a string.');
	    }
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	    if (options === null || options === undefined) {
	      options = {};
	    }
	    if (typeof options !== 'object') {
	      throw new TypeError('Options must be an object (or null).');
	    }
	    if (typeof callback !== 'function') {
	      callback = undefined;
	    }

	    method = method.toUpperCase();
	    options.headers = options.headers || {};


	    function attempt(n) {
	      doRequest(method, url, {
	        qs: options.qs,
	        headers: options.headers,
	        timeout: options.timeout
	      }).nodeify(function (err, res) {
	        var retry = err || res.statusCode >= 400;
	        if (typeof options.retry === 'function') {
	          retry = options.retry(err, res, n + 1);
	        }
	        if (n >= (options.maxRetries | 5)) {
	          retry = false;
	        }
	        if (retry) {
	          var delay = options.retryDelay;
	          if (typeof options.retryDelay === 'function') {
	            delay = options.retryDelay(err, res, n + 1);
	          }
	          delay = delay || 200;
	          setTimeout(function () {
	            attempt(n + 1);
	          }, delay);
	        } else {
	          if (err) reject(err);
	          else resolve(res);
	        }
	      });
	    }
	    if (options.retry && method === 'GET') {
	      return attempt(0);
	    }

	    // handle cross domain

	    var match;
	    var crossDomain = !!((match = /^([\w-]+:)?\/\/([^\/]+)/.exec(options.uri)) && (match[2] != window.location.host));
	    if (!crossDomain) options.headers['X-Requested-With'] = 'XMLHttpRequest';

	    // handle query string
	    if (options.qs) {
	      url = handleQs(url, options.qs);
	    }

	    // handle json body
	    if (options.json) {
	      options.body = JSON.stringify(options.json);
	      options.headers['Content-Type'] = 'application/json';
	    }

	    if (options.timeout) {
	      xhr.timeout = options.timeout;
	      var start = Date.now();
	      xhr.ontimeout = function () {
	        var duration = Date.now() - start;
	        var err = new Error('Request timed out after ' + duration + 'ms');
	        err.timeout = true;
	        err.duration = duration;
	        reject(err);
	      };
	    }
	    xhr.onreadystatechange = function () {
	      if (xhr.readyState === 4) {
	        var headers = {};
	        xhr.getAllResponseHeaders().split('\r\n').forEach(function (header) {
	          var h = header.split(':');
	          if (h.length > 1) {
	            headers[h[0].toLowerCase()] = h.slice(1).join(':').trim();
	          }
	        });
	        var res = new Response(xhr.status, headers, xhr.responseText);
	        res.url = url;
	        resolve(res);
	      }
	    };

	    // method, url, async
	    xhr.open(method, url, true);

	    for (var name in options.headers) {
	      xhr.setRequestHeader(name, options.headers[name]);
	    }

	    // avoid sending empty string (#319)
	    xhr.send(options.body ? options.body : null);
	  });
	  result.getBody = function () {
	    return result.then(function (res) { return res.getBody(); });
	  };
	  return result.nodeify(callback);
	}


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(79)
	__webpack_require__(82)
	__webpack_require__(83)
	__webpack_require__(84)

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var asap = __webpack_require__(80)

	module.exports = Promise;
	function Promise(fn) {
	  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
	  if (typeof fn !== 'function') throw new TypeError('not a function')
	  var state = null
	  var value = null
	  var deferreds = []
	  var self = this

	  this.then = function(onFulfilled, onRejected) {
	    return new self.constructor(function(resolve, reject) {
	      handle(new Handler(onFulfilled, onRejected, resolve, reject))
	    })
	  }

	  function handle(deferred) {
	    if (state === null) {
	      deferreds.push(deferred)
	      return
	    }
	    asap(function() {
	      var cb = state ? deferred.onFulfilled : deferred.onRejected
	      if (cb === null) {
	        (state ? deferred.resolve : deferred.reject)(value)
	        return
	      }
	      var ret
	      try {
	        ret = cb(value)
	      }
	      catch (e) {
	        deferred.reject(e)
	        return
	      }
	      deferred.resolve(ret)
	    })
	  }

	  function resolve(newValue) {
	    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then
	        if (typeof then === 'function') {
	          doResolve(then.bind(newValue), resolve, reject)
	          return
	        }
	      }
	      state = true
	      value = newValue
	      finale()
	    } catch (e) { reject(e) }
	  }

	  function reject(newValue) {
	    state = false
	    value = newValue
	    finale()
	  }

	  function finale() {
	    for (var i = 0, len = deferreds.length; i < len; i++)
	      handle(deferreds[i])
	    deferreds = null
	  }

	  doResolve(fn, resolve, reject)
	}


	function Handler(onFulfilled, onRejected, resolve, reject){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null
	  this.resolve = resolve
	  this.reject = reject
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, onFulfilled, onRejected) {
	  var done = false;
	  try {
	    fn(function (value) {
	      if (done) return
	      done = true
	      onFulfilled(value)
	    }, function (reason) {
	      if (done) return
	      done = true
	      onRejected(reason)
	    })
	  } catch (ex) {
	    if (done) return
	    done = true
	    onRejected(ex)
	  }
	}


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {
	// Use the fastest possible means to execute a task in a future turn
	// of the event loop.

	// linked list of tasks (single, with head node)
	var head = {task: void 0, next: null};
	var tail = head;
	var flushing = false;
	var requestFlush = void 0;
	var isNodeJS = false;

	function flush() {
	    /* jshint loopfunc: true */

	    while (head.next) {
	        head = head.next;
	        var task = head.task;
	        head.task = void 0;
	        var domain = head.domain;

	        if (domain) {
	            head.domain = void 0;
	            domain.enter();
	        }

	        try {
	            task();

	        } catch (e) {
	            if (isNodeJS) {
	                // In node, uncaught exceptions are considered fatal errors.
	                // Re-throw them synchronously to interrupt flushing!

	                // Ensure continuation if the uncaught exception is suppressed
	                // listening "uncaughtException" events (as domains does).
	                // Continue in next event to avoid tick recursion.
	                if (domain) {
	                    domain.exit();
	                }
	                setTimeout(flush, 0);
	                if (domain) {
	                    domain.enter();
	                }

	                throw e;

	            } else {
	                // In browsers, uncaught exceptions are not fatal.
	                // Re-throw them asynchronously to avoid slow-downs.
	                setTimeout(function() {
	                   throw e;
	                }, 0);
	            }
	        }

	        if (domain) {
	            domain.exit();
	        }
	    }

	    flushing = false;
	}

	if (typeof process !== "undefined" && process.nextTick) {
	    // Node.js before 0.9. Note that some fake-Node environments, like the
	    // Mocha test runner, introduce a `process` global without a `nextTick`.
	    isNodeJS = true;

	    requestFlush = function () {
	        process.nextTick(flush);
	    };

	} else if (typeof setImmediate === "function") {
	    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	    if (typeof window !== "undefined") {
	        requestFlush = setImmediate.bind(window, flush);
	    } else {
	        requestFlush = function () {
	            setImmediate(flush);
	        };
	    }

	} else if (typeof MessageChannel !== "undefined") {
	    // modern browsers
	    // http://www.nonblocking.io/2011/06/windownexttick.html
	    var channel = new MessageChannel();
	    channel.port1.onmessage = flush;
	    requestFlush = function () {
	        channel.port2.postMessage(0);
	    };

	} else {
	    // old browsers
	    requestFlush = function () {
	        setTimeout(flush, 0);
	    };
	}

	function asap(task) {
	    tail = tail.next = {
	        task: task,
	        domain: isNodeJS && process.domain,
	        next: null
	    };

	    if (!flushing) {
	        flushing = true;
	        requestFlush();
	    }
	};

	module.exports = asap;


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(81).setImmediate))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(4).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(81).setImmediate, __webpack_require__(81).clearImmediate))

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Promise = __webpack_require__(79)
	var asap = __webpack_require__(80)

	module.exports = Promise
	Promise.prototype.done = function (onFulfilled, onRejected) {
	  var self = arguments.length ? this.then.apply(this, arguments) : this
	  self.then(null, function (err) {
	    asap(function () {
	      throw err
	    })
	  })
	}

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains the ES6 extensions to the core Promises/A+ API

	var Promise = __webpack_require__(79)
	var asap = __webpack_require__(80)

	module.exports = Promise

	/* Static Functions */

	function ValuePromise(value) {
	  this.then = function (onFulfilled) {
	    if (typeof onFulfilled !== 'function') return this
	    return new Promise(function (resolve, reject) {
	      asap(function () {
	        try {
	          resolve(onFulfilled(value))
	        } catch (ex) {
	          reject(ex);
	        }
	      })
	    })
	  }
	}
	ValuePromise.prototype = Promise.prototype

	var TRUE = new ValuePromise(true)
	var FALSE = new ValuePromise(false)
	var NULL = new ValuePromise(null)
	var UNDEFINED = new ValuePromise(undefined)
	var ZERO = new ValuePromise(0)
	var EMPTYSTRING = new ValuePromise('')

	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value

	  if (value === null) return NULL
	  if (value === undefined) return UNDEFINED
	  if (value === true) return TRUE
	  if (value === false) return FALSE
	  if (value === 0) return ZERO
	  if (value === '') return EMPTYSTRING

	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value))
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex)
	      })
	    }
	  }

	  return new ValuePromise(value)
	}

	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr)

	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([])
	    var remaining = args.length
	    function res(i, val) {
	      try {
	        if (val && (typeof val === 'object' || typeof val === 'function')) {
	          var then = val.then
	          if (typeof then === 'function') {
	            then.call(val, function (val) { res(i, val) }, reject)
	            return
	          }
	        }
	        args[i] = val
	        if (--remaining === 0) {
	          resolve(args);
	        }
	      } catch (ex) {
	        reject(ex)
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i])
	    }
	  })
	}

	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) { 
	    reject(value);
	  });
	}

	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) { 
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    })
	  });
	}

	/* Prototype Methods */

	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	}


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//This file contains then/promise specific extensions that are only useful for node.js interop

	var Promise = __webpack_require__(79)
	var asap = __webpack_require__(80)

	module.exports = Promise

	/* Static Functions */

	Promise.denodeify = function (fn, argumentCount) {
	  argumentCount = argumentCount || Infinity
	  return function () {
	    var self = this
	    var args = Array.prototype.slice.call(arguments)
	    return new Promise(function (resolve, reject) {
	      while (args.length && args.length > argumentCount) {
	        args.pop()
	      }
	      args.push(function (err, res) {
	        if (err) reject(err)
	        else resolve(res)
	      })
	      var res = fn.apply(self, args)
	      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
	        resolve(res)
	      }
	    })
	  }
	}
	Promise.nodeify = function (fn) {
	  return function () {
	    var args = Array.prototype.slice.call(arguments)
	    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
	    var ctx = this
	    try {
	      return fn.apply(this, arguments).nodeify(callback, ctx)
	    } catch (ex) {
	      if (callback === null || typeof callback == 'undefined') {
	        return new Promise(function (resolve, reject) { reject(ex) })
	      } else {
	        asap(function () {
	          callback.call(ctx, ex)
	        })
	      }
	    }
	  }
	}

	Promise.prototype.nodeify = function (callback, ctx) {
	  if (typeof callback != 'function') return this

	  this.then(function (value) {
	    asap(function () {
	      callback.call(ctx, null, value)
	    })
	  }, function (err) {
	    asap(function () {
	      callback.call(ctx, err)
	    })
	  })
	}


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parse = __webpack_require__(86).parse;
	var stringify = __webpack_require__(86).stringify;

	module.exports = handleQs;
	function handleQs(url, query) {
	  url = url.split('?');
	  var start = url[0];
	  var qs = (url[1] || '').split('#')[0];
	  var end = url[1] && url[1].split('#').length > 1 ? '#' + url[1].split('#')[1] : '';

	  var baseQs = parse(qs);
	  for (var i in query) {
	    baseQs[i] = query[i];
	  }
	  qs = stringify(baseQs);
	  if (qs !== '') {
	    qs = '?' + qs;
	  }
	  return start + qs + end;
	}


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(87);


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Stringify = __webpack_require__(88);
	var Parse = __webpack_require__(90);


	// Declare internals

	var internals = {};


	module.exports = {
	    stringify: Stringify,
	    parse: Parse
	};


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(89);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    arrayPrefixGenerators: {
	        brackets: function (prefix, key) {
	            return prefix + '[]';
	        },
	        indices: function (prefix, key) {
	            return prefix + '[' + key + ']';
	        },
	        repeat: function (prefix, key) {
	            return prefix;
	        }
	    }
	};


	internals.stringify = function (obj, prefix, generateArrayPrefix) {

	    if (Utils.isBuffer(obj)) {
	        obj = obj.toString();
	    }
	    else if (obj instanceof Date) {
	        obj = obj.toISOString();
	    }
	    else if (obj === null) {
	        obj = '';
	    }

	    if (typeof obj === 'string' ||
	        typeof obj === 'number' ||
	        typeof obj === 'boolean') {

	        return [encodeURIComponent(prefix) + '=' + encodeURIComponent(obj)];
	    }

	    var values = [];

	    if (typeof obj === 'undefined') {
	        return values;
	    }

	    var objKeys = Object.keys(obj);
	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];
	        if (Array.isArray(obj)) {
	            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix));
	        }
	        else {
	            values = values.concat(internals.stringify(obj[key], prefix + '[' + key + ']', generateArrayPrefix));
	        }
	    }

	    return values;
	};


	module.exports = function (obj, options) {

	    options = options || {};
	    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;

	    var keys = [];

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return '';
	    }

	    var arrayFormat;
	    if (options.arrayFormat in internals.arrayPrefixGenerators) {
	        arrayFormat = options.arrayFormat;
	    }
	    else if ('indices' in options) {
	        arrayFormat = options.indices ? 'indices' : 'repeat';
	    }
	    else {
	        arrayFormat = 'indices';
	    }

	    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];

	    var objKeys = Object.keys(obj);
	    for (var i = 0, il = objKeys.length; i < il; ++i) {
	        var key = objKeys[i];
	        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix));
	    }

	    return keys.join(delimiter);
	};


/***/ },
/* 89 */
/***/ function(module, exports) {

	// Load modules


	// Declare internals

	var internals = {};


	exports.arrayToObject = function (source) {

	    var obj = {};
	    for (var i = 0, il = source.length; i < il; ++i) {
	        if (typeof source[i] !== 'undefined') {

	            obj[i] = source[i];
	        }
	    }

	    return obj;
	};


	exports.merge = function (target, source) {

	    if (!source) {
	        return target;
	    }

	    if (typeof source !== 'object') {
	        if (Array.isArray(target)) {
	            target.push(source);
	        }
	        else {
	            target[source] = true;
	        }

	        return target;
	    }

	    if (typeof target !== 'object') {
	        target = [target].concat(source);
	        return target;
	    }

	    if (Array.isArray(target) &&
	        !Array.isArray(source)) {

	        target = exports.arrayToObject(target);
	    }

	    var keys = Object.keys(source);
	    for (var k = 0, kl = keys.length; k < kl; ++k) {
	        var key = keys[k];
	        var value = source[key];

	        if (!target[key]) {
	            target[key] = value;
	        }
	        else {
	            target[key] = exports.merge(target[key], value);
	        }
	    }

	    return target;
	};


	exports.decode = function (str) {

	    try {
	        return decodeURIComponent(str.replace(/\+/g, ' '));
	    } catch (e) {
	        return str;
	    }
	};


	exports.compact = function (obj, refs) {

	    if (typeof obj !== 'object' ||
	        obj === null) {

	        return obj;
	    }

	    refs = refs || [];
	    var lookup = refs.indexOf(obj);
	    if (lookup !== -1) {
	        return refs[lookup];
	    }

	    refs.push(obj);

	    if (Array.isArray(obj)) {
	        var compacted = [];

	        for (var i = 0, il = obj.length; i < il; ++i) {
	            if (typeof obj[i] !== 'undefined') {
	                compacted.push(obj[i]);
	            }
	        }

	        return compacted;
	    }

	    var keys = Object.keys(obj);
	    for (i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        obj[key] = exports.compact(obj[key], refs);
	    }

	    return obj;
	};


	exports.isRegExp = function (obj) {
	    return Object.prototype.toString.call(obj) === '[object RegExp]';
	};


	exports.isBuffer = function (obj) {

	    if (obj === null ||
	        typeof obj === 'undefined') {

	        return false;
	    }

	    return !!(obj.constructor &&
	        obj.constructor.isBuffer &&
	        obj.constructor.isBuffer(obj));
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	// Load modules

	var Utils = __webpack_require__(89);


	// Declare internals

	var internals = {
	    delimiter: '&',
	    depth: 5,
	    arrayLimit: 20,
	    parameterLimit: 1000
	};


	internals.parseValues = function (str, options) {

	    var obj = {};
	    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);

	    for (var i = 0, il = parts.length; i < il; ++i) {
	        var part = parts[i];
	        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;

	        if (pos === -1) {
	            obj[Utils.decode(part)] = '';
	        }
	        else {
	            var key = Utils.decode(part.slice(0, pos));
	            var val = Utils.decode(part.slice(pos + 1));

	            if (!Object.prototype.hasOwnProperty.call(obj, key)) {
	                obj[key] = val;
	            }
	            else {
	                obj[key] = [].concat(obj[key]).concat(val);
	            }
	        }
	    }

	    return obj;
	};


	internals.parseObject = function (chain, val, options) {

	    if (!chain.length) {
	        return val;
	    }

	    var root = chain.shift();

	    var obj = {};
	    if (root === '[]') {
	        obj = [];
	        obj = obj.concat(internals.parseObject(chain, val, options));
	    }
	    else {
	        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;
	        var index = parseInt(cleanRoot, 10);
	        var indexString = '' + index;
	        if (!isNaN(index) &&
	            root !== cleanRoot &&
	            indexString === cleanRoot &&
	            index >= 0 &&
	            index <= options.arrayLimit) {

	            obj = [];
	            obj[index] = internals.parseObject(chain, val, options);
	        }
	        else {
	            obj[cleanRoot] = internals.parseObject(chain, val, options);
	        }
	    }

	    return obj;
	};


	internals.parseKeys = function (key, val, options) {

	    if (!key) {
	        return;
	    }

	    // The regex chunks

	    var parent = /^([^\[\]]*)/;
	    var child = /(\[[^\[\]]*\])/g;

	    // Get the parent

	    var segment = parent.exec(key);

	    // Don't allow them to overwrite object prototype properties

	    if (Object.prototype.hasOwnProperty(segment[1])) {
	        return;
	    }

	    // Stash the parent if it exists

	    var keys = [];
	    if (segment[1]) {
	        keys.push(segment[1]);
	    }

	    // Loop through children appending to the array until we hit depth

	    var i = 0;
	    while ((segment = child.exec(key)) !== null && i < options.depth) {

	        ++i;
	        if (!Object.prototype.hasOwnProperty(segment[1].replace(/\[|\]/g, ''))) {
	            keys.push(segment[1]);
	        }
	    }

	    // If there's a remainder, just add whatever is left

	    if (segment) {
	        keys.push('[' + key.slice(segment.index) + ']');
	    }

	    return internals.parseObject(keys, val, options);
	};


	module.exports = function (str, options) {

	    if (str === '' ||
	        str === null ||
	        typeof str === 'undefined') {

	        return {};
	    }

	    options = options || {};
	    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;
	    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;
	    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;
	    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;

	    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;
	    var obj = {};

	    // Iterate over the keys and setup the new object

	    var keys = Object.keys(tempObj);
	    for (var i = 0, il = keys.length; i < il; ++i) {
	        var key = keys[i];
	        var newObj = internals.parseKeys(key, tempObj[key], options);
	        obj = Utils.merge(obj, newObj);
	    }

	    return Utils.compact(obj);
	};


/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var punycode = __webpack_require__(93);

	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;

	exports.Url = Url;

	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}

	// Reference: RFC 3986, RFC 1808, RFC 2396

	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,

	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(95);

	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && isObject(url) && url instanceof Url) return url;

	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}

	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }

	  var rest = url;

	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();

	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }

	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }

	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {

	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c

	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.

	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }

	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }

	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }

	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;

	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);

	    // pull out port.
	    this.parseHost();

	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';

	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';

	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }

	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }

	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a puny coded representation of "domain".
	      // It only converts the part of the domain name that
	      // has non ASCII characters. I.e. it dosent matter if
	      // you call it with a domain that already is in ASCII.
	      var domainArray = this.hostname.split('.');
	      var newOut = [];
	      for (var i = 0; i < domainArray.length; ++i) {
	        var s = domainArray[i];
	        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
	            'xn--' + punycode.encode(s) : s);
	      }
	      this.hostname = newOut.join('.');
	    }

	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;

	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }

	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {

	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }


	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }

	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }

	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};

	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}

	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }

	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';

	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }

	  if (this.query &&
	      isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }

	  var search = this.search || (query && ('?' + query)) || '';

	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }

	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;

	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');

	  return protocol + host + pathname + search + hash;
	};

	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}

	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};

	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}

	Url.prototype.resolveObject = function(relative) {
	  if (isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }

	  var result = new Url();
	  Object.keys(this).forEach(function(k) {
	    result[k] = this[k];
	  }, this);

	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;

	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }

	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    Object.keys(relative).forEach(function(k) {
	      if (k !== 'protocol')
	        result[k] = relative[k];
	    });

	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }

	    result.href = result.format();
	    return result;
	  }

	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      Object.keys(relative).forEach(function(k) {
	        result[k] = relative[k];
	      });
	      result.href = result.format();
	      return result;
	    }

	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }

	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];

	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }

	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especialy happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!isNull(result.pathname) || !isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }

	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }

	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host) && (last === '.' || last === '..') ||
	      last === '');

	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last == '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }

	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }

	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }

	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');

	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especialy happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }

	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }

	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }

	  //to support request.http
	  if (!isNull(result.pathname) || !isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};

	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	function isString(arg) {
	  return typeof arg === "string";
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isNull(arg) {
	  return arg === null;
	}
	function isNullOrUndefined(arg) {
	  return  arg == null;
	}


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {

		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}

		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

		/*--------------------------------------------------------------------------*/

		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}

		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}

		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}

		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}

		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}

		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}

		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}

		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}

		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;

			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.

			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}

			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}

			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.

			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

					if (index >= inputLength) {
						error('invalid-input');
					}

					digit = basicToDigit(input.charCodeAt(index++));

					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}

					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

					if (digit < t) {
						break;
					}

					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}

					w *= baseMinusT;

				}

				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);

				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}

				n += floor(i / out);
				i %= out;

				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);

			}

			return ucs2encode(output);
		}

		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;

			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);

			// Cache the length
			inputLength = input.length;

			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;

			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}

			handledCPCount = basicLength = output.length;

			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.

			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}

			// Main encoding loop:
			while (handledCPCount < inputLength) {

				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}

				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}

				delta += (m - n) * handledCPCountPlusOne;
				n = m;

				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];

					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}

					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}

						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}

				++delta;
				++n;

			}
			return output.join('');
		}

		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}

		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}

		/*--------------------------------------------------------------------------*/

		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};

		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}

	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(94)(module), (function() { return this; }())))

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.decode = exports.parse = __webpack_require__(96);
	exports.encode = exports.stringify = __webpack_require__(97);


/***/ },
/* 96 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};

	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }

	  var regexp = /\+/g;
	  qs = qs.split(sep);

	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }

	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }

	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;

	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }

	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);

	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }

	  return obj;
	};


/***/ },
/* 97 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	'use strict';

	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;

	    case 'boolean':
	      return v ? 'true' : 'false';

	    case 'number':
	      return isFinite(v) ? v : '';

	    default:
	      return '';
	  }
	};

	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }

	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);

	  }

	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(99);

	module.exports = function (obj, opts) {
	    if (!opts) opts = {};
	    if (typeof opts === 'function') opts = { cmp: opts };
	    var space = opts.space || '';
	    if (typeof space === 'number') space = Array(space+1).join(' ');
	    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
	    var replacer = opts.replacer || function(key, value) { return value; };

	    var cmp = opts.cmp && (function (f) {
	        return function (node) {
	            return function (a, b) {
	                var aobj = { key: a, value: node[a] };
	                var bobj = { key: b, value: node[b] };
	                return f(aobj, bobj);
	            };
	        };
	    })(opts.cmp);

	    var seen = [];
	    return (function stringify (parent, key, node, level) {
	        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
	        var colonSeparator = space ? ': ' : ':';

	        if (node && node.toJSON && typeof node.toJSON === 'function') {
	            node = node.toJSON();
	        }

	        node = replacer.call(parent, key, node);

	        if (node === undefined) {
	            return;
	        }
	        if (typeof node !== 'object' || node === null) {
	            return json.stringify(node);
	        }
	        if (isArray(node)) {
	            var out = [];
	            for (var i = 0; i < node.length; i++) {
	                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
	                out.push(indent + space + item);
	            }
	            return '[' + out.join(',') + indent + ']';
	        }
	        else {
	            if (seen.indexOf(node) !== -1) {
	                if (cycles) return json.stringify('__cycle__');
	                throw new TypeError('Converting circular structure to JSON');
	            }
	            else seen.push(node);

	            var keys = objectKeys(node).sort(cmp && cmp(node));
	            var out = [];
	            for (var i = 0; i < keys.length; i++) {
	                var key = keys[i];
	                var value = stringify(node, key, node[key], level+1);

	                if(!value) continue;

	                var keyValue = json.stringify(key)
	                    + colonSeparator
	                    + value;
	                ;
	                out.push(indent + space + keyValue);
	            }
	            return '{' + out.join(',') + indent + '}';
	        }
	    })({ '': obj }, '', obj, 0);
	};

	var isArray = Array.isArray || function (x) {
	    return {}.toString.call(x) === '[object Array]';
	};

	var objectKeys = Object.keys || function (obj) {
	    var has = Object.prototype.hasOwnProperty || function () { return true };
	    var keys = [];
	    for (var key in obj) {
	        if (has.call(obj, key)) keys.push(key);
	    }
	    return keys;
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	exports.parse = __webpack_require__(100);
	exports.stringify = __webpack_require__(101);


/***/ },
/* 100 */
/***/ function(module, exports) {

	var at, // The index of the current character
	    ch, // The current character
	    escapee = {
	        '"':  '"',
	        '\\': '\\',
	        '/':  '/',
	        b:    '\b',
	        f:    '\f',
	        n:    '\n',
	        r:    '\r',
	        t:    '\t'
	    },
	    text,

	    error = function (m) {
	        // Call error when something is wrong.
	        throw {
	            name:    'SyntaxError',
	            message: m,
	            at:      at,
	            text:    text
	        };
	    },
	    
	    next = function (c) {
	        // If a c parameter is provided, verify that it matches the current character.
	        if (c && c !== ch) {
	            error("Expected '" + c + "' instead of '" + ch + "'");
	        }
	        
	        // Get the next character. When there are no more characters,
	        // return the empty string.
	        
	        ch = text.charAt(at);
	        at += 1;
	        return ch;
	    },
	    
	    number = function () {
	        // Parse a number value.
	        var number,
	            string = '';
	        
	        if (ch === '-') {
	            string = '-';
	            next('-');
	        }
	        while (ch >= '0' && ch <= '9') {
	            string += ch;
	            next();
	        }
	        if (ch === '.') {
	            string += '.';
	            while (next() && ch >= '0' && ch <= '9') {
	                string += ch;
	            }
	        }
	        if (ch === 'e' || ch === 'E') {
	            string += ch;
	            next();
	            if (ch === '-' || ch === '+') {
	                string += ch;
	                next();
	            }
	            while (ch >= '0' && ch <= '9') {
	                string += ch;
	                next();
	            }
	        }
	        number = +string;
	        if (!isFinite(number)) {
	            error("Bad number");
	        } else {
	            return number;
	        }
	    },
	    
	    string = function () {
	        // Parse a string value.
	        var hex,
	            i,
	            string = '',
	            uffff;
	        
	        // When parsing for string values, we must look for " and \ characters.
	        if (ch === '"') {
	            while (next()) {
	                if (ch === '"') {
	                    next();
	                    return string;
	                } else if (ch === '\\') {
	                    next();
	                    if (ch === 'u') {
	                        uffff = 0;
	                        for (i = 0; i < 4; i += 1) {
	                            hex = parseInt(next(), 16);
	                            if (!isFinite(hex)) {
	                                break;
	                            }
	                            uffff = uffff * 16 + hex;
	                        }
	                        string += String.fromCharCode(uffff);
	                    } else if (typeof escapee[ch] === 'string') {
	                        string += escapee[ch];
	                    } else {
	                        break;
	                    }
	                } else {
	                    string += ch;
	                }
	            }
	        }
	        error("Bad string");
	    },

	    white = function () {

	// Skip whitespace.

	        while (ch && ch <= ' ') {
	            next();
	        }
	    },

	    word = function () {

	// true, false, or null.

	        switch (ch) {
	        case 't':
	            next('t');
	            next('r');
	            next('u');
	            next('e');
	            return true;
	        case 'f':
	            next('f');
	            next('a');
	            next('l');
	            next('s');
	            next('e');
	            return false;
	        case 'n':
	            next('n');
	            next('u');
	            next('l');
	            next('l');
	            return null;
	        }
	        error("Unexpected '" + ch + "'");
	    },

	    value,  // Place holder for the value function.

	    array = function () {

	// Parse an array value.

	        var array = [];

	        if (ch === '[') {
	            next('[');
	            white();
	            if (ch === ']') {
	                next(']');
	                return array;   // empty array
	            }
	            while (ch) {
	                array.push(value());
	                white();
	                if (ch === ']') {
	                    next(']');
	                    return array;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad array");
	    },

	    object = function () {

	// Parse an object value.

	        var key,
	            object = {};

	        if (ch === '{') {
	            next('{');
	            white();
	            if (ch === '}') {
	                next('}');
	                return object;   // empty object
	            }
	            while (ch) {
	                key = string();
	                white();
	                next(':');
	                if (Object.hasOwnProperty.call(object, key)) {
	                    error('Duplicate key "' + key + '"');
	                }
	                object[key] = value();
	                white();
	                if (ch === '}') {
	                    next('}');
	                    return object;
	                }
	                next(',');
	                white();
	            }
	        }
	        error("Bad object");
	    };

	value = function () {

	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.

	    white();
	    switch (ch) {
	    case '{':
	        return object();
	    case '[':
	        return array();
	    case '"':
	        return string();
	    case '-':
	        return number();
	    default:
	        return ch >= '0' && ch <= '9' ? number() : word();
	    }
	};

	// Return the json_parse function. It will have access to all of the above
	// functions and variables.

	module.exports = function (source, reviver) {
	    var result;
	    
	    text = source;
	    at = 0;
	    ch = ' ';
	    result = value();
	    white();
	    if (ch) {
	        error("Syntax error");
	    }

	    // If there is a reviver function, we recursively walk the new structure,
	    // passing each name/value pair to the reviver function for possible
	    // transformation, starting with a temporary root object that holds the result
	    // in an empty key. If there is not a reviver function, we simply return the
	    // result.

	    return typeof reviver === 'function' ? (function walk(holder, key) {
	        var k, v, value = holder[key];
	        if (value && typeof value === 'object') {
	            for (k in value) {
	                if (Object.prototype.hasOwnProperty.call(value, k)) {
	                    v = walk(value, k);
	                    if (v !== undefined) {
	                        value[k] = v;
	                    } else {
	                        delete value[k];
	                    }
	                }
	            }
	        }
	        return reviver.call(holder, key, value);
	    }({'': result}, '')) : result;
	};


/***/ },
/* 101 */
/***/ function(module, exports) {

	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	    gap,
	    indent,
	    meta = {    // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    },
	    rep;

	function quote(string) {
	    // If the string contains no control characters, no quote characters, and no
	    // backslash characters, then we can safely slap some quotes around it.
	    // Otherwise we must also replace the offending characters with safe escape
	    // sequences.
	    
	    escapable.lastIndex = 0;
	    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	        var c = meta[a];
	        return typeof c === 'string' ? c :
	            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	    }) + '"' : '"' + string + '"';
	}

	function str(key, holder) {
	    // Produce a string from holder[key].
	    var i,          // The loop counter.
	        k,          // The member key.
	        v,          // The member value.
	        length,
	        mind = gap,
	        partial,
	        value = holder[key];
	    
	    // If the value has a toJSON method, call it to obtain a replacement value.
	    if (value && typeof value === 'object' &&
	            typeof value.toJSON === 'function') {
	        value = value.toJSON(key);
	    }
	    
	    // If we were called with a replacer function, then call the replacer to
	    // obtain a replacement value.
	    if (typeof rep === 'function') {
	        value = rep.call(holder, key, value);
	    }
	    
	    // What happens next depends on the value's type.
	    switch (typeof value) {
	        case 'string':
	            return quote(value);
	        
	        case 'number':
	            // JSON numbers must be finite. Encode non-finite numbers as null.
	            return isFinite(value) ? String(value) : 'null';
	        
	        case 'boolean':
	        case 'null':
	            // If the value is a boolean or null, convert it to a string. Note:
	            // typeof null does not produce 'null'. The case is included here in
	            // the remote chance that this gets fixed someday.
	            return String(value);
	            
	        case 'object':
	            if (!value) return 'null';
	            gap += indent;
	            partial = [];
	            
	            // Array.isArray
	            if (Object.prototype.toString.apply(value) === '[object Array]') {
	                length = value.length;
	                for (i = 0; i < length; i += 1) {
	                    partial[i] = str(i, value) || 'null';
	                }
	                
	                // Join all of the elements together, separated with commas, and
	                // wrap them in brackets.
	                v = partial.length === 0 ? '[]' : gap ?
	                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
	                    '[' + partial.join(',') + ']';
	                gap = mind;
	                return v;
	            }
	            
	            // If the replacer is an array, use it to select the members to be
	            // stringified.
	            if (rep && typeof rep === 'object') {
	                length = rep.length;
	                for (i = 0; i < length; i += 1) {
	                    k = rep[i];
	                    if (typeof k === 'string') {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            else {
	                // Otherwise, iterate through all of the keys in the object.
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = str(k, value);
	                        if (v) {
	                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
	                        }
	                    }
	                }
	            }
	            
	        // Join all of the member texts together, separated with commas,
	        // and wrap them in braces.

	        v = partial.length === 0 ? '{}' : gap ?
	            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
	            '{' + partial.join(',') + '}';
	        gap = mind;
	        return v;
	    }
	}

	module.exports = function (value, replacer, space) {
	    var i;
	    gap = '';
	    indent = '';
	    
	    // If the space parameter is a number, make an indent string containing that
	    // many spaces.
	    if (typeof space === 'number') {
	        for (i = 0; i < space; i += 1) {
	            indent += ' ';
	        }
	    }
	    // If the space parameter is a string, it will be used as the indent string.
	    else if (typeof space === 'string') {
	        indent = space;
	    }

	    // If there is a replacer, it must be a function or an array.
	    // Otherwise, throw an error.
	    rep = replacer;
	    if (replacer && typeof replacer !== 'function'
	    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
	        throw new Error('JSON.stringify');
	    }
	    
	    // Make a fake root object containing our value under the key of ''.
	    // Return the result of stringifying the value.
	    return str('', {'': value});
	};


/***/ }
/******/ ]);