module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(1);
	/***
	 * Load API synchronously
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param expand Whether to expand traits and resource types
	 * @return Opt<Api>. Call .isDefined() Opt member to find out if the result actually contains an Api. Call .getOrThrow() Opt member to retrieve the Api.
	 ***/
	function loadApi(apiPath, expand) {
	    if (expand === void 0) { expand = true; }
	    return RamlWrapper.loadApi(apiPath, expand);
	}
	exports.loadApi = loadApi;
	/***
	 * Load API asynchronously
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param expand Whether to expand traits and resource types
	 * @return Promise<Api>
	 ***/
	function loadApiAsync(apiPath, expand) {
	    if (expand === void 0) { expand = true; }
	    return RamlWrapper.loadApiAsync(apiPath, expand);
	}
	exports.loadApiAsync = loadApiAsync;
	/***
	 * Turn model node into an object. Should not be relied on for API analysis and manipulation by the parser users.
	 * @param node Model node
	 * @return Stringifyable object representation of the node.
	 ***/
	function toJSON(node, serializeOptions) {
	    return RamlWrapper.toJSON(node, serializeOptions);
	}
	exports.toJSON = toJSON;
	;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/*****************************************************
	 * <p>See <a href="http://raml.org">http://raml.org</a> for more information about RAML.</p>
	 *
	 * <p>This parser is at a beta state of development, as part of the API Workbench development cycle (<a href="http://apiworkbench.com">http://apiworkbench.com</a>).</p>
	 *
	 * <h2>Installation</h2>
	 *
	 * <pre><code>git clone https://github.com/raml-org/raml-js-parser-2
	 *
	 * cd raml-js-parser-2
	 *
	 * npm install
	 *
	 * node test/test.js  //here you should observe JSON representation of XKCD API in your console
	 *
	 * node test/testAsync.js  //same as above but in asynchronous mode
	 * </code></pre>
	 *
	 * <h2>Usage</h2>
	 *
	 * <ul>
	 * <li>For parser usage example refer to <code>test/test.js</code></li>
	 * <li>For asynchrounous usage example refer to <code>test/test.js</code></li>
	 * </ul>
	 ****************************************************/
	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var hl = __webpack_require__(2);
	var json2lowlevel = __webpack_require__(60);
	var core = __webpack_require__(85);
	var apiLoader = __webpack_require__(86);
	var helper = __webpack_require__(88);
	var RAMLLanguageElementImpl = (function (_super) {
	    __extends(RAMLLanguageElementImpl, _super);
	    function RAMLLanguageElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLLanguageElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLLanguageElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLLanguageElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLLanguageElementImpl.prototype.getKind = function () {
	        return "RAMLLanguageElement";
	    };
	    /***
	     * The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     ***/
	    RAMLLanguageElementImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    RAMLLanguageElementImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]
	     ***/
	    RAMLLanguageElementImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    RAMLLanguageElementImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return RAMLLanguageElementImpl;
	})(core.BasicNodeImpl);
	exports.RAMLLanguageElementImpl = RAMLLanguageElementImpl;
	var ValueTypeImpl = (function () {
	    function ValueTypeImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ValueTypeImpl.prototype.wrapperClassName = function () {
	        return "ValueTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ValueTypeImpl.prototype.getKind = function () {
	        return "ValueType";
	    };
	    /***
	     * @return String representation of the node value
	     ***/
	    ValueTypeImpl.prototype.value = function () {
	        return this.attr.value();
	    };
	    /***
	     * @return Underlying High Level attribute node
	     ***/
	    ValueTypeImpl.prototype.highLevel = function () {
	        return this.attr;
	    };
	    return ValueTypeImpl;
	})();
	exports.ValueTypeImpl = ValueTypeImpl;
	var NumberTypeImpl = (function (_super) {
	    __extends(NumberTypeImpl, _super);
	    function NumberTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    NumberTypeImpl.prototype.wrapperClassName = function () {
	        return "NumberTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    NumberTypeImpl.prototype.getKind = function () {
	        return "NumberType";
	    };
	    return NumberTypeImpl;
	})(ValueTypeImpl);
	exports.NumberTypeImpl = NumberTypeImpl;
	var BooleanTypeImpl = (function (_super) {
	    __extends(BooleanTypeImpl, _super);
	    function BooleanTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    BooleanTypeImpl.prototype.wrapperClassName = function () {
	        return "BooleanTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    BooleanTypeImpl.prototype.getKind = function () {
	        return "BooleanType";
	    };
	    return BooleanTypeImpl;
	})(ValueTypeImpl);
	exports.BooleanTypeImpl = BooleanTypeImpl;
	var ReferenceImpl = (function () {
	    function ReferenceImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ReferenceImpl.prototype.wrapperClassName = function () {
	        return "ReferenceImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ReferenceImpl.prototype.getKind = function () {
	        return "Reference";
	    };
	    /***
	     * @return StructuredValue object representing the node value
	     ***/
	    ReferenceImpl.prototype.value = function () {
	        return core.toStructuredValue(this.attr);
	    };
	    return ReferenceImpl;
	})();
	exports.ReferenceImpl = ReferenceImpl;
	var ResourceTypeRefImpl = (function (_super) {
	    __extends(ResourceTypeRefImpl, _super);
	    function ResourceTypeRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceTypeRefImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceTypeRefImpl.prototype.getKind = function () {
	        return "ResourceTypeRef";
	    };
	    return ResourceTypeRefImpl;
	})(ReferenceImpl);
	exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
	var TraitRefImpl = (function (_super) {
	    __extends(TraitRefImpl, _super);
	    function TraitRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    TraitRefImpl.prototype.wrapperClassName = function () {
	        return "TraitRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    TraitRefImpl.prototype.getKind = function () {
	        return "TraitRef";
	    };
	    return TraitRefImpl;
	})(ReferenceImpl);
	exports.TraitRefImpl = TraitRefImpl;
	var SecuritySchemaRefImpl = (function (_super) {
	    __extends(SecuritySchemaRefImpl, _super);
	    function SecuritySchemaRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaRefImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaRefImpl.prototype.getKind = function () {
	        return "SecuritySchemaRef";
	    };
	    return SecuritySchemaRefImpl;
	})(ReferenceImpl);
	exports.SecuritySchemaRefImpl = SecuritySchemaRefImpl;
	/***
	 * Annotations allow you to attach information to your API
	 ***/
	var AnnotationRefImpl = (function (_super) {
	    __extends(AnnotationRefImpl, _super);
	    function AnnotationRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    AnnotationRefImpl.prototype.wrapperClassName = function () {
	        return "AnnotationRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    AnnotationRefImpl.prototype.getKind = function () {
	        return "AnnotationRef";
	    };
	    return AnnotationRefImpl;
	})(ReferenceImpl);
	exports.AnnotationRefImpl = AnnotationRefImpl;
	var DataElementRefImpl = (function (_super) {
	    __extends(DataElementRefImpl, _super);
	    function DataElementRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DataElementRefImpl.prototype.wrapperClassName = function () {
	        return "DataElementRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DataElementRefImpl.prototype.getKind = function () {
	        return "DataElementRef";
	    };
	    return DataElementRefImpl;
	})(ReferenceImpl);
	exports.DataElementRefImpl = DataElementRefImpl;
	var ramlexpressionImpl = (function (_super) {
	    __extends(ramlexpressionImpl, _super);
	    function ramlexpressionImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ramlexpressionImpl.prototype.wrapperClassName = function () {
	        return "ramlexpressionImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ramlexpressionImpl.prototype.getKind = function () {
	        return "ramlexpression";
	    };
	    return ramlexpressionImpl;
	})(ValueTypeImpl);
	exports.ramlexpressionImpl = ramlexpressionImpl;
	/***
	 * Elements to which this Annotation can be applied (enum)
	 ***/
	var AnnotationTargetImpl = (function (_super) {
	    __extends(AnnotationTargetImpl, _super);
	    function AnnotationTargetImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    AnnotationTargetImpl.prototype.wrapperClassName = function () {
	        return "AnnotationTargetImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    AnnotationTargetImpl.prototype.getKind = function () {
	        return "AnnotationTarget";
	    };
	    return AnnotationTargetImpl;
	})(ValueTypeImpl);
	exports.AnnotationTargetImpl = AnnotationTargetImpl;
	var pointerImpl = (function (_super) {
	    __extends(pointerImpl, _super);
	    function pointerImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    pointerImpl.prototype.wrapperClassName = function () {
	        return "pointerImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    pointerImpl.prototype.getKind = function () {
	        return "pointer";
	    };
	    return pointerImpl;
	})(ValueTypeImpl);
	exports.pointerImpl = pointerImpl;
	var StringTypeImpl = (function (_super) {
	    __extends(StringTypeImpl, _super);
	    function StringTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    StringTypeImpl.prototype.wrapperClassName = function () {
	        return "StringTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    StringTypeImpl.prototype.getKind = function () {
	        return "StringType";
	    };
	    return StringTypeImpl;
	})(ValueTypeImpl);
	exports.StringTypeImpl = StringTypeImpl;
	/***
	 * This type currently serves both for absolute and relative urls
	 ***/
	var UriTemplateImpl = (function (_super) {
	    __extends(UriTemplateImpl, _super);
	    function UriTemplateImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    UriTemplateImpl.prototype.wrapperClassName = function () {
	        return "UriTemplateImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    UriTemplateImpl.prototype.getKind = function () {
	        return "UriTemplate";
	    };
	    return UriTemplateImpl;
	})(StringTypeImpl);
	exports.UriTemplateImpl = UriTemplateImpl;
	/***
	 * This  type describes relative uri templates
	 ***/
	var RelativeUriImpl = (function (_super) {
	    __extends(RelativeUriImpl, _super);
	    function RelativeUriImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RelativeUriImpl.prototype.wrapperClassName = function () {
	        return "RelativeUriImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RelativeUriImpl.prototype.getKind = function () {
	        return "RelativeUri";
	    };
	    return RelativeUriImpl;
	})(UriTemplateImpl);
	exports.RelativeUriImpl = RelativeUriImpl;
	/***
	 * This  type describes absolute uri templates
	 ***/
	var FullUriTemplateImpl = (function (_super) {
	    __extends(FullUriTemplateImpl, _super);
	    function FullUriTemplateImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FullUriTemplateImpl.prototype.wrapperClassName = function () {
	        return "FullUriTemplateImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FullUriTemplateImpl.prototype.getKind = function () {
	        return "FullUriTemplate";
	    };
	    return FullUriTemplateImpl;
	})(UriTemplateImpl);
	exports.FullUriTemplateImpl = FullUriTemplateImpl;
	var StatusCodeImpl = (function (_super) {
	    __extends(StatusCodeImpl, _super);
	    function StatusCodeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    StatusCodeImpl.prototype.wrapperClassName = function () {
	        return "StatusCodeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    StatusCodeImpl.prototype.getKind = function () {
	        return "StatusCode";
	    };
	    return StatusCodeImpl;
	})(StringTypeImpl);
	exports.StatusCodeImpl = StatusCodeImpl;
	/***
	 * This  type describes fixed uris
	 ***/
	var FixedUriImpl = (function (_super) {
	    __extends(FixedUriImpl, _super);
	    function FixedUriImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FixedUriImpl.prototype.wrapperClassName = function () {
	        return "FixedUriImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FixedUriImpl.prototype.getKind = function () {
	        return "FixedUri";
	    };
	    return FixedUriImpl;
	})(StringTypeImpl);
	exports.FixedUriImpl = FixedUriImpl;
	var ContentTypeImpl = (function (_super) {
	    __extends(ContentTypeImpl, _super);
	    function ContentTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ContentTypeImpl.prototype.wrapperClassName = function () {
	        return "ContentTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ContentTypeImpl.prototype.getKind = function () {
	        return "ContentType";
	    };
	    return ContentTypeImpl;
	})(StringTypeImpl);
	exports.ContentTypeImpl = ContentTypeImpl;
	var ValidityExpressionImpl = (function (_super) {
	    __extends(ValidityExpressionImpl, _super);
	    function ValidityExpressionImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ValidityExpressionImpl.prototype.wrapperClassName = function () {
	        return "ValidityExpressionImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ValidityExpressionImpl.prototype.getKind = function () {
	        return "ValidityExpression";
	    };
	    return ValidityExpressionImpl;
	})(StringTypeImpl);
	exports.ValidityExpressionImpl = ValidityExpressionImpl;
	var DateFormatSpecImpl = (function (_super) {
	    __extends(DateFormatSpecImpl, _super);
	    function DateFormatSpecImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DateFormatSpecImpl.prototype.wrapperClassName = function () {
	        return "DateFormatSpecImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DateFormatSpecImpl.prototype.getKind = function () {
	        return "DateFormatSpec";
	    };
	    return DateFormatSpecImpl;
	})(StringTypeImpl);
	exports.DateFormatSpecImpl = DateFormatSpecImpl;
	var FunctionalInterfaceImpl = (function (_super) {
	    __extends(FunctionalInterfaceImpl, _super);
	    function FunctionalInterfaceImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FunctionalInterfaceImpl.prototype.wrapperClassName = function () {
	        return "FunctionalInterfaceImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FunctionalInterfaceImpl.prototype.getKind = function () {
	        return "FunctionalInterface";
	    };
	    return FunctionalInterfaceImpl;
	})(StringTypeImpl);
	exports.FunctionalInterfaceImpl = FunctionalInterfaceImpl;
	/***
	 * Schema at this moment only two subtypes are supported (json schema and xsd)
	 ***/
	var SchemaStringImpl = (function (_super) {
	    __extends(SchemaStringImpl, _super);
	    function SchemaStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SchemaStringImpl.prototype.wrapperClassName = function () {
	        return "SchemaStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SchemaStringImpl.prototype.getKind = function () {
	        return "SchemaString";
	    };
	    return SchemaStringImpl;
	})(StringTypeImpl);
	exports.SchemaStringImpl = SchemaStringImpl;
	/***
	 * JSON schema
	 ***/
	var JSonSchemaStringImpl = (function (_super) {
	    __extends(JSonSchemaStringImpl, _super);
	    function JSonSchemaStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    JSonSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "JSonSchemaStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    JSonSchemaStringImpl.prototype.getKind = function () {
	        return "JSonSchemaString";
	    };
	    return JSonSchemaStringImpl;
	})(SchemaStringImpl);
	exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
	/***
	 * XSD schema
	 ***/
	var XMLSchemaStringImpl = (function (_super) {
	    __extends(XMLSchemaStringImpl, _super);
	    function XMLSchemaStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    XMLSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "XMLSchemaStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    XMLSchemaStringImpl.prototype.getKind = function () {
	        return "XMLSchemaString";
	    };
	    return XMLSchemaStringImpl;
	})(SchemaStringImpl);
	exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
	/***
	 * Examples at this moment only two subtypes are supported (json  and xml)
	 ***/
	var ExampleStringImpl = (function (_super) {
	    __extends(ExampleStringImpl, _super);
	    function ExampleStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ExampleStringImpl.prototype.wrapperClassName = function () {
	        return "ExampleStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ExampleStringImpl.prototype.getKind = function () {
	        return "ExampleString";
	    };
	    return ExampleStringImpl;
	})(StringTypeImpl);
	exports.ExampleStringImpl = ExampleStringImpl;
	/***
	 * script to inject to tooling environment
	 ***/
	var ScriptingHookImpl = (function (_super) {
	    __extends(ScriptingHookImpl, _super);
	    function ScriptingHookImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ScriptingHookImpl.prototype.wrapperClassName = function () {
	        return "ScriptingHookImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ScriptingHookImpl.prototype.getKind = function () {
	        return "ScriptingHook";
	    };
	    return ScriptingHookImpl;
	})(StringTypeImpl);
	exports.ScriptingHookImpl = ScriptingHookImpl;
	var SecuritySchemaHookScriptImpl = (function (_super) {
	    __extends(SecuritySchemaHookScriptImpl, _super);
	    function SecuritySchemaHookScriptImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaHookScriptImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaHookScriptImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaHookScriptImpl.prototype.getKind = function () {
	        return "SecuritySchemaHookScript";
	    };
	    return SecuritySchemaHookScriptImpl;
	})(ScriptingHookImpl);
	exports.SecuritySchemaHookScriptImpl = SecuritySchemaHookScriptImpl;
	var RAMLPointerImpl = (function (_super) {
	    __extends(RAMLPointerImpl, _super);
	    function RAMLPointerImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLPointerImpl.prototype.wrapperClassName = function () {
	        return "RAMLPointerImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLPointerImpl.prototype.getKind = function () {
	        return "RAMLPointer";
	    };
	    return RAMLPointerImpl;
	})(StringTypeImpl);
	exports.RAMLPointerImpl = RAMLPointerImpl;
	var RAMLSelectorImpl = (function (_super) {
	    __extends(RAMLSelectorImpl, _super);
	    function RAMLSelectorImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLSelectorImpl.prototype.wrapperClassName = function () {
	        return "RAMLSelectorImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLSelectorImpl.prototype.getKind = function () {
	        return "RAMLSelector";
	    };
	    return RAMLSelectorImpl;
	})(StringTypeImpl);
	exports.RAMLSelectorImpl = RAMLSelectorImpl;
	/***
	 * This sub type of the string represents mime types
	 ***/
	var MimeTypeImpl = (function (_super) {
	    __extends(MimeTypeImpl, _super);
	    function MimeTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MimeTypeImpl.prototype.wrapperClassName = function () {
	        return "MimeTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MimeTypeImpl.prototype.getKind = function () {
	        return "MimeType";
	    };
	    return MimeTypeImpl;
	})(StringTypeImpl);
	exports.MimeTypeImpl = MimeTypeImpl;
	/***
	 * [GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)
	 ***/
	var MarkdownStringImpl = (function (_super) {
	    __extends(MarkdownStringImpl, _super);
	    function MarkdownStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MarkdownStringImpl.prototype.wrapperClassName = function () {
	        return "MarkdownStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MarkdownStringImpl.prototype.getKind = function () {
	        return "MarkdownString";
	    };
	    return MarkdownStringImpl;
	})(StringTypeImpl);
	exports.MarkdownStringImpl = MarkdownStringImpl;
	var DocumentationItemImpl = (function (_super) {
	    __extends(DocumentationItemImpl, _super);
	    function DocumentationItemImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DocumentationItemImpl.prototype.wrapperClassName = function () {
	        return "DocumentationItemImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DocumentationItemImpl.prototype.getKind = function () {
	        return "DocumentationItem";
	    };
	    /***
	     * Title of documentation section
	     ***/
	    DocumentationItemImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /***
	     * @hidden
	     * Set title value
	     ***/
	    DocumentationItemImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /***
	     * Content of documentation section
	     ***/
	    DocumentationItemImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return DocumentationItemImpl;
	})(RAMLLanguageElementImpl);
	exports.DocumentationItemImpl = DocumentationItemImpl;
	var ScriptSpecImpl = (function (_super) {
	    __extends(ScriptSpecImpl, _super);
	    function ScriptSpecImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createScriptSpec(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ScriptSpecImpl.prototype.wrapperClassName = function () {
	        return "ScriptSpecImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ScriptSpecImpl.prototype.getKind = function () {
	        return "ScriptSpec";
	    };
	    ScriptSpecImpl.prototype.language = function () {
	        return _super.prototype.attribute.call(this, 'language', this.toString);
	    };
	    /***
	     * @hidden
	     * Set language value
	     ***/
	    ScriptSpecImpl.prototype.setLanguage = function (param) {
	        this.highLevel().attrOrCreate("language").setValue("" + param);
	        return this;
	    };
	    ScriptSpecImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', this.toString);
	    };
	    /***
	     * @hidden
	     * Set content value
	     ***/
	    ScriptSpecImpl.prototype.setContent = function (param) {
	        this.highLevel().attrOrCreate("content").setValue("" + param);
	        return this;
	    };
	    return ScriptSpecImpl;
	})(RAMLLanguageElementImpl);
	exports.ScriptSpecImpl = ScriptSpecImpl;
	var ApiDescriptionImpl = (function (_super) {
	    __extends(ApiDescriptionImpl, _super);
	    function ApiDescriptionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createApiDescription(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ApiDescriptionImpl.prototype.wrapperClassName = function () {
	        return "ApiDescriptionImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ApiDescriptionImpl.prototype.getKind = function () {
	        return "ApiDescription";
	    };
	    ApiDescriptionImpl.prototype.apiFiles = function () {
	        return _super.prototype.elements.call(this, 'apiFiles');
	    };
	    ApiDescriptionImpl.prototype.script = function () {
	        return _super.prototype.elements.call(this, 'script');
	    };
	    ApiDescriptionImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /***
	     * @hidden
	     * Set type value
	     ***/
	    ApiDescriptionImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    return ApiDescriptionImpl;
	})(RAMLLanguageElementImpl);
	exports.ApiDescriptionImpl = ApiDescriptionImpl;
	var CallbackAPIDescriptionImpl = (function (_super) {
	    __extends(CallbackAPIDescriptionImpl, _super);
	    function CallbackAPIDescriptionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createCallbackAPIDescription(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    CallbackAPIDescriptionImpl.prototype.wrapperClassName = function () {
	        return "CallbackAPIDescriptionImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    CallbackAPIDescriptionImpl.prototype.getKind = function () {
	        return "CallbackAPIDescription";
	    };
	    CallbackAPIDescriptionImpl.prototype.callbackFor = function () {
	        return _super.prototype.element.call(this, 'callbackFor');
	    };
	    return CallbackAPIDescriptionImpl;
	})(ApiDescriptionImpl);
	exports.CallbackAPIDescriptionImpl = CallbackAPIDescriptionImpl;
	var RAMLProjectImpl = (function (_super) {
	    __extends(RAMLProjectImpl, _super);
	    function RAMLProjectImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLProject(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLProjectImpl.prototype.wrapperClassName = function () {
	        return "RAMLProjectImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLProjectImpl.prototype.getKind = function () {
	        return "RAMLProject";
	    };
	    RAMLProjectImpl.prototype.relatedProjects = function () {
	        return _super.prototype.elements.call(this, 'relatedProjects');
	    };
	    RAMLProjectImpl.prototype.declaredApis = function () {
	        return _super.prototype.elements.call(this, 'declaredApis');
	    };
	    RAMLProjectImpl.prototype.license = function () {
	        return _super.prototype.attribute.call(this, 'license', this.toString);
	    };
	    /***
	     * @hidden
	     * Set license value
	     ***/
	    RAMLProjectImpl.prototype.setLicense = function (param) {
	        this.highLevel().attrOrCreate("license").setValue("" + param);
	        return this;
	    };
	    RAMLProjectImpl.prototype.overview = function () {
	        return _super.prototype.attribute.call(this, 'overview', this.toString);
	    };
	    /***
	     * @hidden
	     * Set overview value
	     ***/
	    RAMLProjectImpl.prototype.setOverview = function (param) {
	        this.highLevel().attrOrCreate("overview").setValue("" + param);
	        return this;
	    };
	    RAMLProjectImpl.prototype.url = function () {
	        return _super.prototype.attribute.call(this, 'url', this.toString);
	    };
	    /***
	     * @hidden
	     * Set url value
	     ***/
	    RAMLProjectImpl.prototype.setUrl = function (param) {
	        this.highLevel().attrOrCreate("url").setValue("" + param);
	        return this;
	    };
	    return RAMLProjectImpl;
	})(RAMLLanguageElementImpl);
	exports.RAMLProjectImpl = RAMLProjectImpl;
	/***
	 * Security schema type allows you to contribute your own security schema type with settings and optinal configurator for plugging into client sdks auth mechanism
	 ***/
	var SecuritySchemaTypeImpl = (function (_super) {
	    __extends(SecuritySchemaTypeImpl, _super);
	    function SecuritySchemaTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaTypeImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaTypeImpl.prototype.getKind = function () {
	        return "SecuritySchemaType";
	    };
	    /***
	     * You may declare settings needed to use this type of security security schemas
	     ***/
	    SecuritySchemaTypeImpl.prototype.requiredSettings = function () {
	        return _super.prototype.elements.call(this, 'requiredSettings');
	    };
	    /***
	     * The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.
	     * This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation.
	     ***/
	    SecuritySchemaTypeImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    return SecuritySchemaTypeImpl;
	})(RAMLLanguageElementImpl);
	exports.SecuritySchemaTypeImpl = SecuritySchemaTypeImpl;
	var DataElementImpl = (function (_super) {
	    __extends(DataElementImpl, _super);
	    function DataElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDataElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DataElementImpl.prototype.wrapperClassName = function () {
	        return "DataElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DataElementImpl.prototype.getKind = function () {
	        return "DataElement";
	    };
	    /***
	     * name of the parameter
	     ***/
	    DataElementImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    DataElementImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    DataElementImpl.prototype.xml = function () {
	        return _super.prototype.element.call(this, 'xml');
	    };
	    /***
	     * When extending from a type you can define new facets (which can then be set to concrete values by subtypes).
	     ***/
	    DataElementImpl.prototype.facets = function () {
	        return _super.prototype.elements.call(this, 'facets');
	    };
	    /***
	     * Alias for the type property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version.
	     ***/
	    DataElementImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', this.toString);
	    };
	    /***
	     * @hidden
	     * Set schema value
	     ***/
	    DataElementImpl.prototype.setSchema = function (param) {
	        this.highLevel().attrOrCreate("schema").setValue("" + param);
	        return this;
	    };
	    DataElementImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    DataElementImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /***
	     * A base type which the current type extends, or more generally a type expression.
	     ***/
	    DataElementImpl.prototype["type"] = function () {
	        return _super.prototype.attributes.call(this, 'type', this.toString);
	    };
	    /***
	     * @hidden
	     * Set type value
	     ***/
	    DataElementImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /***
	     * Location of the parameter (can not be edited by user)
	     ***/
	    DataElementImpl.prototype.location = function () {
	        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ModelLocationImpl(attr); });
	    };
	    /***
	     * Kind of location
	     ***/
	    DataElementImpl.prototype.locationKind = function () {
	        return _super.prototype.attribute.call(this, 'locationKind', function (attr) { return new LocationKindImpl(attr); });
	    };
	    /***
	     * Provides default value for a property
	     ***/
	    DataElementImpl.prototype["default"] = function () {
	        return _super.prototype.attribute.call(this, 'default', this.toString);
	    };
	    /***
	     * @hidden
	     * Set default value
	     ***/
	    DataElementImpl.prototype.setDefault = function (param) {
	        this.highLevel().attrOrCreate("default").setValue("" + param);
	        return this;
	    };
	    /***
	     * An example of an instance of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
	     ***/
	    DataElementImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', this.toString);
	    };
	    /***
	     * @hidden
	     * Set example value
	     ***/
	    DataElementImpl.prototype.setExample = function (param) {
	        this.highLevel().attrOrCreate("example").setValue("" + param);
	        return this;
	    };
	    /***
	     * An object containing named examples of instances of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present.
	     ***/
	    DataElementImpl.prototype.examples = function () {
	        return _super.prototype.elements.call(this, 'examples');
	    };
	    /***
	     * The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated.
	     ***/
	    DataElementImpl.prototype.repeat = function () {
	        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set repeat value
	     ***/
	    DataElementImpl.prototype.setRepeat = function (param) {
	        this.highLevel().attrOrCreate("repeat").setValue("" + param);
	        return this;
	    };
	    /***
	     * Sets if property is optional or not
	     ***/
	    DataElementImpl.prototype.required = function () {
	        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set required value
	     ***/
	    DataElementImpl.prototype.setRequired = function (param) {
	        this.highLevel().attrOrCreate("required").setValue("" + param);
	        return this;
	    };
	    /***
	     * An alternate, human-friendly name for the type
	     ***/
	    DataElementImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    DataElementImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the type
	     ***/
	    DataElementImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    DataElementImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return DataElementImpl;
	})(RAMLLanguageElementImpl);
	exports.DataElementImpl = DataElementImpl;
	var XMLInfoImpl = (function (_super) {
	    __extends(XMLInfoImpl, _super);
	    function XMLInfoImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createXMLInfo(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    XMLInfoImpl.prototype.wrapperClassName = function () {
	        return "XMLInfoImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    XMLInfoImpl.prototype.getKind = function () {
	        return "XMLInfo";
	    };
	    XMLInfoImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    XMLInfoImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    XMLInfoImpl.prototype.namespace = function () {
	        return _super.prototype.attribute.call(this, 'namespace', this.toString);
	    };
	    /***
	     * @hidden
	     * Set namespace value
	     ***/
	    XMLInfoImpl.prototype.setNamespace = function (param) {
	        this.highLevel().attrOrCreate("namespace").setValue("" + param);
	        return this;
	    };
	    XMLInfoImpl.prototype.prefix = function () {
	        return _super.prototype.attribute.call(this, 'prefix', this.toString);
	    };
	    /***
	     * @hidden
	     * Set prefix value
	     ***/
	    XMLInfoImpl.prototype.setPrefix = function (param) {
	        this.highLevel().attrOrCreate("prefix").setValue("" + param);
	        return this;
	    };
	    XMLInfoImpl.prototype.attribute = function () {
	        return _super.prototype.attribute.call(this, 'attribute', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set attribute value
	     ***/
	    XMLInfoImpl.prototype.setAttribute = function (param) {
	        this.highLevel().attrOrCreate("attribute").setValue("" + param);
	        return this;
	    };
	    XMLInfoImpl.prototype.wrapped = function () {
	        return _super.prototype.attribute.call(this, 'wrapped', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set wrapped value
	     ***/
	    XMLInfoImpl.prototype.setWrapped = function (param) {
	        this.highLevel().attrOrCreate("wrapped").setValue("" + param);
	        return this;
	    };
	    return XMLInfoImpl;
	})(core.BasicNodeImpl);
	exports.XMLInfoImpl = XMLInfoImpl;
	var ModelLocationImpl = (function () {
	    function ModelLocationImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ModelLocationImpl.prototype.wrapperClassName = function () {
	        return "ModelLocationImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ModelLocationImpl.prototype.getKind = function () {
	        return "ModelLocation";
	    };
	    return ModelLocationImpl;
	})();
	exports.ModelLocationImpl = ModelLocationImpl;
	var LocationKindImpl = (function () {
	    function LocationKindImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    LocationKindImpl.prototype.wrapperClassName = function () {
	        return "LocationKindImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    LocationKindImpl.prototype.getKind = function () {
	        return "LocationKind";
	    };
	    return LocationKindImpl;
	})();
	exports.LocationKindImpl = LocationKindImpl;
	var ExampleSpecImpl = (function (_super) {
	    __extends(ExampleSpecImpl, _super);
	    function ExampleSpecImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createExampleSpec(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ExampleSpecImpl.prototype.wrapperClassName = function () {
	        return "ExampleSpecImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ExampleSpecImpl.prototype.getKind = function () {
	        return "ExampleSpec";
	    };
	    /***
	     * The example itself
	     ***/
	    ExampleSpecImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', this.toString);
	    };
	    /***
	     * @hidden
	     * Set content value
	     ***/
	    ExampleSpecImpl.prototype.setContent = function (param) {
	        this.highLevel().attrOrCreate("content").setValue("" + param);
	        return this;
	    };
	    /***
	     * By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate.
	     ***/
	    ExampleSpecImpl.prototype.strict = function () {
	        return _super.prototype.attribute.call(this, 'strict', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set strict value
	     ***/
	    ExampleSpecImpl.prototype.setStrict = function (param) {
	        this.highLevel().attrOrCreate("strict").setValue("" + param);
	        return this;
	    };
	    ExampleSpecImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    ExampleSpecImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * An alternate, human-friendly name for the example
	     ***/
	    ExampleSpecImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    ExampleSpecImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the example
	     ***/
	    ExampleSpecImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    ExampleSpecImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return ExampleSpecImpl;
	})(RAMLLanguageElementImpl);
	exports.ExampleSpecImpl = ExampleSpecImpl;
	/***
	 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
	 ***/
	var FileParameterImpl = (function (_super) {
	    __extends(FileParameterImpl, _super);
	    function FileParameterImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createFileParameter(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FileParameterImpl.prototype.wrapperClassName = function () {
	        return "FileParameterImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FileParameterImpl.prototype.getKind = function () {
	        return "FileParameter";
	    };
	    /***
	     * It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type * /* should be a valid value.
	     ***/
	    FileParameterImpl.prototype.fileTypes = function () {
	        return _super.prototype.attributes.call(this, 'fileTypes', function (attr) { return new ContentTypeImpl(attr); });
	    };
	    /***
	     * The minLength attribute specifies the parameter value's minimum number of bytes.
	     ***/
	    FileParameterImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minLength value
	     ***/
	    FileParameterImpl.prototype.setMinLength = function (param) {
	        this.highLevel().attrOrCreate("minLength").setValue("" + param);
	        return this;
	    };
	    /***
	     * The maxLength attribute specifies the parameter value's maximum number of bytes.
	     ***/
	    FileParameterImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maxLength value
	     ***/
	    FileParameterImpl.prototype.setMaxLength = function (param) {
	        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	        return this;
	    };
	    return FileParameterImpl;
	})(DataElementImpl);
	exports.FileParameterImpl = FileParameterImpl;
	var ArrayFieldImpl = (function (_super) {
	    __extends(ArrayFieldImpl, _super);
	    function ArrayFieldImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createArrayField(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ArrayFieldImpl.prototype.wrapperClassName = function () {
	        return "ArrayFieldImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ArrayFieldImpl.prototype.getKind = function () {
	        return "ArrayField";
	    };
	    /***
	     * Should items in array be unique
	     ***/
	    ArrayFieldImpl.prototype.uniqueItems = function () {
	        return _super.prototype.attribute.call(this, 'uniqueItems', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set uniqueItems value
	     ***/
	    ArrayFieldImpl.prototype.setUniqueItems = function (param) {
	        this.highLevel().attrOrCreate("uniqueItems").setValue("" + param);
	        return this;
	    };
	    /***
	     * Array component type.
	     ***/
	    ArrayFieldImpl.prototype.items = function () {
	        return _super.prototype.element.call(this, 'items');
	    };
	    /***
	     * Minimum amount of items in array
	     ***/
	    ArrayFieldImpl.prototype.minItems = function () {
	        return _super.prototype.attribute.call(this, 'minItems', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minItems value
	     ***/
	    ArrayFieldImpl.prototype.setMinItems = function (param) {
	        this.highLevel().attrOrCreate("minItems").setValue("" + param);
	        return this;
	    };
	    /***
	     * Maximum amount of items in array
	     ***/
	    ArrayFieldImpl.prototype.maxItems = function () {
	        return _super.prototype.attribute.call(this, 'maxItems', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maxItems value
	     ***/
	    ArrayFieldImpl.prototype.setMaxItems = function (param) {
	        this.highLevel().attrOrCreate("maxItems").setValue("" + param);
	        return this;
	    };
	    return ArrayFieldImpl;
	})(DataElementImpl);
	exports.ArrayFieldImpl = ArrayFieldImpl;
	var UnionFieldImpl = (function (_super) {
	    __extends(UnionFieldImpl, _super);
	    function UnionFieldImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createUnionField(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    UnionFieldImpl.prototype.wrapperClassName = function () {
	        return "UnionFieldImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    UnionFieldImpl.prototype.getKind = function () {
	        return "UnionField";
	    };
	    /***
	     * Type property name to be used as a discriminator or boolean
	     ***/
	    UnionFieldImpl.prototype.discriminator = function () {
	        return _super.prototype.attribute.call(this, 'discriminator', this.toString);
	    };
	    /***
	     * @hidden
	     * Set discriminator value
	     ***/
	    UnionFieldImpl.prototype.setDiscriminator = function (param) {
	        this.highLevel().attrOrCreate("discriminator").setValue("" + param);
	        return this;
	    };
	    return UnionFieldImpl;
	})(DataElementImpl);
	exports.UnionFieldImpl = UnionFieldImpl;
	var ObjectFieldImpl = (function (_super) {
	    __extends(ObjectFieldImpl, _super);
	    function ObjectFieldImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createObjectField(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ObjectFieldImpl.prototype.wrapperClassName = function () {
	        return "ObjectFieldImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ObjectFieldImpl.prototype.getKind = function () {
	        return "ObjectField";
	    };
	    /***
	     * The properties that instances of this type may or must have.
	     ***/
	    ObjectFieldImpl.prototype.properties = function () {
	        return _super.prototype.elements.call(this, 'properties');
	    };
	    /***
	     * The minimum number of properties allowed for instances of this type.
	     ***/
	    ObjectFieldImpl.prototype.minProperties = function () {
	        return _super.prototype.attribute.call(this, 'minProperties', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minProperties value
	     ***/
	    ObjectFieldImpl.prototype.setMinProperties = function (param) {
	        this.highLevel().attrOrCreate("minProperties").setValue("" + param);
	        return this;
	    };
	    /***
	     * The maximum number of properties allowed for instances of this type.
	     ***/
	    ObjectFieldImpl.prototype.maxProperties = function () {
	        return _super.prototype.attribute.call(this, 'maxProperties', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maxProperties value
	     ***/
	    ObjectFieldImpl.prototype.setMaxProperties = function (param) {
	        this.highLevel().attrOrCreate("maxProperties").setValue("" + param);
	        return this;
	    };
	    /***
	     * JSON schema style syntax for declaring maps
	     ***/
	    ObjectFieldImpl.prototype.additionalProperties = function () {
	        return _super.prototype.element.call(this, 'additionalProperties');
	    };
	    /***
	     * JSON schema style syntax for declaring key restricted maps
	     ***/
	    ObjectFieldImpl.prototype.patternProperties = function () {
	        return _super.prototype.elements.call(this, 'patternProperties');
	    };
	    /***
	     * Type property name to be used as discriminator, or boolean
	     ***/
	    ObjectFieldImpl.prototype.discriminator = function () {
	        return _super.prototype.attribute.call(this, 'discriminator', function (attr) { return new pointerImpl(attr); });
	    };
	    /***
	     * The value of discriminator for the type.
	     ***/
	    ObjectFieldImpl.prototype.discriminatorValue = function () {
	        return _super.prototype.attribute.call(this, 'discriminatorValue', this.toString);
	    };
	    /***
	     * @hidden
	     * Set discriminatorValue value
	     ***/
	    ObjectFieldImpl.prototype.setDiscriminatorValue = function (param) {
	        this.highLevel().attrOrCreate("discriminatorValue").setValue("" + param);
	        return this;
	    };
	    return ObjectFieldImpl;
	})(DataElementImpl);
	exports.ObjectFieldImpl = ObjectFieldImpl;
	/***
	 * Value must be a string
	 ***/
	var StrElementImpl = (function (_super) {
	    __extends(StrElementImpl, _super);
	    function StrElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createStrElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    StrElementImpl.prototype.wrapperClassName = function () {
	        return "StrElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    StrElementImpl.prototype.getKind = function () {
	        return "StrElement";
	    };
	    /***
	     * Regular expression that this string should path
	     ***/
	    StrElementImpl.prototype.pattern = function () {
	        return _super.prototype.attribute.call(this, 'pattern', this.toString);
	    };
	    /***
	     * @hidden
	     * Set pattern value
	     ***/
	    StrElementImpl.prototype.setPattern = function (param) {
	        this.highLevel().attrOrCreate("pattern").setValue("" + param);
	        return this;
	    };
	    /***
	     * Minimum length of the string
	     ***/
	    StrElementImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minLength value
	     ***/
	    StrElementImpl.prototype.setMinLength = function (param) {
	        this.highLevel().attrOrCreate("minLength").setValue("" + param);
	        return this;
	    };
	    /***
	     * Maximum length of the string
	     ***/
	    StrElementImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maxLength value
	     ***/
	    StrElementImpl.prototype.setMaxLength = function (param) {
	        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
	     ***/
	    StrElementImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /***
	     * @hidden
	     * Set enum value
	     ***/
	    StrElementImpl.prototype.setEnum = function (param) {
	        this.highLevel().attrOrCreate("enum").setValue("" + param);
	        return this;
	    };
	    return StrElementImpl;
	})(DataElementImpl);
	exports.StrElementImpl = StrElementImpl;
	/***
	 * Value must be a boolean
	 ***/
	var BooleanElementImpl = (function (_super) {
	    __extends(BooleanElementImpl, _super);
	    function BooleanElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    BooleanElementImpl.prototype.wrapperClassName = function () {
	        return "BooleanElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    BooleanElementImpl.prototype.getKind = function () {
	        return "BooleanElement";
	    };
	    return BooleanElementImpl;
	})(DataElementImpl);
	exports.BooleanElementImpl = BooleanElementImpl;
	/***
	 * Value must be a boolean
	 ***/
	var ValueElementImpl = (function (_super) {
	    __extends(ValueElementImpl, _super);
	    function ValueElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createValueElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ValueElementImpl.prototype.wrapperClassName = function () {
	        return "ValueElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ValueElementImpl.prototype.getKind = function () {
	        return "ValueElement";
	    };
	    return ValueElementImpl;
	})(DataElementImpl);
	exports.ValueElementImpl = ValueElementImpl;
	/***
	 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
	 ***/
	var NumberElementImpl = (function (_super) {
	    __extends(NumberElementImpl, _super);
	    function NumberElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createNumberElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    NumberElementImpl.prototype.wrapperClassName = function () {
	        return "NumberElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    NumberElementImpl.prototype.getKind = function () {
	        return "NumberElement";
	    };
	    /***
	     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
	     ***/
	    NumberElementImpl.prototype.minimum = function () {
	        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minimum value
	     ***/
	    NumberElementImpl.prototype.setMinimum = function (param) {
	        this.highLevel().attrOrCreate("minimum").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
	     ***/
	    NumberElementImpl.prototype.maximum = function () {
	        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maximum value
	     ***/
	    NumberElementImpl.prototype.setMaximum = function (param) {
	        this.highLevel().attrOrCreate("maximum").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
	     ***/
	    NumberElementImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /***
	     * @hidden
	     * Set enum value
	     ***/
	    NumberElementImpl.prototype.setEnum = function (param) {
	        this.highLevel().attrOrCreate("enum").setValue("" + param);
	        return this;
	    };
	    /***
	     * Value format
	     ***/
	    NumberElementImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /***
	     * @hidden
	     * Set format value
	     ***/
	    NumberElementImpl.prototype.setFormat = function (param) {
	        this.highLevel().attrOrCreate("format").setValue("" + param);
	        return this;
	    };
	    /***
	     * A numeric instance is valid against "multipleOf" if the result of the division of the instance by this keyword's value is an integer.
	     ***/
	    NumberElementImpl.prototype.multipleOf = function () {
	        return _super.prototype.attribute.call(this, 'multipleOf', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set multipleOf value
	     ***/
	    NumberElementImpl.prototype.setMultipleOf = function (param) {
	        this.highLevel().attrOrCreate("multipleOf").setValue("" + param);
	        return this;
	    };
	    return NumberElementImpl;
	})(DataElementImpl);
	exports.NumberElementImpl = NumberElementImpl;
	/***
	 * Value MUST be a integer.
	 ***/
	var IntegerElementImpl = (function (_super) {
	    __extends(IntegerElementImpl, _super);
	    function IntegerElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    IntegerElementImpl.prototype.wrapperClassName = function () {
	        return "IntegerElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    IntegerElementImpl.prototype.getKind = function () {
	        return "IntegerElement";
	    };
	    IntegerElementImpl.prototype.format = function () {
	        return _super.prototype.attribute.call(this, 'format', this.toString);
	    };
	    /***
	     * @hidden
	     * Set format value
	     ***/
	    IntegerElementImpl.prototype.setFormat = function (param) {
	        this.highLevel().attrOrCreate("format").setValue("" + param);
	        return this;
	    };
	    return IntegerElementImpl;
	})(NumberElementImpl);
	exports.IntegerElementImpl = IntegerElementImpl;
	var RAMLPointerElementImpl = (function (_super) {
	    __extends(RAMLPointerElementImpl, _super);
	    function RAMLPointerElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLPointerElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLPointerElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLPointerElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLPointerElementImpl.prototype.getKind = function () {
	        return "RAMLPointerElement";
	    };
	    RAMLPointerElementImpl.prototype.target = function () {
	        return _super.prototype.attribute.call(this, 'target', function (attr) { return new RAMLSelectorImpl(attr); });
	    };
	    return RAMLPointerElementImpl;
	})(DataElementImpl);
	exports.RAMLPointerElementImpl = RAMLPointerElementImpl;
	var RAMLExpressionImpl = (function (_super) {
	    __extends(RAMLExpressionImpl, _super);
	    function RAMLExpressionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLExpression(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLExpressionImpl.prototype.wrapperClassName = function () {
	        return "RAMLExpressionImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLExpressionImpl.prototype.getKind = function () {
	        return "RAMLExpression";
	    };
	    return RAMLExpressionImpl;
	})(DataElementImpl);
	exports.RAMLExpressionImpl = RAMLExpressionImpl;
	var ScriptHookElementImpl = (function (_super) {
	    __extends(ScriptHookElementImpl, _super);
	    function ScriptHookElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createScriptHookElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ScriptHookElementImpl.prototype.wrapperClassName = function () {
	        return "ScriptHookElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ScriptHookElementImpl.prototype.getKind = function () {
	        return "ScriptHookElement";
	    };
	    /***
	     * Typescript file defining interface which this scrip should comply to
	     ***/
	    ScriptHookElementImpl.prototype.declaredIn = function () {
	        return _super.prototype.attribute.call(this, 'declaredIn', this.toString);
	    };
	    /***
	     * @hidden
	     * Set declaredIn value
	     ***/
	    ScriptHookElementImpl.prototype.setDeclaredIn = function (param) {
	        this.highLevel().attrOrCreate("declaredIn").setValue("" + param);
	        return this;
	    };
	    /***
	     * Name of the interface which scripts should comply to
	     ***/
	    ScriptHookElementImpl.prototype.interfaceName = function () {
	        return _super.prototype.attribute.call(this, 'interfaceName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set interfaceName value
	     ***/
	    ScriptHookElementImpl.prototype.setInterfaceName = function (param) {
	        this.highLevel().attrOrCreate("interfaceName").setValue("" + param);
	        return this;
	    };
	    return ScriptHookElementImpl;
	})(DataElementImpl);
	exports.ScriptHookElementImpl = ScriptHookElementImpl;
	var SchemaElementImpl = (function (_super) {
	    __extends(SchemaElementImpl, _super);
	    function SchemaElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSchemaElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SchemaElementImpl.prototype.wrapperClassName = function () {
	        return "SchemaElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SchemaElementImpl.prototype.getKind = function () {
	        return "SchemaElement";
	    };
	    return SchemaElementImpl;
	})(DataElementImpl);
	exports.SchemaElementImpl = SchemaElementImpl;
	/***
	 * Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. or according to specified date format
	 ***/
	var DateElementImpl = (function (_super) {
	    __extends(DateElementImpl, _super);
	    function DateElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DateElementImpl.prototype.wrapperClassName = function () {
	        return "DateElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DateElementImpl.prototype.getKind = function () {
	        return "DateElement";
	    };
	    DateElementImpl.prototype.dateFormat = function () {
	        return _super.prototype.attribute.call(this, 'dateFormat', function (attr) { return new DateFormatSpecImpl(attr); });
	    };
	    return DateElementImpl;
	})(DataElementImpl);
	exports.DateElementImpl = DateElementImpl;
	var HasNormalParametersImpl = (function (_super) {
	    __extends(HasNormalParametersImpl, _super);
	    function HasNormalParametersImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createHasNormalParameters(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    HasNormalParametersImpl.prototype.wrapperClassName = function () {
	        return "HasNormalParametersImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    HasNormalParametersImpl.prototype.getKind = function () {
	        return "HasNormalParameters";
	    };
	    /***
	     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
	     ***/
	    HasNormalParametersImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /***
	     * Headers that allowed at this position
	     ***/
	    HasNormalParametersImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    HasNormalParametersImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    return HasNormalParametersImpl;
	})(RAMLLanguageElementImpl);
	exports.HasNormalParametersImpl = HasNormalParametersImpl;
	var MethodBaseImpl = (function (_super) {
	    __extends(MethodBaseImpl, _super);
	    function MethodBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MethodBaseImpl.prototype.wrapperClassName = function () {
	        return "MethodBaseImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MethodBaseImpl.prototype.getKind = function () {
	        return "MethodBase";
	    };
	    /***
	     * Information about the expected responses to a request
	     ***/
	    MethodBaseImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /***
	     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.
	     * Resources CAN have alternate representations. For example, an API might support both JSON and XML representations.
	     * A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
	     ***/
	    MethodBaseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /***
	     * A method can override the protocols specified in the resource or at the API root, by employing this property.
	     ***/
	    MethodBaseImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /***
	     * @hidden
	     * Set protocols value
	     ***/
	    MethodBaseImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /***
	     * Instantiation of applyed traits
	     ***/
	    MethodBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     ***/
	    MethodBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    return MethodBaseImpl;
	})(HasNormalParametersImpl);
	exports.MethodBaseImpl = MethodBaseImpl;
	var ResponseImpl = (function (_super) {
	    __extends(ResponseImpl, _super);
	    function ResponseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResponseImpl.prototype.wrapperClassName = function () {
	        return "ResponseImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResponseImpl.prototype.getKind = function () {
	        return "Response";
	    };
	    /***
	     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
	     ***/
	    ResponseImpl.prototype.code = function () {
	        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeImpl(attr); });
	    };
	    /***
	     * Detailed information about any response headers returned by this method
	     ***/
	    ResponseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /***
	     * The body of the response: a body declaration
	     ***/
	    ResponseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /***
	     * An alternate, human-friendly name for the response
	     ***/
	    ResponseImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    ResponseImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the response
	     ***/
	    ResponseImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    ResponseImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /***
	     * true for codes < 400 and false otherwise
	     ***/
	    ResponseImpl.prototype.isOkRange = function () {
	        return helper.isOkRange(this);
	    };
	    return ResponseImpl;
	})(RAMLLanguageElementImpl);
	exports.ResponseImpl = ResponseImpl;
	var TraitImpl = (function (_super) {
	    __extends(TraitImpl, _super);
	    function TraitImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    TraitImpl.prototype.wrapperClassName = function () {
	        return "TraitImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    TraitImpl.prototype.getKind = function () {
	        return "Trait";
	    };
	    /***
	     * Name of the trait
	     ***/
	    TraitImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    TraitImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    TraitImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    TraitImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /***
	     * You may import library locally here it contents is accessible only inside of this trait
	     ***/
	    TraitImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return TraitImpl;
	})(MethodBaseImpl);
	exports.TraitImpl = TraitImpl;
	var LibraryBaseImpl = (function (_super) {
	    __extends(LibraryBaseImpl, _super);
	    function LibraryBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createLibraryBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    LibraryBaseImpl.prototype.wrapperClassName = function () {
	        return "LibraryBaseImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    LibraryBaseImpl.prototype.getKind = function () {
	        return "LibraryBase";
	    };
	    LibraryBaseImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    LibraryBaseImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * Alias for the types property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version.
	     ***/
	    LibraryBaseImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /***
	     * Declarations of (data) types for use within this API
	     ***/
	    LibraryBaseImpl.prototype.types = function () {
	        return _super.prototype.elements.call(this, 'types');
	    };
	    /***
	     * Declarations of traits for use within this API
	     ***/
	    LibraryBaseImpl.prototype.traits = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /***
	     * Declarations of resource types for use within this API
	     ***/
	    LibraryBaseImpl.prototype.resourceTypes = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /***
	     * Declarations of annotation types for use by annotations
	     ***/
	    LibraryBaseImpl.prototype.annotationTypes = function () {
	        return _super.prototype.elements.call(this, 'annotationTypes');
	    };
	    /***
	     * Security schemas types declarations
	     ***/
	    LibraryBaseImpl.prototype.securitySchemaTypes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemaTypes');
	    };
	    /***
	     * Declarations of security schemes for use within this API.
	     ***/
	    LibraryBaseImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /***
	     * Importing libraries
	     ***/
	    LibraryBaseImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return LibraryBaseImpl;
	})(RAMLLanguageElementImpl);
	exports.LibraryBaseImpl = LibraryBaseImpl;
	var LibraryImpl = (function (_super) {
	    __extends(LibraryImpl, _super);
	    function LibraryImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createLibrary(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    LibraryImpl.prototype.wrapperClassName = function () {
	        return "LibraryImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    LibraryImpl.prototype.getKind = function () {
	        return "Library";
	    };
	    /***
	     * contains description of why library exist
	     ***/
	    LibraryImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    LibraryImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    return LibraryImpl;
	})(LibraryBaseImpl);
	exports.LibraryImpl = LibraryImpl;
	var MethodImpl = (function (_super) {
	    __extends(MethodImpl, _super);
	    function MethodImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MethodImpl.prototype.wrapperClassName = function () {
	        return "MethodImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MethodImpl.prototype.getKind = function () {
	        return "Method";
	    };
	    MethodImpl.prototype.signature = function () {
	        return _super.prototype.attribute.call(this, 'signature', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /***
	     * Method that can be called
	     ***/
	    MethodImpl.prototype.method = function () {
	        return _super.prototype.attribute.call(this, 'method', this.toString);
	    };
	    /***
	     * @hidden
	     * Set method value
	     ***/
	    MethodImpl.prototype.setMethod = function (param) {
	        this.highLevel().attrOrCreate("method").setValue("" + param);
	        return this;
	    };
	    /***
	     * An alternate, human-friendly name for the method (in the resource's context).
	     ***/
	    MethodImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    MethodImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the method (in the resource's context)
	     ***/
	    MethodImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Specifies the query string needed by this method. Mutually exclusive with queryParameters.
	     ***/
	    MethodImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    /***
	     * Detailed information about any query parameters needed by this method. Mutually exclusive with queryString.
	     ***/
	    MethodImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /***
	     * Detailed information about any request headers needed by this method.
	     ***/
	    MethodImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /***
	     * Some methods admit request bodies, which are described by this property.
	     ***/
	    MethodImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /***
	     * A list of the traits to apply to this method. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section.
	     ***/
	    MethodImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    MethodImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /***
	     * The security schemes that apply to this method
	     ***/
	    MethodImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * For methods of Resources returns parent resource. For methods of ResourceTypes returns undefined Opt.
	     ***/
	    MethodImpl.prototype.parentResource = function () {
	        return helper.parentResource(this);
	    };
	    /***
	     * Api owning the resource as a sibling
	     ***/
	    MethodImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /***
	     * // For methods of Resources: `{parent Resource relative path} {methodName}`.
	     * // For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	     * // For other methods throws Exception.
	     ***/
	    MethodImpl.prototype.methodId = function () {
	        return helper.methodId(this);
	    };
	    return MethodImpl;
	})(MethodBaseImpl);
	exports.MethodImpl = MethodImpl;
	var SecuritySchemaPartImpl = (function (_super) {
	    __extends(SecuritySchemaPartImpl, _super);
	    function SecuritySchemaPartImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaPart(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaPartImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaPartImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaPartImpl.prototype.getKind = function () {
	        return "SecuritySchemaPart";
	    };
	    /***
	     * Headers that allowed at this position
	     ***/
	    SecuritySchemaPartImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /***
	     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
	     ***/
	    SecuritySchemaPartImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    /***
	     * Specifies the query string, used by the schema in order to authorize the request. Mutually exclusive with queryParameters.
	     ***/
	    SecuritySchemaPartImpl.prototype.queryString = function () {
	        return _super.prototype.element.call(this, 'queryString');
	    };
	    /***
	     * Optional array of responses, describing the possible responses that could be sent. See [[raml-10-spec-responses|Responses]] section.
	     ***/
	    SecuritySchemaPartImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /***
	     * Instantiation of applyed traits
	     ***/
	    SecuritySchemaPartImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     ***/
	    SecuritySchemaPartImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * An alternate, human-friendly name for the security scheme part
	     ***/
	    SecuritySchemaPartImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    SecuritySchemaPartImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the security scheme part
	     ***/
	    SecuritySchemaPartImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Annotations to be applied to this security scheme part. Annotations are any property whose key begins with "(" and ends with ")" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See [[raml-10-spec-annotations|the section on annotations]].
	     ***/
	    SecuritySchemaPartImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    return SecuritySchemaPartImpl;
	})(MethodBaseImpl);
	exports.SecuritySchemaPartImpl = SecuritySchemaPartImpl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var SecuritySchemaImpl = (function (_super) {
	    __extends(SecuritySchemaImpl, _super);
	    function SecuritySchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaImpl.prototype.getKind = function () {
	        return "SecuritySchema";
	    };
	    SecuritySchemaImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    SecuritySchemaImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
	     ***/
	    SecuritySchemaImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /***
	     * @hidden
	     * Set type value
	     ***/
	    SecuritySchemaImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /***
	     * The description MAY be used to describe a securityScheme.
	     ***/
	    SecuritySchemaImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes.
	     * Including the security scheme description completes an API documentation.
	     ***/
	    SecuritySchemaImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    /***
	     * The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared.
	     * It describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more.
	     ***/
	    SecuritySchemaImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return SecuritySchemaImpl;
	})(RAMLLanguageElementImpl);
	exports.SecuritySchemaImpl = SecuritySchemaImpl;
	var SecuritySchemaSettingsImpl = (function (_super) {
	    __extends(SecuritySchemaSettingsImpl, _super);
	    function SecuritySchemaSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaSettingsImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaSettingsImpl.prototype.getKind = function () {
	        return "SecuritySchemaSettings";
	    };
	    return SecuritySchemaSettingsImpl;
	})(core.BasicNodeImpl);
	exports.SecuritySchemaSettingsImpl = SecuritySchemaSettingsImpl;
	var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
	    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth1SecuritySchemeSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.getKind = function () {
	        return "OAuth1SecuritySchemeSettings";
	    };
	    /***
	     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
	        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    OAuth1SecuritySchemeSettingsImpl.prototype.signatures = function () {
	        return _super.prototype.attributes.call(this, 'signatures', this.toString);
	    };
	    /***
	     * @hidden
	     * Set signatures value
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.setSignatures = function (param) {
	        this.highLevel().attrOrCreate("signatures").setValue("" + param);
	        return this;
	    };
	    return OAuth1SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
	var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
	    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth2SecuritySchemeSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.getKind = function () {
	        return "OAuth2SecuritySchemeSettings";
	    };
	    /***
	     * The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2. Not required forby implicit grant type.
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1. Required forby authorization_code and implicit grant types.
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
	        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
	    };
	    /***
	     * @hidden
	     * Set authorizationGrants value
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
	        this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
	        return this;
	    };
	    /***
	     * A list of scopes supported by the security scheme as defined in RFC6749 [RFC6749] Section 3.3
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
	        return _super.prototype.attributes.call(this, 'scopes', this.toString);
	    };
	    /***
	     * @hidden
	     * Set scopes value
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
	        this.highLevel().attrOrCreate("scopes").setValue("" + param);
	        return this;
	    };
	    return OAuth2SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
	var PassThroughSettingsImpl = (function (_super) {
	    __extends(PassThroughSettingsImpl, _super);
	    function PassThroughSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createPassThroughSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    PassThroughSettingsImpl.prototype.wrapperClassName = function () {
	        return "PassThroughSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    PassThroughSettingsImpl.prototype.getKind = function () {
	        return "PassThroughSettings";
	    };
	    PassThroughSettingsImpl.prototype.queryParameterName = function () {
	        return _super.prototype.attribute.call(this, 'queryParameterName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set queryParameterName value
	     ***/
	    PassThroughSettingsImpl.prototype.setQueryParameterName = function (param) {
	        this.highLevel().attrOrCreate("queryParameterName").setValue("" + param);
	        return this;
	    };
	    PassThroughSettingsImpl.prototype.headerName = function () {
	        return _super.prototype.attribute.call(this, 'headerName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set headerName value
	     ***/
	    PassThroughSettingsImpl.prototype.setHeaderName = function (param) {
	        this.highLevel().attrOrCreate("headerName").setValue("" + param);
	        return this;
	    };
	    return PassThroughSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.PassThroughSettingsImpl = PassThroughSettingsImpl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var Oath2Impl = (function (_super) {
	    __extends(Oath2Impl, _super);
	    function Oath2Impl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOath2(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    Oath2Impl.prototype.wrapperClassName = function () {
	        return "Oath2Impl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    Oath2Impl.prototype.getKind = function () {
	        return "Oath2";
	    };
	    Oath2Impl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return Oath2Impl;
	})(SecuritySchemaImpl);
	exports.Oath2Impl = Oath2Impl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var Oath1Impl = (function (_super) {
	    __extends(Oath1Impl, _super);
	    function Oath1Impl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOath1(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    Oath1Impl.prototype.wrapperClassName = function () {
	        return "Oath1Impl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    Oath1Impl.prototype.getKind = function () {
	        return "Oath1";
	    };
	    Oath1Impl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return Oath1Impl;
	})(SecuritySchemaImpl);
	exports.Oath1Impl = Oath1Impl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var PassThroughImpl = (function (_super) {
	    __extends(PassThroughImpl, _super);
	    function PassThroughImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createPassThrough(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    PassThroughImpl.prototype.wrapperClassName = function () {
	        return "PassThroughImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    PassThroughImpl.prototype.getKind = function () {
	        return "PassThrough";
	    };
	    PassThroughImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return PassThroughImpl;
	})(SecuritySchemaImpl);
	exports.PassThroughImpl = PassThroughImpl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var BasicImpl = (function (_super) {
	    __extends(BasicImpl, _super);
	    function BasicImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBasic(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    BasicImpl.prototype.wrapperClassName = function () {
	        return "BasicImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    BasicImpl.prototype.getKind = function () {
	        return "Basic";
	    };
	    return BasicImpl;
	})(SecuritySchemaImpl);
	exports.BasicImpl = BasicImpl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var DigestImpl = (function (_super) {
	    __extends(DigestImpl, _super);
	    function DigestImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDigest(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DigestImpl.prototype.wrapperClassName = function () {
	        return "DigestImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DigestImpl.prototype.getKind = function () {
	        return "Digest";
	    };
	    return DigestImpl;
	})(SecuritySchemaImpl);
	exports.DigestImpl = DigestImpl;
	/***
	 * Declares globally referable security schema definition
	 ***/
	var CustomImpl = (function (_super) {
	    __extends(CustomImpl, _super);
	    function CustomImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createCustom(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    CustomImpl.prototype.wrapperClassName = function () {
	        return "CustomImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    CustomImpl.prototype.getKind = function () {
	        return "Custom";
	    };
	    return CustomImpl;
	})(SecuritySchemaImpl);
	exports.CustomImpl = CustomImpl;
	var ResourceBaseImpl = (function (_super) {
	    __extends(ResourceBaseImpl, _super);
	    function ResourceBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceBaseImpl.prototype.wrapperClassName = function () {
	        return "ResourceBaseImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceBaseImpl.prototype.getKind = function () {
	        return "ResourceBase";
	    };
	    /***
	     * Methods that are part of this resource type definition
	     ***/
	    ResourceBaseImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /***
	     * A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section. Individual methods may override this declaration
	     ***/
	    ResourceBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * The resource type which this resource inherits. . See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section.
	     ***/
	    ResourceBaseImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /***
	     * The security schemes that apply to all methods declared (implicitly or explicitly) for this resource.
	     ***/
	    ResourceBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * Detailed information about any URI parameters of this resource
	     ***/
	    ResourceBaseImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    return ResourceBaseImpl;
	})(RAMLLanguageElementImpl);
	exports.ResourceBaseImpl = ResourceBaseImpl;
	var ResourceTypeImpl = (function (_super) {
	    __extends(ResourceTypeImpl, _super);
	    function ResourceTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceTypeImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceTypeImpl.prototype.getKind = function () {
	        return "ResourceType";
	    };
	    /***
	     * Name of the resource type
	     ***/
	    ResourceTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    ResourceTypeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    ResourceTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    ResourceTypeImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /***
	     * You may import library locally here it contents is accessible only inside of this resource type
	     ***/
	    ResourceTypeImpl.prototype.uses = function () {
	        return _super.prototype.elements.call(this, 'uses');
	    };
	    return ResourceTypeImpl;
	})(ResourceBaseImpl);
	exports.ResourceTypeImpl = ResourceTypeImpl;
	var ResourceImpl = (function (_super) {
	    __extends(ResourceImpl, _super);
	    function ResourceImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceImpl.prototype.wrapperClassName = function () {
	        return "ResourceImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceImpl.prototype.getKind = function () {
	        return "Resource";
	    };
	    ResourceImpl.prototype.signature = function () {
	        return _super.prototype.attribute.call(this, 'signature', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /***
	     * Relative URL of this resource from the parent resource
	     ***/
	    ResourceImpl.prototype.relativeUri = function () {
	        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriImpl(attr); });
	    };
	    /***
	     * A nested resource is identified as any property whose name begins with a slash ("/") and is therefore treated as a relative URI.
	     ***/
	    ResourceImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /***
	     * An alternate, human-friendly name for the resource.
	     ***/
	    ResourceImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    ResourceImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the resource.
	     ***/
	    ResourceImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    ResourceImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /***
	     * Path relative to API root
	     ***/
	    ResourceImpl.prototype.completeRelativeUri = function () {
	        return helper.completeRelativeUri(this);
	    };
	    /***
	     * baseUri of owning Api concatenated with completeRelativeUri
	     ***/
	    ResourceImpl.prototype.absoluteUri = function () {
	        return helper.absoluteUri(this);
	    };
	    /***
	     * Parent resource for non top level resources
	     ***/
	    ResourceImpl.prototype.parentResource = function () {
	        return helper.parent(this);
	    };
	    /***
	     * Get child resource by its relative path
	     ***/
	    ResourceImpl.prototype.getChildResource = function (relPath) {
	        return helper.getChildResource(this, relPath);
	    };
	    /***
	     * Get child method by its name
	     ***/
	    ResourceImpl.prototype.getChildMethod = function (method) {
	        return helper.getChildMethod(this, method);
	    };
	    /***
	     * Api owning the resource as a sibling
	     ***/
	    ResourceImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /***
	     * Retrieve all uri parameters regardless of whether they are described in `uriParameters` or not
	     * //
	     ***/
	    ResourceImpl.prototype.allUriParameters = function () {
	        return helper.uriParameters(this);
	    };
	    /***
	     * Retrieve all absolute uri parameters regardless of whether they are described in
	     * //`baseUriParameters` and `uriParameters` or not
	     ***/
	    ResourceImpl.prototype.absoluteUriParameters = function () {
	        return helper.absoluteUriParameters(this);
	    };
	    return ResourceImpl;
	})(ResourceBaseImpl);
	exports.ResourceImpl = ResourceImpl;
	var AnnotationTypeImpl = (function (_super) {
	    __extends(AnnotationTypeImpl, _super);
	    function AnnotationTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createAnnotationType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    AnnotationTypeImpl.prototype.wrapperClassName = function () {
	        return "AnnotationTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    AnnotationTypeImpl.prototype.getKind = function () {
	        return "AnnotationType";
	    };
	    /***
	     * Name of this annotation type
	     ***/
	    AnnotationTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    AnnotationTypeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * Instructions on how and when to use this annotation in a RAML spec.
	     ***/
	    AnnotationTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    AnnotationTypeImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /***
	     * Declarations of parameters allowed in this annotation type
	     ***/
	    AnnotationTypeImpl.prototype.parameters = function () {
	        return _super.prototype.elements.call(this, 'parameters');
	    };
	    /***
	     * Whether multiple instances of annotations of this type may be applied simultaneously at the same location
	     ***/
	    AnnotationTypeImpl.prototype.allowMultiple = function () {
	        return _super.prototype.attribute.call(this, 'allowMultiple', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set allowMultiple value
	     ***/
	    AnnotationTypeImpl.prototype.setAllowMultiple = function (param) {
	        this.highLevel().attrOrCreate("allowMultiple").setValue("" + param);
	        return this;
	    };
	    /***
	     * Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property.
	     ***/
	    AnnotationTypeImpl.prototype.allowedTargets = function () {
	        return _super.prototype.attributes.call(this, 'allowedTargets', function (attr) { return new AnnotationTargetImpl(attr); });
	    };
	    /***
	     * An alternate, human-friendly name for the annotation
	     ***/
	    AnnotationTypeImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    AnnotationTypeImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the annotation
	     ***/
	    AnnotationTypeImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return AnnotationTypeImpl;
	})(RAMLLanguageElementImpl);
	exports.AnnotationTypeImpl = AnnotationTypeImpl;
	var RAMLSimpleElementImpl = (function (_super) {
	    __extends(RAMLSimpleElementImpl, _super);
	    function RAMLSimpleElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLSimpleElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLSimpleElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLSimpleElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLSimpleElementImpl.prototype.getKind = function () {
	        return "RAMLSimpleElement";
	    };
	    return RAMLSimpleElementImpl;
	})(core.BasicNodeImpl);
	exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
	var ImportDeclarationImpl = (function (_super) {
	    __extends(ImportDeclarationImpl, _super);
	    function ImportDeclarationImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createImportDeclaration(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ImportDeclarationImpl.prototype.wrapperClassName = function () {
	        return "ImportDeclarationImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ImportDeclarationImpl.prototype.getKind = function () {
	        return "ImportDeclaration";
	    };
	    /***
	     * Name prefix (without dot) used to refer imported declarations
	     ***/
	    ImportDeclarationImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /***
	     * @hidden
	     * Set key value
	     ***/
	    ImportDeclarationImpl.prototype.setKey = function (param) {
	        this.highLevel().attrOrCreate("key").setValue("" + param);
	        return this;
	    };
	    /***
	     * Content of the declared namespace
	     ***/
	    ImportDeclarationImpl.prototype.value = function () {
	        return _super.prototype.element.call(this, 'value');
	    };
	    return ImportDeclarationImpl;
	})(RAMLSimpleElementImpl);
	exports.ImportDeclarationImpl = ImportDeclarationImpl;
	/***
	 * Content of the schema
	 ***/
	var GlobalSchemaImpl = (function (_super) {
	    __extends(GlobalSchemaImpl, _super);
	    function GlobalSchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    GlobalSchemaImpl.prototype.wrapperClassName = function () {
	        return "GlobalSchemaImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    GlobalSchemaImpl.prototype.getKind = function () {
	        return "GlobalSchema";
	    };
	    /***
	     * Name of the global schema, used to refer on schema content
	     ***/
	    GlobalSchemaImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /***
	     * @hidden
	     * Set key value
	     ***/
	    GlobalSchemaImpl.prototype.setKey = function (param) {
	        this.highLevel().attrOrCreate("key").setValue("" + param);
	        return this;
	    };
	    /***
	     * Content of the schema
	     ***/
	    GlobalSchemaImpl.prototype.value = function () {
	        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    return GlobalSchemaImpl;
	})(RAMLSimpleElementImpl);
	exports.GlobalSchemaImpl = GlobalSchemaImpl;
	var ApiImpl = (function (_super) {
	    __extends(ApiImpl, _super);
	    function ApiImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ApiImpl.prototype.wrapperClassName = function () {
	        return "ApiImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ApiImpl.prototype.getKind = function () {
	        return "Api";
	    };
	    /***
	     * Short plain-text label for the API
	     ***/
	    ApiImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /***
	     * @hidden
	     * Set title value
	     ***/
	    ApiImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /***
	     * The version of the API, e.g. "v1"
	     ***/
	    ApiImpl.prototype.version = function () {
	        return _super.prototype.attribute.call(this, 'version', this.toString);
	    };
	    /***
	     * @hidden
	     * Set version value
	     ***/
	    ApiImpl.prototype.setVersion = function (param) {
	        this.highLevel().attrOrCreate("version").setValue("" + param);
	        return this;
	    };
	    /***
	     * A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI.
	     ***/
	    ApiImpl.prototype.baseUri = function () {
	        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateImpl(attr); });
	    };
	    /***
	     * Named parameters used in the baseUri (template)
	     ***/
	    ApiImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /***
	     * The protocols supported by the API
	     ***/
	    ApiImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /***
	     * @hidden
	     * Set protocols value
	     ***/
	    ApiImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /***
	     * The default media type to use for request and response bodies (payloads), e.g. "application/json"
	     ***/
	    ApiImpl.prototype.mediaType = function () {
	        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
	    };
	    /***
	     * The security schemes that apply to every resource and method in the API
	     ***/
	    ApiImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc
	     ***/
	    ApiImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /***
	     * Additional overall documentation for the API
	     ***/
	    ApiImpl.prototype.documentation = function () {
	        return _super.prototype.elements.call(this, 'documentation');
	    };
	    /***
	     * The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself).
	     ***/
	    ApiImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    ApiImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    ApiImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    ApiImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * A longer, human-friendly description of the API
	     ***/
	    ApiImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * Most of RAML model elements may have attached annotations decribing additional meta data about this element
	     ***/
	    ApiImpl.prototype.annotations = function () {
	        return _super.prototype.attributes.call(this, 'annotations', function (attr) { return new AnnotationRefImpl(attr); });
	    };
	    /***
	     * Security schemas types declarations
	     ***/
	    ApiImpl.prototype.securitySchemaTypes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemaTypes');
	    };
	    /***
	     * Equivalent API with traits and resource types expanded
	     ***/
	    ApiImpl.prototype.expandTraitsAndResourceTypes = function () {
	        return helper.expandTraitsAndResourceTypes(this);
	    };
	    /***
	     * Retrieve all traits including those defined in libraries
	     ***/
	    ApiImpl.prototype.allTraits = function () {
	        return helper.allTraits(this);
	    };
	    /***
	     * Retrieve all resource types including those defined in libraries
	     ***/
	    ApiImpl.prototype.allResourceTypes = function () {
	        return helper.allResourceTypes(this);
	    };
	    /***
	     * Get child resource by its relative path
	     ***/
	    ApiImpl.prototype.getChildResource = function (relPath) {
	        return helper.getChildResource(this, relPath);
	    };
	    /***
	     * Retrieve all resources ofthe Api
	     ***/
	    ApiImpl.prototype.allResources = function () {
	        return helper.allResources(this);
	    };
	    /***
	     * Retrieve all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	     * //
	     ***/
	    ApiImpl.prototype.allBaseUriParameters = function () {
	        return helper.baseUriParameters(this);
	    };
	    return ApiImpl;
	})(LibraryBaseImpl);
	exports.ApiImpl = ApiImpl;
	var OverlayImpl = (function (_super) {
	    __extends(OverlayImpl, _super);
	    function OverlayImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOverlay(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    OverlayImpl.prototype.wrapperClassName = function () {
	        return "OverlayImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    OverlayImpl.prototype.getKind = function () {
	        return "Overlay";
	    };
	    /***
	     * contains description of why overlay exist
	     ***/
	    OverlayImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    OverlayImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    OverlayImpl.prototype.masterRef = function () {
	        return _super.prototype.attribute.call(this, 'masterRef', this.toString);
	    };
	    /***
	     * @hidden
	     * Set masterRef value
	     ***/
	    OverlayImpl.prototype.setMasterRef = function (param) {
	        this.highLevel().attrOrCreate("masterRef").setValue("" + param);
	        return this;
	    };
	    /***
	     * Short plain-text label for the API
	     ***/
	    OverlayImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /***
	     * @hidden
	     * Set title value
	     ***/
	    OverlayImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    return OverlayImpl;
	})(ApiImpl);
	exports.OverlayImpl = OverlayImpl;
	var ExtensionImpl = (function (_super) {
	    __extends(ExtensionImpl, _super);
	    function ExtensionImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createExtension(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ExtensionImpl.prototype.wrapperClassName = function () {
	        return "ExtensionImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ExtensionImpl.prototype.getKind = function () {
	        return "Extension";
	    };
	    /***
	     * contains description of why extension exist
	     ***/
	    ExtensionImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    ExtensionImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    ExtensionImpl.prototype.masterRef = function () {
	        return _super.prototype.attribute.call(this, 'masterRef', this.toString);
	    };
	    /***
	     * @hidden
	     * Set masterRef value
	     ***/
	    ExtensionImpl.prototype.setMasterRef = function (param) {
	        this.highLevel().attrOrCreate("masterRef").setValue("" + param);
	        return this;
	    };
	    /***
	     * Short plain-text label for the API
	     ***/
	    ExtensionImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /***
	     * @hidden
	     * Set title value
	     ***/
	    ExtensionImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    return ExtensionImpl;
	})(ApiImpl);
	exports.ExtensionImpl = ExtensionImpl;
	/***
	 * @hidden
	 ***/
	function createApi(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Api");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createLibraryBase(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("LibraryBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLLanguageElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLLanguageElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createDocumentationItem(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DocumentationItem");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createScriptSpec(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ScriptSpec");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createApiDescription(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ApiDescription");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createCallbackAPIDescription(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("CallbackAPIDescription");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLProject(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLProject");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchemaType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createDataElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DataElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createXMLInfo(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("XMLInfo");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createExampleSpec(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ExampleSpec");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createFileParameter(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("FileParameter");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createArrayField(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ArrayField");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createUnionField(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("UnionField");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createObjectField(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ObjectField");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createStrElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("StrElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createBooleanElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("BooleanElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createValueElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ValueElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createNumberElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("NumberElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createIntegerElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("IntegerElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLPointerElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLPointerElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLExpression(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLExpression");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createScriptHookElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ScriptHookElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSchemaElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SchemaElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createDateElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("DateElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchemaPart(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaPart");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createMethodBase(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("MethodBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createHasNormalParameters(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("HasNormalParameters");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResponse(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Response");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createTrait(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Trait");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createLibrary(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Library");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createMethod(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Method");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchema(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchemaSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("SecuritySchemaSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOAuth1SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OAuth1SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOAuth2SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("OAuth2SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createPassThroughSettings(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("PassThroughSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOath2(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Oath2");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOath1(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Oath1");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createPassThrough(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("PassThrough");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createBasic(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Basic");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createDigest(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Digest");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createCustom(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Custom");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResourceBase(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ResourceBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResourceType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ResourceType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResource(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Resource");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createAnnotationType(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("AnnotationType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createGlobalSchema(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("GlobalSchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLSimpleElement(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("RAMLSimpleElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createImportDeclaration(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("ImportDeclaration");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOverlay(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Overlay");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createExtension(key) {
	    var universe = hl.universeProvider("RAML10");
	    var nc = universe.getType("Extension");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * Load API synchronously
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param expand Whether to expand traits and resource types
	 * @return Opt&lt;Api&gt;. Call .isDefined() Opt member to find out if the result actually contains an Api. Call .getOrThrow() Opt member to retrieve the Api.
	 ***/
	function loadApi(apiPath, expand) {
	    if (expand === void 0) { expand = true; }
	    return apiLoader.loadApi1(apiPath, {
	        expandTraitsAndResourceTypes: expand
	    });
	}
	exports.loadApi = loadApi;
	/***
	 * Load API asynchronously
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param expand Whether to expand traits and resource types
	 * @return Promise&lt;Api&gt;
	 ***/
	function loadApiAsync(apiPath, expand) {
	    if (expand === void 0) { expand = true; }
	    return apiLoader.loadApi1Async(apiPath, {
	        expandTraitsAndResourceTypes: expand
	    });
	}
	exports.loadApiAsync = loadApiAsync;
	/***
	 * Turn model node into an object. Should not be relied on for API analysis and manipulation by the parser users.
	 * @param node Model node
	 * @return Stringifyable object representation of the node.
	 ***/
	function toJSON(node, serializeOptions) {
	    return json2lowlevel.serialize(node.highLevel().lowLevel(), serializeOptions);
	}
	exports.toJSON = toJSON;
	;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ds = __webpack_require__(3);
	var universes = __webpack_require__(62);
	(function (NodeKind) {
	    NodeKind[NodeKind["BASIC"] = 0] = "BASIC";
	    NodeKind[NodeKind["NODE"] = 1] = "NODE";
	    NodeKind[NodeKind["ATTRIBUTE"] = 2] = "ATTRIBUTE";
	})(exports.NodeKind || (exports.NodeKind = {}));
	var NodeKind = exports.NodeKind;
	(function (IssueCode) {
	    IssueCode[IssueCode["UNRESOLVED_REFERENCE"] = 0] = "UNRESOLVED_REFERENCE";
	    IssueCode[IssueCode["YAML_ERROR"] = 1] = "YAML_ERROR";
	    IssueCode[IssueCode["UNKNOWN_NODE"] = 2] = "UNKNOWN_NODE";
	    IssueCode[IssueCode["MISSING_REQUIRED_PROPERTY"] = 3] = "MISSING_REQUIRED_PROPERTY";
	    IssueCode[IssueCode["PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE"] = 4] = "PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE";
	    //TODO IMPLEMENT
	    IssueCode[IssueCode["KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT"] = 5] = "KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT";
	    IssueCode[IssueCode["UNABLE_TO_RESOLVE_INCLUDE_FILE"] = 6] = "UNABLE_TO_RESOLVE_INCLUDE_FILE";
	    IssueCode[IssueCode["INVALID_VALUE_SCHEMA"] = 7] = "INVALID_VALUE_SCHEMA";
	    IssueCode[IssueCode["MISSED_CONTEXT_REQUIREMENT"] = 8] = "MISSED_CONTEXT_REQUIREMENT";
	    IssueCode[IssueCode["NODE_HAS_VALUE"] = 9] = "NODE_HAS_VALUE";
	    IssueCode[IssueCode["ONLY_OVERRIDE_ALLOWED"] = 10] = "ONLY_OVERRIDE_ALLOWED";
	})(exports.IssueCode || (exports.IssueCode = {}));
	var IssueCode = exports.IssueCode;
	;
	var Problem = (function () {
	    function Problem() {
	        this.code = 0;
	    }
	    Problem.prototype.isOk = function () {
	        return this.code == 0;
	    };
	    return Problem;
	})();
	exports.Problem = Problem;
	function ast2Object(node) {
	    var result = {};
	    node.attrs().forEach(function (x) {
	        result[x.property().nameId()] = x.value();
	    });
	    node.elements().forEach(function (x) {
	        var m = result[x.property().nameId()];
	        if (Array.isArray(m)) {
	            m.push(ast2Object(x));
	        }
	        result[x.property().nameId()] = x.property().isMultiValue() ? [ast2Object(x)] : ast2Object(x);
	    });
	    return result;
	}
	exports.ast2Object = ast2Object;
	exports.universeProvider = __webpack_require__(93);
	var hlImpl = __webpack_require__(5);
	exports.getDefinitionSystemType = function (contents, ast) {
	    var spec = "";
	    var ptype = "Api";
	    var num = 0;
	    var pt = 0;
	    for (var n = 0; n < contents.length; n++) {
	        var c = contents.charAt(n);
	        if (c == '\r' || c == '\n') {
	            if (spec) {
	                ptype = contents.substring(pt, n).trim();
	            }
	            else {
	                spec = contents.substring(0, n).trim();
	            }
	            break;
	        }
	        if (c == ' ') {
	            num++;
	            if (!spec && num == 2) {
	                spec = contents.substring(0, n);
	                pt = n;
	            }
	        }
	    }
	    var localUniverse = spec == "#%RAML 1.0" ? new ds.Universe("RAML10", exports.universeProvider("RAML10"), "RAML10") : new ds.Universe("RAML08", exports.universeProvider("RAML08"));
	    if (ptype == 'API') {
	        ptype = "Api";
	    }
	    if (ptype == 'NamedExample') {
	        ptype = "ExampleSpec";
	    }
	    if (ptype == 'DataType') {
	        ptype = "DataElement";
	    }
	    if (ptype == 'SecurityScheme') {
	        ptype = "SecuritySchema";
	    }
	    localUniverse.setTopLevel(ptype);
	    localUniverse.setTypedVersion(spec);
	    // localUniverse.setDescription(spec);
	    return { ptype: ptype, localUniverse: localUniverse };
	};
	function fromUnit(l) {
	    if (l == null)
	        return null;
	    var contents = l.contents();
	    var ast = l.ast();
	    var __ret = exports.getDefinitionSystemType(contents, ast);
	    var ptype = __ret.ptype;
	    var localUniverse = __ret.localUniverse;
	    var apiType = localUniverse.type(ptype);
	    if (!apiType)
	        apiType = localUniverse.type("Api");
	    var api = new hlImpl.ASTNodeImpl(ast, null, apiType, null);
	    api.setUniverse(localUniverse);
	    return api;
	}
	exports.fromUnit = fromUnit;
	function globalId(h) {
	    if (h.parent()) {
	        return globalId(h.parent()) + "/" + h.localId();
	    }
	}
	exports.globalId = globalId;
	function nodeAtPosition(h, position) {
	    var ch = h.children();
	    var len = ch.length;
	    var res = null;
	    for (var num = 0; num < len; num++) {
	        var cn = ch[num];
	        if (cn.lowLevel().start() > position) {
	            break;
	        }
	        if (cn.lowLevel().end() < position) {
	            continue;
	        }
	        var nm = nodeAtPosition(cn, position);
	        if (nm != null) {
	            return nm;
	        }
	        return cn;
	    }
	}
	exports.nodeAtPosition = nodeAtPosition;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function kindBasic(node) {
	    return node.getKind() == 0 /* BASIC */;
	}
	exports.kindBasic = kindBasic;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function kindAttribute(node) {
	    return node.getKind() == 2 /* ATTRIBUTE */;
	}
	exports.kindAttribute = kindAttribute;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function kindNode(node) {
	    return node.getKind() == 1 /* NODE */;
	}
	exports.kindNode = kindNode;
	function isResourceNode(node) {
	    return kindNode(node) && node.definition && node.definition().name() == "Resource";
	}
	exports.isResourceNode = isResourceNode;
	function isResourceWithSignature(node) {
	    if (!isResourceNode(node)) {
	        return false;
	    }
	    var hNode = node;
	    var uriAttribute = hNode.attr("relativeUri");
	    if (uriAttribute && uriAttribute.value() && typeof uriAttribute.value() == "string" && uriAttribute.value().indexOf(".") >= 0) {
	        var signature = hNode.attrValue("signature");
	        if (!signature)
	            return false;
	        if (typeof signature == "string" && signature.length == 0)
	            return false;
	        return true;
	    }
	    return false;
	}
	exports.isResourceWithSignature = isResourceWithSignature;
	function isRAML10(node) {
	    var text = node.lowLevel().unit().contents();
	    return text.indexOf("#%RAML 1.0") >= 0;
	}
	exports.isRAML10 = isRAML10;
	function isRAML08(node) {
	    var text = node.lowLevel().unit().contents();
	    return text.indexOf("#%RAML 0.8") >= 0;
	}
	exports.isRAML08 = isRAML08;
	/**
	 * Shortcut for checking node type and getting it as attribute
	 * Returns null for non-attributes
	 * @param node
	 */
	function asAttribute(node) {
	    if (!node.getKind) {
	        return null;
	    }
	    if (node.getKind() != 2 /* ATTRIBUTE */) {
	        return null;
	    }
	    return node;
	}
	exports.asAttribute = asAttribute;
	/**
	 * Shortcut for checking node type
	 * @param node
	 */
	function asNode(node) {
	    if (!node.getKind) {
	        return null;
	    }
	    if (node.getKind() != 1 /* NODE */) {
	        return null;
	    }
	    return node;
	}
	exports.asNode = asNode;
	/**
	 * Checks if specified node is library
	 * @param node
	 * @returns {IHighLevelNode|boolean}
	 */
	function isLibrary(node) {
	    return asNode(node) && asNode(node).definition().key() == universes.Universe10.Library;
	}
	exports.isLibrary = isLibrary;
	/**
	 * Check is specified node is library and returns library name. Returns null otherwise.
	 * @param node
	 * @returns {any}
	 */
	function getLibraryName(node) {
	    if (!isLibrary(node)) {
	        return null;
	    }
	    return asNode(node).attrValue("name");
	}
	exports.getLibraryName = getLibraryName;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var _ = __webpack_require__(4);
	var hlimpl = __webpack_require__(5);
	var jsyaml = __webpack_require__(6);
	var su = __webpack_require__(73);
	var selector = __webpack_require__(98);
	var typeBuilder = __webpack_require__(66);
	var defs = __webpack_require__(3);
	var search = __webpack_require__(65);
	var universes = __webpack_require__(62);
	var Annotation = (function () {
	    function Annotation(_name) {
	        this._name = _name;
	    }
	    Annotation.prototype.name = function () {
	        return this._name;
	    };
	    return Annotation;
	})();
	exports.Annotation = Annotation;
	var Described = (function () {
	    function Described(_name, _description) {
	        if (_description === void 0) { _description = ""; }
	        this._name = _name;
	        this._description = _description;
	        this._issues = [];
	        this._toClarify = [];
	        this._itCovers = [];
	        this._tags = [];
	    }
	    Described.prototype.nameId = function () {
	        return this._name;
	    };
	    Described.prototype.description = function () {
	        return this._description;
	    };
	    Described.prototype.withIssue = function (description) {
	        this._issues.push(description);
	        return this;
	    };
	    Described.prototype.withTag = function (description) {
	        this._tags.push(description);
	        return this;
	    };
	    Described.prototype.withClarify = function (description) {
	        this._toClarify.push(description);
	        return this;
	    };
	    Described.prototype.getCoveredStuff = function () {
	        return this._itCovers;
	    };
	    Described.prototype.withThisFeatureCovers = function (description) {
	        this._itCovers.push(description);
	        return this;
	    };
	    Described.prototype.withVersion = function (verstion) {
	        this._version = verstion;
	    };
	    Described.prototype.version = function () {
	        return this._version;
	    };
	    Described.prototype.issues = function () {
	        return this._issues;
	    };
	    Described.prototype.toClarify = function () {
	        return this._toClarify;
	    };
	    Described.prototype.tags = function () {
	        return this._tags;
	    };
	    Described.prototype.withDescription = function (d) {
	        this._description = d;
	        return this;
	    };
	    return Described;
	})();
	exports.Described = Described;
	var ValueRequirement = (function () {
	    function ValueRequirement(name, value) {
	        this.name = name;
	        this.value = value;
	    }
	    return ValueRequirement;
	})();
	exports.ValueRequirement = ValueRequirement;
	var AbstractType = (function (_super) {
	    __extends(AbstractType, _super);
	    function AbstractType(_name, _universe, _path) {
	        _super.call(this, _name);
	        this._universe = _universe;
	        this._path = _path;
	        this._superTypes = [];
	        this._subTypes = [];
	        this._annotations = [];
	        this._requirements = [];
	        this._aliases = [];
	        this._defining = [];
	        this.fixedFacets = {};
	        this._methods = [];
	    }
	    AbstractType.prototype.key = function () {
	        if (this._key) {
	            return this._key;
	        }
	        this._key = this.universe().matched()[this.nameId()];
	        if (!this._key) {
	            return null;
	        }
	        return this._key;
	    };
	    AbstractType.prototype.isRuntime = function () {
	        return false;
	    };
	    AbstractType.prototype.union = function () {
	        return null;
	    };
	    AbstractType.prototype.isUserDefined = function () {
	        return false;
	    };
	    AbstractType.prototype.isArray = function () {
	        return false;
	    };
	    AbstractType.prototype.isUnion = function () {
	        return false;
	    };
	    AbstractType.prototype.fixFacet = function (name, v) {
	        this.fixedFacets[name] = v;
	    };
	    AbstractType.prototype.getFixedFacets = function () {
	        if (this._af) {
	            return this._af;
	        }
	        var sp = this.allSuperTypes();
	        var mm = {};
	        for (var q in this.fixedFacets) {
	            mm[q] = this.fixedFacets[q];
	        }
	        sp.forEach(function (x) {
	            if (x instanceof NodeClass) {
	                x.contributeFacets(mm);
	                var ff = x.fixedFacets;
	                for (var q in ff) {
	                    mm[q] = ff[q];
	                }
	            }
	        });
	        this.contributeFacets(mm);
	        this._af = mm;
	        return mm;
	    };
	    AbstractType.prototype.contributeFacets = function (x) {
	    };
	    AbstractType.prototype.setDeclaringNode = function (n) {
	        this._node = n;
	    };
	    AbstractType.prototype.getDeclaringNode = function () {
	        return this._node;
	    };
	    AbstractType.prototype.toRuntime = function () {
	        return this;
	    };
	    AbstractType.prototype.setConsumesRefs = function (b) {
	        this._consumesRef = b;
	    };
	    AbstractType.prototype.definingPropertyIsEnough = function (v) {
	        this._defining.push(v);
	    };
	    AbstractType.prototype.getDefining = function () {
	        return this._defining;
	    };
	    AbstractType.prototype.getConsumesRefs = function () {
	        return this._consumesRef;
	    };
	    AbstractType.prototype.addAlias = function (al) {
	        this._aliases.push(al);
	    };
	    AbstractType.prototype.getAliases = function () {
	        return this._aliases;
	    };
	    AbstractType.prototype.isValid = function (h, v, p) {
	        return true;
	    };
	    AbstractType.prototype.getPath = function () {
	        return this._path;
	    };
	    AbstractType.prototype.withFunctionalDescriminator = function (code) {
	        this._fDesc = code;
	    };
	    AbstractType.prototype.addMethod = function (name, text) {
	        this._methods.push({ name: name, text: text });
	    };
	    AbstractType.prototype.methods = function () {
	        return this._methods;
	    };
	    AbstractType.prototype.setNameAtRuntime = function (name) {
	        this._nameAtRuntime = name;
	    };
	    AbstractType.prototype.getNameAtRuntime = function () {
	        return this._nameAtRuntime;
	    };
	    AbstractType.prototype.getFunctionalDescriminator = function () {
	        return this._fDesc;
	    };
	    AbstractType.prototype.getRuntimeExtenders = function () {
	        return [];
	    };
	    AbstractType.prototype.universe = function () {
	        return this._universe;
	    };
	    AbstractType.prototype.superTypes = function () {
	        return [].concat(this._superTypes);
	    };
	    AbstractType.prototype.isAssignableFrom = function (typeName) {
	        if (this.nameId() == typeName) {
	            if (this.isUserDefined()) {
	                return false;
	            }
	            return true;
	        }
	        var currentSuperTypes = this.allSuperTypes();
	        for (var i = 0; i < currentSuperTypes.length; i++) {
	            if (currentSuperTypes[i].nameId() == typeName) {
	                return true;
	            }
	        }
	        return false;
	    };
	    AbstractType.prototype.subTypes = function () {
	        return [].concat(this._subTypes);
	    };
	    AbstractType.prototype.allSubTypes = function () {
	        var rs = [];
	        this.subTypes().forEach(function (x) {
	            rs.push(x);
	            rs = rs.concat(x.allSubTypes());
	        });
	        return _.unique(rs);
	    };
	    AbstractType.prototype.allSuperTypes = function () {
	        var rs = [];
	        this.allSuperTypesRecurrent(this, {}, rs);
	        return _.unique(rs);
	    };
	    AbstractType.prototype.allSuperTypesRecurrent = function (t, m, result) {
	        var _this = this;
	        t.superTypes().forEach(function (x) {
	            result.push(x);
	            if (!m[x.nameId()]) {
	                m[x.nameId()] = x;
	                _this.allSuperTypesRecurrent(x, m, result);
	            }
	        });
	    };
	    AbstractType.prototype.addRequirement = function (name, value) {
	        this._requirements.push(new ValueRequirement(name, value));
	    };
	    //FIXME simplify it
	    AbstractType.prototype.valueRequirements = function () {
	        return this._requirements;
	    };
	    AbstractType.prototype.annotations = function () {
	        return this._annotations;
	    };
	    return AbstractType;
	})(Described);
	exports.AbstractType = AbstractType;
	var ValueType = (function (_super) {
	    __extends(ValueType, _super);
	    function ValueType(name, _universe, path, description, _restriction) {
	        if (description === void 0) { description = ""; }
	        if (_restriction === void 0) { _restriction = null; }
	        _super.call(this, name, _universe, path);
	        this._restriction = _restriction;
	        this._declaredBy = [];
	    }
	    ValueType.prototype.hasStructure = function () {
	        if (this.nameId() == "structure") {
	            return true;
	        }
	        return false;
	    };
	    ValueType.prototype.isValid = function (h, v, p) {
	        try {
	            if (this.key() == universes.Universe10.AnnotationRef) {
	                var targets = p.referenceTargets(h);
	                var actualAnnotation = _.find(targets, function (x) { return hlimpl.qName(x, h) == v; });
	                if (actualAnnotation != null) {
	                    var attrs = actualAnnotation.attributes("allowedTargets");
	                    if (attrs) {
	                        var aVals = attrs.map(function (x) { return x.value(); });
	                        if (aVals.length > 0) {
	                            var found = false;
	                            //no we should actually check that we are applying annotation properly
	                            var tps = h.definition().allSuperTypes();
	                            tps = tps.concat([h.definition()]);
	                            var tpNames = tps.map(function (x) { return x.nameId(); });
	                            aVals.forEach(function (x) {
	                                //FIXME this is deeply wrong code
	                                if (x == "API") {
	                                    x = "Api";
	                                }
	                                if (x == "NamedExample") {
	                                    x = "ExampleSpec";
	                                }
	                                if (x == "SecurityScheme") {
	                                    x = "SecuritySchema";
	                                }
	                                if (x == "SecuritySchemeSettings") {
	                                    x = "SecuritySchemaSettings";
	                                }
	                                if (_.find(tpNames, function (y) { return y == x; })) {
	                                    found = true;
	                                }
	                                else {
	                                    if (x == "Parameter") {
	                                        if (h.computedValue("location")) {
	                                            found = true;
	                                        }
	                                    }
	                                    if (x == "Field") {
	                                        if (h.computedValue("field")) {
	                                            found = true;
	                                        }
	                                    }
	                                }
	                            });
	                            if (!found) {
	                                return new Error("annotation " + v + " can not be placed at this location, allowed targets are:" + aVals);
	                            }
	                        }
	                    }
	                }
	                return tm;
	            }
	            if (this.key() == universes.Universe08.SchemaString || this.key() == universes.Universe10.SchemaString) {
	                var tm = su.createSchema(v);
	                if (tm instanceof Error) {
	                    tm.canBeRef = true;
	                }
	                return tm;
	            }
	            if (this.key() == universes.Universe08.StatusCode || this.key() == universes.Universe10.StatusCode) {
	                if (v.length != 3) {
	                    return new Error("Status code should be 3 digits number with optional 'x' as wildcards");
	                }
	                for (var i = 0; i < v.length; i++) {
	                    var c = v[i];
	                    if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x', 'X'], function (x) { return x == c; })) {
	                        return new Error("Status code should be 3 digits number with optional 'x' as wildcards");
	                    }
	                }
	            }
	            if (this.key() == universes.Universe08.JSonSchemaString || this.key() == universes.Universe10.JSonSchemaString) {
	                var jsshema = su.getJSONSchema(v);
	                if (jsshema instanceof Error) {
	                    jsshema.canBeRef = true;
	                }
	                return jsshema;
	            }
	            if (this.key() == universes.Universe08.XMLSchemaString || this.key() == universes.Universe10.XMLSchemaString) {
	                var xmlschema = su.getXMLSchema(v);
	                if (xmlschema instanceof Error) {
	                    xmlschema.canBeRef = true;
	                }
	                return xmlschema;
	            }
	            if (this.key() == universes.Universe08.BooleanType || this.key() == universes.Universe10.BooleanType) {
	                if (!(v == 'true' || v == 'false')) {
	                    return new Error("'true' or 'false' is expected here");
	                }
	            }
	            if (this.key() == universes.Universe08.NumberType || this.key() == universes.Universe10.NumberType) {
	                var q = parseFloat(v);
	                if (isNaN(q)) {
	                    return new Error("number is expected here");
	                }
	            }
	            //if (this.name()=='ramlexpression'){
	            //    try {
	            //        if (p.name()=='condition'){
	            //            if (h.computedValue("response")) {
	            //                h = h.parent().parent().parent();
	            //            }
	            //            else{
	            //                h=h.parent().parent();
	            //            }
	            //        }
	            //        if (p.name()=='validWhen'||p.name()=='requiredWhen'){
	            //            h=h.parent();
	            //        }
	            //        ramlexp.validate(v, h);
	            //    } catch (e){
	            //        return e;
	            //    }
	            //}
	            //if (this.name()=="pointer") {
	            //    var pointer = search.resolveRamlPointer(h, v);
	            //    if (!pointer) {
	            //        return new Error("Unable to resolve raml pointer:" + v);
	            //    }
	            //    else{
	            //        var dp=<defs.Property>p;
	            //        var sl=dp.getSelector(h);
	            //        if (sl){
	            //            var pp=h;
	            //            if (pp.definition().isAnnotation()){
	            //                pp=pp.parent();
	            //            }
	            //            var options=sl.apply(pp);
	            //            if (!_.find(options,x=>x==pointer)){
	            //                return new Error("Pointer does not fits to scope " + v);
	            //            }
	            //        }
	            //    }
	            //}
	            //if (this.name()=="RAMLSelector") {
	            //    try {
	            //        var sl = selector.parse(h,v);
	            //        return sl;
	            //    } catch(e){
	            //        return new Error("Unable to parse RAML selector :"+e.message);
	            //    }
	            //}
	            return true;
	        }
	        catch (e) {
	            e.canBeRef = true; //FIXME
	            return e;
	        }
	    };
	    ValueType.prototype.isValueType = function () {
	        return true;
	    };
	    ValueType.prototype.isUnionType = function () {
	        return false;
	    };
	    ValueType.prototype.properties = function () {
	        return [];
	    };
	    ValueType.prototype.allProperties = function () {
	        return [];
	    };
	    ValueType.prototype.globallyDeclaredBy = function () {
	        return this._declaredBy;
	    };
	    ValueType.prototype.setGloballyDeclaredBy = function (c) {
	        this._declaredBy.push(c);
	    };
	    ValueType.prototype.getValueRestriction = function () {
	        return this._restriction;
	    };
	    ValueType.prototype.match = function (r) {
	        return false;
	    };
	    return ValueType;
	})(AbstractType);
	exports.ValueType = ValueType;
	var EnumType = (function (_super) {
	    __extends(EnumType, _super);
	    function EnumType() {
	        _super.apply(this, arguments);
	        this.values = [];
	    }
	    return EnumType;
	})(ValueType);
	exports.EnumType = EnumType;
	var ReferenceType = (function (_super) {
	    __extends(ReferenceType, _super);
	    function ReferenceType(name, path, referenceTo, _universe) {
	        _super.call(this, name, _universe, path);
	        this.referenceTo = referenceTo;
	    }
	    ReferenceType.prototype.getReferencedType = function () {
	        return this.universe().getType(this.referenceTo);
	    };
	    ReferenceType.prototype.hasStructure = function () {
	        var rt = this.getReferencedType();
	        if (rt) {
	            return rt.isInlinedTemplates() || (rt.findMembersDeterminer() != null) || rt.key() == universes.Universe08.SecuritySchema || rt.key() === universes.Universe10.SecuritySchema; //FIXME
	        }
	        else {
	            return false;
	        }
	    };
	    return ReferenceType;
	})(ValueType);
	exports.ReferenceType = ReferenceType;
	var ScriptingHookType = (function (_super) {
	    __extends(ScriptingHookType, _super);
	    function ScriptingHookType(name, path, refTo, _universe) {
	        _super.call(this, name, _universe, path);
	        this.refTo = refTo;
	    }
	    ScriptingHookType.prototype.getReferencedType = function () {
	        return this.universe().getType(this.refTo);
	    };
	    return ScriptingHookType;
	})(ValueType);
	exports.ScriptingHookType = ScriptingHookType;
	var NodeClass = (function (_super) {
	    __extends(NodeClass, _super);
	    function NodeClass(_name, universe, path, _description) {
	        if (_description === void 0) { _description = ""; }
	        _super.call(this, _name, universe, path);
	        this._properties = [];
	        this._declaresType = null;
	        this._runtimeExtenders = [];
	        this._inlinedTemplates = false;
	        this._contextReq = [];
	        this._allowQuestion = false;
	        this._canInherit = [];
	    }
	    NodeClass.prototype.isRuntime = function () {
	        return this._isRuntime;
	    };
	    NodeClass.prototype.isUserDefined = function () {
	        return false;
	    };
	    NodeClass.prototype.getRepresentationOf = function () {
	        return this._representationOf;
	    };
	    NodeClass.prototype.toRuntime = function () {
	        var c = new NodeClass(this.nameId(), this.universe(), "");
	        c._isRuntime = true;
	        c._representationOf = this;
	        //c._properties=this.allRuntimeProperties();
	        return c;
	    };
	    NodeClass.prototype.allFacets = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (this._allFacets) {
	            return this._allFacets;
	        }
	        if (ps[this.nameId()]) {
	            return [];
	        }
	        ps[this.nameId()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    x.allFacets(ps).forEach(function (y) { return n[y.nameId()] = y; });
	                }
	            });
	        }
	        this._properties.forEach(function (x) { return n[x.nameId()] = x; });
	        this._allFacets = Object.keys(n).map(function (x) { return n[x]; });
	        //this.contributeToFacets(this._allFacets);
	        return this._allFacets;
	    };
	    NodeClass.prototype.facet = function (name) {
	        return _.find(this.allFacets(), function (x) { return x.nameId() == name; });
	    };
	    NodeClass.prototype.isDeclaration = function () {
	        if (this._inlinedTemplates) {
	            return true;
	        }
	        if (this._convertsToGlobal) {
	            return true;
	        }
	        if (this._declaresType) {
	            return true;
	        }
	        if (this.key() === universes.Universe10.Library) {
	            return true;
	        }
	        return false;
	    };
	    NodeClass.prototype.isAnnotation = function () {
	        if (this._annotationChecked) {
	            return this._isAnnotation;
	        }
	        this._annotationChecked = true;
	        this._isAnnotation = (_.find(this.allSuperTypes(), function (x) { return x.key() == universes.Universe10.Annotation; }) != null);
	        return this._isAnnotation;
	    };
	    NodeClass.prototype.allowValue = function () {
	        if (this._allowValueSet) {
	            return this._allowValue;
	        }
	        if (_.find(this.allProperties(), function (x) { return x.isValue() || x.canBeValue(); })) {
	            this._allowValue = true;
	            this._allowValueSet = true;
	            return true;
	        }
	        this._allowValueSet = true;
	        return false;
	    };
	    NodeClass.prototype.printDetails = function () {
	        var result = "";
	        result += this.nameId() + "\n";
	        this.properties().forEach(function (property) {
	            result += "  " + property.nameId() + ":" + property.range() + "\n";
	        });
	        return result;
	    };
	    NodeClass.prototype.withCanInherit = function (clazz) {
	        this._canInherit.push(clazz);
	    };
	    NodeClass.prototype.getCanInherit = function () {
	        return this._canInherit;
	    };
	    NodeClass.prototype.getReferenceIs = function () {
	        return this._referenceIs;
	    };
	    NodeClass.prototype.withReferenceIs = function (fname) {
	        this._referenceIs = fname;
	    };
	    NodeClass.prototype.withAllowQuestion = function () {
	        this._allowQuestion = true;
	    };
	    NodeClass.prototype.requiredProperties = function () {
	        return this.allProperties().filter(function (x) { return x.isRequired(); });
	    };
	    NodeClass.prototype.getAllowQuestion = function () {
	        return this._allowQuestion;
	    };
	    NodeClass.prototype.withAllowAny = function () {
	        this._allowAny = true;
	    };
	    NodeClass.prototype.getAllowAny = function () {
	        return this._allowAny;
	    };
	    NodeClass.prototype.withActuallyExports = function (pname) {
	        this._actuallyExports = pname;
	    };
	    NodeClass.prototype.withConvertsToGlobal = function (pname) {
	        this._convertsToGlobal = pname;
	    };
	    NodeClass.prototype.getConvertsToGlobal = function () {
	        return this._convertsToGlobal;
	    };
	    NodeClass.prototype.getActuallyExports = function () {
	        return this._actuallyExports;
	    };
	    NodeClass.prototype.withContextRequirement = function (name, value) {
	        this._contextReq.push({ name: name, value: value });
	    };
	    NodeClass.prototype.getContextRequirements = function () {
	        return this._contextReq;
	    };
	    NodeClass.prototype.isGlobalDeclaration = function () {
	        if (this._actuallyExports) {
	            return true;
	        }
	        if (this._inlinedTemplates) {
	            return true;
	        }
	        if (this._declaresType) {
	            return true;
	        }
	        return false;
	    };
	    NodeClass.prototype.findMembersDeterminer = function () {
	        return _.find(this.allProperties(), function (x) { return x.isThisPropertyDeclaresTypeFields(); });
	    };
	    NodeClass.prototype.isTypeSystemMember = function () {
	        return this._declaresType != null;
	    };
	    NodeClass.prototype.hasStructure = function () {
	        return true;
	    };
	    NodeClass.prototype.getExtendedType = function () {
	        return this.universe().type(this._declaresType);
	    };
	    NodeClass.prototype.setInlinedTemplates = function (b) {
	        this._inlinedTemplates = b;
	        return this;
	    };
	    NodeClass.prototype.isInlinedTemplates = function () {
	        return this._inlinedTemplates;
	    };
	    NodeClass.prototype.setExtendedTypeName = function (name) {
	        this._declaresType = name;
	        var tp = this.universe().type(name);
	        if (tp instanceof NodeClass) {
	            var nc = tp;
	            nc._runtimeExtenders.push(this);
	        }
	    };
	    //private vReqInitied=false;
	    NodeClass.prototype.getRuntimeExtenders = function () {
	        return this._runtimeExtenders;
	    };
	    NodeClass.prototype.createStubNode = function (p, key) {
	        if (key === void 0) { key = null; }
	        var lowLevel = jsyaml.createNode(key ? key : "key");
	        var nm = new hlimpl.ASTNodeImpl(lowLevel, null, this, p);
	        this.allProperties().forEach(function (x) {
	            if (x.range().isValueType() && !x.isSystem()) {
	                var a = nm.attr(x.nameId());
	                if (!a) {
	                }
	            }
	        });
	        nm.children();
	        return nm;
	    };
	    NodeClass.prototype.createProperty = function (parent, key) {
	        if (key === void 0) { key = null; }
	        var lowLevel = jsyaml.createNode(key ? key : "key");
	        var p = new Property('zzz');
	        return p;
	    };
	    NodeClass.prototype.descriminatorValue = function () {
	        if (this.valueRequirements().length == 0) {
	            return this.nameId();
	        }
	        return this.valueRequirements()[0].value;
	    };
	    NodeClass.prototype.match = function (r, alreadyFound) {
	        var _this = this;
	        //this.vReqInitied=true;
	        if (r.isAttr() || r.isUnknown()) {
	            return false;
	        }
	        var el = r;
	        //if (this.name()=="ObjectField"){
	        //   var tp= el.attr("type");
	        //    if (tp&&tp.value()) {
	        //        //FIXME
	        //        if (!_.find(["string","boolean","file","number","integer","date","pointer","script"], x=>x==tp.value())) {
	        //            return true;
	        //        }
	        //    }
	        //}
	        var hasSuperType = _.find(this.superTypes(), function (x) {
	            var dp = _.find(x.allProperties(), function (x) { return x.isDescriminating(); });
	            if (dp) {
	                var a = el.attr(dp.nameId());
	                if (a) {
	                    if (a.value() == _this.nameId()) {
	                        return true;
	                    }
	                }
	            }
	            return false;
	        });
	        if (hasSuperType) {
	            return true;
	        }
	        if (this.valueRequirements().length == 0) {
	            return false;
	        }
	        var matches = true;
	        //descriminating constraint
	        this.valueRequirements().forEach(function (x) {
	            var a = el.attr(x.name);
	            if (a) {
	                if (a.value() == x.value) {
	                }
	                else {
	                    if (_this.getConsumesRefs()) {
	                        var vl = a.value();
	                        var allSubs = [];
	                        _this.superTypes().forEach(function (x) { return x.allSubTypes().forEach(function (y) {
	                            allSubs.push(y);
	                        }); });
	                        var allSubNames = [];
	                        _.unique(allSubs).forEach(function (x) {
	                            allSubNames.push(x.nameId());
	                            x.valueRequirements().forEach(function (y) {
	                                allSubNames.push(y.value);
	                            });
	                            x.getAliases().forEach(function (y) { return allSubNames.push(y); });
	                        });
	                        if (_.find(allSubNames, function (x) { return x == vl; })) {
	                            matches = false;
	                        }
	                    }
	                    else {
	                        matches = false;
	                    }
	                }
	            }
	            else {
	                var m = _this.getDefining();
	                var ms = false;
	                m.forEach(function (x) {
	                    el.lowLevel().children().forEach(function (y) {
	                        if (y.key() == x) {
	                            ms = true;
	                        }
	                        if (y.key() == "$ref") {
	                            if (el.definition().universe().version() == "Swagger") {
	                                var resolved = search.resolveReference(y, y.value());
	                                if (resolved) {
	                                    if (_.find(resolved.children(), function (z) { return z.key() == x; })) {
	                                        ms = true;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                });
	                if (ms) {
	                    matches = true;
	                    return;
	                }
	                if (!alreadyFound) {
	                    var pr = _this.property(x.name);
	                    if (pr && pr.defaultValue() == x.value) {
	                    }
	                    else {
	                        matches = false;
	                    }
	                }
	            }
	        });
	        return matches;
	    };
	    NodeClass.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (this._props) {
	            return this._props;
	        }
	        if (ps[this.nameId()]) {
	            return [];
	        }
	        ps[this.nameId()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    x.allProperties(ps).forEach(function (y) { return n[y.nameId()] = y; });
	                }
	                else {
	                    x.allProperties().forEach(function (y) { return n[y.nameId()] = y; });
	                }
	            });
	        }
	        for (var x in this.getFixedFacets()) {
	            delete n[x];
	        }
	        this._properties.forEach(function (x) { return n[x.nameId()] = x; });
	        this._props = Object.keys(n).map(function (x) { return n[x]; });
	        return this._props;
	    };
	    NodeClass.prototype.isValueType = function () {
	        return false;
	    };
	    NodeClass.prototype.isAbstract = function () {
	        return this._isAbstract;
	    };
	    NodeClass.prototype.isUnionType = function () {
	        return false;
	    };
	    NodeClass.prototype.property = function (propName) {
	        return _.find(this.allProperties(), function (x) { return x.nameId() == propName; });
	    };
	    NodeClass.prototype.propertyIndex = function (name) {
	        var props = this.properties();
	        for (var i = 0; i < props.length; i++) {
	            if (props[i].nameId() == name)
	                return i;
	        }
	        return -1;
	    };
	    NodeClass.prototype.allPropertyIndex = function (name) {
	        var props = this.allProperties();
	        for (var i = 0; i < props.length; i++) {
	            if (props[i].nameId() == name)
	                return i;
	        }
	        return -1;
	    };
	    NodeClass.prototype.properties = function () {
	        return [].concat(this._properties);
	    };
	    NodeClass.prototype.getKeyProp = function () {
	        return _.find(this.allProperties(), function (x) { return x.isKey(); });
	    };
	    NodeClass.prototype.registerProperty = function (p) {
	        if (p.domain() != this) {
	            throw new Error("Should be already owned by this");
	        }
	        if (this._properties.indexOf(p) != -1) {
	            throw new Error("Already included");
	        }
	        this._properties.push(p);
	    };
	    NodeClass.prototype.allRuntimeProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        return [];
	    };
	    return NodeClass;
	})(AbstractType);
	exports.NodeClass = NodeClass;
	var UserDefinedClass = (function (_super) {
	    __extends(UserDefinedClass, _super);
	    function UserDefinedClass(name, universe, hl, path, description) {
	        _super.call(this, name, universe, path, description);
	        this.uc = false;
	        this.setDeclaringNode(hl);
	    }
	    UserDefinedClass.prototype.addRuntimeProperty = function (p) {
	        this._runtimeProperties.push(p);
	    };
	    UserDefinedClass.prototype.key = function () {
	        return null;
	    };
	    UserDefinedClass.prototype.isArray = function () {
	        return _.find(this.allSuperTypes(), function (x) { return x.isArray(); }) != null;
	    };
	    UserDefinedClass.prototype.isUnion = function () {
	        return _.find(this.allSuperTypes(), function (x) {
	            var mm = x;
	            if (mm.uc) {
	                return false;
	            }
	            mm.uc = true;
	            try {
	                return x.isUnion();
	            }
	            finally {
	                mm.uc = false;
	            }
	        }) != null;
	    };
	    UserDefinedClass.prototype.isUserDefined = function () {
	        return true;
	    };
	    UserDefinedClass.prototype.contributeFacets = function (x) {
	        this.findFacets(this.getDeclaringNode(), x);
	    };
	    UserDefinedClass.prototype.findFacets = function (node, x) {
	        if (node) {
	            var chd = node.lowLevel().children();
	            var mi = _.find(chd, function (x) { return x.key() == "minProperties"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	            var mi = _.find(chd, function (x) { return x.key() == "maxProperties"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	        }
	    };
	    UserDefinedClass.prototype.initRuntime = function () {
	        var _this = this;
	        this._runtimeProperties = [];
	        var node = this.getDeclaringNode();
	        if (node) {
	            var el = node.elementsOfKind("properties");
	            el.forEach(function (x) {
	                var prop = typeBuilder.elementToProp(x, true);
	                _this.addRuntimeProperty(prop);
	            });
	        }
	    };
	    UserDefinedClass.prototype.isValueType = function () {
	        if (this.isRuntime()) {
	            return this._value;
	        }
	        if (this.isAssignableFrom("ObjectField")) {
	            return false;
	        }
	        return true;
	    };
	    UserDefinedClass.prototype.componentType = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof Array) {
	                res = y.component;
	            }
	        });
	        return res;
	    };
	    UserDefinedClass.prototype.union = function () {
	        var x = this.allSuperTypes();
	        var res = null;
	        x.forEach(function (y) {
	            if (y instanceof Union) {
	                res = y;
	            }
	        });
	        return res;
	    };
	    UserDefinedClass.prototype.toRuntime = function () {
	        if (this.runtime) {
	            return this.runtime;
	        }
	        var c = new UserDefinedClass(this.nameId(), this.universe(), null, this.getPath(), "");
	        this.runtime = c;
	        c._isRuntime = true;
	        c._representationOf = this;
	        c._properties = this.allRuntimeProperties();
	        c.setDeclaringNode(this.getDeclaringNode());
	        if (this.isAssignableFrom("ObjectField")) {
	            c._value = false;
	            if (c._properties.length == 0) {
	                c.withAllowAny();
	            }
	        }
	        else {
	            c._value = true;
	        }
	        if (this.isUnion()) {
	            var ut = new Union(this.nameId(), this.universe(), this.getPath(), "");
	            ut._representationOf = this;
	            ut._isRuntime = true;
	            ut.setDeclaringNode(this.getDeclaringNode());
	            var cm = this.union();
	            if (cm) {
	                if (cm.left) {
	                    ut.left = cm.left.toRuntime();
	                }
	                if (cm.right) {
	                    ut.right = cm.right.toRuntime();
	                }
	                return ut;
	            }
	            this.runtime = ut;
	            //at.component=this.component.toRuntime();
	            return ut;
	        }
	        if (this.isArray()) {
	            var at = new defs.Array(this.nameId(), this.universe(), this.getPath(), "");
	            this.runtime = at;
	            at._representationOf = this;
	            at.setDeclaringNode(this.getDeclaringNode());
	            var cm = this.componentType();
	            if (cm) {
	                at.component = cm.toRuntime();
	            }
	            //at.component=this.component.toRuntime();
	            return at;
	        }
	        return c;
	    };
	    UserDefinedClass.prototype.allRuntimeProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        if (!this._runtimeProperties) {
	            this.initRuntime();
	            this._rprops = null;
	        }
	        if (this._rprops) {
	            return this._rprops;
	        }
	        if (ps[this.nameId()]) {
	            return [];
	        }
	        ps[this.nameId()] = this;
	        var n = {};
	        if (this.superTypes().length > 0) {
	            this.superTypes().forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    x.allRuntimeProperties(ps).forEach(function (y) { return n[y.nameId()] = y; });
	                }
	            });
	        }
	        this._runtimeProperties.forEach(function (x) { return n[x.nameId()] = x; });
	        this._rprops = Object.keys(n).map(function (x) { return n[x]; });
	        return this._rprops;
	    };
	    UserDefinedClass.prototype.getRuntimeProperties = function () {
	        if (!this._runtimeProperties) {
	            this.initRuntime();
	        }
	        return this._runtimeProperties;
	    };
	    return UserDefinedClass;
	})(NodeClass);
	exports.UserDefinedClass = UserDefinedClass;
	var AnnotationType = (function (_super) {
	    __extends(AnnotationType, _super);
	    function AnnotationType() {
	        _super.apply(this, arguments);
	    }
	    AnnotationType.prototype.allProperties = function (ps) {
	        if (ps === void 0) { ps = {}; }
	        var result = _super.prototype.allProperties.call(this, ps);
	        if (result.length <= 1) {
	            //we have only key property defined
	            var up = new UserDefinedProp("value");
	            up.withDomain(this);
	            up._node = this.getDeclaringNode();
	            up.withCanBeValue();
	            up.withRequired(false);
	            up.withRange(this.universe().getType("StringType"));
	            var rr = [].concat(result);
	            rr.push(up);
	            return rr;
	        }
	        return result;
	    };
	    return AnnotationType;
	})(UserDefinedClass);
	exports.AnnotationType = AnnotationType;
	var Universe = (function (_super) {
	    __extends(Universe, _super);
	    function Universe(name, _parent, v) {
	        if (name === void 0) { name = ""; }
	        if (_parent === void 0) { _parent = null; }
	        if (v === void 0) { v = "RAML08"; }
	        _super.call(this, name);
	        this._parent = _parent;
	        this._classes = [];
	        this._uversion = "RAML08";
	        this.aMap = {};
	        this._uversion = v;
	    }
	    Universe.prototype.matched = function () {
	        if (this.matchedObjects) {
	            return this.matchedObjects;
	        }
	        if (this._parent) {
	            return this._parent.matched();
	        }
	        if (this._uversion == "RAML08") {
	            this.matchedObjects = universes.Universe08;
	            return this.matchedObjects;
	        }
	        else {
	            this.matchedObjects = universes.Universe10;
	            return this.matchedObjects;
	        }
	    };
	    Universe.prototype.setTopLevel = function (t) {
	        this._topLevel = t;
	    };
	    Universe.prototype.getTopLevel = function () {
	        return this._topLevel;
	    };
	    Universe.prototype.setTypedVersion = function (tv) {
	        this._typedVersion = tv;
	    };
	    Universe.prototype.getTypedVersion = function () {
	        return this._typedVersion;
	    };
	    Universe.prototype.version = function () {
	        return this._uversion;
	    };
	    Universe.prototype.setUniverseVersion = function (version) {
	        this._uversion = version;
	    };
	    Universe.prototype.types = function () {
	        var result = [].concat(this._classes);
	        if (this._parent != null) {
	            result = result.concat(this._parent.types());
	        }
	        return result;
	    };
	    Universe.prototype.type = function (name) {
	        if (this.aMap[name]) {
	            return this.aMap[name];
	        }
	        var tp = _.find(this._classes, function (x) { return x.nameId() == name; });
	        if (tp == null) {
	            if (this._parent) {
	                var tp = this._parent.type(name);
	                if (tp instanceof AbstractType) {
	                    var at = tp;
	                    at._universe = this; //FIXME
	                }
	            }
	        }
	        return tp;
	    };
	    Universe.prototype.getType = function (name) {
	        return this.type(name);
	    };
	    Universe.prototype.register = function (t) {
	        this._classes.push(t);
	        if (t instanceof NodeClass) {
	            this._classes.forEach(function (x) {
	                if (x instanceof NodeClass) {
	                    var nc = x;
	                    if (nc.getExtendedType() == t) {
	                        t.getRuntimeExtenders().push(x);
	                    }
	                }
	            });
	        }
	        return this;
	    };
	    Universe.prototype.registerAlias = function (a, t) {
	        this.aMap[a] = t;
	    };
	    Universe.prototype.unregister = function (t) {
	        this._classes = this._classes.filter(function (x) { return x != t; });
	        var st = t.superTypes();
	        st.forEach(function (x) {
	            var a = x;
	            a._superTypes = a._superTypes.filter(function (x) { return x != t; });
	        });
	        st = t.subTypes();
	        st.forEach(function (x) {
	            var a = x;
	            a._subTypes = a._subTypes.filter(function (x) { return x != t; });
	        });
	        return this;
	    };
	    Universe.prototype.registerSuperClass = function (t0, t1) {
	        var a0 = t0;
	        var a1 = t1;
	        a0._superTypes.push(t1);
	        a1._subTypes.push(t0);
	    };
	    return Universe;
	})(Described);
	exports.Universe = Universe;
	var ValueRestriction = (function () {
	    function ValueRestriction() {
	    }
	    ValueRestriction.prototype.test = function (n, p, value) {
	        throw new Error("Should be overriden in subclasses");
	    };
	    return ValueRestriction;
	})();
	exports.ValueRestriction = ValueRestriction;
	/**
	 * references element in upper hierarchy
	 */
	var ReferenceTo = (function (_super) {
	    __extends(ReferenceTo, _super);
	    function ReferenceTo(_requiredClass) {
	        _super.call(this);
	        this._requiredClass = _requiredClass;
	    }
	    ReferenceTo.prototype.requiredClass = function () {
	        return this._requiredClass;
	    };
	    return ReferenceTo;
	})(ValueRestriction);
	exports.ReferenceTo = ReferenceTo;
	/**
	 * should be fixed set
	 */
	var FixedSetRestriction = (function (_super) {
	    __extends(FixedSetRestriction, _super);
	    function FixedSetRestriction(_allowedValues) {
	        _super.call(this);
	        this._allowedValues = _allowedValues;
	    }
	    FixedSetRestriction.prototype.values = function () {
	        return this._allowedValues;
	    };
	    return FixedSetRestriction;
	})(ValueRestriction);
	exports.FixedSetRestriction = FixedSetRestriction;
	/**
	 * should be reg exp
	 */
	var RegExpRestriction = (function (_super) {
	    __extends(RegExpRestriction, _super);
	    function RegExpRestriction(_regExp) {
	        _super.call(this);
	        this._regExp = _regExp;
	    }
	    RegExpRestriction.prototype.regeExp = function () {
	        return this._regExp;
	    };
	    return RegExpRestriction;
	})(ValueRestriction);
	exports.RegExpRestriction = RegExpRestriction;
	var UnionType = (function () {
	    function UnionType(_base) {
	        this._base = _base;
	    }
	    UnionType.prototype.key = function () {
	        return null;
	    };
	    UnionType.prototype.getDeclaringNode = function () {
	        return null;
	    };
	    UnionType.prototype.setDeclaringNode = function (c) {
	        return null;
	    };
	    UnionType.prototype.isUserDefined = function () {
	        return false;
	    };
	    UnionType.prototype.isRuntime = function () {
	        return false;
	    };
	    UnionType.prototype.nameId = function () {
	        return this.name();
	    };
	    UnionType.prototype.isArray = function () {
	        return false;
	    };
	    UnionType.prototype.isUnion = function () {
	        return true;
	    };
	    UnionType.prototype.union = function () {
	        return null;
	    };
	    UnionType.prototype.getRuntimeExtenders = function () {
	        return [];
	    };
	    UnionType.prototype.methods = function () {
	        return [];
	    };
	    UnionType.prototype.superTypes = function () {
	        return [];
	    };
	    UnionType.prototype.allSuperTypes = function () {
	        return [];
	    };
	    UnionType.prototype.isAssignableFrom = function (typeName) {
	        return false;
	    };
	    UnionType.prototype.subTypes = function () {
	        return [];
	    };
	    UnionType.prototype.name = function () {
	        return this._base.map(function (x) { return x.nameId(); }).join(",");
	    };
	    UnionType.prototype.hasStructure = function () {
	        return false;
	    };
	    UnionType.prototype.description = function () {
	        return "";
	    };
	    UnionType.prototype.isValid = function () {
	        return true;
	    };
	    UnionType.prototype.universe = function () {
	        return this._base[0].universe();
	    };
	    UnionType.prototype.match = function (r) {
	        return false;
	    };
	    UnionType.prototype.allSubTypes = function () {
	        throw new Error("Union types should not be used in this context");
	    };
	    UnionType.prototype.annotations = function () {
	        throw new Error("Union types should not be used in this context");
	    };
	    UnionType.prototype.allProperties = function () {
	        throw new Error("Union types should be never used in this context");
	    };
	    UnionType.prototype.getAlternatives = function () {
	        return [].concat(this._base);
	    };
	    UnionType.prototype.valueRequirements = function () {
	        throw new Error("Union types should be never used in this context");
	    };
	    UnionType.prototype.toRuntime = function () {
	        throw new Error("Not implemented");
	    };
	    UnionType.prototype.properties = function () {
	        var res = [];
	        this._base.forEach(function (x) { return res.concat(x.properties()); });
	        return res;
	    };
	    UnionType.prototype.isValueType = function () {
	        if (this._base.filter(function (x) { return (x.isValueType() == true); }).length == this._base.length) {
	            return true;
	        }
	        if (this._base.filter(function (x) { return (x.isValueType() == false); }).length == this._base.length) {
	            return false;
	        }
	        return null;
	    };
	    UnionType.prototype.isUnionType = function () {
	        return true;
	    };
	    return UnionType;
	})();
	exports.UnionType = UnionType;
	var PropertyTrait = (function () {
	    function PropertyTrait() {
	    }
	    return PropertyTrait;
	})();
	exports.PropertyTrait = PropertyTrait;
	var DefinesImplicitKey = (function (_super) {
	    __extends(DefinesImplicitKey, _super);
	    function DefinesImplicitKey(_where, _childKeyDefined) {
	        _super.call(this);
	        this._where = _where;
	        this._childKeyDefined = _childKeyDefined;
	    }
	    DefinesImplicitKey.prototype.where = function () {
	        return this._where;
	    };
	    DefinesImplicitKey.prototype.definesKeyOf = function () {
	        return this._childKeyDefined;
	    };
	    return DefinesImplicitKey;
	})(PropertyTrait);
	exports.DefinesImplicitKey = DefinesImplicitKey;
	var ExpansionTrait = (function (_super) {
	    __extends(ExpansionTrait, _super);
	    function ExpansionTrait() {
	        _super.call(this);
	    }
	    return ExpansionTrait;
	})(PropertyTrait);
	exports.ExpansionTrait = ExpansionTrait;
	function prop(name, desc, domain, range) {
	    var prop = new Property(name, desc);
	    return prop.withDomain(domain).withRange(range);
	}
	exports.prop = prop;
	var ChildValueConstraint = (function () {
	    function ChildValueConstraint(name, value) {
	        this.name = name;
	        this.value = value;
	    }
	    return ChildValueConstraint;
	})();
	exports.ChildValueConstraint = ChildValueConstraint;
	var Property = (function (_super) {
	    __extends(Property, _super);
	    function Property() {
	        _super.apply(this, arguments);
	        this._keyShouldStartFrom = null;
	        this._isMultiValue = false;
	        this._isFromParentValue = false;
	        this._isFromParentKey = false;
	        this._isRequired = false;
	        this._key = false;
	        this._traits = [];
	        this._describes = null;
	        this._descriminates = false;
	        this._selfNode = false;
	        this._contextReq = [];
	        this._vrestr = [];
	        this.determinesChildValues = [];
	    }
	    Property.prototype.withNoDirectParse = function () {
	        this._noDirectParse = true;
	    };
	    Property.prototype.isNoDirectParse = function () {
	        return this._noDirectParse;
	    };
	    Property.prototype.setDocTableName = function (val) {
	        this._docTableName = val;
	    };
	    Property.prototype.docTableName = function () {
	        return this._docTableName;
	    };
	    Property.prototype.setHidden = function (val) {
	        this._isHidden = val;
	    };
	    Property.prototype.isHidden = function () {
	        return this._isHidden;
	    };
	    Property.prototype.setMarkdownDescription = function (val) {
	        this._markdownDescription = val;
	    };
	    Property.prototype.markdownDescription = function () {
	        return this._markdownDescription;
	    };
	    Property.prototype.setValueDescription = function (val) {
	        this._valueDescription = val;
	    };
	    Property.prototype.valueDescription = function () {
	        return this._valueDescription;
	    };
	    Property.prototype.isExampleProperty = function () {
	        return this.domain() && (!this.domain().isUserDefined()) && ((this.nameId() == universes.Universe10.DataElement.properties.example.name) || (this.nameId() == universes.Universe10.ExampleSpec.properties.content.name));
	    };
	    Property.prototype.getFacetValidator = function () {
	        return this.facetValidator;
	    };
	    Property.prototype.setFacetValidator = function (f) {
	        this.facetValidator = f;
	    };
	    Property.prototype.withSelfNode = function () {
	        this._selfNode = true;
	    };
	    Property.prototype.isSelfNode = function () {
	        return this._selfNode;
	    };
	    Property.prototype.getSelector = function (h) {
	        var sl = this._selector;
	        if (sl instanceof selector.Selector) {
	            return sl;
	        }
	        if (!h) {
	            return null;
	        }
	        if (this._selector) {
	            return selector.parse(h, this._selector);
	        }
	        return null;
	    };
	    Property.prototype.setSelector = function (s) {
	        this._selector = s;
	        return this;
	    };
	    Property.prototype.valueDocProvider = function () {
	        return this._vprovider;
	    };
	    Property.prototype.setValueDocProvider = function (v) {
	        this._vprovider = v;
	        return this;
	    };
	    Property.prototype.suggester = function () {
	        return this._suggester;
	    };
	    Property.prototype.setValueSuggester = function (s) {
	        this._suggester = s;
	    };
	    Property.prototype.enumOptions = function () {
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.getOftenKeys = function () {
	        return this._oftenKeys;
	    };
	    Property.prototype.withOftenKeys = function (keys) {
	        this._oftenKeys = keys;
	        return this;
	    };
	    Property.prototype.withCanBeValue = function () {
	        this._canBeValue = true;
	        return this;
	    };
	    Property.prototype.withInherited = function (w) {
	        this._isInherited = w;
	    };
	    Property.prototype.isInherited = function () {
	        return this._isInherited;
	    };
	    Property.prototype.isAllowNull = function () {
	        return this._isAllowNull;
	    };
	    Property.prototype.withAllowNull = function () {
	        this._isAllowNull = true;
	    };
	    Property.prototype.isDescriminator = function () {
	        return this._descriminates;
	    };
	    Property.prototype.getCanBeDuplicator = function () {
	        return this._canBeDuplicator;
	    };
	    Property.prototype.isValue = function () {
	        return this._isFromParentValue;
	    };
	    Property.prototype.canBeValue = function () {
	        return this._canBeValue;
	    };
	    Property.prototype.setCanBeDuplicator = function () {
	        this._canBeDuplicator = true;
	        return true;
	    };
	    Property.prototype.inheritedContextValue = function () {
	        return this._inheritsValueFromContext;
	    };
	    Property.prototype.withInheritedContextValue = function (v) {
	        this._inheritsValueFromContext = v;
	        return this;
	    };
	    Property.prototype.withPropertyGrammarType = function (pt) {
	        this._propertyGrammarType = pt;
	    };
	    Property.prototype.getPropertyGrammarType = function () {
	        return this._propertyGrammarType;
	    };
	    Property.prototype.withContextRequirement = function (name, value) {
	        this._contextReq.push({ name: name, value: value });
	    };
	    Property.prototype.getContextRequirements = function () {
	        return this._contextReq;
	    };
	    Property.prototype.withDescriminating = function (b) {
	        this._descriminates = b;
	        return this;
	    };
	    Property.prototype.isDescriminating = function () {
	        return this._descriminates;
	    };
	    Property.prototype.withDescribes = function (a) {
	        this._describes = a;
	        return this;
	    };
	    Property.prototype.withValueRewstrinction = function (exp, message) {
	        this._vrestr.push({ exp: exp, message: message });
	        return this;
	    };
	    Property.prototype.getValueRestrictionExpressions = function () {
	        return this._vrestr;
	    };
	    Property.prototype.describesAnnotation = function () {
	        return this._describes != null;
	    };
	    Property.prototype.describedAnnotation = function () {
	        return this._describes;
	    };
	    Property.prototype.createAttr = function (val) {
	        var lowLevel = jsyaml.createMapping(this.nameId(), val);
	        var nm = new hlimpl.ASTPropImpl(lowLevel, null, this.range(), this);
	        return nm;
	    };
	    Property.prototype.isReference = function () {
	        return this.range() instanceof ReferenceType;
	    };
	    Property.prototype.referencesTo = function () {
	        return this.range().getReferencedType();
	    };
	    Property.prototype.newInstanceName = function () {
	        if (this._newInstanceName) {
	            return this._newInstanceName;
	        }
	        return this.range().nameId();
	    };
	    Property.prototype.withThisPropertyDeclaresFields = function (b) {
	        if (b === void 0) { b = true; }
	        this._declaresFields = b;
	        return this;
	    };
	    Property.prototype.isThisPropertyDeclaresTypeFields = function () {
	        return this._declaresFields;
	    };
	    Property.prototype.withNewInstanceName = function (name) {
	        this._newInstanceName = name;
	        return this;
	    };
	    Property.prototype.addChildValueConstraint = function (c) {
	        this.determinesChildValues.push(c);
	    };
	    Property.prototype.setDefaultVal = function (s) {
	        this._defaultVal = s;
	        return this;
	    };
	    Property.prototype.defaultValue = function () {
	        return this._defaultVal;
	    };
	    Property.prototype.getChildValueConstraints = function () {
	        return this.determinesChildValues;
	    };
	    Property.prototype.childRestrictions = function () {
	        return this.determinesChildValues;
	    };
	    Property.prototype.isSystem = function () {
	        return this._isSystem;
	    };
	    Property.prototype.withSystem = function (s) {
	        this._isSystem = s;
	        return this;
	    };
	    Property.prototype.isEmbedMap = function () {
	        return this._isEmbedMap;
	    };
	    Property.prototype.withEmbedMap = function () {
	        this._isEmbedMap = true;
	        return this;
	    };
	    Property.prototype.id = function () {
	        if (this._id) {
	            return this._id;
	        }
	        if (!this._groupName) {
	            return null;
	        }
	        if (this.domain().getDeclaringNode()) {
	            return null;
	        }
	        this._id = this._groupName + this.domain().nameId();
	        return this._id;
	    };
	    Property.prototype.isValidValue = function (vl, c) {
	        var node = search.declRoot(c);
	        if (!node._cach) {
	            node._cach = {};
	        }
	        var id = this.id();
	        if (id) {
	            var cached = node._cach[id];
	            if (cached) {
	                return cached[vl] != null;
	            }
	        }
	        var vls = this.enumValues(c);
	        var mm = {};
	        vls.forEach(function (x) { return mm[x] = 1; });
	        if (this._groupName) {
	            node._cach[id] = mm;
	        }
	        return mm[vl] != null;
	    };
	    Property.prototype.enumValues = function (c) {
	        if (c) {
	            var rs = [];
	            //TODO FIXME it is very very weird idea but I need to get it working right now
	            if (this.isTypeExpr()) {
	                var definitionNodes = search.globalDeclarations(c).filter(function (node) {
	                    var nc = node.definition().key();
	                    if (nc === universes.Universe08.GlobalSchema || nc === universes.Universe10.GlobalSchema) {
	                        return true;
	                    }
	                    return (node.definition().isAssignableFrom(universes.Universe10.DataElement.name));
	                    //return true;
	                });
	                rs = definitionNodes.map(function (x) { return hlimpl.qName(x, c); });
	                var de = c.definition().universe().getType(universes.Universe10.DataElement.name);
	                if (de) {
	                    var subTypes = de.allSubTypes();
	                    rs = rs.concat(subTypes.map(function (x) { return x.descriminatorValue(); }));
	                }
	                return rs;
	            }
	            else {
	                if (this.range().key() == universes.Universe08.SchemaString || this.range().key() == universes.Universe10.SchemaString) {
	                    if (this.range().universe().version() == "RAML10") {
	                        if (this.range() instanceof defs.ValueType) {
	                            var definitionNodes = search.globalDeclarations(c).filter(function (node) {
	                                if (node.definition().key() == universes.Universe10.GlobalSchema) {
	                                    return true;
	                                }
	                                return node.definition().isAssignableFrom(universes.Universe10.DataElement.name);
	                            });
	                            rs = definitionNodes.map(function (x) { return hlimpl.qName(x, c); });
	                        }
	                    }
	                }
	            }
	            if (this.isDescriminating()) {
	                var subTypes = search.subTypesWithLocals(this.domain(), c);
	                rs = rs.concat(subTypes.map(function (x) { return x.descriminatorValue(); }));
	            }
	            else if (this.isReference()) {
	                rs = search.nodesDeclaringType(this.referencesTo(), c).map(function (x) { return hlimpl.qName(x, c); });
	            }
	            else if (this.range().isValueType() && this.range() instanceof ValueType) {
	                var vt = this.range();
	                if (vt.globallyDeclaredBy().length > 0) {
	                    var definitionNodes = search.globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                    rs = rs.concat(definitionNodes.map(function (x) { return hlimpl.qName(x, c); }));
	                }
	            }
	            if (this.isAllowNull()) {
	                rs.push("null");
	            }
	            if (this._enumOptions) {
	                rs = rs.concat(this._enumOptions);
	            }
	            return rs;
	        }
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.isTypeExpr = function () {
	        if (this.teDef && false) {
	            return this.texpr;
	        }
	        if (this.domain()) {
	            var dc = this.domain().key();
	            this.texpr = ((this.nameId() == universes.Universe10.DataElement.properties.type.name || this.nameId() == universes.Universe10.DataElement.properties.schema.name) && dc == universes.Universe10.DataElement) || (this.nameId() == universes.Universe08.BodyLike.properties.schema.name && dc === universes.Universe08.BodyLike);
	        }
	        if (!this.texpr) {
	            if (this.range().key() === universes.Universe08.SchemaString || this.range().key() === universes.Universe10.SchemaString) {
	                if (this.range().universe().version() == "RAML10") {
	                    if (this.range() instanceof defs.ValueType) {
	                        this.texpr = true;
	                    }
	                }
	            }
	        }
	        this.teDef = true;
	        return this.texpr;
	    };
	    Property.prototype.priority = function () {
	        if (this.isKey())
	            return 128;
	        else if (this.isReference())
	            return 64;
	        else if (this.isTypeExpr())
	            return 32;
	        else if (this.nameId() == 'example')
	            return 0;
	        else
	            return -1024;
	    };
	    Property.prototype.referenceTargets = function (c) {
	        if (this.isTypeExpr()) {
	            var definitionNodes = search.globalDeclarations(c).filter(function (node) {
	                var nc = node.definition().key();
	                if (nc === universes.Universe08.GlobalSchema || nc === universes.Universe10.GlobalSchema) {
	                    return true;
	                }
	                return node.definition().isAssignableFrom(universes.Universe10.DataElement.name);
	            });
	            return definitionNodes;
	        }
	        if (this.isDescriminating()) {
	            var subTypes = search.nodesDeclaringType(this.range(), c);
	            return subTypes;
	        }
	        if (this.isReference()) {
	            var rt = this.referencesTo();
	            var subTypes = search.nodesDeclaringType(rt, c);
	            return subTypes;
	        }
	        if (this.range().isValueType()) {
	            var vt = this.range();
	            if (vt.globallyDeclaredBy().length > 0) {
	                var definitionNodes = search.globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                return definitionNodes;
	            }
	        }
	        return [];
	    };
	    Property.prototype.getEnumOptions = function () {
	        if (this._enumOptions && typeof this._enumOptions == 'string') {
	            return [this._enumOptions + ""];
	        }
	        return this._enumOptions;
	    };
	    Property.prototype.withEnumOptions = function (op) {
	        this._enumOptions = op;
	        return this;
	    };
	    Property.prototype.withDomain = function (d) {
	        this._ownerClass = d;
	        d.registerProperty(this);
	        return this;
	    };
	    Property.prototype.withRange = function (t) {
	        this._nodeRange = t;
	        return this;
	    };
	    Property.prototype.getTraits = function () {
	        return this._traits;
	    };
	    Property.prototype.keyPrefix = function () {
	        return this._keyShouldStartFrom;
	    };
	    Property.prototype.isAnnotation = function () {
	        return this._groupName == 'annotations' && this.domain() && !this.domain().isUserDefined();
	    };
	    Property.prototype.matchKey = function (k) {
	        if (k == null) {
	            return false;
	        }
	        if (this._groupName != null) {
	            if (this.isAnnotation()) {
	                if (k.charAt(0) == '(' && k.charAt(k.length - 1) == ')') {
	                    return true;
	                }
	                return false;
	            }
	            return this._groupName == k;
	        }
	        else {
	            if (this._keyShouldStartFrom != null) {
	                if (k.indexOf(this._keyShouldStartFrom) == 0) {
	                    return true;
	                }
	            }
	            if (this._enumOptions) {
	                if (this._enumOptions.indexOf(k) != -1) {
	                    return true;
	                }
	            }
	            if (this.getKeyRegexp()) {
	                try {
	                    if (new RegExp(this.getKeyRegexp()).test(k)) {
	                        return true;
	                    }
	                }
	                catch (Error) {
	                }
	            }
	            return false;
	        }
	    };
	    Property.prototype.withMultiValue = function (v) {
	        if (v === void 0) { v = true; }
	        this._isMultiValue = v;
	        return this;
	    };
	    Property.prototype.withFromParentValue = function (v) {
	        if (v === void 0) { v = true; }
	        this._isFromParentValue = v;
	        return this;
	    };
	    Property.prototype.withFromParentKey = function (v) {
	        if (v === void 0) { v = true; }
	        this._isFromParentKey = v;
	        return this;
	    };
	    Property.prototype.isFromParentKey = function () {
	        return this._isFromParentKey;
	    };
	    Property.prototype.isFromParentValue = function () {
	        return this._isFromParentValue;
	    };
	    Property.prototype.withGroupName = function (gname) {
	        this._groupName = gname;
	        return this;
	    };
	    Property.prototype.withRequired = function (req) {
	        this._isRequired = req;
	        return this;
	    };
	    Property.prototype.unmerge = function () {
	        this._groupName = this.nameId();
	        return this;
	    };
	    Property.prototype.merge = function () {
	        this._groupName = null;
	        return this;
	    };
	    Property.prototype.withKey = function (isKey) {
	        this._key = isKey;
	        return this;
	    };
	    /**
	     * TODO THIS STUFF SHOULD BE MORE ABSTRACT (LATER...)
	     * @param keyShouldStartFrom
	     * @returns {Property}
	     */
	    Property.prototype.withKeyRestriction = function (keyShouldStartFrom) {
	        this._keyShouldStartFrom = keyShouldStartFrom;
	        return this;
	    };
	    Property.prototype.withKeyRegexp = function (regexp) {
	        this._keyRegexp = regexp;
	    };
	    Property.prototype.getKeyRegexp = function () {
	        return this._keyRegexp;
	    };
	    Property.prototype.domain = function () {
	        return this._ownerClass;
	    };
	    Property.prototype.range = function () {
	        return this._nodeRange;
	    };
	    Property.prototype.isKey = function () {
	        return this._key;
	    };
	    Property.prototype.isValueProperty = function () {
	        return this._nodeRange.isValueType();
	    };
	    Property.prototype.isRequired = function () {
	        return this._isRequired;
	    };
	    Property.prototype.isMultiValue = function () {
	        if (this.range() && this.range() instanceof Array) {
	            return true;
	        }
	        return this._isMultiValue;
	    };
	    Property.prototype.isMerged = function () {
	        return this._groupName == null;
	    };
	    Property.prototype.isPrimitive = function () {
	        if (!this._nodeRange) {
	            return true;
	        }
	        var key = this._nodeRange.key();
	        if (key == universes.Universe08.StringType || key == universes.Universe10.StringType) {
	            return true;
	        }
	        if (key == universes.Universe08.NumberType || key == universes.Universe10.NumberType) {
	            return true;
	        }
	        if (key == universes.Universe08.BooleanType || key == universes.Universe10.BooleanType) {
	            return true;
	        }
	        return false;
	    };
	    Property.prototype.groupName = function () {
	        return this._groupName;
	    };
	    Property.prototype.key = function () {
	        //TODO implement that
	        return null;
	    };
	    return Property;
	})(Described);
	exports.Property = Property;
	var Array = (function (_super) {
	    __extends(Array, _super);
	    function Array() {
	        _super.apply(this, arguments);
	    }
	    Array.prototype.isArray = function () {
	        return true;
	    };
	    Array.prototype.isUserDefined = function () {
	        return true;
	    };
	    Array.prototype.componentType = function () {
	        return this.component;
	    };
	    Array.prototype.key = function () {
	        return null;
	    };
	    Array.prototype.findFacets = function (node, x) {
	        if (node) {
	            var chd = node.lowLevel().children();
	            var mi = _.find(chd, function (x) { return x.key() == "minItems"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	            var mi = _.find(chd, function (x) { return x.key() == "maxItems"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	            var mi = _.find(chd, function (x) { return x.key() == "uniqueItems"; });
	            if (mi) {
	                x[mi.key()] = mi;
	            }
	        }
	    };
	    Array.prototype.isValid = function (h, v, p) {
	        if (this.component) {
	            return this.component.isValid(h, v, p);
	        }
	        return true;
	    };
	    Array.prototype.toRuntime = function () {
	        var rs = new Array(this.nameId(), this.universe(), "");
	        rs._af = {};
	        var fs = this.getFixedFacets();
	        for (var i in fs) {
	            rs._af[i] = fs[i];
	        }
	        rs._representationOf = this;
	        rs.component = this.component ? this.component.toRuntime() : this.component;
	        rs.dimensions = this.dimensions;
	        return rs;
	    };
	    return Array;
	})(NodeClass);
	exports.Array = Array;
	var ExternalType = (function (_super) {
	    __extends(ExternalType, _super);
	    function ExternalType() {
	        _super.apply(this, arguments);
	    }
	    ExternalType.prototype.isUserDefined = function () {
	        return true;
	    };
	    return ExternalType;
	})(NodeClass);
	exports.ExternalType = ExternalType;
	var Union = (function (_super) {
	    __extends(Union, _super);
	    function Union() {
	        _super.apply(this, arguments);
	    }
	    Union.prototype.key = function () {
	        return null;
	    };
	    Union.prototype.leftType = function () {
	        return this.left;
	    };
	    Union.prototype.rightType = function () {
	        return this.right;
	    };
	    Union.prototype.isUserDefined = function () {
	        return true;
	    };
	    Union.prototype.toRuntime = function () {
	        var u = new Union(this.nameId(), this.universe(), "");
	        u.left = this.left;
	        u.right = this.right;
	        u.setDeclaringNode(this.getDeclaringNode());
	        return this;
	    };
	    Union.prototype.union = function () {
	        return this;
	    };
	    Union.prototype.isUnion = function () {
	        return true;
	    };
	    Union.prototype.isArray = function () {
	        if (this.left && this.right) {
	            return this.left.isArray() || this.right.isArray();
	        }
	        if (this.left) {
	            return this.left.isArray();
	        }
	        if (this.right) {
	            return this.right.isArray();
	        }
	    };
	    return Union;
	})(NodeClass);
	exports.Union = Union;
	var UserDefinedProp = (function (_super) {
	    __extends(UserDefinedProp, _super);
	    function UserDefinedProp() {
	        _super.apply(this, arguments);
	    }
	    UserDefinedProp.prototype.withDisplayName = function (name) {
	        this._displayName = name;
	    };
	    UserDefinedProp.prototype.getDisplayName = function () {
	        return this._displayName;
	    };
	    UserDefinedProp.prototype.node = function () {
	        return this._node;
	    };
	    return UserDefinedProp;
	})(Property);
	exports.UserDefinedProp = UserDefinedProp;


/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = require("underscore");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var jsyaml = __webpack_require__(6);
	var defs = __webpack_require__(3);
	var hl = __webpack_require__(2);
	var ll = __webpack_require__(8);
	var _ = __webpack_require__(4);
	var yaml = __webpack_require__(7);
	var proxy = __webpack_require__(59);
	var typeExpression = __webpack_require__(63);
	var def = __webpack_require__(3);
	var builder = __webpack_require__(80);
	var linter = __webpack_require__(72);
	var typeBuilder = __webpack_require__(66);
	var search = __webpack_require__(65);
	var universes = __webpack_require__(62);
	var textutil = __webpack_require__(42);
	var ModelFactory = __webpack_require__(81);
	var ovlval = __webpack_require__(97);
	function qName(x, context) {
	    var dr = search.declRoot(context);
	    var nm = x.name();
	    var o = nm;
	    var ind = nm.indexOf("<"); //TODO SCOPE IT
	    if (ind != -1) {
	        nm = nm.substring(0, ind);
	    }
	    while (true) {
	        var np = x.parent();
	        if (!np || np == dr) {
	            break;
	        }
	        else {
	            if (np.definition().key() == universes.Universe10.Library && np.parent()) {
	                nm = np.name() + "." + nm;
	            }
	            x = np;
	        }
	    }
	    return nm;
	}
	exports.qName = qName;
	function insideResourceTypeOrTrait(h) {
	    var declRoot = h;
	    while (true) {
	        if (declRoot.definition().isInlinedTemplates()) {
	            return true;
	        }
	        var np = declRoot.parent();
	        if (!np) {
	            break;
	        }
	        else {
	            declRoot = np;
	        }
	    }
	    return false;
	}
	var loophole = __webpack_require__(79);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	exports.evalInSandbox = evalInSandbox;
	var BasicASTNode = (function () {
	    function BasicASTNode(_node, _parent) {
	        this._node = _node;
	        this._parent = _parent;
	        this._implicit = false;
	        this.values = {};
	        if (_node) {
	            _node.setHighLevelParseResult(this);
	        }
	    }
	    BasicASTNode.prototype.getKind = function () {
	        return 0 /* BASIC */;
	    };
	    BasicASTNode.prototype.hashkey = function () {
	        if (!this._hashkey)
	            this._hashkey = this.parent() ? this.parent().hashkey() + "/" + this.name() : this.name();
	        return this._hashkey;
	    };
	    BasicASTNode.prototype.root = function () {
	        if (this.parent()) {
	            return this.parent().root();
	        }
	        return this;
	    };
	    BasicASTNode.prototype.isSameNode = function (n) {
	        if (n) {
	            if (n.lowLevel().actual() == this.lowLevel().actual()) {
	                return true;
	            }
	        }
	        return false;
	    };
	    BasicASTNode.prototype.checkContextValue = function (name, value, thisObj) {
	        var vl = this.computedValue(name);
	        if (vl && vl.indexOf(value) != -1) {
	            return true; //FIXME
	        }
	        if (!vl) {
	            try {
	                var res = evalInSandbox("return " + name, thisObj, []);
	                if (res != undefined) {
	                    return "" + res == value;
	                }
	            }
	            catch (e) {
	            }
	        }
	        return value == vl || value == 'false';
	    };
	    BasicASTNode.prototype.printDetails = function (indent) {
	        return (indent ? indent : "") + "Unkown\n";
	    };
	    BasicASTNode.prototype.errors = function () {
	        var errors = [];
	        var q = {
	            accept: function (c) {
	                errors.push(c);
	            },
	            begin: function () {
	            },
	            end: function () {
	            }
	        };
	        this.validate(q);
	        return errors;
	    };
	    BasicASTNode.prototype.toRuntimeModel = function () {
	        var _this = this;
	        var thisObj = {};
	        //FIXME it should be be done in much cooler way
	        //Spec for runtime is also needed
	        this.children().forEach(function (x) {
	            if (x instanceof ASTPropImpl) {
	                var pr = x;
	                var val = pr.value();
	                if (val) {
	                    var type = pr.property().range();
	                    val = _this.fillValue(type, val);
	                    thisObj[x.name()] = val;
	                }
	            }
	        });
	        return thisObj;
	    };
	    BasicASTNode.prototype.fillValue = function (type, val) {
	        type.methods().forEach(function (m) {
	            if (typeof val == 'string') {
	                var newVal = {};
	                newVal['value'] = new loophole.Function("return this._value");
	                newVal._value = val;
	                val = newVal;
	            }
	            var nm = m.name;
	            var body = m.text;
	            var actualText = body.substring(body.indexOf('{') + 1, body.lastIndexOf('}'));
	            var func = new loophole.Function(actualText);
	            val[nm] = func;
	        });
	        val['$$'] = this;
	        return val;
	    };
	    BasicASTNode.prototype.markCh = function () {
	        var n = this.lowLevel();
	        n = n._node ? n._node : n;
	        if (n['markCh']) {
	            return true;
	        }
	        n['markCh'] = 1;
	    };
	    BasicASTNode.prototype.unmarkCh = function () {
	        var n = this.lowLevel();
	        n = n._node ? n._node : n;
	        delete n['markCh'];
	    };
	    BasicASTNode.prototype.validate = function (v) {
	        var _this = this;
	        if (this.lowLevel() && this._parent == null) {
	            this.lowLevel().errors().forEach(function (x) {
	                var em = {
	                    code: 1 /* YAML_ERROR */,
	                    message: x.message,
	                    node: null,
	                    start: x.mark.position,
	                    end: x.mark.position + 1,
	                    isWarning: false,
	                    path: _this.lowLevel().unit() == _this.root().lowLevel().unit() ? null : _this.lowLevel().unit().path(),
	                    unit: _this.lowLevel().unit()
	                };
	                v.accept(em);
	            });
	        }
	        this.validateIncludes(v);
	        if (this.isUnknown()) {
	            if (this.needSequence) {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "node: " + this.name() + " should be wrapped in sequence", this));
	            }
	            if (this.unresolvedRef) {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "reference : " + this.lowLevel().value() + " can not be resolved", this));
	            }
	            if (this.knownProperty && this.lowLevel().value()) {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "property " + this.name() + " can not have scalar value", this));
	            }
	            else {
	                v.accept(createIssue(2 /* UNKNOWN_NODE */, "Unknown node:" + this.name(), this));
	            }
	        }
	        if (this.markCh() && !this.allowRecursive()) {
	            v.accept(createIssue(2 /* UNKNOWN_NODE */, "Recursive definition:" + this.name(), this));
	            return;
	        }
	        try {
	            this.directChildren().forEach(function (x) { return x.validate(v); });
	        }
	        finally {
	            this.unmarkCh();
	        }
	    };
	    BasicASTNode.prototype.allowRecursive = function () {
	        return false;
	    };
	    BasicASTNode.prototype.validateIncludes = function (v) {
	        var _this = this;
	        if (this.lowLevel()) {
	            this.lowLevel().includeErrors().forEach(function (x) {
	                var em = createIssue(6 /* UNABLE_TO_RESOLVE_INCLUDE_FILE */, x, _this);
	                v.accept(em);
	            });
	        }
	    };
	    BasicASTNode.prototype.setComputed = function (name, v) {
	        this.values[name] = v;
	    };
	    BasicASTNode.prototype.computedValue = function (name) {
	        var vl = this.values[name];
	        if (!vl && this.parent()) {
	            return this.parent().computedValue(name);
	        }
	        return vl;
	    };
	    BasicASTNode.prototype.lowLevel = function () {
	        return this._node;
	    };
	    BasicASTNode.prototype.expansionSpec = function () {
	        return null;
	    };
	    BasicASTNode.prototype.name = function () {
	        var c = this.lowLevel().key();
	        if (!c) {
	            return "";
	        }
	        return c;
	    };
	    BasicASTNode.prototype.parent = function () {
	        return this._parent;
	    };
	    BasicASTNode.prototype.setParent = function (parent) {
	        this._parent = parent;
	    };
	    BasicASTNode.prototype.isElement = function () {
	        return false;
	    };
	    BasicASTNode.prototype.directChildren = function () {
	        return this.children();
	    };
	    BasicASTNode.prototype.children = function () {
	        return [];
	    };
	    BasicASTNode.prototype.isAttached = function () {
	        return this.parent() != null;
	    };
	    BasicASTNode.prototype.isImplicit = function () {
	        return this._implicit;
	    };
	    BasicASTNode.prototype.isAttr = function () {
	        return false;
	    };
	    BasicASTNode.prototype.isUnknown = function () {
	        return true;
	    };
	    BasicASTNode.prototype.id = function () {
	        var _this = this;
	        if (this._parent) {
	            var parentId = this.parent().id();
	            parentId += "." + this.name();
	            var sameName = this.parent().directChildren().filter(function (x) { return x.name() == _this.name(); });
	            if (sameName.length > 1) {
	                var ind = sameName.indexOf(this);
	                parentId += "[" + ind + "]";
	            }
	            return parentId;
	        }
	        return "";
	    };
	    BasicASTNode.prototype.localId = function () {
	        return this.name();
	    };
	    BasicASTNode.prototype.property = function () {
	        return null;
	    };
	    return BasicASTNode;
	})();
	exports.BasicASTNode = BasicASTNode;
	function createIssue(c, message, node, w) {
	    if (w === void 0) { w = false; }
	    return linter.createIssue(c, message, node, w);
	}
	exports.createIssue = createIssue;
	var StructuredValue = (function () {
	    function StructuredValue(node, _parent, _pr, kv) {
	        if (kv === void 0) { kv = null; }
	        this.node = node;
	        this._parent = _parent;
	        this.kv = kv;
	        this._pr = _pr;
	    }
	    StructuredValue.prototype.valueName = function () {
	        var res = null;
	        if (this.kv) {
	            res = this.kv;
	        }
	        res = this.node.key();
	        if (this._pr && this._pr.isAnnotation()) {
	            if (res && res.charAt(0) == '(') {
	                res = res.substring(1, res.length - 1);
	            }
	        }
	        return res;
	    };
	    StructuredValue.prototype.children = function () {
	        return this.node.children().map(function (x) { return new StructuredValue(x, null, null); });
	    };
	    StructuredValue.prototype.lowLevel = function () {
	        return this.node;
	    };
	    StructuredValue.prototype.toHighlevel = function (parent) {
	        if (!parent && this._parent)
	            parent = this._parent;
	        var vn = this.valueName();
	        var cands = this._pr.referenceTargets(parent).filter(function (x) { return qName(x, parent) == vn; });
	        if (cands && cands[0]) {
	            var tp = typeBuilder.typeFromNode(cands[0]);
	            var node = new ASTNodeImpl(this.node, parent, tp, this._pr);
	            if (this._pr) {
	                this._pr.childRestrictions().forEach(function (y) {
	                    node.setComputed(y.name, y.value);
	                });
	            }
	            return node;
	        }
	        return null;
	    };
	    return StructuredValue;
	})();
	exports.StructuredValue = StructuredValue;
	function genStructuredValue(type, name, mappings, parent) {
	    var map = yaml.newMap(mappings.map(function (mapping) { return yaml.newMapping(yaml.newScalar(mapping.key), yaml.newScalar(mapping.value)); }));
	    var node = new jsyaml.ASTNode(map, (parent ? parent.lowLevel().unit() : null), parent ? parent.lowLevel() : null, null, null);
	    return new StructuredValue(node, parent, parent ? parent.definition().property(type) : null, name);
	}
	exports.genStructuredValue = genStructuredValue;
	function checkPropertyQuard(n, v) {
	    var pr = n.property();
	    if (pr) {
	        pr.getContextRequirements().forEach(function (x) {
	            if (!n.checkContextValue(x.name, x.value, n.parent().toRuntimeModel())) {
	                v.accept(createIssue(8 /* MISSED_CONTEXT_REQUIREMENT */, x.name + " should be " + x.value + " to use property " + pr.nameId(), n));
	            }
	        });
	    }
	    return pr;
	}
	;
	function isTypeOrSchema(d) {
	    return d.nameId() == universes.Universe10.DataElement.properties.type.name || d.nameId() == universes.Universe10.DataElement.properties.schema.name;
	}
	function isExampleProp(d) {
	    if (!d.domain()) {
	        return;
	    }
	    if (d.domain().isUserDefined()) {
	        return false;
	    }
	    return d.nameId() == universes.Universe10.DataElement.properties.example.name || d.nameId() == universes.Universe10.ExampleSpec.properties.content.name;
	}
	var ASTPropImpl = (function (_super) {
	    __extends(ASTPropImpl, _super);
	    function ASTPropImpl(node, parent, _def, _prop, fromKey) {
	        if (fromKey === void 0) { fromKey = false; }
	        _super.call(this, node, parent);
	        this._def = _def;
	        this._prop = _prop;
	        this.fromKey = fromKey;
	    }
	    ASTPropImpl.prototype.definition = function () {
	        return this._def;
	    };
	    ASTPropImpl.prototype.isString = function () {
	        if (this._def) {
	            if (this._def.key() === universes.Universe08.StringType || this._def.key() == universes.Universe10.StringType) {
	                return true;
	            }
	        }
	        return false;
	    };
	    ASTPropImpl.prototype.getKind = function () {
	        return 2 /* ATTRIBUTE */;
	    };
	    ASTPropImpl.prototype.owningWrapper = function () {
	        return {
	            node: this.parent().wrapperNode(),
	            property: this.name()
	        };
	    };
	    ASTPropImpl.prototype.patchType = function (t) {
	        this._def = t;
	    };
	    ASTPropImpl.prototype.findReferenceDeclaration = function () {
	        var _this = this;
	        var targets = this.property().referenceTargets(this.parent());
	        var vl = this.value();
	        if (vl instanceof StructuredValue) {
	            var st = vl;
	            var nm = st.valueName();
	        }
	        else {
	            var nm = "" + vl;
	        }
	        var t = _.find(targets, function (x) { return qName(x, _this.parent()) == nm; });
	        return t;
	    };
	    ASTPropImpl.prototype.findReferencedValue = function () {
	        var c = this.findReferenceDeclaration();
	        if (c) {
	            var vl = c.attr("value");
	            var ck = c.definition().key();
	            if (ck === universes.Universe08.GlobalSchema || ck === universes.Universe10.GlobalSchema) {
	                if (vl) {
	                    var actualValue = vl.value();
	                    if (actualValue) {
	                        var rf = this._def.isValid(this.parent(), actualValue, vl.property());
	                        return rf;
	                    }
	                }
	                return null;
	            }
	        }
	        return c;
	    };
	    /**
	     * TODO Split this method into the cases depending from property kind
	     * @param v
	     */
	    ASTPropImpl.prototype.validate = function (v) {
	        var pr = checkPropertyQuard(this, v);
	        var vl = this.value();
	        if (!this.property().range().hasStructure()) {
	            if (vl instanceof StructuredValue && !this.property().isSelfNode()) {
	                //TODO THIS SHOULD BE MOVED TO TYPESYSTEM FOR STS AT SOME MOMENT
	                if (isTypeOrSchema(this.property())) {
	                    if (this.property().domain().key() == universes.Universe08.BodyLike) {
	                        var structValue = vl;
	                        var node = new ASTNodeImpl(this.lowLevel(), this.parent(), this.parent().definition().universe().getType("ObjectField"), this.property());
	                        node.validate(v);
	                        return;
	                    }
	                }
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Scalar is expected here", this));
	            }
	        }
	        if (this.parent().allowsQuestion() && this.property().isKey()) {
	            if (vl != null && vl.length > 0 && vl.charAt(vl.length - 1) == '?') {
	                vl = vl.substr(0, vl.length - 1);
	            }
	        }
	        if (typeof vl == 'string' && vl.indexOf("<<") != -1) {
	            if (vl.indexOf(">>") > vl.indexOf("<<")) {
	                if (insideResourceTypeOrTrait(this.parent())) {
	                    return;
	                }
	            }
	        }
	        this.validateIncludes(v);
	        if ((this.property().range().key() == universes.Universe08.MimeType || this.property().range().key() == universes.Universe10.MimeType) || (this.property().nameId() == universes.Universe10.DataElement.properties.name.name && this.parent().property().nameId() == universes.Universe10.Method.properties.body.name)) {
	            new linter.MediaTypeValidator().validate(this, v);
	            return;
	        }
	        if (this.property().isKey()) {
	            if (vl.indexOf(" ") != -1) {
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Keys should not have spaces '" + this.value() + "'", this));
	            }
	        }
	        if (isExampleProp(this.property())) {
	            new linter.ExampleValidator().validate(this, v);
	        }
	        if (this.property().nameId() == universes.Universe10.DataElement.properties.name.name) {
	            //TODO MOVE TO DEF SYSTEM
	            if (this.parent().property() && this.parent().property().nameId() == universes.Universe08.Resource.properties.uriParameters.name) {
	                new linter.UrlParameterNameValidator().validate(this, v);
	                return;
	            }
	            if (this.parent().property() && this.parent().property().nameId() == universes.Universe08.Resource.properties.baseUriParameters.name) {
	                new linter.UrlParameterNameValidator().validate(this, v);
	                return;
	            }
	        }
	        if (this.property().range().key() == universes.Universe08.RelativeUri || this.property().range().key() == universes.Universe10.RelativeUri) {
	            new linter.UriValidator().validate(this, v);
	            return;
	        }
	        if (this.property().range().key() == universes.Universe08.FullUriTemplate || this.property().range().key() == universes.Universe10.FullUriTemplate) {
	            new linter.UriValidator().validate(this, v);
	            return;
	        }
	        if ("pattern" == this.name() && universes.Universe10.StringType == this.definition().key() && this.parent().definition().isAssignableFrom("StrElement")) {
	            try {
	                new RegExp(this.value());
	            }
	            catch (Error) {
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Illegal pattern " + this.value(), this));
	            }
	        }
	        if ("name" == this.name() && universes.Universe10.StringType == this.definition().key() && (typeof this.value() == "string") && this.value().indexOf("[") == 0 && this.value().lastIndexOf("]") == this.value().length - 1) {
	            if (this.parent() instanceof ASTNodeImpl && universes.Universe10.ObjectField.properties.properties.name == this.parent().property().nameId()) {
	                if (this.parent().parent() instanceof ASTNodeImpl && universes.Universe10.ObjectField == this.parent().parent().definition().key()) {
	                    try {
	                        var cleanedValue = this.value().substr(1, this.value().length - 2);
	                        new RegExp(cleanedValue);
	                    }
	                    catch (Error) {
	                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Illegal pattern " + cleanedValue, this));
	                    }
	                }
	            }
	        }
	        if (this.property().range().key() == universes.Universe10.SchemaString) {
	            new linter.SchemaOrTypeValidator().validate(this, v);
	            return;
	        }
	        if (this.property() instanceof def.Property) {
	            if (pr.isTypeExpr()) {
	                new linter.SchemaOrTypeValidator().validate(this, v);
	                return;
	            }
	        }
	        if (pr.isReference() || pr.isDescriminator()) {
	            new linter.DescriminatorOrReferenceValidator().validate(this, v);
	        }
	        else {
	            new linter.NormalValidator().validate(this, v);
	        }
	    };
	    ASTPropImpl.prototype.toRuntime = function () {
	        var vl = this.value();
	        var valueObj = this.fillValue(this.property().range(), vl);
	        if (valueObj['parse']) {
	            try {
	                return valueObj.parse();
	            }
	            catch (e) {
	                return e;
	            }
	        }
	        return valueObj;
	    };
	    ASTPropImpl.prototype.isElement = function () {
	        return false;
	    };
	    ASTPropImpl.prototype.property = function () {
	        return this._prop;
	    };
	    ASTPropImpl.prototype.convertMultivalueToString = function (value) {
	        //|\n  xxx\n  yyy\n  zzz
	        var gap = 0;
	        var pos = 2;
	        while (value[pos] == ' ') {
	            gap++;
	            pos++;
	        }
	        //console.log('gap: ' + gap);
	        var lines = textutil.splitOnLines(value);
	        lines = lines.map(function (line) {
	            //console.log('line: ' + line);
	            return line.substring(gap, line.length);
	        });
	        return lines.join('');
	    };
	    ASTPropImpl.prototype.value = function () {
	        if (this._computed) {
	            return this.computedValue(this.property().nameId());
	        }
	        if (this.fromKey) {
	            return this._node.key();
	        }
	        if (this.property().isAnnotation() && this._node.key() && this._node.key() != 'annotations') {
	            return new StructuredValue(this._node, this.parent(), this._prop);
	        }
	        var actualValue = this._node.value(); //TODO FIXME
	        if (this.property().isSelfNode()) {
	            if (!actualValue || actualValue instanceof jsyaml.ASTNode) {
	                actualValue = this._node;
	                if (actualValue.children().length == 0) {
	                    actualValue = null;
	                }
	            }
	        }
	        if (actualValue instanceof jsyaml.ASTNode || actualValue instanceof proxy.LowLevelProxyNode) {
	            return new StructuredValue(actualValue, this.parent(), this._prop);
	        }
	        if (textutil.isMultiLineValue(actualValue)) {
	            var res = this.convertMultivalueToString(actualValue);
	            //console.log('converted: [' + textutil.replaceNewlines(res) + ']');
	            return res;
	        }
	        return actualValue;
	    };
	    ASTPropImpl.prototype.name = function () {
	        return this._prop.nameId();
	    };
	    ASTPropImpl.prototype.printDetails = function (indent) {
	        var className = this.definition().nameId();
	        var definitionClassName = this.property().range().nameId();
	        return (indent ? indent : "") + (this.name() + " : " + className + "[" + definitionClassName + "]" + "  =  " + this.value()) + "\n";
	    };
	    ASTPropImpl.prototype.isAttr = function () {
	        return true;
	    };
	    ASTPropImpl.prototype.isUnknown = function () {
	        return false;
	    };
	    ASTPropImpl.prototype.setValue = function (value) {
	        if (value == this.value())
	            return;
	        var c = new ll.CompositeCommand();
	        if (typeof value === 'string') {
	            var val = value;
	            //FIXME actually isFromParentKey should be enough in future does not changing it now for safety reasons
	            if (this._prop.isFromParentKey() || this._prop.isAnnotation()) {
	                if (this._prop.isAnnotation()) {
	                    val = '(' + val + ')';
	                }
	                c.commands.push(ll.setKey(this._node, val));
	            }
	            else {
	                if ((!val || val.length == 0) && !this.isEmbedded()) {
	                    c.commands.push(ll.removeNode(this._node.parent(), this._node));
	                    this.parent().clearChildrenCache();
	                }
	                else {
	                    if (!val)
	                        val = '';
	                    c.commands.push(ll.setAttr(this._node, val));
	                }
	            }
	        }
	        else {
	            if (this._prop.isFromParentKey()) {
	                throw new Error("couldn't set structured value to a key: " + this._prop.nameId());
	            }
	            var sval = value;
	            c.commands.push(ll.setAttrStructured(this._node, sval));
	        }
	        this._node.execute(c);
	    };
	    ASTPropImpl.prototype.setKey = function (value) {
	        if (value == this.name())
	            return;
	        var c = new ll.CompositeCommand();
	        c.commands.push(ll.setKey(this._node, value));
	        this._node.execute(c);
	    };
	    ASTPropImpl.prototype.children = function () {
	        return [];
	    };
	    ASTPropImpl.prototype.addStringValue = function (value) {
	        var sc = jsyaml.createScalar(value);
	        var target = this.lowLevel();
	        //console.log('add to target: ' + target.kindName());
	        if (target.isScalar()) {
	            target = target.parent();
	        }
	        else if (target.isMapping()) {
	        }
	        //var llparent = this.lowLevel().parent();
	        //console.log('parent: ' + llparent.kind());
	        //var attr = new ASTPropImpl(sc, this.parent(), this.property().range(), this.property());
	        //this.parent().add(attr);
	        var command = new ll.CompositeCommand();
	        command.commands.push(ll.insertNode(target, sc, null, true));
	        this.lowLevel().execute(command);
	        this.parent().clearChildrenCache();
	    };
	    ASTPropImpl.prototype.addStructuredValue = function (sv) {
	        //var sc = jsyaml.createScalar(value);
	        var target = this.lowLevel();
	        //console.log('add to target: ' + target.kindName());
	        if (target.isScalar()) {
	            target = target.parent();
	        }
	        else if (target.isMapping()) {
	            var ln = this.lowLevel();
	        }
	        //var llparent = this.lowLevel().parent();
	        //console.log('parent: ' + llparent.kind());
	        //var attr = new ASTPropImpl(sc, this.parent(), this.property().range(), this.property());
	        //this.parent().add(attr);
	        var command = new ll.CompositeCommand();
	        command.commands.push(ll.insertNode(target, sv.lowLevel(), null, true));
	        this.lowLevel().execute(command);
	        this.parent().clearChildrenCache();
	    };
	    ASTPropImpl.prototype.addValue = function (value) {
	        if (!this.property().isMultiValue())
	            throw new Error("setValue(string) only apply to multi-values properties");
	        if (typeof value == 'string') {
	            this.addStringValue(value);
	        }
	        else {
	            this.addStructuredValue(value);
	        }
	    };
	    ASTPropImpl.prototype.isEmbedded = function () {
	        var keyname = this.lowLevel().asMapping().key.value;
	        //console.log('propery: ' + this.property().name());
	        //console.log('mapping: ' + keyname);
	        return this.property().canBeValue() && keyname != this.property().nameId();
	    };
	    ASTPropImpl.prototype.remove = function () {
	        //if(!this.property().isMultiValue()) throw "setValue(string) only apply to multi-values properties";
	        //var sc = jsyaml.createScalar(value);
	        var llparent = this.lowLevel().parent();
	        //llparent.show('parent:');
	        //this.lowLevel().show('attribute:');
	        //console.log('parent: ' + llparent.kind());
	        //var attr = new ASTPropImpl(sc, this.parent(), this.property().range(), this.property());
	        //this.parent().add(attr);
	        if (!this.property().isMultiValue() && this.isEmbedded()) {
	            // it's embedded value, need to clean scalar instead
	            //console.log('embedded!');
	            this.setValue('');
	        }
	        else {
	            var command = new ll.CompositeCommand();
	            command.commands.push(ll.removeNode(llparent, this.lowLevel()));
	            this.lowLevel().execute(command);
	            this.parent().clearChildrenCache();
	        }
	    };
	    ASTPropImpl.prototype.setValues = function (values) {
	        var _this = this;
	        if (!this.property().isMultiValue())
	            throw new Error("setValue(string[]) only apply to multi-values properties");
	        var node = this.parent();
	        if (this.isEmpty()) {
	        }
	        else {
	            var llnode = node.lowLevel();
	            var attrs = node.attributes(this.name());
	            attrs.forEach(function (attr) { return attr.remove(); });
	        }
	        values.forEach(function (val) { return node.attrOrCreate(_this.name()).addValue(val); });
	        /*
	         if(attrs.length == 1) {
	         var anode = <jsyaml.ASTNode>attrs[0].lowLevel();
	         //console.log('attribute : ' + anode.kindName());
	         //anode.show("ATTR:");
	         if(anode.isMapping()) {
	         // that's crazy but it means zero length array indeed )
	         // nothing to remove so...
	         } else {
	         attrs.forEach(attr => attr.remove());
	         }
	         } else {
	         attrs.forEach(attr => attr.remove());
	         }
	         */
	    };
	    ASTPropImpl.prototype.isEmpty = function () {
	        if (!this.property().isMultiValue())
	            throw new Error("isEmpty() only apply to multi-values attributes");
	        //console.log('remove: ' + this.name());
	        var node = this.parent();
	        var llnode = node.lowLevel();
	        //node.lowLevel().show('Parent:');
	        var attrs = node.attributes(this.name());
	        //console.log('attributes: ' + attrs.length);
	        if (attrs.length == 0) {
	            return true;
	        }
	        else if (attrs.length == 1) {
	            var anode = attrs[0].lowLevel();
	            //console.log('attribute : ' + anode.kindName());
	            //anode.show("ATTR:");
	            if (anode.isMapping()) {
	                // that's crazy but it means zero length array indeed )
	                return true;
	            }
	            else {
	                return false;
	            }
	        }
	        else {
	            return false;
	        }
	    };
	    return ASTPropImpl;
	})(BasicASTNode);
	exports.ASTPropImpl = ASTPropImpl;
	var nodeBuilder = new builder.BasicNodeBuilder();
	var ASTNodeImpl = (function (_super) {
	    __extends(ASTNodeImpl, _super);
	    function ASTNodeImpl(node, parent, _def, _prop) {
	        _super.call(this, node, parent);
	        this._def = _def;
	        this._prop = _prop;
	        this._expanded = false;
	        this._allowQuestion = false;
	        this._subTypesCache = null;
	        this._auxChecked = false;
	        if (node) {
	            node.setHighLevelNode(this);
	        }
	    }
	    ASTNodeImpl.prototype.getKind = function () {
	        return 1 /* NODE */;
	    };
	    ASTNodeImpl.prototype.wrapperNode = function () {
	        if (!this._wrapperNode) {
	            this._wrapperNode = ModelFactory.buildWrapperNode(this);
	        }
	        return this._wrapperNode;
	    };
	    ASTNodeImpl.prototype.propertiesAllowedToUse = function () {
	        var _this = this;
	        return this.definition().allProperties().filter(function (x) { return _this.isAllowedToUse(x); });
	    };
	    ASTNodeImpl.prototype.isAllowedToUse = function (p) {
	        var _this = this;
	        var ok = true;
	        if (p.isSystem()) {
	            return false;
	        }
	        p.getContextRequirements().forEach(function (y) {
	            if (y.name.indexOf('(') != -1) {
	                //TODO HANDLE IT LATER
	                return true;
	            }
	            var vl = _this.computedValue(y.name);
	            if (vl) {
	                ok = ok && (vl == y.value);
	            }
	            else {
	                if (y.value) {
	                    ok = false;
	                }
	            }
	        });
	        return ok;
	    };
	    ASTNodeImpl.prototype.allowRecursive = function () {
	        if (this.definition().isUserDefined()) {
	            return true;
	        }
	        return false;
	    };
	    ASTNodeImpl.prototype.setWrapperNode = function (node) {
	        this._wrapperNode = node;
	    };
	    ASTNodeImpl.prototype.setAssociatedType = function (d) {
	        this._associatedDef = d;
	    };
	    ASTNodeImpl.prototype.associatedType = function () {
	        return this._associatedDef;
	    };
	    ASTNodeImpl.prototype.findById = function (id) {
	        var _this = this;
	        var v = this._knownIds;
	        if (!v) {
	            this._knownIds = {};
	            var all = search.allChildren(this);
	            all.forEach(function (x) { return _this._knownIds[x.id()] = x; });
	        }
	        return this._knownIds[id];
	    };
	    ASTNodeImpl.prototype.isAuxilary = function () {
	        var _this = this;
	        if (this._isAux) {
	            return true;
	        }
	        if (this._auxChecked) {
	            return false;
	        }
	        this._auxChecked = true;
	        var mr = _.find(this.lowLevel().children(), function (x) { return x.key() == "masterRef"; });
	        if (mr && mr.value()) {
	            this._isAux = true;
	            var val = mr.value();
	            var unit = this.lowLevel().unit().project().resolve(this.lowLevel().unit().path(), val);
	            var api = hl.fromUnit(unit);
	            if (api) {
	                var v = search.allChildren(api);
	                this._knownIds = {};
	                v.forEach(function (x) { return _this._knownIds[x.id()] = x; });
	                this._knownIds[""] = api;
	            }
	            return true;
	        }
	        return false;
	    };
	    ASTNodeImpl.prototype.insideOfDeclaration = function () {
	        if (this.definition().isDeclaration()) {
	            return true;
	        }
	        if (this.parent()) {
	            return this.parent().insideOfDeclaration();
	        }
	    };
	    ASTNodeImpl.prototype.isAllowedId = function () {
	        var r = this.root();
	        if (this.id() == "") {
	            return true;
	        }
	        if (r.definition().key() == universes.Universe10.Extension) {
	            return true;
	        }
	        if (r.isAuxilary()) {
	            if (this.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name && this.definition().key() == universes.Universe10.AnnotationType) {
	                return true;
	            }
	            if (this.property().nameId() == universes.Universe10.LibraryBase.properties.types.name && this.definition().isAssignableFrom(universes.Universe10.DataElement.name)) {
	                return true;
	            }
	            if (this.insideOfDeclaration()) {
	                var vl = this.computedValue("decls");
	                if (vl == "true") {
	                    return true;
	                }
	            }
	            if (r._knownIds) {
	                var m = r._knownIds[this.id()] != null;
	                if (!m) {
	                    if (this.parent() && this.parent().parent()) {
	                        if (this.parent().isAllowedId()) {
	                            return true;
	                        }
	                    }
	                }
	                return m;
	            }
	            if (this.parent() && this.parent().parent()) {
	                if (this.parent().isAllowedId()) {
	                    return true;
	                }
	            }
	            return false;
	        }
	        return true;
	    };
	    ASTNodeImpl.prototype.printDetails = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var classname = this.definition().nameId();
	        var definitionClasName = this.property() ? this.property().range().nameId() : "";
	        var parentPropertyName = this.property() ? this.property().nameId() : "";
	        result += indent + parentPropertyName + " : " + classname + "[" + definitionClasName + "]" + "\n";
	        this.children().forEach(function (child) {
	            result += child.printDetails(indent + "\t");
	        });
	        return result;
	    };
	    ASTNodeImpl.prototype.getExtractedChildren = function () {
	        var r = this.root();
	        if (r.isAuxilary()) {
	            if (r._knownIds) {
	                var i = r._knownIds[this.id()];
	                if (i) {
	                    return i.children();
	                }
	            }
	            return [];
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.allowsQuestion = function () {
	        return this._allowQuestion || this.definition().getAllowQuestion();
	    };
	    ASTNodeImpl.prototype.findReferences = function () {
	        var rs = [];
	        search.refFinder(this.root(), this, rs);
	        //filtering out equal results
	        var filteredReferences = [];
	        rs.forEach(function (ref) {
	            if (!_.find(filteredReferences, function (existing) { return existing == ref; })) {
	                filteredReferences.push(ref);
	            }
	        });
	        return filteredReferences;
	    };
	    ASTNodeImpl.prototype.name = function () {
	        var ka = _.find(this.directChildren(), function (x) { return x.property() && x.property().isKey(); });
	        if (ka && ka instanceof ASTPropImpl) {
	            var c = ka.value();
	            if (c) {
	                var io = c.indexOf(':');
	                if (io != -1) {
	                    return c.substring(0, io);
	                }
	            }
	            return c;
	        }
	        return _super.prototype.name.call(this);
	    };
	    ASTNodeImpl.prototype.findElementAtOffset = function (n) {
	        return this._findNode(this, n, n);
	    };
	    ASTNodeImpl.prototype.isElement = function () {
	        return true;
	    };
	    ASTNodeImpl.prototype.universe = function () {
	        if (this._universe) {
	            return this._universe;
	        }
	        return this.definition().universe();
	    };
	    ASTNodeImpl.prototype.setUniverse = function (u) {
	        this._universe = u;
	    };
	    ASTNodeImpl.prototype.validate = function (v) {
	        var _this = this;
	        if (!this.definition()) {
	            return; //FIXME
	        }
	        if (!this.parent()) {
	            var u = this.universe();
	            var tv = u.getTypedVersion();
	            if (tv) {
	                if (tv.indexOf("#%") == 0) {
	                    if (tv != "#%RAML 0.8" && tv != "#%RAML 1.0") {
	                        var i = createIssue(9 /* NODE_HAS_VALUE */, "Unknown version of RAML expected to see one of '#%RAML 0.8' or '#%RAML 1.0'", this);
	                        v.accept(i);
	                    }
	                    var tl = u.getTopLevel();
	                    if (tl) {
	                        if (tl != this.definition().nameId()) {
	                            if (this.definition().nameId() == "Api") {
	                                var i = createIssue(9 /* NODE_HAS_VALUE */, "Unknown top level type:" + tl, this);
	                                v.accept(i);
	                            }
	                        }
	                    }
	                }
	            }
	            if (this.definition().key() == universes.Universe08.Api || this.definition().key() == universes.Universe10.Api) {
	                if (this.definition().universe().version() != "RAML08") {
	                    var owl = new ovlval.OverloadingValidator();
	                    owl.validateApi(this.wrapperNode(), v);
	                }
	            }
	            var r = this.lowLevel().unit();
	            this.lowLevel().visit(function (x) {
	                if (x.unit() != r) {
	                    return false;
	                }
	                if (x.value() && x._node && x._node.value) {
	                    if (x._node.value.doubleQuoted) {
	                        var ind = (x.value() + "").indexOf(":");
	                        var nl = (x.value() + "").indexOf("\n");
	                        if (ind != -1 && nl != -1 && (!x.includePath() || x.includePath().length == 0)) {
	                            var i = createIssue(9 /* NODE_HAS_VALUE */, "Suspicious double quoted multiline scalar, it is likely that you forgot closing \" " + x.value(), _this, true);
	                            i.start = x._node.value.startPosition;
	                            i.end = x._node.value.endPosition;
	                            if (i.start == i.end) {
	                                i.end++;
	                            }
	                            v.accept(i);
	                        }
	                    }
	                }
	                return true;
	            });
	            linter.lintNode(this, v);
	        }
	        if (!this.isAllowedId()) {
	            if ((!this.property()) || this.property().nameId() != universes.Universe10.RAMLLanguageElement.properties.annotations.name) {
	                if (this.definition().key() != universes.Universe08.GlobalSchema && this.definition().key() != universes.Universe10.GlobalSchema) {
	                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "This node does not override any node from master api:" + this.id(), this);
	                    v.accept(i);
	                }
	            }
	        }
	        var nc = this.definition();
	        if (!this.definition().getAllowAny()) {
	            _super.prototype.validate.call(this, v);
	        }
	        else {
	            this.validateIncludes(v);
	        }
	        ;
	        if (nc instanceof def.NodeClass) {
	            var anc = nc;
	            if (nc.isAssignableFrom(universes.Universe10.DataElement.name)) {
	                //var tpes=anc.allSuperTypes();
	                var props = this.elementsOfKind("properties");
	                if (props.length > 0) {
	                    var types = this.attributes("type");
	                    types.forEach(function (t) {
	                        var tp = typeExpression.getType(_this, t.value(), {});
	                        if (tp instanceof def.NodeClass) {
	                            var xnc = tp;
	                            var rps = xnc.allRuntimeProperties();
	                            rps.forEach(function (rp) {
	                                var override = _.find(props, function (x) { return x.name() == rp.nameId(); });
	                                if (override) {
	                                    var node = _this;
	                                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "overriding property " + override.name() + " inhertied from " + t.value(), override);
	                                    v.accept(i);
	                                }
	                            });
	                        }
	                    });
	                }
	                var faceted = this.elementsOfKind("facets");
	                if (faceted.length > 0) {
	                    var types = this.attributes("type");
	                    types.forEach(function (t) {
	                        var tp = typeExpression.getType(_this, t.value(), {});
	                        if (tp instanceof def.NodeClass) {
	                            var xnc = tp;
	                            var rps = xnc.allProperties();
	                            rps.forEach(function (rp) {
	                                var override = _.find(faceted, function (x) { return x.name() == rp.nameId(); });
	                                if (override) {
	                                    var node = _this;
	                                    var i = createIssue(10 /* ONLY_OVERRIDE_ALLOWED */, "overriding facet " + override.name() + " inhertied from " + t.value(), override);
	                                    v.accept(i);
	                                }
	                            });
	                        }
	                    });
	                }
	            }
	            if (anc.isRuntime()) {
	                var facets = anc.getFixedFacets();
	                for (var fk in facets) {
	                    var facet = anc.getRepresentationOf().facet(fk);
	                    if (facet) {
	                        var fv = facet.getFacetValidator();
	                        if (fv) {
	                            var obj = this.lowLevel().dumpToObject();
	                            obj = obj[this.lowLevel().key()];
	                            try {
	                                var message = fv(obj, facets[fk]);
	                                if (typeof message == 'string') {
	                                    var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + message, this);
	                                    v.accept(i);
	                                }
	                            }
	                            catch (e) {
	                                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, this);
	                                v.accept(i);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        checkPropertyQuard(this, v);
	        if (typeof this.value() == 'string' && !this.definition().allowValue()) {
	            if (this.parent()) {
	                var i = createIssue(9 /* NODE_HAS_VALUE */, "node " + this.name() + " can not be a scalar", this);
	                v.accept(i);
	            }
	        }
	        this.definition().requiredProperties().forEach(function (x) {
	            var r = x.range();
	            if (r instanceof def.Array) {
	                var ar = r;
	                r = ar.component;
	            }
	            if (r.isValueType()) {
	                var nm = _this.attr(x.nameId());
	                if (!nm) {
	                    var i = createIssue(3 /* MISSING_REQUIRED_PROPERTY */, "Missing required property " + x.nameId(), _this);
	                    v.accept(i);
	                }
	            }
	            else {
	                var el = _this.elementsOfKind(x.nameId());
	                if (!el || el.length == 0) {
	                    var i = createIssue(3 /* MISSING_REQUIRED_PROPERTY */, "Missing required property " + x.nameId(), _this);
	                    v.accept(i);
	                }
	            }
	        });
	        this.definition().getContextRequirements().forEach(function (x) {
	            if (!_this.checkContextValue(x.name, x.value, _this.toRuntimeModel())) {
	                v.accept(createIssue(8 /* MISSED_CONTEXT_REQUIREMENT */, x.name + " should be " + x.value + " to use type " + _this.definition().nameId(), _this));
	            }
	        });
	        if (this.definition().universe().version() == "RAML08") {
	            var m = {};
	            var els = this.directChildren().filter(function (x) { return x.isElement(); });
	            els.forEach(function (x) {
	                if (x["_computed"]) {
	                    return;
	                }
	                if (!x.name()) {
	                    return; //handling nodes with no key (documentation)
	                }
	                var rm = x.lowLevel().parent() ? x.lowLevel().parent().end() : "";
	                var k = x.name() + rm;
	                if (m[k]) {
	                    var i = createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, x.name() + " already exists in this context", x);
	                    v.accept(i);
	                }
	                else {
	                    m[k] = 1;
	                }
	            });
	        }
	        else {
	            var m = {};
	            var els = this.directChildren().filter(function (x) { return x.isElement(); });
	            els.forEach(function (x) {
	                if (x["_computed"]) {
	                    return;
	                }
	                if (!x.name()) {
	                    return; //handling nodes with no key (documentation)
	                }
	                if (allowOwerride[x.property().nameId()]) {
	                    return;
	                }
	                var k = x.name() + x.property().nameId();
	                if (m[k]) {
	                    var i = createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, x.name() + " already exists in this context", x);
	                    v.accept(i);
	                }
	                else {
	                    m[k] = 1;
	                }
	            });
	        }
	        var allLowlevel = this.lowLevel().children();
	        var mm = _.groupBy(allLowlevel, function (x) { return x.key(); });
	        var pr = this.directChildren().filter(function (x) { return x.isAttr(); });
	        var gr = _.groupBy(pr, function (x) { return x.name(); });
	        var all = this.directChildren();
	        var allG = _.groupBy(all, function (x) { return x.name(); });
	        var computedAnnotationsMultiplValues = false;
	        Object.keys(mm).forEach(function (x) {
	            if (x.charAt(0) == '(') {
	                if (mm[x].length > 1) {
	                    if (!computedAnnotationsMultiplValues) {
	                        computedAnnotationsMultiplValues = true;
	                        pr.forEach(function (z) {
	                            if (z.property().isAnnotation()) {
	                                var annotationRange = z.property().range();
	                                var attr = z;
	                                var refsTo = attr.findReferenceDeclaration();
	                                if (refsTo != null) {
	                                    var refNode = refsTo;
	                                    var multiple = refNode.attr("allowMultiple");
	                                    if (multiple) {
	                                        var mv = multiple.value();
	                                        if (mv == 'true') {
	                                            delete mm[attr.lowLevel().key()];
	                                        }
	                                    }
	                                }
	                            }
	                        });
	                    }
	                }
	            }
	        });
	        Object.keys(mm).forEach(function (x) {
	            if (x) {
	                if (mm[x].length > 1 && !allG[x]) {
	                    var i = createIssue(4 /* PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE */, x + " should have a single value", _this);
	                    i.start = mm[x][0].keyStart();
	                    i.end = mm[x][0].keyEnd();
	                    v.accept(i);
	                }
	            }
	        });
	        Object.keys(gr).forEach(function (x) {
	            if (gr[x].length > 1 && !gr[x][0].property().isMultiValue()) {
	                gr[x].forEach(function (y) {
	                    var i = createIssue(4 /* PROPERTY_EXPECT_TO_HAVE_SINGLE_VALUE */, y.property().nameId() + " should have a single value", y);
	                    v.accept(i);
	                });
	            }
	        });
	        if (this._def && this.property() && this.property().nameId() == "types") {
	            if (buildIns[this.name()]) {
	                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not redeclare build in types", this);
	                v.accept(i);
	            }
	            var at = this.attributes("type");
	            if (at) {
	                var fn = false;
	                at.forEach(function (x) {
	                    if (x.value() == _this.name()) {
	                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", _this.attr("type") ? _this.attr("type") : _this);
	                        v.accept(i);
	                        fn = true;
	                        return;
	                    }
	                });
	                if (fn) {
	                    return;
	                }
	            }
	            try {
	                this.traverseDec(this._def, v, 0);
	            }
	            catch (e) {
	            }
	            if (!this._associatedDef) {
	                if (_.find(this.definition().allSuperTypes(), function (x) { return x.key() == universes.Universe10.DataElement; })) {
	                    this._associatedDef = typeBuilder.typeFromNode(this);
	                }
	            }
	            if (this._associatedDef) {
	                var st = this._associatedDef.superTypes();
	                var nameMap = {};
	                st.forEach(function (x) {
	                    nameMap[x.nameId()] = x;
	                });
	                var newSt = [];
	                for (var nm in nameMap) {
	                    newSt.push(nameMap[nm]);
	                }
	                st = newSt;
	                if (st.length > 1) {
	                    if (_.find(st, function (x) { return _this.isPrimitive(x); })) {
	                        if (_.find(st, function (x) { return _this.isObject(x); })) {
	                            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit both from types of different kind", this.attr("type") ? this.attr("type") : this);
	                            v.accept(i);
	                            return;
	                        }
	                    }
	                    if (_.find(st, function (x) { return _this.isArray(x); })) {
	                        if (_.find(st, function (x) { return !_this.isArray(x); })) {
	                            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit both from types of different kind", this.attr("type") ? this.attr("type") : this);
	                            v.accept(i);
	                            return;
	                        }
	                    }
	                    if (_.filter(st, function (x) { return _this.isPrimitive(x); }).length > 1) {
	                        var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "You can not inherit from two primitive types", this.attr("type") ? this.attr("type") : this);
	                        v.accept(i);
	                        return;
	                    }
	                }
	            }
	        }
	    };
	    ASTNodeImpl.prototype.isPrimitive = function (q) {
	        return !this.isArray(q) && !this.isObject(q) && !this.isUnion(q) && q.key() != universes.Universe10.DataElement;
	    };
	    ASTNodeImpl.prototype.isObject = function (q) {
	        return q.isAssignableFrom(universes.Universe10.ObjectField.name);
	    };
	    ASTNodeImpl.prototype.isArray = function (q) {
	        return _.find(q.allSuperTypes(), function (x) { return x instanceof defs.Array; }) != null;
	    };
	    ASTNodeImpl.prototype.isUnion = function (q) {
	        return _.find(q.allSuperTypes(), function (x) { return x instanceof defs.Union; }) != null;
	    };
	    /**
	     * !!!You cannot inherit from types of different kind at the same moment ( kinds are: union types, array types, object types, scalar types )
	     * !!!You cannot inherit from types extending union types ( ex: you cannot extend from Pet if Pet = Dog | Cat )
	     * You cannot inherit from multiple primitive types
	     * !!! You cannot inherit from a type that extends Array type
	     * Facets are always inherited
	     * You can fix a previously defined facet to a value if the facet is defined on a superclass
	     * Properties are only allowed on object types
	     * You cannot create cyclic dependencies when inheriting
	     * @param d
	     * @param v
	     * @param level
	     * @param visited
	     */
	    ASTNodeImpl.prototype.traverseDec = function (d, v, level, visited) {
	        var _this = this;
	        if (visited === void 0) { visited = {}; }
	        if (d == null) {
	            return;
	        }
	        if (d instanceof def.Array && level > 0) {
	            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Extending from types extending array types is not allowed", this.attr("type") ? this.attr("type") : this);
	            v.accept(i);
	            return;
	        }
	        if (d instanceof def.Union && level > 0) {
	            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Extending from types extending union types is not allowed", this.attr("type") ? this.attr("type") : this);
	            v.accept(i);
	            return;
	        }
	        if (visited[d.nameId()]) {
	            var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", this.attr("type") ? this.attr("type") : this);
	            v.accept(i);
	            throw new Error();
	        }
	        visited[d.nameId()] = this.definition();
	        try {
	            if (d.nameId() == this.name() && level > 0) {
	                var i = createIssue(7 /* INVALID_VALUE_SCHEMA */, "Recurrent type definition", this.attr("type") ? this.attr("type") : this);
	                v.accept(i);
	                throw new Error();
	            }
	            if (d instanceof defs.Array) {
	                this.traverseDec(d.component, v, level + 1, visited);
	                return;
	            }
	            if (d instanceof defs.Union) {
	                var lleft = level + 1;
	                var lright = level + 1;
	                var union = d;
	                if (union.left instanceof defs.Union) {
	                    var ul = union.left;
	                    if (union.getDeclaringNode() == ul.getDeclaringNode()) {
	                        lleft = level;
	                    }
	                }
	                if (union.right instanceof defs.Union) {
	                    var ul = union.right;
	                    if (union.getDeclaringNode() == ul.getDeclaringNode()) {
	                        lright = level;
	                    }
	                }
	                if (lleft == level + 1) {
	                    this.traverseDec(union.left, v, lleft, visited);
	                }
	                if (lright == level + 1) {
	                    this.traverseDec(union.right, v, lright, visited);
	                }
	                return;
	            }
	            var mn = d.allSuperTypes();
	            mn.forEach(function (yy) {
	                if (yy instanceof defs.AbstractType) {
	                    var node = yy.getDeclaringNode();
	                    if (node || yy instanceof defs.Array || yy instanceof defs.Union) {
	                        _this.traverseDec(yy, v, level + 1, visited);
	                    }
	                }
	            });
	        }
	        finally {
	            delete visited[d.nameId()];
	        }
	    };
	    ASTNodeImpl.prototype._findNode = function (n, offset, end) {
	        var _this = this;
	        if (n == null) {
	            return null;
	        }
	        if (n.lowLevel()) {
	            //var node:ASTNode=<ASTNode>n;
	            if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
	                var res = n;
	                //TODO INCLUDES
	                n.elements().forEach(function (x) {
	                    if (x.lowLevel().unit() != n.lowLevel().unit()) {
	                        return;
	                    }
	                    var m = _this._findNode(x, offset, end);
	                    if (m) {
	                        res = m;
	                    }
	                });
	                return res;
	            }
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.isStub = function () {
	        return (!this.lowLevel().unit()) || this.lowLevel().unit().isStubUnit();
	    };
	    ASTNodeImpl.prototype.findInsertionPointLowLevel = function (llnode, property, attr) {
	        //console.log('LL find insertion: node is attr: ' + attr);
	        var llchilds = this.lowLevel().children();
	        var insertionPoint = null;
	        var embed = property && property.isEmbedMap();
	        if (embed && _.find(this.lowLevel().children(), function (x) { return x.key() == property.nameId(); })) {
	            embed = false;
	        }
	        if (attr || embed) {
	            var last = this.findLastAttribute();
	            if (!last) {
	                //insertionPoint = new jsyaml.InsertionPoint(jsyaml.InsertionPointType.START);
	                insertionPoint = jsyaml.InsertionPoint.atStart();
	            }
	            else {
	                insertionPoint = last;
	            }
	        }
	        else {
	        }
	        return insertionPoint;
	    };
	    ASTNodeImpl.prototype.findInsertionPoint = function (node) {
	        //console.log('find insertion point for node (HL): ' + node.property().name() + '; attr: ' + node.isAttr());
	        //console.log('node1: ' + node.lowLevel().text());
	        //always insert attributes at start
	        if (!this.isStub()) {
	            this.clearChildrenCache();
	        }
	        var ch = this.children();
	        var embed = node.property() && node.property().isEmbedMap();
	        if (embed && _.find(this.lowLevel().children(), function (x) { return x.key() == node.property().nameId(); })) {
	            embed = false;
	        }
	        //console.log('node2: ' + node.lowLevel().text());
	        if (node.isAttr() || embed) {
	            var toRet = null;
	            for (var i = 0; i < ch.length; i++) {
	                if (!ch[i].isAttr()) {
	                    break;
	                }
	                else {
	                    toRet = ch[i].lowLevel();
	                }
	            }
	            if (toRet == null) {
	                toRet = this.lowLevel();
	            }
	            return toRet;
	        }
	        else {
	            var pname = node.property().nameId();
	            var cls = this.definition();
	            var props = cls.allProperties();
	            //console.log('class: ' + cls.name());
	            //props.forEach(x=> console.log('  prop: ' + x.name()));
	            var pindex = cls.propertyIndex(pname);
	            if (pindex < 0) {
	                return null;
	            }
	            var llchilds = this.lowLevel().children();
	            for (var i = 0; i < llchilds.length; i++) {
	                var llch = llchilds[i];
	                //console.log('  child: ' + llch.kindName());
	                if (!llch.isMapping())
	                    continue;
	                var cpnme = llch.asMapping().key.value;
	                var pi = cls.propertyIndex(cpnme);
	                //console.log('  property: ' + cpnme + ' index: ' + pi + ' at pos: ' + i);
	                if (pi > pindex) {
	                    //console.log('  property: ' + cpnme + ' - found');
	                    var lastok = i - 1;
	                    //console.log('lastok: ' + lastok);
	                    if (lastok < 0) {
	                        //TODO insert at the very beginning
	                        //console.log('insert to very beginning');
	                        return null;
	                    }
	                    else {
	                        console.log('insert to node: ' + lastok);
	                        return llchilds[lastok];
	                    }
	                }
	                else {
	                }
	            }
	            return null;
	        }
	        //console.log('HL insertion: ' + toRet);
	        //return toRet;
	    };
	    ASTNodeImpl.prototype.add = function (node) {
	        if (!this.isStub() && this.isEmptyRamlFile()) {
	            this.initRamlFile();
	        }
	        var llnode = node.lowLevel();
	        if (!this._children) {
	            this._children = [];
	        }
	        if (!node.property()) {
	            //now we should find correct property;
	            var an = node;
	            var allProps = this.definition().allProperties();
	            var cp = null;
	            allProps.forEach(function (x) {
	                var r = x.range();
	                if (r == an.definition()) {
	                    cp = x;
	                }
	                var isOk = _.find(an.definition().allSuperTypes(), function (x) { return x == r; });
	                if (isOk) {
	                    cp = x;
	                }
	            });
	            if (!cp) {
	                throw new Error("Unable to find correct child");
	            }
	            else {
	                an._prop = cp;
	            }
	        }
	        var insertionPoint = this.findInsertionPoint(node);
	        //console.log('high level op: ' + this.property() + '.add ' + node.property().name());
	        if (insertionPoint) {
	        }
	        //var newLowLevel:ll.ILowLevelASTNode=null;
	        var command = new ll.CompositeCommand();
	        //now we need to understand to which low level node it should go
	        //command.commands.push(ll.insertNode(this.lowLevel(), node.lowLevel()))
	        var insertionTarget = null;
	        if (node.property().isMerged() || node.property().range().isValueType()) {
	            //console.log('CASE 1');
	            //newLowLevel = node.lowLevel();
	            command.commands.push(ll.insertNode(this.lowLevel(), node.lowLevel(), insertionPoint));
	            insertionTarget = this.lowLevel();
	        }
	        else {
	            //console.log('CASE 2');
	            var name = node.property().nameId();
	            var target = this.lowLevel();
	            //target.show('TARGET:');
	            //llnode.show('NODE:');
	            var found = this.lowLevel().find(name);
	            insertionTarget = found;
	            if (!found) {
	                //console.log('node not found');
	                var nn = null;
	                //var nn: jsyaml.ASTNode = jsyaml.createSeqNode(name);
	                //var mapping = <yaml.YAMLMapping>nn._actualNode();
	                //var seq: yaml.YAMLSequence = <yaml.YAMLSequence>mapping.value;
	                //if(!seq.items) seq.items = [];
	                //seq.items.push((<jsyaml.ASTNode>node.lowLevel())._actualNode());
	                if (node.property().isEmbedMap()) {
	                    var v10 = this.definition().universe().version() == 'RAML10';
	                    if (llnode.isValueMap() && v10)
	                        nn = jsyaml.createMapNode(name);
	                    else
	                        nn = jsyaml.createSeqNode(name);
	                    //console.log('NN: ' + yaml.Kind[nn._actualNode().kind]);
	                    nn.addChild(node.lowLevel());
	                }
	                else {
	                    nn = jsyaml.createNode(name);
	                    nn.addChild(node.lowLevel());
	                }
	                //nn.show('WRAPPED NODE:');
	                //target.show('INSERT WRAPPED NODE TO:');
	                command.commands.push(ll.insertNode(target, nn, insertionPoint));
	                insertionTarget = target;
	            }
	            else {
	                //console.log('node found');
	                //found.show('INSERT2: ');
	                if (node.property().isEmbedMap()) {
	                    //newLowLevel=node.lowLevel();
	                    command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, true));
	                }
	                else {
	                    //newLowLevel=node.lowLevel();
	                    command.commands.push(ll.insertNode(found, node.lowLevel(), insertionPoint, false));
	                }
	            }
	        }
	        if (this.isStub()) {
	            var insertionIndex = this.findLastAttributeIndex();
	            if (insertionIndex < 0) {
	                this._children.push(node);
	            }
	            else {
	                //TODO behavior should be smarter we are ignoring insertion points now
	                this._children.splice(insertionIndex, 0, node);
	            }
	            command.commands.forEach(function (x) { return insertionTarget.addChild(x.value); });
	            return;
	        }
	        this.lowLevel().execute(command);
	        this._children.push(node);
	        //now we need to add new child to our children;
	        node.setParent(this);
	    };
	    ASTNodeImpl.prototype.remove = function (node) {
	        if (this.isStub()) {
	            if (node instanceof ASTNodeImpl) {
	                var cm = node;
	                if (cm.isInEdit) {
	                    return;
	                }
	            }
	            if (!this._children) {
	                return;
	            }
	            this._children = this._children.filter(function (x) { return x != node; });
	            return;
	        }
	        var command = new ll.CompositeCommand();
	        if (node instanceof ASTNodeImpl) {
	            var aNode = node;
	            if (!aNode.property().isMerged()) {
	                if (this.elementsOfKind(aNode.property().nameId()).length == 1) {
	                    command.commands.push(ll.removeNode(this.lowLevel(), aNode.lowLevel().parent().parent()));
	                }
	                else {
	                    command.commands.push(ll.removeNode(this.lowLevel(), aNode.lowLevel()));
	                }
	            }
	            else {
	                command.commands.push(ll.removeNode(this.lowLevel(), aNode.lowLevel()));
	            }
	        }
	        else {
	            command.commands.push(ll.removeNode(this.lowLevel(), node.lowLevel()));
	        }
	        this.lowLevel().execute(command);
	        //update high level
	        this._children = this._children.filter(function (x) { return x != node; });
	    };
	    ASTNodeImpl.prototype.dump = function (flavor) {
	        return this._node.dump();
	    };
	    ASTNodeImpl.prototype.patchType = function (d) {
	        this._def = d;
	        var ass = this._associatedDef;
	        this._associatedDef = null;
	        this._children = null;
	    };
	    ASTNodeImpl.prototype.children = function () {
	        if (this._children) {
	            var extra = this.getExtractedChildren();
	            var res = this._children.concat(extra);
	            return res;
	        }
	        if (this._node) {
	            this._children = nodeBuilder.process(this, this._node.children());
	            this._children = this._children.filter(function (x) { return x != null; });
	            //FIXME
	            var extra = this.getExtractedChildren();
	            var res = this._children.concat(extra);
	            return res;
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.directChildren = function () {
	        if (this._children) {
	            return this._children;
	        }
	        if (this._node) {
	            this._children = nodeBuilder.process(this, this._node.children());
	            return this._children;
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.resetChildren = function () {
	        this._children = null;
	    };
	    //createAttr(n:string,v:string){
	    //    var mapping=jsyaml.createMapping(n,v);
	    //    this._node.addChild(mapping);
	    //    this._children=null;
	    //}
	    ASTNodeImpl.prototype.findLastAttributeIndex = function () {
	        var last = -1;
	        var childs = this.lowLevel().children();
	        for (var i = 0; i < childs.length; i++) {
	            var node = childs[i];
	            if (!node.isMapping())
	                continue;
	            var name = node.asMapping().key.value;
	            var property = this.definition().property(name);
	            if (!property)
	                continue;
	            //console.log(property.name() + ': isval: ' + property.isValue() + '; multi: ' + property.isMultiValue() + '; range val: ' + property.range().isValueType());
	            //if((property.isValue() || /*property.isMultiValue()) ||*/ property.range().isValueType()) {
	            if (property.isValue() || property.range().isValueType()) {
	                last = i;
	            }
	        }
	        //console.log('last attr index1: ' + last);
	        return last;
	    };
	    ASTNodeImpl.prototype.findLastAttribute = function () {
	        var childs = this.lowLevel().children();
	        var index = this.findLastAttributeIndex();
	        //console.log('last attr index2: ' + index);
	        return (index < 0) ? null : childs[index];
	    };
	    ASTNodeImpl.prototype.isEmptyRamlFile = function () {
	        var llroot = this.lowLevel().root();
	        return llroot.isScalar();
	    };
	    ASTNodeImpl.prototype.initRamlFile = function () {
	        var llroot = this.lowLevel().root();
	        var command = new ll.CompositeCommand();
	        var newroot = jsyaml.createMap([]);
	        command.commands.push(ll.initRamlFile(this.lowLevel(), newroot));
	        this.lowLevel().execute(command);
	        var root = this.root();
	        //console.log('root: ' + root);
	        root._node = newroot;
	        root.clearChildrenCache();
	        //root.lowLevel().show('NEW ROOT:');
	    };
	    ASTNodeImpl.prototype.createAttr = function (n, v) {
	        var mapping = jsyaml.createMapping(n, v);
	        //console.log('create attribute: ' + n);
	        if (this.isStub()) {
	            //console.log('create-attr: stub case');
	            var insertionIndex = this.findLastAttributeIndex();
	            //console.log('stub insertion index: ' + insertionIndex);
	            this._node.addChild(mapping, insertionIndex + 1);
	        }
	        else {
	            //console.log('root: ' + llroot.kindName());
	            if (this.isEmptyRamlFile()) {
	                this.initRamlFile();
	            }
	            //console.log('create-attr: real node case');
	            //this._node.addChild(mapping);
	            //this.clearChildrenCache();
	            var command = new ll.CompositeCommand();
	            var insertionPoint = this.findInsertionPointLowLevel(mapping, this.definition().property(n), true);
	            //command.commands.push(ll.insertNode(this.lowLevel(), mapping, null));
	            //var toseq = this.property().isMultiValue();
	            command.commands.push(ll.insertNode(this.lowLevel(), mapping, insertionPoint));
	            this.lowLevel().execute(command);
	        }
	        this.clearChildrenCache();
	    };
	    ASTNodeImpl.prototype.isAttr = function () {
	        return false;
	    };
	    ASTNodeImpl.prototype.isUnknown = function () {
	        return false;
	    };
	    ASTNodeImpl.prototype.value = function () {
	        return this._node.value();
	    };
	    ASTNodeImpl.prototype.valuesOf = function (propName) {
	        var pr = this._def.property(propName);
	        if (pr != null) {
	            return this.elements().filter(function (x) { return x.property() == pr; });
	        }
	        return [];
	    };
	    ASTNodeImpl.prototype.attr = function (n) {
	        return _.find(this.attrs(), function (y) { return y.name() == n; });
	    };
	    ASTNodeImpl.prototype.attrOrCreate = function (name) {
	        var a = this.attr(name);
	        if (!a)
	            this.createAttr(name, '');
	        return this.attr(name);
	    };
	    ASTNodeImpl.prototype.attrValue = function (n) {
	        var a = this.attr(n);
	        return a ? a.value() : null;
	    };
	    ASTNodeImpl.prototype.attributes = function (n) {
	        return _.filter(this.attrs(), function (y) { return y.name() == n; });
	    };
	    ASTNodeImpl.prototype.attrs = function () {
	        return this.children().filter(function (x) { return x.isAttr(); });
	    };
	    /*
	    allAttrs():hl.IAttribute[]{
	        var attrs = <hl.IAttribute[]>this.children().filter(x=>x.isAttr());
	        var attributes = [];
	        //console.log('Attributes(' + this.definition().name() + '): ');
	        (<NodeClass>this.definition()).allProperties().forEach(x=>{
	            if(x.range().isValueType()&&!x.isSystem()){
	                var a = _.find(attrs,y=>y.name()==x.name());
	                //var a = this.attr(x.name());
	                if (a){
	                    //console.log('  real   : ' + x.name() + ' = ' + a.value());
	                    attributes.push(a);
	                } else {
	                    a = new VirtualAttribute(this, this.definition(), x, false);
	                    //console.log('  virtual: ' + x.name());
	                    attributes.push(a);
	                }
	            }
	        })
	        return attributes;
	    }
	    */
	    ASTNodeImpl.prototype.elements = function () {
	        return this.children().filter(function (x) { return !x.isAttr() && !x.isUnknown(); });
	    };
	    ASTNodeImpl.prototype.element = function (n) {
	        var r = this.elementsOfKind(n);
	        if (r.length > 0) {
	            return r[0];
	        }
	        return null;
	    };
	    ASTNodeImpl.prototype.elementsOfKind = function (n) {
	        var r = this.elements().filter(function (x) { return x.property().nameId() == n; });
	        return r;
	    };
	    ASTNodeImpl.prototype.definition = function () {
	        return this._def;
	    };
	    ASTNodeImpl.prototype.property = function () {
	        return this._prop;
	    };
	    ASTNodeImpl.prototype.isExpanded = function () {
	        return this._expanded;
	    };
	    ASTNodeImpl.prototype.copy = function () {
	        return new ASTNodeImpl(this.lowLevel().copy(), this.parent(), this.definition(), this.property());
	    };
	    ASTNodeImpl.prototype.clearChildrenCache = function () {
	        this._children = null;
	    };
	    return ASTNodeImpl;
	})(BasicASTNode);
	exports.ASTNodeImpl = ASTNodeImpl;
	function typeFromNode(node) {
	    return typeBuilder.typeFromNode(node);
	}
	exports.typeFromNode = typeFromNode;
	function createStub0(parent, property, key) {
	    var p = parent.definition().property(property);
	    if (!p)
	        return null;
	    var nc = p.range();
	    var node = nc.createStubNode(p, key);
	    return node;
	}
	exports.createStub0 = createStub0;
	function createStub(parent, property, key) {
	    var p = parent.definition().property(property);
	    if (!p)
	        return null;
	    var nc = p.range();
	    var node = nc.createStubNode(p, key);
	    node.isInEdit = true;
	    var su = parent.lowLevel().unit().stub();
	    node.lowLevel()._unit = su;
	    node._parent = parent.copy();
	    node._parent.lowLevel()._unit = su;
	    return node;
	}
	exports.createStub = createStub;
	function createResourceStub(parent, key) {
	    return createStub(parent, "resources", key);
	}
	exports.createResourceStub = createResourceStub;
	function createMethodStub(parent, key) {
	    return createStub(parent, 'methods', key);
	}
	exports.createMethodStub = createMethodStub;
	function createResponseStub(parent, key) {
	    return createStub(parent, 'responses', key);
	}
	exports.createResponseStub = createResponseStub;
	function createBodyStub(parent, key) {
	    return createStub(parent, 'body', key);
	}
	exports.createBodyStub = createBodyStub;
	function createUriParameterStub(parent, key) {
	    return createStub(parent, 'uriParameters', key);
	}
	exports.createUriParameterStub = createUriParameterStub;
	function createQueryParameterStub(parent, key) {
	    return createStub(parent, 'queryParameters', key);
	}
	exports.createQueryParameterStub = createQueryParameterStub;
	function createObjectFieldStub(parent, name) {
	    var type = parent.definition().universe().getType('ObjectField');
	    //var property = def.prop('types', 'xxx', <def.NodeClass>parent.definition(), type);
	    var property = parent.definition().property('types');
	    property = property.withRange(type);
	    var nc = property.range();
	    return nc.createStubNode(property, name);
	}
	exports.createObjectFieldStub = createObjectFieldStub;
	var allowOwerride = { resources: 1, queryParameters: 1, headers: 1, body: 1, methods: 1, responses: 1 };
	var buildIns = {
	    string: 1,
	    date: 1,
	    boolean: 1,
	    number: 1,
	    integer: 1,
	    object: 1,
	    array: 1,
	    union: 1,
	    file: 1,
	    value: 1,
	    any: 1,
	    scalar: 1
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var yaml = __webpack_require__(7);
	var lowlevel = __webpack_require__(8);
	var path = __webpack_require__(9);
	var fs = __webpack_require__(10);
	var parser = __webpack_require__(11);
	var dumper = __webpack_require__(41);
	var Error = __webpack_require__(14);
	var textutil = __webpack_require__(42);
	var rr = __webpack_require__(43);
	var SimpleExecutor = __webpack_require__(52);
	var util = __webpack_require__(54);
	var URL = __webpack_require__(58);
	var MarkupIndentingBuffer = (function () {
	    function MarkupIndentingBuffer(indent) {
	        this.text = '';
	        this.indent = indent;
	    }
	    MarkupIndentingBuffer.prototype.isLastNL = function () {
	        return this.text.length > 0 && this.text[this.text.length - 1] == '\n';
	    };
	    MarkupIndentingBuffer.prototype.addWithIndent = function (lev, s) {
	        if (this.isLastNL()) {
	            this.text += textutil.indent(lev);
	            this.text += this.indent;
	        }
	        this.text += s;
	    };
	    MarkupIndentingBuffer.prototype.addChar = function (ch) {
	        if (this.isLastNL()) {
	            this.text += this.indent;
	        }
	        this.text += ch;
	    };
	    MarkupIndentingBuffer.prototype.append = function (s) {
	        for (var i = 0; i < s.length; i++) {
	            this.addChar(s[i]);
	        }
	    };
	    return MarkupIndentingBuffer;
	})();
	exports.MarkupIndentingBuffer = MarkupIndentingBuffer;
	var CompilationUnit = (function () {
	    function CompilationUnit(_path, _content, _tl, _project, _apath) {
	        this._path = _path;
	        this._content = _content;
	        this._tl = _tl;
	        this._project = _project;
	        this._apath = _apath;
	    }
	    CompilationUnit.prototype.isStubUnit = function () {
	        return this.stu;
	    };
	    CompilationUnit.prototype.resolveAsync = function (p) {
	        var unit = this._project.resolveAsync(this._path, p);
	        return unit;
	    };
	    CompilationUnit.prototype.getIncludeNodes = function () {
	        var ast = this.ast();
	        var arr = [];
	        ast.gatherIncludes(arr);
	        return arr;
	    };
	    CompilationUnit.prototype.cloneToProject = function (p) {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, p, this._apath);
	        return newUnit;
	    };
	    CompilationUnit.prototype.clone = function () {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
	        return newUnit;
	    };
	    CompilationUnit.prototype.stub = function () {
	        var newUnit = new CompilationUnit(this._path, this._content, this._tl, this.project(), this._apath);
	        newUnit.stu = true;
	        return newUnit;
	    };
	    CompilationUnit.prototype.isDirty = function () {
	        return false;
	    };
	    CompilationUnit.prototype.absolutePath = function () {
	        return this._apath;
	    };
	    CompilationUnit.prototype.isRAMLUnit = function () {
	        var en = path.extname(this._path);
	        return en == '.raml' || en == '.yaml';
	    };
	    CompilationUnit.prototype.contents = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.resolve = function (p) {
	        var unit = this._project.resolve(this._path, p);
	        return unit;
	    };
	    CompilationUnit.prototype.path = function () {
	        return this._path;
	    };
	    CompilationUnit.prototype.lexerErrors = function () {
	        if (this.errors == null) {
	            this.ast();
	        }
	        return this.errors;
	    };
	    CompilationUnit.prototype.ast = function () {
	        var _this = this;
	        if (this._node) {
	            return this._node;
	        }
	        try {
	            var result = parser.load(this._content, {});
	            this.errors = result.errors;
	            this.errors.forEach(function (x) {
	                if (x.mark) {
	                    x.mark.filePath = _this.absolutePath();
	                }
	            });
	            this._node = new ASTNode(result, this, null, null, null);
	            this._node._errors = this.errors;
	            return this._node;
	        }
	        catch (e) {
	            this.errors = [];
	            this.errors.push(new Error(e.message));
	            //console.log(this._content)
	            //console.log(e)
	            this._node = null;
	            return this._node;
	        }
	    };
	    CompilationUnit.prototype.isTopLevel = function () {
	        return this._tl;
	    };
	    CompilationUnit.prototype.updateContent = function (n) {
	        this._content = n;
	        this.errors = null;
	        this._node = null; //todo incremental update
	    };
	    CompilationUnit.prototype.updateContentSafe = function (n) {
	        this._content = n;
	    };
	    CompilationUnit.prototype.project = function () {
	        return this._project;
	    };
	    return CompilationUnit;
	})();
	exports.CompilationUnit = CompilationUnit;
	var HTTPResolverImpl = (function () {
	    function HTTPResolverImpl() {
	        this.executor = new SimpleExecutor.SimpleExecutor();
	    }
	    HTTPResolverImpl.prototype.getResource = function (url) {
	        var response = this.executor.execute({
	            method: 'get',
	            url: url
	        });
	        if (!response) {
	            throw new Error("Unable to execute GET " + url);
	        }
	        var result = this.toResponse(response, url);
	        return result;
	    };
	    HTTPResolverImpl.prototype.getResourceAsync = function (url) {
	        var _this = this;
	        return this.executor.executeAsync({
	            method: 'get',
	            url: url
	        }).then(function (x) {
	            if (!x) {
	                return Promise.reject(new Error("Unable to execute GET " + url));
	            }
	            var result = _this.toResponse(x, url);
	            return result;
	        }, function (x) {
	            return Promise.reject(new Error("Unable to execute GET " + url));
	        });
	    };
	    HTTPResolverImpl.prototype.toResponse = function (response, url) {
	        var msg = null;
	        if (response.status >= 400) {
	            msg = "GET " + url + "\nreturned error: " + response.status;
	            if (response.statusText) {
	                msg += " " + response.statusText;
	            }
	        }
	        var content = null;
	        if (response.content && response.content.text) {
	            content = response.content.text;
	        }
	        var result = {
	            content: content,
	            errorMessage: msg
	        };
	        return result;
	    };
	    return HTTPResolverImpl;
	})();
	exports.HTTPResolverImpl = HTTPResolverImpl;
	var FSResolver = (function () {
	    function FSResolver() {
	    }
	    FSResolver.prototype.content = function (path) {
	        if (!fs.existsSync(path)) {
	            return null;
	        }
	        try {
	            return fs.readFileSync(path).toString();
	        }
	        catch (e) {
	            return null;
	        }
	    };
	    FSResolver.prototype.list = function (path) {
	        return fs.readdirSync(path);
	    };
	    return FSResolver;
	})();
	exports.FSResolver = FSResolver;
	function copyNode(n) {
	    if (n == null) {
	        return null;
	    }
	    switch (n.kind) {
	        case 0 /* SCALAR */:
	            return {
	                errors: [],
	                startPosition: n.startPosition,
	                endPosition: n.endPosition,
	                value: n.value,
	                kind: 0 /* SCALAR */,
	                parent: n.parent
	            };
	        case 1 /* MAPPING */:
	            var map = n;
	            return {
	                errors: [],
	                key: copyNode(map.key),
	                value: copyNode(map.value),
	                startPosition: map.startPosition,
	                endPosition: map.endPosition,
	                kind: 1 /* MAPPING */,
	                parent: map.parent
	            };
	        case 2 /* MAP */:
	            var ymap = n;
	            return {
	                errors: [],
	                startPosition: n.startPosition,
	                endPosition: n.endPosition,
	                mappings: ymap.mappings.map(function (x) { return copyNode(x); }),
	                kind: 2 /* MAP */,
	                parent: ymap.parent
	            };
	    }
	    return n;
	}
	var innerShift = function (offset, yaNode, shift) {
	    if (!yaNode)
	        return;
	    if (yaNode.startPosition >= offset) {
	        yaNode.startPosition += shift;
	    }
	    if (yaNode.endPosition > offset) {
	        yaNode.endPosition += shift;
	    }
	    //this kind is a separate case
	    if (yaNode.kind == 1 /* MAPPING */) {
	        var m = yaNode;
	        innerShift(offset, m.key, shift);
	        innerShift(offset, m.value, shift);
	    }
	};
	function splitOnLines(text) {
	    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
	    return lines;
	}
	//TODO IMPROVE INDENTS
	function stripIndent(text, indent) {
	    var lines = splitOnLines(text);
	    var rs = [];
	    for (var i = 0; i < lines.length; i++) {
	        if (i == 0) {
	            rs.push(lines[0]);
	        }
	        else {
	            rs.push(lines[i].substring(indent.length));
	        }
	    }
	    return rs.join("");
	}
	var leadingIndent = function (node, text) {
	    var leading = "";
	    var pos = node.start() - 1;
	    while (pos > 0) {
	        var ch = text[pos];
	        //if (ch == '\r' || ch == '\n' || ch != ' ') break;
	        //console.log('char: [' + ch + ']');
	        if (ch != ' ' && ch != '-')
	            break;
	        leading = ' ' + leading;
	        pos--;
	    }
	    return leading;
	};
	function indent(line) {
	    var rs = "";
	    for (var i = 0; i < line.length; i++) {
	        var c = line[i];
	        if (c == '\r' || c == '\n') {
	            continue;
	        }
	        if (c == ' ' || c == '\t') {
	            rs += c;
	            continue;
	        }
	        break;
	    }
	    return rs;
	}
	function indentLines(s, indent) {
	    return s.split("\n").map(function (x) {
	        if (x.trim().length == 0) {
	            return x;
	        }
	        return indent + x;
	    }).join("\n");
	}
	function extraIndent(text, indent) {
	    var lines = splitOnLines(text);
	    var rs = [];
	    for (var i = 0; i < lines.length; i++) {
	        if (i == 0) {
	            rs.push(lines[0]);
	        }
	        else {
	            if (lines[i].trim().length > 0) {
	                rs.push(indent + lines[i]);
	            }
	            else {
	                rs.push("");
	            }
	        }
	    }
	    return rs.join("");
	}
	var Project = (function () {
	    /**
	     *
	     * @param rootPath - path to folder where your root api is located
	     * @param resolver
	     * @param _httpResolver
	     */
	    function Project(rootPath, resolver, _httpResolver) {
	        if (resolver === void 0) { resolver = new FSResolver(); }
	        if (_httpResolver === void 0) { _httpResolver = new HTTPResolverImpl(); }
	        this.rootPath = rootPath;
	        this.resolver = resolver;
	        this._httpResolver = _httpResolver;
	        this.listeners = [];
	        this.tlisteners = [];
	        this.pathToUnit = {};
	    }
	    Project.prototype.cloneWithResolver = function (newResolver, httpResolver) {
	        if (httpResolver === void 0) { httpResolver = null; }
	        var newProject = new Project(this.rootPath, newResolver, httpResolver ? httpResolver : this._httpResolver);
	        for (var unitPath in this.pathToUnit) {
	            newProject.pathToUnit[unitPath] = this.pathToUnit[unitPath].cloneToProject(newProject);
	        }
	        return newProject;
	    };
	    Project.prototype.setCachedUnitContent = function (pth, cnt, tl) {
	        if (tl === void 0) { tl = true; }
	        var relPath = pth;
	        var apath = toAbsolutePath(this.rootPath, pth);
	        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
	        this.pathToUnit[apath] = unit;
	        return unit;
	    };
	    Project.prototype.resolveAsync = function (unitPath, pathInUnit) {
	        if (!pathInUnit) {
	            return Promise.reject(new Error("Unit path is null"));
	        }
	        if (pathInUnit.charAt(0) == '/') {
	            return this.unitAsync(pathInUnit);
	        }
	        if (isWebPath(pathInUnit)) {
	            return this.unitAsync(pathInUnit, true);
	        }
	        if (unitPath.charAt(0) == '/') {
	            var absPath = toAbsolutePath(path.dirname(unitPath), pathInUnit);
	            return this.unitAsync(absPath, true);
	        }
	        var absPath = toAbsolutePath(path.dirname(toAbsolutePath(this.rootPath, unitPath)), pathInUnit);
	        return this.unitAsync(absPath, true);
	    };
	    Project.prototype.resolve = function (unitPath, pathInUnit) {
	        if (!pathInUnit) {
	            return null;
	        }
	        if (pathInUnit.charAt(0) == '/') {
	            return this.unit(pathInUnit);
	        }
	        if (isWebPath(pathInUnit)) {
	            return this.unit(pathInUnit, true);
	        }
	        if (unitPath.charAt(0) == '/') {
	            var absPath = toAbsolutePath(path.dirname(unitPath), pathInUnit);
	            return this.unit(absPath, true);
	        }
	        var absPath = toAbsolutePath(path.dirname(toAbsolutePath(this.rootPath, unitPath)), pathInUnit);
	        return this.unit(absPath, true);
	    };
	    Project.prototype.units = function () {
	        var _this = this;
	        var names = this.resolver.list(this.rootPath).filter(function (x) { return path.extname(x) == '.raml'; });
	        return names.map(function (x) { return _this.unit(x); }).filter(function (y) { return y.isTopLevel(); });
	    };
	    Project.prototype.lexerErrors = function () {
	        var results = [];
	        this.units().forEach(function (x) {
	            results = results.concat(x.lexerErrors());
	        });
	        return results;
	    };
	    Project.prototype.deleteUnit = function (p, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        var apath = null;
	        if (p.indexOf("http://") == 0 || p.indexOf("https://") == 0) {
	            apath = p;
	        }
	        else {
	            apath = absolute ? p : toAbsolutePath(this.rootPath, p);
	        }
	        delete this.pathToUnit[apath];
	    };
	    Project.prototype.unit = function (p, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        var cnt = null;
	        var apath = p;
	        if (isWebPath(p)) {
	            if (this.pathToUnit[apath]) {
	                return this.pathToUnit[apath];
	            }
	            if (this._httpResolver) {
	                var resp = this._httpResolver.getResource(p);
	                if (resp.errorMessage) {
	                    throw new Error(resp.errorMessage);
	                }
	                cnt = resp.content;
	            }
	            else {
	                cnt = rr.readFromCacheOrGet(p);
	            }
	        }
	        else {
	            if (p.charAt(0) == '/' && !absolute) {
	                p = p.substr(1); //TODO REVIEW IT
	            }
	            var apath = toAbsolutePath(this.rootPath, p);
	            if (this.pathToUnit[apath]) {
	                return this.pathToUnit[apath];
	            }
	            if (isWebPath(apath)) {
	                if (this._httpResolver) {
	                    var resp = this._httpResolver.getResource(apath);
	                    if (resp.errorMessage) {
	                        throw new Error(resp.errorMessage);
	                    }
	                    cnt = resp.content;
	                }
	                else {
	                    cnt = rr.readFromCacheOrGet(apath);
	                }
	            }
	            else {
	                cnt = this.resolver.content(apath);
	            }
	        }
	        if (cnt == null) {
	            return null;
	        }
	        var tl = util.stringStartsWith(cnt, "#%RAML");
	        var relPath = path.relative(this.rootPath, apath);
	        var unit = new CompilationUnit(relPath, cnt, tl, this, apath);
	        this.pathToUnit[apath] = unit;
	        return unit;
	    };
	    Project.prototype.unitAsync = function (p, absolute) {
	        var _this = this;
	        if (absolute === void 0) { absolute = false; }
	        var cnt = null;
	        var apath = p;
	        if (isWebPath(p)) {
	            if (this.pathToUnit[apath]) {
	                return Promise.resolve(this.pathToUnit[apath]);
	            }
	            if (this._httpResolver) {
	                var resp = this._httpResolver.getResourceAsync(apath);
	                cnt = resp.then(function (x) {
	                    if (x.errorMessage) {
	                        return Promise.reject(new Error(x.errorMessage));
	                    }
	                    return x.content;
	                });
	            }
	            else {
	                cnt = Promise.resolve(rr.readFromCacheOrGet(apath));
	            }
	        }
	        else {
	            if (p.charAt(0) == '/' && !absolute) {
	                p = p.substr(1); //TODO REVIEW IT
	            }
	            if (absolute) {
	                apath = p;
	            }
	            else {
	                apath = toAbsolutePath(this.rootPath, p);
	            }
	            if (this.pathToUnit[apath]) {
	                return Promise.resolve(this.pathToUnit[apath]);
	            }
	            if (isWebPath(apath)) {
	                if (this._httpResolver) {
	                    var resp = this._httpResolver.getResourceAsync(apath);
	                    cnt = resp.then(function (x) {
	                        if (x.errorMessage) {
	                            return Promise.reject(new Error(x.errorMessage));
	                        }
	                        return x.content;
	                    });
	                }
	                else {
	                    cnt = Promise.resolve(rr.readFromCacheOrGet(apath));
	                }
	            }
	            else {
	                cnt = Promise.resolve(this.resolver.content(apath));
	            }
	        }
	        if (cnt == null) {
	            return Promise.resolve(null);
	        }
	        var relPath = path.relative(this.rootPath, apath);
	        return cnt.then(function (x) {
	            if (!x) {
	                return Promise.reject(new Error("Can note resolve " + apath));
	            }
	            var tl = util.stringStartsWith(x, "#%RAML");
	            var unit = new CompilationUnit(relPath, x, tl, _this, apath);
	            _this.pathToUnit[apath] = unit;
	            return unit;
	        });
	    };
	    Project.prototype.visualizeNewlines = function (s) {
	        var res = '';
	        for (var i = 0; i < s.length; i++) {
	            var ch = s[i];
	            if (ch == '\r')
	                ch = '\\r';
	            if (ch == '\n')
	                ch = '\\n';
	            res += ch;
	        }
	        return res;
	    };
	    Project.prototype.indent = function (node) {
	        //node.show('NODE');
	        var text = node.unit().contents();
	        //console.log('node text: ' + textutil.replaceNewlines(text.substring(node.start(), node.end())));
	        //console.log('node parent: ' + node.parent());
	        //console.log('node unit: ' + node.unit());
	        if (node == node.root()) {
	            //console.log('node is root');
	            return '';
	        }
	        var leading = leadingIndent(node, text);
	        //console.log('leading: [' + leading + '] ' + leading.length);
	        var dmp = splitOnLines(node.dump());
	        if (dmp.length > 1) {
	            if (dmp[1].trim().length > 0) {
	                //console.log('DMP0: [' + dmp[0] + ']');
	                //console.log('DMP1: [' + dmp[1] + ']');
	                var extra = indent(dmp[1]);
	                return leading + extra;
	            }
	        }
	        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
	        return leading + '  ';
	    };
	    Project.prototype.startIndent = function (node) {
	        var text = node.unit().contents();
	        //console.log('Node text:\n' + this.visualizeNewlines(text.substring(node.start(), node.end())));
	        if (node == node.root())
	            return '';
	        var dmp = splitOnLines(node.dump());
	        if (dmp.length > 0) {
	            console.log('FIRST: ' + dmp[0]);
	            var extra = indent(dmp[0]);
	            return extra + '  ';
	        }
	        //console.log('LEADING: [' + this.visualizeNewlines(leading) + '] ');
	        return '';
	    };
	    Project.prototype.canWriteInOneLine = function (node) {
	        return false;
	    };
	    Project.prototype.isOneLine = function (node) {
	        return node.text().indexOf('\n') < 0;
	    };
	    Project.prototype.recalcPositionsUp = function (target) {
	        var np = target;
	        while (np) {
	            np.recalcEndPositionFromChilds();
	            np = np.parent();
	        }
	    };
	    Project.prototype.add2 = function (target, node, toSeq, ipoint, json) {
	        if (json === void 0) { json = false; }
	        var unit = target.unit();
	        var api = target.root();
	        //console.log('api: ' + api);
	        var point = null;
	        if (ipoint) {
	            if (ipoint instanceof ASTNode) {
	                //console.log('insertion: ast node');
	                point = ipoint;
	            }
	            if (ipoint instanceof InsertionPoint) {
	                //console.log('insertion: ip');
	                point = ipoint.point;
	            }
	        }
	        //console.log('target: ' + target.kindName() + '/' + target.valueKindName() + ' node: ' + node.kindName());
	        //if(point) point.show('POINT:');
	        if (target.isValueInclude()) {
	            //console.log('insert to include ref');
	            var childs = target.children();
	            if (childs.length == 0) {
	                throw new Error("not implemented: insert into empty include ref");
	            }
	            var parent = childs[0].parent();
	            //console.log('parent: ' + parent);
	            //parent.show('INCLUDE PARENT:');
	            this.add2(parent, node, toSeq, point, json);
	            return;
	        }
	        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
	        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
	        var unitText = target.unit().contents();
	        if (target.valueKind() == 3 /* SEQ */) {
	            target = createSeq(target.valueAsSeq(), target, target.unit());
	        }
	        var json = this.isJson(target);
	        //console.log('target: ' + target.start() + '..' + target.end());
	        var originalIndent = json ? '' : this.indent(target.isSeq() ? target.parent() : target);
	        //console.log('indent: [' + originalIndent + '] ' + originalIndent.length + '; toseq: ' + toSeq + '; json: ' + json);
	        var xindent = originalIndent;
	        var indentLength = originalIndent.length;
	        var isTargetSeq = target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value); //target.valueKind() == yaml.Kind.SEQ || target.isSeq();
	        //toSeq = false;
	        //console.log('target: ' + target.kindName() + '/' + yaml.Kind[target.valueKind()] + '; toseq: ' + toSeq);
	        //target.root().show("API:");
	        //target.show("TARGET:");
	        //console.log('oindent: ' + originalIndent.length);
	        toSeq = toSeq; // || isTargetSeq;
	        if (toSeq) {
	            if (json) {
	            }
	            else {
	                if (isTargetSeq) {
	                    xindent += "  ";
	                    indentLength += 2;
	                }
	            }
	        }
	        //console.log('xindent: ' + xindent.length);
	        var buf = new MarkupIndentingBuffer(xindent);
	        //target.show('TARGET:');
	        //node.show('NODE1');
	        node.markupNode(buf, node._actualNode(), 0, json);
	        var text = buf.text;
	        //node.show('NODE2', 0, text);
	        //console.log('TEXT TO ADD0: ' + textutil.replaceNewlines(text));
	        if (toSeq) {
	            //if(target.valueKind() == yaml.Kind.SEQ) {
	            var trimText = textutil.trimEnd(text);
	            var trimLen = text.length - trimText.length;
	            if (trimLen > 0) {
	                //console.log('trim len: ' + trimLen);
	                var textlen = text.length;
	                text = text.substring(0, textlen - trimLen);
	                node.shiftNodes(textlen - trimLen, -trimLen);
	            }
	        }
	        //target.show('TARGET2');
	        //node.show('NODE2', 0, text);
	        //console.log('TEXT TO ADD1: ' + textutil.replaceNewlines(text));
	        //console.log('TEXT TO ADD:\n' + this.visualizeNewlines(text));
	        //console.log('toseq: ' + toSeq);
	        if (toSeq && !json) {
	            if (node.highLevelNode()) {
	            }
	            //console.log('target: ' + target.kindName());
	            if (target.isMapping()) {
	            }
	            if (target.isSeq() || target.isMapping() && (target.isValueSeq() || target.isValueScalar() || !target.asMapping().value)) {
	                //console.log('--- make it seq');
	                text = originalIndent + '- ' + text;
	            }
	            else {
	                //console.log('--- keep it map');
	                text = originalIndent + text;
	            }
	        }
	        else {
	            text = originalIndent + text;
	        }
	        //console.log('TEXT TO ADD2: ' + textutil.replaceNewlines(text));
	        //target.show('TARGET3');
	        var pos = target.end();
	        //console.log('insert to target end: ' + pos+ ' ; point: ' + point);
	        if (point) {
	            //point.show("POINT");
	            if (point != target) {
	                pos = point.end();
	            }
	            else {
	                if (json && toSeq) {
	                }
	                else {
	                    pos = target.keyEnd() + 1;
	                    pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
	                }
	            }
	        }
	        else {
	            if (json && toSeq) {
	                var seq = target.asSeq();
	                if (seq) {
	                    if (seq.items.length > 0) {
	                        pos = seq.items[seq.items.length - 1].endPosition;
	                    }
	                    else {
	                        pos = seq.endPosition - 1;
	                    }
	                }
	            }
	            else {
	                if (ipoint && (ipoint instanceof InsertionPoint)) {
	                    //ipoint.show('insertion point provided');
	                    var ip = ipoint;
	                    if (ip.type == 1 /* START */) {
	                        pos = target.keyEnd() + 1;
	                        pos = new textutil.TextRange(unitText, pos, pos).extendAnyUntilNewLines().endpos();
	                    }
	                }
	            }
	        }
	        //console.log('insert poition: ' + pos);
	        var insertionRange = new textutil.TextRange(unitText, 0, pos);
	        pos = insertionRange.extendToNewlines().reduceSpaces().endpos();
	        if (json && target.isSeq()) {
	            var seq = target.asSeq();
	            if (seq.items.length > 0) {
	                text = ', ' + text;
	                indentLength += 2;
	            }
	        }
	        else if (pos > 0 && unitText[pos - 1] != '\n') {
	            text = "\n" + text;
	            indentLength++;
	        }
	        var suffixLen = 0;
	        if (toSeq && !json) {
	            text += '\n';
	            suffixLen++;
	        }
	        //console.log('FINAL TEXT TO ADD: [' + textutil.replaceNewlines(text) + '] at position ' + pos);
	        var newtext = unitText.substring(0, pos) + text + unitText.substring(pos, unitText.length);
	        var cu = unit;
	        cu.updateContentSafe(newtext);
	        this.executeReplace(new textutil.TextRange(unitText, pos, pos), text, cu);
	        //console.log('shift root from position: ' + pos);
	        target.root().shiftNodes(pos, indentLength + (node.end() - node.start()) + suffixLen);
	        //console.log('node len: ' + (node.end()-node.start()));
	        //console.log('text len: ' + text.length);
	        //(<ASTNode>target.root()).shiftNodes(pos, text.length+indentLength);
	        //target.show('TARGET2:');
	        //node.show('NODE TO ADD:');
	        if (point) {
	            var childs = target.children();
	            var index = -1;
	            for (var i = 0; i < childs.length; i++) {
	                var x = childs[i];
	                if (x.start() == point.start() && x.end() == point.end()) {
	                    index = i;
	                    break;
	                }
	            }
	            //console.log('index: ' + index);
	            if (index >= 0) {
	                target.addChild(node, index + 1);
	            }
	            else {
	                target.addChild(node);
	            }
	        }
	        else {
	            target.addChild(node);
	        }
	        node.shiftNodes(0, pos + indentLength);
	        //target.show('TARGET UPDATED:');
	        this.recalcPositionsUp(target);
	        //target.show('TARGET UPDATED POSITIONS:');
	        //api.show('ROOT UPDATED POSITIONS:');
	        node.setUnit(target.unit());
	        node.visit(function (n) {
	            var node = n;
	            node.setUnit(target.unit());
	            return true;
	        });
	    };
	    Project.prototype.isJsonMap = function (node) {
	        if (!node.isMap())
	            return false;
	        var text = node.text().trim();
	        return text.length >= 2 && text[0] == '{' && text[text.length - 1] == '}';
	    };
	    Project.prototype.isJsonSeq = function (node) {
	        if (!node.isSeq())
	            return false;
	        var text = node.text().trim();
	        return text.length >= 2 && text[0] == '[' && text[text.length - 1] == ']';
	    };
	    Project.prototype.isJson = function (node) {
	        return this.isJsonMap(node) || this.isJsonSeq(node);
	    };
	    Project.prototype.remove = function (unit, target, node) {
	        var parent = node.parent();
	        node._oldText = node.dump();
	        //node.showParents('PARENTS:');
	        //console.log('REMOVE NODE: ' + node.kindName() + ' from ' + target.kindName());
	        //console.log('INITIAL SELECTION: [' + textutil.replaceNewlines(range.text()) + ']');
	        //console.log('  text: \n' + unitText.substring(startpos,endpos));
	        if (this.isOneLine(node) && node.isMapping() && node.parent().isMap()) {
	            var mapnode = node.parent();
	            if (mapnode.asMap().mappings.length == 1 && mapnode.parent() != null) {
	                //console.log('REMOVE MAP INSTEAD!');
	                this.remove(unit, mapnode.parent(), mapnode);
	                return;
	            }
	        }
	        if (this.isOneLine(node) && node.isScalar() && node.parent().isSeq()) {
	            var seqnode = node.parent();
	            var seqn = seqnode.asSeq();
	            //console.log('SEQ: ' + seqn.items.length);
	            if (seqn.items.length == 1) {
	                //console.log('REMOVE SEQ INSTEAD!');
	                this.remove(unit, seqnode.parent(), seqnode);
	                return;
	            }
	        }
	        if (target.isMapping() && node.isSeq()) {
	            //console.log('remove seq from mapping');
	            var map = target.parent();
	            //console.log('REMOVE MAPPING INSTEAD!');
	            this.remove(unit, map, target);
	            return;
	        }
	        //target.show('TARGET:');
	        //node.show('NODE:');
	        var range = new textutil.TextRange(unit.contents(), node.start(), node.end());
	        var targetRange = new textutil.TextRange(unit.contents(), target.start(), target.end());
	        var parentRange = new textutil.TextRange(unit.contents(), parent.start(), parent.end());
	        var originalStartPos = range.startpos();
	        //console.log('REMOVE TEXT: ' +  this.visualizeNewlines(range.text()));
	        if (target.isSeq()) {
	            // extend range to start of line
	            //console.log('RANGE SEQ 0: ' + textutil.replaceNewlines(range.text()));
	            var seq = (node.isSeq() ? node : node.parentOfKind(3 /* SEQ */));
	            //console.log('seq: ' + seq.text() + ' json: ' + this.isJson(seq));
	            if (seq && this.isJson(seq)) {
	                range = range.extendSpaces().extendCharIfAny(',').extendSpaces();
	            }
	            else {
	                range = range.extendToStartOfLine().extendAnyUntilNewLines().extendToNewlines(); //
	            }
	        }
	        if (target.isMap()) {
	            // extend range to end of line
	            //console.log('RANGE MAP 0: [' +  this.visualizeNewlines(range.text()) + ']');
	            range = range.trimEnd().extendAnyUntilNewLines().extendToNewlines();
	            //console.log('RANGE MAP 1: [' +  this.visualizeNewlines(range.text()) + ']');
	            range = range.extendToStartOfLine().extendUntilNewlinesBack();
	        }
	        if (target.kind() == 1 /* MAPPING */) {
	            //console.log('RANGE MAPPING 0: ' +  this.visualizeNewlines(range.text()));
	            //console.log('NODE TEXT: ' + node.text());
	            if (this.isJson(node) && this.isOneLine(node)) {
	            }
	            else {
	                // extend range to end of line
	                //console.log('RANGE MAP 0: ' +  this.visualizeNewlines(range.text()));
	                range = range.extendSpacesUntilNewLines();
	                range = range.extendToNewlines();
	                //console.log('RANGE MAP 2: ' +  this.visualizeNewlines(range.text()));
	                range = range.extendToStartOfLine().extendUntilNewlinesBack();
	            }
	        }
	        if (node.isSeq()) {
	            //console.log('cleanup seq');
	            range = range.reduceSpaces();
	        }
	        //console.log('NODE:\n-----------\n' + range.unitText() + '\n-------------');
	        //console.log('TARGET: ' + target.kindName());
	        //target.show('TARGET');
	        //console.log('FINAL REMOVE TEXT: [' +  this.visualizeNewlines(range.text()) + ']');
	        //console.log('NEW TEXT:\n-----------\n' + range.remove() + '\n-------------');
	        var cu = unit;
	        cu.updateContentSafe(range.remove());
	        this.executeReplace(range, "", cu);
	        //node.parent().show('Before remove');
	        node.parent().removeChild(node);
	        var shift = -range.len();
	        //console.log('shift: ' + shift);
	        target.root().shiftNodes(originalStartPos, shift);
	        this.recalcPositionsUp(target);
	        //this.executeTextChange(new lowlevel.TextChangeCommand(range.startpos(), range.len(), "", unit))
	        //target.show('TARGET AFTER REMOVE:');
	        //target.root().show('API AFTER REMOVE:');
	    };
	    Project.prototype.changeKey = function (unit, attr, newval) {
	        //console.log('set key: ' + newval);
	        var range = new textutil.TextRange(attr.unit().contents(), attr.keyStart(), attr.keyEnd());
	        if (attr.kind() == 1 /* MAPPING */) {
	            var sc = attr._actualNode().key;
	            sc.value = newval;
	            sc.endPosition = sc.startPosition + newval.length;
	        }
	        var cu = unit;
	        this.executeReplace(range, newval, cu);
	        //console.log('new text: ' + this.visualizeNewlines(newtext));
	        var shift = newval.length - range.len();
	        //console.log('shift: ' + shift);
	        attr.root().shiftNodes(range.startpos(), shift, attr);
	        this.recalcPositionsUp(attr);
	    };
	    Project.prototype.executeReplace = function (r, txt, unit) {
	        var command = new lowlevel.TextChangeCommand(r.startpos(), r.endpos() - r.startpos(), txt, unit);
	        unit.project();
	        try {
	            this.tlisteners.forEach(function (x) { return x(command); });
	        }
	        catch (e) {
	            return false;
	        }
	        var newtext = r.replace(txt);
	        unit.updateContentSafe(newtext);
	        return true;
	    };
	    Project.prototype.changeValue = function (unit, attr, newval) {
	        //console.log('set value: ' + newval);mark
	        //console.log('ATTR ' + yaml.Kind[attr.kind()] + '; VALUE: ' + val + ' => ' + newval);
	        //attr.root().show('NODE:');
	        //console.log('TEXT:\n' + attr.unit().contents());
	        var range = new textutil.TextRange(attr.unit().contents(), attr.start(), attr.end());
	        //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	        //console.log('ATTR: ' + attr.kindName());
	        //attr.root().show('BEFORE');
	        var newNodeText;
	        var prefix = 0;
	        var delta = 0;
	        var replacer = null;
	        var mapping = null;
	        //console.log('attr: ' + attr.kindName());
	        if (attr.kind() == 0 /* SCALAR */) {
	            if (typeof newval == 'string') {
	                attr.asScalar().value = newval;
	                //range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
	                //console.log('Range1: ' + this.visualizeNewlines(range.text()));
	                //console.log('Range0: ' + range.startpos() + '..' + range.endpos());
	                newNodeText = newval;
	            }
	            else {
	                throw new Error("not implemented");
	            }
	        }
	        else if (attr.kind() == 1 /* MAPPING */) {
	            //attr.show('ATTR:');
	            mapping = attr.asMapping();
	            //console.log('mapping val: ' + attr.valueKindName());
	            if (attr.isValueInclude()) {
	                var inc = attr.valueAsInclude();
	                var includePath = inc.value;
	                //console.log("attr.setValue: path: " + includePath);
	                var resolved = attr.unit().resolve(includePath);
	                if (resolved == null) {
	                    console.log("attr.setValue: couldn't resolve: " + includePath);
	                    return; // "can not resolve "+includePath
	                }
	                //console.log("attr.setValue: resolved: " + includePath);
	                if (resolved.isRAMLUnit()) {
	                    //TODO DIFFERENT DATA TYPES, inner references
	                    return;
	                }
	                resolved.updateContent(newval);
	                return;
	            }
	            //console.log('Range0: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	            if (mapping.value)
	                range = range.withStart(attr.valueStart()).withEnd(attr.valueEnd());
	            else
	                range = range.withStart(attr.keyEnd() + 1).withEnd(attr.keyEnd() + 1);
	            //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
	            range = range.reduceNewlinesEnd();
	            //console.log('Range2: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	            if (newval == null) {
	                newNodeText = '';
	                mapping.value = null;
	            }
	            else if (typeof newval == 'string' || newval == null) {
	                var newstr = newval;
	                var ind = this.indent(attr);
	                //console.log('indent: ' + ind.length);
	                if (newstr && textutil.isMultiLine(newstr)) {
	                    newstr = '' + textutil.makeMutiLine(newstr, ind.length / 2);
	                }
	                newNodeText = newstr;
	                //var valueNode = null;
	                if (!mapping.value) {
	                    console.log('no value');
	                    mapping.value = yaml.newScalar(newstr);
	                    mapping.value.startPosition = attr.keyEnd() + 1;
	                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
	                    mapping.endPosition = mapping.value.endPosition;
	                    if (unit.contents().length > attr.keyEnd() + 1) {
	                        var vlPos = attr.keyEnd() + 1;
	                        if (unit.contents()[vlPos - 1] == ':') {
	                            newNodeText = " " + newNodeText;
	                            mapping.value.startPosition++;
	                            mapping.value.endPosition++;
	                            mapping.endPosition++;
	                            delta++;
	                        }
	                    }
	                }
	                else if (mapping.value.kind == 3 /* SEQ */) {
	                    console.log('seq value');
	                    var v = mapping.value.items[0];
	                    throw "assign value!!!";
	                }
	                else if (mapping.value.kind == 0 /* SCALAR */) {
	                    //console.log('scalar value');
	                    var sc = mapping.value;
	                    var oldtext = sc.value;
	                    //console.log('oldval: ' + sc.value);
	                    //console.log('newstr: ' + newstr + ' ' + newstr.length);
	                    sc.value = newstr;
	                    //console.log('value1: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
	                    mapping.value.endPosition = mapping.value.startPosition + newstr.length;
	                    //console.log('value2: ' + mapping.value.startPosition + '..' + mapping.value.endPosition);
	                    mapping.endPosition = mapping.value.endPosition;
	                    //console.log('mvalue: ' + mapping.startPosition + '..' + mapping.endPosition);
	                    //console.log('newval: ' + sc.value);
	                    delta += newstr.length - oldtext.length;
	                }
	            }
	            else {
	                var n = newval;
	                if (n.isMapping()) {
	                    newval = createMap([n.asMapping()]);
	                    n = newval;
	                }
	                else if (n.isMap()) {
	                }
	                else {
	                    throw new Error("only MAP/MAPPING nodes allowed as values");
	                }
	                //n.show('NODE1');
	                var buf = new MarkupIndentingBuffer('');
	                n.markupNode(buf, n._actualNode(), 0, true);
	                //n.show('NODE2');
	                newNodeText = '' + buf.text + '';
	                //indent++;
	                //n.shiftNodes(0, 1);
	                //console.log('node text: [[[' + newNodeText + ']]]');
	                //n.show("NN1:", 0, newNodeText);
	                //range = mapping.value? range.withStart(attr.valueStart()).withEnd(attr.valueEnd()) : range.withStart(attr.keyEnd()+1).withEnd(attr.keyEnd()+1 + newNodeText);
	                n.shiftNodes(0, range.startpos() + delta);
	                //n.show("NN2:");
	                replacer = n;
	            }
	        }
	        else {
	            console.log('Unsupported change value case: ' + attr.kindName());
	        }
	        //console.log('RangeX: ' + range.startpos() + '..' + range.endpos() + ': [' + this.visualizeNewlines(range.text()) + ']');
	        //console.log('new node text: ' + newNodeText);
	        var cu = unit;
	        //console.log('Range1: ' + range.startpos() + '..' + range.endpos());
	        //console.log('replace: ' + range.len());
	        //console.log('Range: ' + range.startpos() + '..' + range.endpos());
	        //console.log('OldText: ' + this.visualizeNewlines(cu.contents()));
	        this.executeReplace(range, newNodeText, cu);
	        //var newtext = range.replace(newNodeText);
	        //console.log('NewText: ' + this.visualizeNewlines(newtext));
	        //cu.updateContentSafe(newtext);
	        var shift = newNodeText.length - range.len();
	        //var shift = delta;
	        //attr.root().show('BEFORE SHIFT');
	        //console.log('shift: ' + shift + '; from: ' + (range.endpos() + prefix) + '; delta: ' + delta + '; prefix: ' + prefix);
	        attr.root().shiftNodes(range.endpos() + prefix, shift, attr);
	        //(<ASTNode>attr.root()).shiftNodes(range.endpos()+indent, shift);
	        //attr.show('ATTR2:');
	        if (replacer) {
	            mapping.value = replacer._actualNode();
	        }
	        this.recalcPositionsUp(attr);
	    };
	    Project.prototype.initWithRoot = function (root, newroot) {
	        var shift = root.end();
	        newroot.markup(false);
	        newroot._actualNode().startPosition = shift;
	        newroot._actualNode().endPosition = shift;
	        newroot.setUnit(root.unit());
	    };
	    Project.prototype.execute = function (cmd) {
	        var _this = this;
	        //console.log('Commands: ' + cmd.commands.length);
	        cmd.commands.forEach(function (x) {
	            switch (x.kind) {
	                case 4 /* CHANGE_VALUE */:
	                    var attr = x.target;
	                    var curval = attr.value();
	                    if (!curval) {
	                        curval = "";
	                    }
	                    var newval = x.value;
	                    //console.log('set value: ' + (typeof curval) + ' ==> ' + (typeof newval));
	                    if (typeof curval == 'string' && typeof newval == 'string') {
	                        //console.log('set value: str => str');
	                        if (curval != newval) {
	                            _this.changeValue(attr.unit(), attr, newval);
	                        }
	                    }
	                    else if (typeof curval == 'string' && typeof newval != 'string') {
	                        //console.log('set value: str => obj');
	                        // change structure
	                        //this.changeValue(attr.unit(), attr, null);
	                        _this.changeValue(attr.unit(), attr, newval);
	                    }
	                    else if (typeof curval != 'string' && typeof newval == 'string') {
	                        var newstr = x.value;
	                        if (curval.kind() == 1 /* MAPPING */) {
	                            if (textutil.isMultiLine(newstr)) {
	                                //console.log('multiline');
	                                attr.children().forEach(function (n) {
	                                    _this.remove(attr.unit(), attr, n);
	                                });
	                                _this.changeValue(attr.unit(), attr, newstr);
	                            }
	                            else {
	                                //console.log('singleline');
	                                _this.changeKey(attr.unit(), curval, newstr);
	                            }
	                        }
	                        else {
	                            throw new Error('unsupported case: attribute value conversion: ' + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported');
	                        }
	                    }
	                    else if (typeof curval != 'string' && typeof newval != 'string') {
	                        var newvalnode = newval;
	                        //(<ASTNode>curval).show("OLD:");
	                        //newvalnode.show("NEW:");
	                        if (newvalnode.isMapping()) {
	                            newval = createMap([newvalnode.asMapping()]);
	                        }
	                        //console.log('obj obj: ' + (curval == newval));
	                        if (curval == newval)
	                            break;
	                        // change structure
	                        //console.log('set value: obj => obj');
	                        var node = newval;
	                        var map = node.asMap();
	                        //console.log('attr: ' + attr.kindName() + " " + attr.dump());
	                        attr.children().forEach(function (n) {
	                            _this.remove(attr.unit(), attr, n);
	                        });
	                        node.children().forEach(function (m) {
	                            //this.add2(attr, <ASTNode>m, false, null, true);
	                        });
	                        _this.changeValue(attr.unit(), attr, newval);
	                    }
	                    else {
	                        throw new Error("shouldn't be this case: attribute value conversion " + (typeof curval) + ' ==> ' + (typeof newval) + ' not supported');
	                    }
	                    return;
	                case 3 /* CHANGE_KEY */:
	                    var attr = x.target;
	                    _this.changeKey(attr.unit(), attr, x.value);
	                    return;
	                case 0 /* ADD_CHILD */:
	                    var attr = x.target;
	                    var newValueNode = x.value;
	                    _this.add2(attr, newValueNode, x.toSeq, x.insertionPoint);
	                    return;
	                case 1 /* REMOVE_CHILD */:
	                    var target = x.target;
	                    var node = x.value;
	                    _this.remove(target.unit(), target, node);
	                    return;
	                case 5 /* INIT_RAML_FILE */:
	                    var root = x.target;
	                    var newroot = x.value;
	                    _this.initWithRoot(root, newroot);
	                    return;
	                default:
	                    console.log('UNSUPPORTED COMMAND: ' + lowlevel.CommandKind[x.kind]);
	                    return;
	            }
	        });
	    };
	    Project.prototype.replaceYamlNode = function (target, newNodeContent, offset, shift, unit) {
	        //console.log('New content:\n' + newNodeContent);
	        //target.show('OLD TARGET');
	        var newYamlNode = parser.load(newNodeContent, {});
	        //console.log('new yaml: ' + yaml.Kind[newYamlNode.kind]);
	        this.updatePositions(target.start(), newYamlNode);
	        //console.log('Shift: ' + shift);
	        //(<ASTNode>unit.ast()).shiftNodes(offset, shift);
	        target.root().shiftNodes(offset, shift);
	        var targetParent = target.parent();
	        var targetYamlNode = target._actualNode();
	        var parent = targetYamlNode.parent;
	        newYamlNode.parent = parent;
	        if (targetParent && targetParent.kind() == 2 /* MAP */) {
	            //console.log('MAP!!!');
	            var targetParentMapNode = targetParent._actualNode();
	            targetParentMapNode.mappings = targetParentMapNode.mappings.map(function (x) {
	                if (x != targetYamlNode) {
	                    return x;
	                }
	                return newYamlNode;
	            });
	        }
	        target.updateFrom(newYamlNode);
	        //target.show('MEW TARGET');
	        this.recalcPositionsUp(target);
	    };
	    Project.prototype.executeTextChange2 = function (textCommand) {
	        var cu = textCommand.unit;
	        var unitText = cu.contents();
	        var target = textCommand.target;
	        if (target) {
	            var cnt = unitText.substring(target.start(), target.end());
	            var original = unitText;
	            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
	            var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) + textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
	            cu.updateContentSafe(unitText);
	            if (textCommand.offset > target.start()) {
	                try {
	                    var shift = textCommand.text.length - textCommand.replacementLength;
	                    var offset = textCommand.offset;
	                    target.unit().project().replaceYamlNode(target, newNodeContent, offset, shift, textCommand.unit);
	                }
	                catch (e) {
	                    console.log('New node contents (causes error below): \n' + newNodeContent);
	                    console.log('Reparse error: ' + e.stack);
	                }
	            }
	        }
	        else {
	            unitText = unitText.substr(0, textCommand.offset) + textCommand.text + unitText.substr(textCommand.offset + textCommand.replacementLength);
	        }
	        cu.updateContent(unitText);
	        this.listeners.forEach(function (x) {
	            x(null);
	        });
	        this.tlisteners.forEach(function (x) {
	            x(textCommand);
	        });
	    };
	    Project.prototype.executeTextChange = function (textCommand) {
	        var l0 = new Date().getTime();
	        try {
	            var oc = textCommand.unit.contents();
	            //console.log('Offset: ' + textCommand.offset + '; end: ' + (textCommand.offset + textCommand.replacementLength) + '; len: ' + textCommand.replacementLength);
	            var target = textCommand.target;
	            if (target == null) {
	                target = this.findNode(textCommand.unit.ast(), textCommand.offset, textCommand.offset + textCommand.replacementLength);
	            }
	            var cu = textCommand.unit;
	            if (target) {
	                var cnt = oc.substring(target.start(), target.end());
	                //console.log('Content: ' + cnt);
	                var original = oc;
	                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
	                var newNodeContent = cnt.substr(0, textCommand.offset - target.start()) + textCommand.text + cnt.substr(textCommand.offset - target.start() + textCommand.replacementLength);
	                cu.updateContentSafe(oc);
	                //console.log('UPDATED TEXT: ' + oc);
	                var hasNewLines = breaksTheLine(original, textCommand);
	                if (textCommand.offset > target.start()) {
	                    try {
	                        var newYamlNode = parser.load(newNodeContent, {});
	                        this.updatePositions(target.start(), newYamlNode);
	                        //console.log("Positions updated")
	                        //lets shift all after it
	                        var shift = textCommand.text.length - textCommand.replacementLength;
	                        //console.log('shift: ' + shift);
	                        //console.log('offset: ' + textCommand.offset);
	                        textCommand.unit.ast().shiftNodes(textCommand.offset, shift);
	                        //console.log('Unit AST: ' + textCommand.unit.ast())
	                        if (newYamlNode != null && newYamlNode.kind == 2 /* MAP */) {
	                            var actualResult = newYamlNode.mappings[0];
	                            var targetYamlNode = target._actualNode();
	                            var parent = targetYamlNode.parent;
	                            var cmd = new lowlevel.ASTDelta();
	                            var unit = textCommand.unit;
	                            cmd.commands = [
	                                new lowlevel.ASTChangeCommand(4 /* CHANGE_VALUE */, new ASTNode(copyNode(targetYamlNode), unit, null, null, null), new ASTNode(actualResult, unit, null, null, null), 0)
	                            ];
	                            if (parent && parent.kind == 2 /* MAP */) {
	                                var map = parent;
	                                map.mappings = map.mappings.map(function (x) {
	                                    if (x != targetYamlNode) {
	                                        return x;
	                                    }
	                                    return actualResult;
	                                });
	                            }
	                            actualResult.parent = parent;
	                            //updating low level ast from yaml
	                            this.recalcPositionsUp(target);
	                            target.updateFrom(actualResult);
	                            //console.log("Incremental without listeners: "+(new Date().getTime()-l0));
	                            //console.log("Notify listeners1: " + this.listeners.length + ":" + this.tlisteners.length);
	                            this.listeners.forEach(function (x) {
	                                x(cmd);
	                            });
	                            this.tlisteners.forEach(function (x) {
	                                x(textCommand);
	                            });
	                            //console.log("Incremental update processed");
	                            return;
	                        }
	                    }
	                    catch (e) {
	                        console.log('New node contents (causes error below): \n' + newNodeContent);
	                        console.log('Reparse error: ' + e.stack);
	                    }
	                }
	            }
	            else {
	                oc = oc.substr(0, textCommand.offset) + textCommand.text + oc.substr(textCommand.offset + textCommand.replacementLength);
	            }
	            var t2 = new Date().getTime();
	            //console.log("Full without listeners:"+(t2-l0));
	            //!find node in scope
	            cu.updateContent(oc);
	            //console.log("Notify listeners2: " + this.listeners.length + ":" + this.tlisteners.length);
	            this.listeners.forEach(function (x) {
	                x(null);
	            });
	            this.tlisteners.forEach(function (x) {
	                x(textCommand);
	            });
	        }
	        finally {
	            var t2 = new Date().getTime();
	        }
	    };
	    Project.prototype.updatePositions = function (offset, n) {
	        var _this = this;
	        if (n == null) {
	            return;
	        }
	        if (n.startPosition == -1) {
	            n.startPosition = offset;
	        }
	        else {
	            n.startPosition = offset + n.startPosition;
	        }
	        n.endPosition = offset + n.endPosition;
	        switch (n.kind) {
	            case 2 /* MAP */:
	                var m = n;
	                m.mappings.forEach(function (x) { return _this.updatePositions(offset, x); });
	                break;
	            case 1 /* MAPPING */:
	                var ma = n;
	                this.updatePositions(offset, ma.key);
	                this.updatePositions(offset, ma.value);
	                break;
	            case 0 /* SCALAR */:
	                break;
	            case 3 /* SEQ */:
	                var s = n;
	                s.items.forEach(function (x) { return _this.updatePositions(offset, x); });
	                break;
	        }
	    };
	    Project.prototype.findNode = function (n, offset, end) {
	        var _this = this;
	        if (n == null) {
	            return null;
	        }
	        var node = n;
	        if (n.start() <= offset && n.end() >= end) {
	            var res = n;
	            node.directChildren().forEach(function (x) {
	                var m = _this.findNode(x, offset, end);
	                if (m) {
	                    res = m;
	                }
	            });
	            return res;
	        }
	        return null;
	    };
	    //shiftNodes(n:lowlevel.ILowLevelASTNode, offset:number, shift:number):lowlevel.ILowLevelASTNode{
	    //    var node:ASTNode=<ASTNode>n;
	    //    if (node==null){
	    //        return null;
	    //    }
	    //    node.directChildren().forEach(x=> {
	    //        var m = this.shiftNodes(x, offset, shift);
	    //    })
	    //    var yaNode=(<ASTNode>n)._actualNode();
	    //    if(yaNode) innerShift(offset, yaNode, shift);
	    //    return null;
	    //}
	    Project.prototype.addTextChangeListener = function (listener) {
	        this.tlisteners.push(listener);
	    };
	    Project.prototype.removeTextChangeListener = function (listener) {
	        this.tlisteners = this.tlisteners.filter(function (x) { return x != listener; });
	    };
	    Project.prototype.addListener = function (listener) {
	        this.listeners.push(listener);
	    };
	    Project.prototype.removeListener = function (listener) {
	        this.listeners = this.listeners.filter(function (x) { return x != listener; });
	    };
	    return Project;
	})();
	exports.Project = Project;
	function breaksTheLine(oc, textCommand) {
	    var oldText = oc.substr(textCommand.offset, textCommand.replacementLength);
	    if (oldText.indexOf('\n') != -1) {
	        return true;
	    }
	    if (textCommand.text.indexOf('\n') != -1) {
	        return true;
	    }
	}
	var ASTNode = (function () {
	    function ASTNode(_node, _unit, _parent, _anchor, _include, cacheChildren) {
	        if (cacheChildren === void 0) { cacheChildren = false; }
	        this._node = _node;
	        this._unit = _unit;
	        this._parent = _parent;
	        this._anchor = _anchor;
	        this._include = _include;
	        this.cacheChildren = cacheChildren;
	        this._errors = [];
	        if (_node == null) {
	            console.log("null");
	        }
	    }
	    ASTNode.prototype.actual = function () {
	        return this._node;
	    };
	    ASTNode.prototype.yamlNode = function () {
	        return this._node;
	    };
	    ASTNode.prototype.gatherIncludes = function (s, inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (s === void 0) { s = []; }
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node == null) {
	            return; //TODO FIXME
	        }
	        var kind = this._node.kind;
	        if (kind == 0 /* SCALAR */) {
	            return;
	        }
	        else if (kind == 2 /* MAP */) {
	            var map = this._node;
	            if (map.mappings.length == 1 && !inOneMemberMap) {
	                new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).gatherIncludes(s);
	            }
	            else {
	                map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); }).forEach(function (x) { return x.gatherIncludes(s); });
	            }
	        }
	        else if (kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	            }
	            else {
	                new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren).gatherIncludes(s);
	            }
	        }
	        else if (kind == 3 /* SEQ */) {
	            var seq = this._node;
	            seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); }).forEach(function (x) { return x.gatherIncludes(s); });
	        }
	        else if (kind == 5 /* INCLUDE_REF */) {
	            if (this._unit) {
	                s.push(this);
	            }
	        }
	    };
	    ASTNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    ASTNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    ASTNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    ASTNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    ASTNode.prototype.start = function () {
	        return this._node.startPosition;
	    };
	    ASTNode.prototype.errors = function () {
	        return this._errors;
	    };
	    ASTNode.prototype.parent = function () {
	        return this._parent;
	    };
	    ASTNode.prototype.recalcEndPositionFromChilds = function () {
	        var childs = this.children();
	        //if(this.children().length == 0) return;
	        var max = 0;
	        var first = this.children()[0];
	        var last = this.children()[this.children().length - 1];
	        //this.children().forEach(n=> {
	        //    var node: ASTNode = <ASTNode>n;
	        //    if(node._node.endPosition > max) max = node._node.endPosition;
	        //});
	        if (this.isMapping()) {
	            var mapping = this.asMapping();
	            //console.log('reposition: mapping');
	            if (mapping.value) {
	                if (mapping.value.kind == 2 /* MAP */) {
	                    var map = mapping.value;
	                    if (map.startPosition < 0 && first) {
	                        map.startPosition = first.start();
	                    }
	                    if (last)
	                        this._node.endPosition = last._node.endPosition;
	                    //console.log('embedded map: ' + map.startPosition + ".." + map.endPosition);
	                    this._node.endPosition = Math.max(this._node.endPosition, mapping.value.endPosition);
	                }
	                else if (mapping.value.kind == 3 /* SEQ */) {
	                    var seq = mapping.value;
	                    if (seq.startPosition < 0) {
	                        //console.log('*** missed start position');
	                        if (seq.items.length > 0) {
	                            var pos = seq.items[0].startPosition;
	                            var range = new textutil.TextRange(this.unit().contents(), pos, pos);
	                            range = range.extendSpacesBack().extendCharIfAnyBack('-');
	                            seq.startPosition = range.startpos();
	                        }
	                        else {
	                        }
	                    }
	                    //console.log('mapping1     : ' + mapping.startPosition + ".." + mapping.endPosition);
	                    //console.log('embedded seq1: ' + seq.startPosition + ".." + seq.endPosition);
	                    if (seq.items.length > 0) {
	                        var ilast = seq.items[seq.items.length - 1];
	                        this._node.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
	                        seq.endPosition = Math.max(this._node.endPosition, seq.endPosition, ilast.endPosition);
	                    }
	                }
	                else if (mapping.value.kind == 0 /* SCALAR */) {
	                }
	                else {
	                    if (last)
	                        this._node.endPosition = last._node.endPosition;
	                }
	            }
	        }
	        else {
	            if (last)
	                this._node.endPosition = last._node.endPosition;
	        }
	        //this._node.endPosition = max;;
	    };
	    ASTNode.prototype.isValueLocal = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var knd = this._node.value.kind;
	            return knd != 5 /* INCLUDE_REF */ && knd != 4 /* ANCHOR_REF */;
	        }
	        return true;
	    };
	    ASTNode.prototype.keyStart = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            return this._node.key.startPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.keyEnd = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            return this._node.key.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.valueStart = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var mapping = this.asMapping();
	            if (mapping.value)
	                return mapping.value.startPosition;
	            else
	                return mapping.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.valueEnd = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var mn = this.asMapping();
	            return mn.value.endPosition;
	        }
	        return -1;
	    };
	    ASTNode.prototype.end = function () {
	        return this._node.endPosition;
	    };
	    ASTNode.prototype.dump = function () {
	        if (this._oldText) {
	            return this._oldText;
	        }
	        if (this._unit && this._node.startPosition > 0 && this._node.endPosition > 0) {
	            var originalText = this._unit.contents().substring(this._node.startPosition, this._node.endPosition);
	            originalText = stripIndent(originalText, leadingIndent(this, this._unit.contents()));
	            //console.log("L:");
	            //console.log(originalText);
	            return originalText;
	        }
	        return dumper.dump(this.dumpToObject(), {});
	    };
	    ASTNode.prototype.dumpToObject = function (full) {
	        if (full === void 0) { full = false; }
	        return this.dumpNode(this._node, full);
	    };
	    ASTNode.prototype.dumpNode = function (n, full) {
	        var _this = this;
	        if (full === void 0) { full = false; }
	        if (!n) {
	            return null;
	        }
	        if (n.kind == 3 /* SEQ */) {
	            var seq = n;
	            var arr = [];
	            seq.items.forEach(function (x) { return arr.push(_this.dumpNode(x)); });
	            return arr;
	        }
	        if (n.kind == 1 /* MAPPING */) {
	            var c = n;
	            var v = {};
	            var val = c.value;
	            var mm = this.dumpNode(val, full);
	            v["" + this.dumpNode(c.key, full)] = mm;
	            return v;
	        }
	        if (n.kind == 0 /* SCALAR */) {
	            var s = n;
	            return s.value;
	        }
	        if (n.kind == 2 /* MAP */) {
	            var map = n;
	            var res = {};
	            if (map.mappings.length == 1) {
	                if (map.mappings[0].key.value == 'value') {
	                    return this.dumpNode(map.mappings[0].value, full);
	                }
	            }
	            if (map.mappings) {
	                map.mappings.forEach(function (x) {
	                    var ms = _this.dumpNode(x.value, full);
	                    if (ms == null) {
	                        ms = "!$$$novalue";
	                    }
	                    if ((ms + "").length > 0 || full) {
	                        res[_this.dumpNode(x.key, full) + ""] = ms;
	                    }
	                });
	            }
	            return res;
	        }
	    };
	    ASTNode.prototype._actualNode = function () {
	        return this._node;
	    };
	    ASTNode.prototype.execute = function (cmd) {
	        if (this.unit()) {
	            this.unit().project().execute(cmd);
	        }
	        else {
	            cmd.commands.forEach(function (x) {
	                switch (x.kind) {
	                    case 4 /* CHANGE_VALUE */:
	                        var attr = x.target;
	                        var newValue = x.value;
	                        var va = attr._actualNode();
	                        var as = attr.start();
	                        if (va.kind == 1 /* MAPPING */) {
	                            va.value = yaml.newScalar("" + newValue);
	                        }
	                        //this.executeTextChange(new lowlevel.TextChangeCommand(as,attr.value().length,<string>newValue,attr.unit()))
	                        return;
	                    case 3 /* CHANGE_KEY */:
	                        var attr = x.target;
	                        var newValue = x.value;
	                        var va = attr._actualNode();
	                        if (va.kind == 1 /* MAPPING */) {
	                            var sc = va.key;
	                            sc.value = newValue;
	                        }
	                        return;
	                }
	            });
	        }
	    };
	    ASTNode.prototype.updateFrom = function (n) {
	        this._node = n;
	    };
	    ASTNode.prototype.value = function () {
	        if (!this._node) {
	            return "";
	        }
	        if (this._node.kind == 0 /* SCALAR */) {
	            //TODO WHAT IS IT IS INCLUDE ACTUALLY
	            return this._node['value'];
	        }
	        if (this._node.kind == 4 /* ANCHOR_REF */) {
	            var ref = this._node;
	            return new ASTNode(ref.value, this._unit, this, null, null).value();
	        }
	        if (this._node.kind == 1 /* MAPPING */) {
	            var map = this._node;
	            if (map.value == null) {
	                return null;
	            }
	            return new ASTNode(map.value, this._unit, this, null, null).value();
	        }
	        if (this._node.kind == 5 /* INCLUDE_REF */) {
	            //here we should resolve include
	            var includePath = this._node['value'];
	            var resolved = this._unit.resolve(includePath);
	            if (resolved == null) {
	                return "can not resolve " + includePath;
	            }
	            if (resolved.isRAMLUnit()) {
	                //TODO DIFFERENT DATA TYPES, inner references
	                return null;
	            }
	            var text = resolved.contents();
	            if (textutil.isMultiLineValue(text)) {
	                text = textutil.fromMutiLine(text);
	            }
	            return text;
	        }
	        if (this._node.kind == 2 /* MAP */) {
	            var amap = this._node;
	            if (amap.mappings.length == 1) {
	                //handle map with one member case differently
	                return new ASTNode(amap.mappings[0], this._unit, this, null, null);
	            }
	        }
	        if (this._node.kind == 3 /* SEQ */) {
	            var aseq = this._node;
	            if (aseq.items.length == 1 && true) {
	                //handle seq with one member case differently
	                return new ASTNode(aseq.items[0], this._unit, this, null, null).value();
	            }
	        }
	        //this are only kinds which has values
	        return null;
	    };
	    ASTNode.prototype.printDetails = function (indent) {
	        var result = "";
	        if (!indent)
	            indent = "";
	        var typeName = this.kindName();
	        if (this.kind() == 0 /* SCALAR */) {
	            result += indent + "[" + typeName + "]" + " " + this.value() + "\n";
	        }
	        else if (this.kind() == 1 /* MAPPING */ && this._node.value && this._node.value.kind == 0 /* SCALAR */) {
	            result += indent + "[" + typeName + "]" + " " + this.key() + " = " + this.value() + "\n";
	        }
	        else if (this.kind() == 1 /* MAPPING */) {
	            result += indent + "[" + typeName + "]" + " " + this.key() + " = :\n";
	            this.children().forEach(function (child) {
	                result += child.printDetails(indent + "\t");
	            });
	        }
	        else {
	            result += indent + "[" + typeName + "]" + " :\n";
	            this.children().forEach(function (child) {
	                result += child.printDetails(indent + "\t");
	            });
	        }
	        return result;
	    };
	    ASTNode.prototype.visit = function (v) {
	        this.children().forEach(function (x) {
	            if (v(x)) {
	                x.visit(v);
	            }
	        });
	    };
	    ASTNode.prototype.key = function () {
	        if (!this._node) {
	            return "";
	        }
	        if (this._node.kind == 1 /* MAPPING */) {
	            var map = this._node;
	            if (map.key.kind == 3 /* SEQ */) {
	                var items = map.key;
	                var mn = "[";
	                items.items.forEach(function (x) { return mn += x.value; });
	                return mn + "]";
	            }
	            return map.key.value;
	        }
	        //other kinds do not have keys
	        return null;
	    };
	    ASTNode.prototype.addChild = function (n, pos) {
	        if (pos === void 0) { pos = -1; }
	        //this.show('ADD TARGET:');
	        var node = n;
	        //console.log('add-child: ' + this.kindName() + ' .add ' + node.kindName());
	        node._parent = this;
	        this._oldText = null;
	        if (this.isMap()) {
	            //console.log('pos: ' + pos);
	            var map = this.asMap();
	            if (map.mappings == null || map.mappings == undefined) {
	                map.mappings = [];
	            }
	            if (pos >= 0) {
	                map.mappings.splice(pos, 0, node.asMapping());
	            }
	            else {
	                map.mappings.push(node.asMapping());
	            }
	        }
	        else if (this.isMapping()) {
	            var mapping = this.asMapping();
	            var val = mapping.value;
	            //console.log('mapping value: ' + val);
	            if (!mapping.value && node.isMap()) {
	                mapping.value = node._actualNode();
	                return;
	            }
	            if (mapping.value && mapping.value.kind == 0 /* SCALAR */) {
	                // cleanup old value
	                mapping.value = null;
	                val = null;
	            }
	            if (!val) {
	                if (node.isScalar() || node.highLevelNode() && node.highLevelNode().property().isEmbedMap()) {
	                    val = yaml.newSeq();
	                }
	                else {
	                    val = yaml.newMap();
	                }
	                mapping.value = val;
	            }
	            if (val.kind == 2 /* MAP */) {
	                var map = val;
	                if (map.mappings == null || map.mappings == undefined) {
	                    map.mappings = [];
	                }
	                if (node.isScalar()) {
	                }
	                if (pos >= 0) {
	                    map.mappings.splice(pos, 0, node.asMapping());
	                }
	                else {
	                    map.mappings.push(node.asMapping());
	                }
	            }
	            else if (val.kind == 3 /* SEQ */) {
	                var seq = val;
	                if (pos >= 0) {
	                    seq.items.splice(pos, 0, node._actualNode());
	                }
	                else {
	                    seq.items.push(node._actualNode());
	                }
	            }
	            else {
	                throw new Error("Insert into mapping with " + yaml.Kind[mapping.value.kind] + " value not supported");
	            }
	        }
	        else if (this.isSeq()) {
	            var seq = this.asSeq();
	            if (pos >= 0) {
	                seq.items.splice(pos, 0, node._actualNode());
	            }
	            else {
	                seq.items.push(node._actualNode());
	            }
	        }
	        else {
	            throw new Error("Insert into " + this.kindName() + " not supported");
	        }
	    };
	    ASTNode.prototype.removeChild = function (n) {
	        this._oldText = null;
	        var node = n;
	        var ynode;
	        var index;
	        //console.log('*** REMOVE FROM: ' + this.kindName());
	        if (this.kind() == 3 /* SEQ */) {
	            //console.log('remove from seq');
	            var seq = this.asSeq();
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            ynode = node._node;
	            index = seq.items.indexOf(ynode);
	            if (index > -1)
	                seq.items.splice(index, 1);
	        }
	        else if (this.kind() == 2 /* MAP */) {
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            var map = this.asMap();
	            //console.log('remove from map: ' + map.mappings.length);
	            ynode = node.asMapping();
	            index = map.mappings.indexOf(ynode);
	            //console.log('  index: ' + index);
	            if (index > -1)
	                map.mappings.splice(index, 1);
	        }
	        else if (this.kind() == 1 /* MAPPING */) {
	            //console.log('*** REMOVE FROM MAPPING');
	            //val = <yaml.YamlMap>((<yaml.YAMLMapping>this._node).value);
	            //console.log('remove from mapping with map as value');
	            var mapping = this.asMapping();
	            //this.show("REMOVE TARGET: ***");
	            //node.show("REMOVE NODE: ***");
	            if (node._actualNode() == mapping.value) {
	                // remove right from mapping
	                //console.log('*** remove map from mapping!');
	                mapping.value = null;
	            }
	            else {
	                var map = (mapping.value);
	                ynode = node.asMapping();
	                if (map && map.mappings) {
	                    index = map.mappings.indexOf(ynode);
	                    if (index > -1)
	                        map.mappings.splice(index, 1);
	                }
	            }
	        }
	        else {
	            throw new Error("Delete from " + yaml.Kind[this.kind()] + " unsupported");
	        }
	    };
	    ASTNode.prototype.includeErrors = function () {
	        if (this._node.kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                return [];
	            }
	            return new ASTNode(mapping.value, this._unit, this, this._anchor, this._include).includeErrors();
	        }
	        var rs = [];
	        if (this._node.kind == 5 /* INCLUDE_REF */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                return [];
	            }
	            var includePath = this.includePath();
	            var resolved = this._unit.resolve(includePath);
	            if (resolved == null) {
	                rs.push("Can not resolve " + includePath);
	                return rs;
	            }
	            if (resolved.isRAMLUnit()) {
	                var ast = resolved.ast();
	                if (ast) {
	                    return [];
	                }
	                else {
	                    rs.push("" + includePath + " can not be parsed");
	                }
	            }
	        }
	        return rs;
	    };
	    ASTNode.prototype.children = function (inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node == null) {
	            return []; //TODO FIXME
	        }
	        if (this.cacheChildren && this._children) {
	            return this._children;
	        }
	        var result;
	        var kind = this._node.kind;
	        if (kind == 0 /* SCALAR */) {
	            result = [];
	        }
	        else if (kind == 2 /* MAP */) {
	            var map = this._node;
	            if (map.mappings.length == 1 && !inOneMemberMap) {
	                //handle map with one member case differently
	                // q:
	                //  []
	                //   - a
	                //   - b
	                // ->
	                // q:
	                //  a
	                //  b
	                result = new ASTNode(map.mappings[0].value, this._unit, this, inc, anc, this.cacheChildren).children(null, null, true);
	            }
	            else {
	                result = map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	            }
	        }
	        else if (kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null) {
	                result = [];
	            }
	            else {
	                result = new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include, this.cacheChildren).children();
	            }
	        }
	        else if (kind == 3 /* SEQ */) {
	            var seq = this._node;
	            result = seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include, _this.cacheChildren); });
	        }
	        else if (kind == 5 /* INCLUDE_REF */) {
	            if (this._unit) {
	                var includePath = this.includePath();
	                var resolved = this._unit.resolve(includePath);
	                if (resolved == null) {
	                    result = [];
	                }
	                else if (resolved.isRAMLUnit() && this.canInclude(resolved)) {
	                    var ast = resolved.ast();
	                    if (ast) {
	                        if (this.cacheChildren) {
	                            ast = toChildCahcingNode(ast);
	                        } //else {
	                        //    ast = <ASTNode>toIncludingNode(ast);
	                        //}
	                        result = resolved.ast().children(this, null);
	                    }
	                }
	            }
	            if (!result) {
	                result = [];
	            }
	        }
	        else if (kind == 4 /* ANCHOR_REF */) {
	            var ref = this._node;
	            result = new ASTNode(ref.value, this._unit, this, null, null, this.cacheChildren).children();
	        }
	        else {
	            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
	        }
	        if (this.cacheChildren) {
	            this._children = result;
	        }
	        return result;
	    };
	    ASTNode.prototype.canInclude = function (unit) {
	        var includedFrom = this.includedFrom();
	        while (includedFrom != null) {
	            if (includedFrom.unit().absolutePath() == unit.absolutePath()) {
	                return false;
	            }
	            includedFrom = includedFrom.includedFrom();
	        }
	        return true;
	    };
	    ASTNode.prototype.directChildren = function (inc, anc, inOneMemberMap) {
	        var _this = this;
	        if (inc === void 0) { inc = null; }
	        if (anc === void 0) { anc = null; }
	        if (inOneMemberMap === void 0) { inOneMemberMap = true; }
	        if (this._node) {
	            switch (this._node.kind) {
	                case 0 /* SCALAR */:
	                    return [];
	                case 2 /* MAP */:
	                    {
	                        var map = this._node;
	                        if (map.mappings.length == 1 && !inOneMemberMap) {
	                            //handle map with one member case differently
	                            return new ASTNode(map.mappings[0].value, this._unit, this, inc, anc).directChildren(null, null, true);
	                        }
	                        return map.mappings.map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
	                    }
	                case 1 /* MAPPING */:
	                    {
	                        var mapping = this._node;
	                        if (mapping.value == null) {
	                            return [];
	                        }
	                        return new ASTNode(mapping.value, this._unit, this, anc ? anc : this._anchor, inc ? inc : this._include).directChildren();
	                    }
	                case 3 /* SEQ */:
	                    {
	                        var seq = this._node;
	                        return seq.items.filter(function (x) { return x != null; }).map(function (x) { return new ASTNode(x, _this._unit, _this, anc ? anc : _this._anchor, inc ? inc : _this._include); });
	                    }
	                case 5 /* INCLUDE_REF */:
	                    {
	                        return [];
	                    }
	                case 4 /* ANCHOR_REF */:
	                    {
	                        return [];
	                    }
	            }
	            throw new Error("Should never happen; kind : " + yaml.Kind[this._node.kind]);
	        }
	        return [];
	    };
	    ASTNode.prototype.anchorId = function () {
	        return this._node.anchorId;
	    };
	    ASTNode.prototype.unit = function () {
	        return this._unit;
	        //if(this._unit) return this._unit;
	        //if(!this.parent()) return null;
	        //return this.parent().unit();
	    };
	    ASTNode.prototype.setUnit = function (unit) {
	        this._unit = unit;
	    };
	    ASTNode.prototype.includePath = function () {
	        if (this._node.kind == 5 /* INCLUDE_REF */) {
	            var includePath = this._node['value'];
	            return includePath;
	        }
	        else if (this._node.kind == 1 /* MAPPING */) {
	            var mapping = this._node;
	            if (mapping.value == null)
	                return null;
	            return new ASTNode(mapping.value, this._unit, this, null, null).includePath();
	        }
	        return null;
	    };
	    ASTNode.prototype.anchoredFrom = function () {
	        return this._anchor;
	    };
	    ASTNode.prototype.includedFrom = function () {
	        return this._include;
	    };
	    ASTNode.prototype.kind = function () {
	        return this._actualNode().kind;
	    };
	    ASTNode.prototype.valueKind = function () {
	        if (this._node.kind != 1 /* MAPPING */) {
	            return null;
	        }
	        var map = this._node;
	        if (!map.value) {
	            return null;
	        }
	        return map.value.kind;
	    };
	    ASTNode.prototype.valueKindName = function () {
	        var kind = this.valueKind();
	        return kind != undefined ? yaml.Kind[kind] : null;
	    };
	    ASTNode.prototype.kindName = function () {
	        return yaml.Kind[this.kind()];
	    };
	    ASTNode.prototype.indent = function (lev, str) {
	        if (str === void 0) { str = ''; }
	        var leading = '';
	        for (var i = 0; i < lev; i++)
	            leading += '  ';
	        return leading + str;
	    };
	    ASTNode.prototype.replaceNewlines = function (s, rep) {
	        if (rep === void 0) { rep = null; }
	        var res = '';
	        for (var i = 0; i < s.length; i++) {
	            var ch = s[i];
	            if (ch == '\r')
	                ch = rep == null ? '\\r' : rep;
	            if (ch == '\n')
	                ch = rep == null ? '\\n' : rep;
	            res += ch;
	        }
	        return res;
	    };
	    ASTNode.prototype.shortText = function (unittext, maxlen) {
	        if (maxlen === void 0) { maxlen = 50; }
	        var elen = this.end() - this.start();
	        var len = elen;
	        //var len = Math.min(elen,50);
	        var unit = this.unit();
	        if (!unittext && unit) {
	            unittext = unit.contents();
	        }
	        var text;
	        if (!unittext) {
	            text = '[no-unit]';
	        }
	        else {
	            var s = unittext;
	            text = s ? s.substring(this.start(), this.end()) : '[no-text]';
	        }
	        text = "[" + this.start() + ".." + this.end() + "] " + elen + " // " + text + ' //';
	        if (len < elen)
	            text += '...';
	        text = this.replaceNewlines(text);
	        return text;
	    };
	    ASTNode.prototype.nodeShortText = function (node, unittext, maxlen) {
	        if (maxlen === void 0) { maxlen = 50; }
	        var elen = node.endPosition - node.startPosition;
	        var len = elen;
	        //var len = Math.min(elen,50);
	        var unit = this.unit();
	        if (!unittext && unit) {
	            unittext = unit.contents();
	        }
	        var text;
	        if (!unittext) {
	            text = '[no-unit]';
	        }
	        else {
	            var s = unittext;
	            text = s ? s.substring(node.startPosition, node.endPosition) : '[no-text]';
	        }
	        text = "[" + node.startPosition + ".." + node.endPosition + "] " + elen + " // " + text + ' //';
	        if (len < elen)
	            text += '...';
	        text = this.replaceNewlines(text);
	        return text;
	    };
	    ASTNode.prototype.show = function (message, lev, text) {
	        if (message === void 0) { message = null; }
	        if (lev === void 0) { lev = 0; }
	        if (text === void 0) { text = null; }
	        if (message && lev == 0) {
	            console.log(message);
	        }
	        var children = this.children();
	        var desc = this.kindName();
	        var val = this._actualNode().value;
	        if (this.kind() == 1 /* MAPPING */) {
	            desc += '[' + this._actualNode().key.value + ']';
	        }
	        if (val) {
	            desc += "/" + yaml.Kind[val.kind];
	        }
	        else
	            desc += "";
	        if (children.length == 0) {
	            //desc += "/" + this.value();
	            console.log(this.indent(lev) + desc + " // " + this.shortText(text));
	            if (this.isMapping() && this.asMapping().value) {
	                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
	            }
	        }
	        else {
	            console.log(this.indent(lev) + desc + " { // " + this.shortText(text));
	            if (this.isMapping() && this.asMapping().value) {
	                console.log(this.indent(lev + 1) + '// ' + this.valueKindName() + ': ' + this.nodeShortText(this.asMapping().value, text));
	            }
	            children.forEach(function (node) {
	                var n = node;
	                n.show(null, lev + 1, text);
	            });
	            console.log(this.indent(lev) + '}');
	        }
	    };
	    ASTNode.prototype.showParents = function (message, lev) {
	        if (lev === void 0) { lev = 0; }
	        if (message && lev == 0) {
	            console.log(message);
	        }
	        var depth = 0;
	        if (this.parent()) {
	            var n = this.parent();
	            depth = n.showParents(null, lev + 1);
	        }
	        var desc = this.kindName();
	        var val = this._actualNode().value;
	        if (val)
	            desc += "/" + yaml.Kind[val.kind];
	        else
	            desc += "/null";
	        console.log(this.indent(depth) + desc + " // " + this.shortText(null));
	        return depth + 1;
	    };
	    ASTNode.prototype.inlined = function (kind) {
	        return kind == 0 /* SCALAR */ || kind == 5 /* INCLUDE_REF */;
	    };
	    ASTNode.prototype.markupNode = function (xbuf, node, lev, json) {
	        if (json === void 0) { json = false; }
	        var start = xbuf.text.length;
	        switch (node.kind) {
	            case 2 /* MAP */:
	                if (json)
	                    xbuf.append('{');
	                var mappings = node.mappings;
	                for (var i = 0; i < mappings.length; i++) {
	                    if (json && i > 0)
	                        xbuf.append(', ');
	                    this.markupNode(xbuf, mappings[i], lev, json);
	                }
	                if (json)
	                    xbuf.append('}');
	                break;
	            case 3 /* SEQ */:
	                var items = node.items;
	                for (var i = 0; i < items.length; i++) {
	                    xbuf.append(this.indent(lev, '- '));
	                    //this.markupNode(xindent, pos+xbuf.text.length-(lev+1)*2, items[i], lev+1, xbuf);
	                    this.markupNode(xbuf, items[i], lev + 1, json);
	                }
	                break;
	            case 1 /* MAPPING */:
	                var mapping = node;
	                var val = mapping.value;
	                //console.log('mapping: ' + mapping.key.value + ' ' + val.kind);
	                if (json) {
	                    xbuf.append(mapping.key.value);
	                    xbuf.append(': ');
	                    if (val.kind == 0 /* SCALAR */) {
	                        var sc = val;
	                        xbuf.append(sc.value);
	                    }
	                    else if (val.kind == 2 /* MAP */) {
	                        //var mp = <yaml.YamlMap>val;
	                        this.markupNode(xbuf, mapping.value, lev + 1, json);
	                    }
	                    else {
	                        throw new Error("markup not implemented: " + yaml.Kind[val.kind]);
	                    }
	                    break;
	                }
	                xbuf.addWithIndent(lev, mapping.key.value + ':');
	                if (!val) {
	                    xbuf.append('\n');
	                    break;
	                }
	                if (val.kind == 0 /* SCALAR */) {
	                    var sc = val;
	                }
	                //xbuf.append(this.indent(lev, mapping.key.value + ':'));
	                if (mapping.value) {
	                    xbuf.append(this.inlined(mapping.value.kind) ? ' ' : '\n');
	                    this.markupNode(xbuf, mapping.value, lev + 1, json);
	                }
	                else {
	                    xbuf.append('\n');
	                }
	                break;
	            case 0 /* SCALAR */:
	                var sc = node;
	                if (textutil.isMultiLine(sc.value)) {
	                    xbuf.append('|\n');
	                    var lines = splitOnLines(sc.value);
	                    for (var i = 0; i < lines.length; i++) {
	                        xbuf.append(this.indent(lev, lines[i]));
	                    }
	                    xbuf.append('\n');
	                }
	                else {
	                    xbuf.append(sc.value + '\n');
	                }
	                break;
	            case 5 /* INCLUDE_REF */:
	                var ref = node;
	                xbuf.append('!include ' + ref.value + '\n');
	                break;
	            default:
	                throw new Error('Unknown node kind: ' + yaml.Kind[node.kind]);
	                break;
	        }
	        while (start < xbuf.text.length && xbuf.text[start] == ' ')
	            start++;
	        node.startPosition = start;
	        node.endPosition = xbuf.text.length;
	    };
	    ASTNode.prototype.markup = function (json) {
	        if (json === void 0) { json = false; }
	        var buf = new MarkupIndentingBuffer('');
	        this.markupNode(buf, this._actualNode(), 0, json);
	        return buf.text;
	    };
	    ASTNode.prototype.root = function () {
	        var node = this;
	        while (node.parent()) {
	            var p = node.parent();
	            //if(p.isValueInclude()) break; // stop on include
	            node = p;
	        }
	        return node;
	    };
	    ASTNode.prototype.parentOfKind = function (kind) {
	        var p = this.parent();
	        while (p) {
	            if (p.kind() == kind)
	                return p;
	            p = p.parent();
	        }
	        return null;
	    };
	    ASTNode.prototype.find = function (name) {
	        var found = null;
	        //console.log('Looking for: ' + name);
	        this.directChildren().forEach(function (y) {
	            if (y.key() && y.key() == name) {
	                if (!found)
	                    found = y;
	            }
	        });
	        return found;
	    };
	    ASTNode.prototype.shiftNodes = function (offset, shift, exclude) {
	        this.directChildren().forEach(function (x) {
	            if (exclude && exclude.start() == x.start() && exclude.end() == x.end()) {
	            }
	            else {
	                var m = x.shiftNodes(offset, shift, exclude);
	            }
	        });
	        if (exclude && exclude.start() == this.start() && exclude.end() == this.end()) {
	        }
	        else {
	            var yaNode = this._actualNode();
	            if (yaNode)
	                innerShift(offset, yaNode, shift);
	        }
	        return null;
	    };
	    ASTNode.prototype.isMap = function () {
	        return this.kind() == 2 /* MAP */;
	    };
	    ASTNode.prototype.isMapping = function () {
	        return this.kind() == 1 /* MAPPING */;
	    };
	    ASTNode.prototype.isSeq = function () {
	        return this.kind() == 3 /* SEQ */;
	    };
	    ASTNode.prototype.isScalar = function () {
	        return this.kind() == 0 /* SCALAR */;
	    };
	    ASTNode.prototype.asMap = function () {
	        if (!this.isMap())
	            throw new Error("map expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asMapping = function () {
	        if (!this.isMapping())
	            throw new Error("maping expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asSeq = function () {
	        if (!this.isSeq())
	            throw new Error("seq expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.asScalar = function () {
	        if (!this.isScalar())
	            throw new Error("scalar expected instead of " + this.kindName());
	        return (this._actualNode());
	    };
	    ASTNode.prototype.isValueSeq = function () {
	        return this.valueKind() == 3 /* SEQ */;
	    };
	    ASTNode.prototype.isValueMap = function () {
	        return this.valueKind() == 2 /* MAP */;
	    };
	    ASTNode.prototype.isValueInclude = function () {
	        return this.valueKind() == 5 /* INCLUDE_REF */;
	    };
	    ASTNode.prototype.isValueScalar = function () {
	        return this.valueKind() == 0 /* SCALAR */;
	    };
	    ASTNode.prototype.valueAsSeq = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != 3 /* SEQ */)
	            throw new Error("mappng/seq expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsMap = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != 2 /* MAP */)
	            throw new Error("mappng/map expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsScalar = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != 0 /* SCALAR */)
	            throw new Error("mappng/scalar expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.valueAsInclude = function () {
	        if (!this.isMapping())
	            throw new Error("mapping expected instead of " + this.kindName());
	        if (this.valueKind() != 5 /* INCLUDE_REF */)
	            throw new Error("mappng/include expected instead of mapping/" + this.kindName());
	        return (this.asMapping().value);
	    };
	    ASTNode.prototype.text = function (unitText) {
	        if (unitText === void 0) { unitText = null; }
	        if (!unitText) {
	            if (!this.unit())
	                return '[no-text]';
	            unitText = this.unit().contents();
	        }
	        return unitText.substring(this.start(), this.end());
	    };
	    ASTNode.prototype.copy = function () {
	        var yn = copyNode(this._actualNode());
	        return new ASTNode(yn, this._unit, this._parent, this._anchor, this._include);
	    };
	    ASTNode.prototype.nodeDefinition = function () {
	        return getDefinitionForLowLevelNode(this);
	    };
	    return ASTNode;
	})();
	exports.ASTNode = ASTNode;
	(function (InsertionPointType) {
	    InsertionPointType[InsertionPointType["NONE"] = 0] = "NONE";
	    InsertionPointType[InsertionPointType["START"] = 1] = "START";
	    InsertionPointType[InsertionPointType["END"] = 2] = "END";
	    InsertionPointType[InsertionPointType["POINT"] = 3] = "POINT";
	})(exports.InsertionPointType || (exports.InsertionPointType = {}));
	var InsertionPointType = exports.InsertionPointType;
	var InsertionPoint = (function () {
	    function InsertionPoint(type, point) {
	        if (point === void 0) { point = null; }
	        this.type = type;
	        this.point = point;
	    }
	    InsertionPoint.after = function (point) {
	        return new InsertionPoint(3 /* POINT */, point);
	    };
	    InsertionPoint.atStart = function () {
	        return new InsertionPoint(1 /* START */);
	    };
	    InsertionPoint.atEnd = function () {
	        return new InsertionPoint(2 /* END */);
	    };
	    InsertionPoint.node = function () {
	        return new InsertionPoint(0 /* NONE */);
	    };
	    InsertionPoint.prototype.show = function (msg) {
	        if (msg) {
	            console.log(msg);
	            console.log('  insertion point type: ' + InsertionPointType[this.type]);
	        }
	        else {
	            console.log('insertion point type: ' + InsertionPointType[this.type]);
	        }
	        if (this.type == 3 /* POINT */ && this.point) {
	            this.point.show();
	        }
	    };
	    return InsertionPoint;
	})();
	exports.InsertionPoint = InsertionPoint;
	function createNode(key) {
	    //console.log('create node: ' + key);
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createNode = createNode;
	function createMap(mappings) {
	    //console.log('create node: ' + key);
	    var node = yaml.newMap(mappings);
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMap = createMap;
	function createScalar(value) {
	    var node = yaml.newScalar(value);
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createScalar = createScalar;
	function createSeq(sn, parent, unit) {
	    return new ASTNode(sn, unit, parent, null, null);
	}
	exports.createSeq = createSeq;
	/*
	export function createMappingWithMap(key:string, map: yaml.YAMLNode){
	    //console.log('create node: ' + key);
	    var node:yaml.YAMLNode=yaml.newMapping(yaml.newScalar(key),map);
	    return new ASTNode(node,null,null,null,null);
	}

	export function createMap(){
	    //console.log('create node: ' + key);
	    var node:yaml.YAMLNode=yaml.newMap();
	    return new ASTNode(node,null,null,null,null);
	}
	*/
	function createSeqNode(key) {
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newItems());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createSeqNode = createSeqNode;
	function createMapNode(key) {
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newMap());
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMapNode = createMapNode;
	function createMapping(key, v) {
	    //console.log('create mapping: ' + key);
	    var node = yaml.newMapping(yaml.newScalar(key), yaml.newScalar(v));
	    return new ASTNode(node, null, null, null, null);
	}
	exports.createMapping = createMapping;
	function toChildCahcingNode(node) {
	    if (!(node instanceof ASTNode)) {
	        return null;
	    }
	    var astNode = node;
	    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, true);
	    result._errors = astNode._errors;
	    return result;
	}
	exports.toChildCahcingNode = toChildCahcingNode;
	function toIncludingNode(node) {
	    if (!(node instanceof ASTNode)) {
	        return null;
	    }
	    var astNode = node;
	    var result = new ASTNode(astNode.yamlNode(), astNode.unit(), null, null, null, false);
	    result._errors = astNode._errors;
	    return result;
	}
	exports.toIncludingNode = toIncludingNode;
	function getDefinitionForLowLevelNode(node) {
	    var hl = node.highLevelNode();
	    if (hl) {
	        return hl.definition();
	    }
	    var parent = node.parent();
	    if (!parent) {
	        return null;
	    }
	    var key = node.key();
	    if (!key) {
	        return null;
	    }
	    var parentDef = parent.nodeDefinition();
	    if (!parentDef) {
	        return null;
	    }
	    if (!parentDef.property) {
	        return null;
	    }
	    var prop = parentDef.property(key);
	    if (!prop) {
	        return null;
	    }
	    return prop.range();
	}
	exports.getDefinitionForLowLevelNode = getDefinitionForLowLevelNode;
	function fetchIncludesAsync(project, apiPath) {
	    var map = {};
	    var errors = {};
	    var nodes = [];
	    var units = [];
	    var processUnits = function (ind) {
	        var lMap = {};
	        while (ind < units.length) {
	            var unit = units[ind];
	            var unitPath = path.dirname(unit.absolutePath());
	            var includeNodes = unit.getIncludeNodes();
	            includeNodes.forEach(function (x) {
	                var ip = x.includePath();
	                var absIncludePath = toAbsolutePath(unitPath, ip);
	                if (map[absIncludePath]) {
	                    return;
	                }
	                if (errors[absIncludePath]) {
	                    x.errors().push(new Error(errors[ip]));
	                    return;
	                }
	                var arr = lMap[absIncludePath];
	                if (!arr) {
	                    arr = [];
	                    lMap[absIncludePath] = arr;
	                }
	                arr.push(x);
	            });
	            ind++;
	        }
	        var unitPaths = Object.keys(lMap);
	        if (unitPaths.length == 0) {
	            return Promise.resolve();
	        }
	        var promises = [];
	        unitPaths.forEach(function (unitPath) {
	            promises.push(project.unitAsync(unitPath).then(function (x) {
	                if (!map[x.absolutePath()]) {
	                    map[x.absolutePath()] = true;
	                    units.push(x);
	                }
	            }, function (x) {
	                lMap[unitPath].forEach(function (node) { return node.errors().push(new Error(x)); });
	                errors[unitPath] = x;
	            }));
	        });
	        return Promise.all(promises).then(function (x) {
	            return processUnits(ind);
	        });
	    };
	    return project.unitAsync(apiPath).then(function (x) {
	        units.push(x);
	        map[x.absolutePath()] = true;
	        return processUnits(0);
	    }, function (x) {
	        Promise.reject(x);
	    }).then(function (x) {
	        return units.length > 0 ? units[0] : null;
	    });
	}
	exports.fetchIncludesAsync = fetchIncludesAsync;
	function toAbsolutePath(rootPath, relPath) {
	    var apath;
	    if (isWebPath(rootPath)) {
	        var rp = util.stringEndsWith(rootPath, "/") ? rootPath : rootPath + "/";
	        apath = URL.resolve(rp, relPath);
	    }
	    else {
	        apath = path.resolve(rootPath, relPath);
	    }
	    return apath;
	}
	function isWebPath(str) {
	    return util.stringStartsWith(str, "http://") || util.stringStartsWith(str, "https://");
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	/// <reference path="../../../typings/tsd.d.ts" />
	(function (Kind) {
	    Kind[Kind["SCALAR"] = 0] = "SCALAR";
	    Kind[Kind["MAPPING"] = 1] = "MAPPING";
	    Kind[Kind["MAP"] = 2] = "MAP";
	    Kind[Kind["SEQ"] = 3] = "SEQ";
	    Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
	    Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
	})(exports.Kind || (exports.Kind = {}));
	var Kind = exports.Kind;
	function newMapping(key, value) {
	    var end = (value ? value.endPosition : key.endPosition + 1); //FIXME.workaround, end should be defied by position of ':'
	    //console.log('key: ' + key.value + ' ' + key.startPosition + '..' + key.endPosition + ' ' + value + ' end: ' + end);
	    var node = {
	        key: key,
	        value: value,
	        startPosition: key.startPosition,
	        endPosition: end,
	        kind: 1 /* MAPPING */,
	        parent: null,
	        errors: []
	    };
	    return node;
	}
	exports.newMapping = newMapping;
	function newAnchorRef(key, start, end, value) {
	    return {
	        errors: [],
	        referencesAnchor: key,
	        value: value,
	        startPosition: start,
	        endPosition: end,
	        kind: 4 /* ANCHOR_REF */,
	        parent: null
	    };
	}
	exports.newAnchorRef = newAnchorRef;
	function newScalar(v) {
	    if (v === void 0) { v = ""; }
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        value: v,
	        kind: 0 /* SCALAR */,
	        parent: null,
	        doubleQuoted: false
	    };
	}
	exports.newScalar = newScalar;
	function newItems() {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        items: [],
	        kind: 3 /* SEQ */,
	        parent: null
	    };
	}
	exports.newItems = newItems;
	function newSeq() {
	    return newItems();
	}
	exports.newSeq = newSeq;
	function newMap(mappings) {
	    return {
	        errors: [],
	        startPosition: -1,
	        endPosition: -1,
	        mappings: mappings ? mappings : [],
	        kind: 2 /* MAP */,
	        parent: null
	    };
	}
	exports.newMap = newMap;


/***/ },
/* 8 */
/***/ function(module, exports) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ASTDelta = (function () {
	    function ASTDelta() {
	    }
	    return ASTDelta;
	})();
	exports.ASTDelta = ASTDelta;
	(function (CommandKind) {
	    CommandKind[CommandKind["ADD_CHILD"] = 0] = "ADD_CHILD";
	    CommandKind[CommandKind["REMOVE_CHILD"] = 1] = "REMOVE_CHILD";
	    CommandKind[CommandKind["MOVE_CHILD"] = 2] = "MOVE_CHILD";
	    CommandKind[CommandKind["CHANGE_KEY"] = 3] = "CHANGE_KEY";
	    CommandKind[CommandKind["CHANGE_VALUE"] = 4] = "CHANGE_VALUE";
	    CommandKind[CommandKind["INIT_RAML_FILE"] = 5] = "INIT_RAML_FILE";
	})(exports.CommandKind || (exports.CommandKind = {}));
	var CommandKind = exports.CommandKind;
	var TextChangeCommand = (function () {
	    function TextChangeCommand(offset, replacementLength, text, unit, target) {
	        if (target === void 0) { target = null; }
	        this.offset = offset;
	        this.replacementLength = replacementLength;
	        this.text = text;
	        this.unit = unit;
	        this.target = target;
	    }
	    return TextChangeCommand;
	})();
	exports.TextChangeCommand = TextChangeCommand;
	var CompositeCommand = (function () {
	    function CompositeCommand() {
	        this.commands = [];
	    }
	    return CompositeCommand;
	})();
	exports.CompositeCommand = CompositeCommand;
	var ASTChangeCommand = (function () {
	    function ASTChangeCommand(kind, target, value, position) {
	        this.toSeq = false;
	        this.kind = kind;
	        this.target = target;
	        this.value = value;
	        this.position = position;
	    }
	    return ASTChangeCommand;
	})();
	exports.ASTChangeCommand = ASTChangeCommand;
	function setAttr(t, value) {
	    return new ASTChangeCommand(4 /* CHANGE_VALUE */, t, value, -1);
	}
	exports.setAttr = setAttr;
	function setAttrStructured(t, value) {
	    return new ASTChangeCommand(4 /* CHANGE_VALUE */, t, value.lowLevel(), -1);
	}
	exports.setAttrStructured = setAttrStructured;
	function setKey(t, value) {
	    return new ASTChangeCommand(3 /* CHANGE_KEY */, t, value, -1);
	}
	exports.setKey = setKey;
	function removeNode(t, child) {
	    return new ASTChangeCommand(1 /* REMOVE_CHILD */, t, child, -1);
	}
	exports.removeNode = removeNode;
	function insertNode(t, child, insertAfter, toSeq) {
	    if (insertAfter === void 0) { insertAfter = null; }
	    if (toSeq === void 0) { toSeq = false; }
	    var s = new ASTChangeCommand(0 /* ADD_CHILD */, t, child, -1);
	    s.insertionPoint = insertAfter;
	    s.toSeq = toSeq;
	    return s;
	}
	exports.insertNode = insertNode;
	function initRamlFile(root, newroot) {
	    return new ASTChangeCommand(5 /* INIT_RAML_FILE */, root, newroot, -1);
	}
	exports.initRamlFile = initRamlFile;


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	'use strict';
	var loader = __webpack_require__(12);
	var dumper = __webpack_require__(41);
	function deprecated(name) {
	    return function () {
	        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	    };
	}
	exports.Type = __webpack_require__(18);
	exports.Schema = __webpack_require__(17);
	exports.FAILSAFE_SCHEMA = __webpack_require__(21);
	exports.JSON_SCHEMA = __webpack_require__(20);
	exports.CORE_SCHEMA = __webpack_require__(19);
	exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(16);
	exports.DEFAULT_FULL_SCHEMA = __webpack_require__(36);
	exports.load = loader.load;
	exports.loadAll = loader.loadAll;
	exports.safeLoad = loader.safeLoad;
	exports.safeLoadAll = loader.safeLoadAll;
	exports.dump = dumper.dump;
	exports.safeDump = dumper.safeDump;
	exports.YAMLException = __webpack_require__(14);
	// Deprecared schema names from JS-YAML 2.0.x
	exports.MINIMAL_SCHEMA = __webpack_require__(21);
	exports.SAFE_SCHEMA = __webpack_require__(16);
	exports.DEFAULT_SCHEMA = __webpack_require__(36);
	// Deprecated functions from JS-YAML 1.x.x
	exports.scan = deprecated('scan');
	exports.parse = deprecated('parse');
	exports.compose = deprecated('compose');
	exports.addConstructor = deprecated('addConstructor');


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	var ast = __webpack_require__(7);
	'use strict';
	/*eslint-disable max-len,no-use-before-define*/
	var common = __webpack_require__(13);
	var YAMLException = __webpack_require__(14);
	var Mark = __webpack_require__(15);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(16);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(36);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CONTEXT_FLOW_IN = 1;
	var CONTEXT_FLOW_OUT = 2;
	var CONTEXT_BLOCK_IN = 3;
	var CONTEXT_BLOCK_OUT = 4;
	var CHOMPING_CLIP = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP = 3;
	var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uD800-\uDFFF\uFFFE\uFFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
	function is_EOL(c) {
	    return (c === 0x0A) || (c === 0x0D);
	}
	function is_WHITE_SPACE(c) {
	    return (c === 0x09) || (c === 0x20);
	}
	function is_WS_OR_EOL(c) {
	    return (c === 0x09) || (c === 0x20) || (c === 0x0A) || (c === 0x0D);
	}
	function is_FLOW_INDICATOR(c) {
	    return 0x2C === c || 0x5B === c || 0x5D === c || 0x7B === c || 0x7D === c;
	}
	function fromHexCode(c) {
	    var lc;
	    if ((0x30 <= c) && (c <= 0x39)) {
	        return c - 0x30;
	    }
	    /*eslint-disable no-bitwise*/
	    lc = c | 0x20;
	    if ((0x61 <= lc) && (lc <= 0x66)) {
	        return lc - 0x61 + 10;
	    }
	    return -1;
	}
	function escapedHexLen(c) {
	    if (c === 0x78) {
	        return 2;
	    }
	    if (c === 0x75) {
	        return 4;
	    }
	    if (c === 0x55) {
	        return 8;
	    }
	    return 0;
	}
	function fromDecimalCode(c) {
	    if ((0x30 <= c) && (c <= 0x39)) {
	        return c - 0x30;
	    }
	    return -1;
	}
	function simpleEscapeSequence(c) {
	    return (c === 0x30) ? '\x00' : (c === 0x61) ? '\x07' : (c === 0x62) ? '\x08' : (c === 0x74) ? '\x09' : (c === 0x09) ? '\x09' : (c === 0x6E) ? '\x0A' : (c === 0x76) ? '\x0B' : (c === 0x66) ? '\x0C' : (c === 0x72) ? '\x0D' : (c === 0x65) ? '\x1B' : (c === 0x20) ? ' ' : (c === 0x22) ? '\x22' : (c === 0x2F) ? '/' : (c === 0x5C) ? '\x5C' : (c === 0x4E) ? '\x85' : (c === 0x5F) ? '\xA0' : (c === 0x4C) ? '\u2028' : (c === 0x50) ? '\u2029' : '';
	}
	function charFromCodepoint(c) {
	    if (c <= 0xFFFF) {
	        return String.fromCharCode(c);
	    }
	    // Encode UTF-16 surrogate pair
	    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	    return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800, ((c - 0x010000) & 0x03FF) + 0xDC00);
	}
	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	    simpleEscapeMap[i] = simpleEscapeSequence(i);
	}
	var State = (function () {
	    function State(input, options) {
	        this.errorMap = {};
	        this.errors = [];
	        this.input = input;
	        this.filename = options['filename'] || null;
	        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	        this.onWarning = options['onWarning'] || null;
	        this.legacy = options['legacy'] || false;
	        this.implicitTypes = this.schema.compiledImplicit;
	        this.typeMap = this.schema.compiledTypeMap;
	        this.length = input.length;
	        this.position = 0;
	        this.line = 0;
	        this.lineStart = 0;
	        this.lineIndent = 0;
	        this.documents = [];
	    }
	    return State;
	})();
	function generateError(state, message) {
	    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line - 1, (state.position - state.lineStart)));
	}
	function throwError(state, message) {
	    //FIXME
	    var error = generateError(state, message);
	    var hash = error.message + error.mark.position;
	    if (!state.errorMap[hash]) {
	        state.errors.push(error);
	        state.errorMap[hash] = 1;
	    }
	    var or = state.position;
	    while (true) {
	        if (state.position >= state.input.length - 1) {
	            return;
	        }
	        var c = state.input.charAt(state.position);
	        if (c == '\n') {
	            state.position--;
	            if (state.position == or) {
	                state.position += 1;
	            }
	            return;
	        }
	        if (c == '\r') {
	            state.position--;
	            if (state.position == or) {
	                state.position += 1;
	            }
	            return;
	        }
	        state.position++;
	    }
	    //throw generateError(state, message);
	}
	function throwWarning(state, message) {
	    var error = generateError(state, message);
	    if (state.onWarning) {
	        state.onWarning.call(null, error);
	    }
	    else {
	    }
	}
	var directiveHandlers = {
	    YAML: function handleYamlDirective(state, name, args) {
	        var match, major, minor;
	        if (null !== state.version) {
	            throwError(state, 'duplication of %YAML directive');
	        }
	        if (1 !== args.length) {
	            throwError(state, 'YAML directive accepts exactly one argument');
	        }
	        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
	        if (null === match) {
	            throwError(state, 'ill-formed argument of the YAML directive');
	        }
	        major = parseInt(match[1], 10);
	        minor = parseInt(match[2], 10);
	        if (1 !== major) {
	            throwError(state, 'unacceptable YAML version of the document');
	        }
	        state.version = args[0];
	        state.checkLineBreaks = (minor < 2);
	        if (1 !== minor && 2 !== minor) {
	            throwWarning(state, 'unsupported YAML version of the document');
	        }
	    },
	    TAG: function handleTagDirective(state, name, args) {
	        var handle, prefix;
	        if (2 !== args.length) {
	            throwError(state, 'TAG directive accepts exactly two arguments');
	        }
	        handle = args[0];
	        prefix = args[1];
	        if (!PATTERN_TAG_HANDLE.test(handle)) {
	            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	        }
	        if (_hasOwnProperty.call(state.tagMap, handle)) {
	            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	        }
	        if (!PATTERN_TAG_URI.test(prefix)) {
	            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	        }
	        state.tagMap[handle] = prefix;
	    }
	};
	function captureSegment(state, start, end, checkJson) {
	    var _position, _length, _character, _result;
	    var scalar = state.result;
	    if (scalar.startPosition == -1) {
	        scalar.startPosition = start;
	    }
	    if (start < end) {
	        _result = state.input.slice(start, end);
	        if (checkJson) {
	            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
	                _character = _result.charCodeAt(_position);
	                if (!(0x09 === _character || 0x20 <= _character && _character <= 0x10FFFF)) {
	                    throwError(state, 'expected valid JSON character');
	                }
	            }
	        }
	        scalar.value += _result;
	        scalar.endPosition = end;
	    }
	}
	function mergeMappings(state, destination, source) {
	    var sourceKeys, key, index, quantity;
	    if (!common.isObject(source)) {
	        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	    }
	    sourceKeys = Object.keys(source);
	    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	        key = sourceKeys[index];
	        if (!_hasOwnProperty.call(destination, key)) {
	            destination[key] = source[key];
	        }
	    }
	}
	function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
	    var index, quantity;
	    if (keyNode == null) {
	        return;
	    }
	    //keyNode = String(keyNode);
	    if (null === _result) {
	        _result = {
	            startPosition: keyNode.startPosition,
	            endPosition: valueNode.endPosition,
	            parent: null,
	            errors: [],
	            mappings: [],
	            kind: 2 /* MAP */
	        };
	    }
	    if ('tag:yaml.org,2002:merge' === keyTag) {
	        throw new Error("Should not happen");
	    }
	    else {
	        var mapping = ast.newMapping(keyNode, valueNode);
	        mapping.parent = _result;
	        keyNode.parent = mapping;
	        if (valueNode != null) {
	            valueNode.parent = mapping;
	        }
	        _result.mappings.push(mapping);
	        _result.endPosition = valueNode ? valueNode.endPosition : keyNode.endPosition + 1; //FIXME.workaround should be position of ':' indeed
	    }
	    return _result;
	}
	function readLineBreak(state) {
	    var ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x0A === ch) {
	        state.position++;
	    }
	    else if (0x0D === ch) {
	        state.position++;
	        if (0x0A === state.input.charCodeAt(state.position)) {
	            state.position++;
	        }
	    }
	    else {
	        throwError(state, 'a line break is expected');
	    }
	    state.line += 1;
	    state.lineStart = state.position;
	}
	function skipSeparationSpace(state, allowComments, checkIndent) {
	    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        while (is_WHITE_SPACE(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        if (allowComments && 0x23 === ch) {
	            do {
	                ch = state.input.charCodeAt(++state.position);
	            } while (ch !== 0x0A && ch !== 0x0D && 0 !== ch);
	        }
	        if (is_EOL(ch)) {
	            readLineBreak(state);
	            ch = state.input.charCodeAt(state.position);
	            lineBreaks++;
	            state.lineIndent = 0;
	            while (0x20 === ch) {
	                state.lineIndent++;
	                ch = state.input.charCodeAt(++state.position);
	            }
	        }
	        else {
	            break;
	        }
	    }
	    if (-1 !== checkIndent && 0 !== lineBreaks && state.lineIndent < checkIndent) {
	        throwWarning(state, 'deficient indentation');
	    }
	    return lineBreaks;
	}
	function testDocumentSeparator(state) {
	    var _position = state.position, ch;
	    ch = state.input.charCodeAt(_position);
	    // Condition state.position === state.lineStart is tested
	    // in parent on each call, for efficiency. No needs to test here again.
	    if ((0x2D === ch || 0x2E === ch) && state.input.charCodeAt(_position + 1) === ch && state.input.charCodeAt(_position + 2) === ch) {
	        _position += 3;
	        ch = state.input.charCodeAt(_position);
	        if (ch === 0 || is_WS_OR_EOL(ch)) {
	            return true;
	        }
	    }
	    return false;
	}
	function writeFoldedLines(state, scalar, count) {
	    if (1 === count) {
	        scalar.value += ' ';
	    }
	    else if (count > 1) {
	        scalar.value += common.repeat('\n', count - 1);
	    }
	}
	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
	    var state_result = ast.newScalar();
	    state.result = state_result;
	    ch = state.input.charCodeAt(state.position);
	    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || 0x23 === ch || 0x26 === ch || 0x2A === ch || 0x21 === ch || 0x7C === ch || 0x3E === ch || 0x27 === ch || 0x22 === ch || 0x25 === ch || 0x40 === ch || 0x60 === ch) {
	        return false;
	    }
	    if (0x3F === ch || 0x2D === ch) {
	        following = state.input.charCodeAt(state.position + 1);
	        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
	            return false;
	        }
	    }
	    state.kind = 'scalar';
	    //state.result = '';
	    captureStart = captureEnd = state.position;
	    hasPendingContent = false;
	    while (0 !== ch) {
	        if (0x3A === ch) {
	            following = state.input.charCodeAt(state.position + 1);
	            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
	                break;
	            }
	        }
	        else if (0x23 === ch) {
	            preceding = state.input.charCodeAt(state.position - 1);
	            if (is_WS_OR_EOL(preceding)) {
	                break;
	            }
	        }
	        else if ((state.position === state.lineStart && testDocumentSeparator(state)) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	            break;
	        }
	        else if (is_EOL(ch)) {
	            _line = state.line;
	            _lineStart = state.lineStart;
	            _lineIndent = state.lineIndent;
	            skipSeparationSpace(state, false, -1);
	            if (state.lineIndent >= nodeIndent) {
	                hasPendingContent = true;
	                ch = state.input.charCodeAt(state.position);
	                continue;
	            }
	            else {
	                state.position = captureEnd;
	                state.line = _line;
	                state.lineStart = _lineStart;
	                state.lineIndent = _lineIndent;
	                break;
	            }
	        }
	        if (hasPendingContent) {
	            captureSegment(state, captureStart, captureEnd, false);
	            writeFoldedLines(state, state_result, state.line - _line);
	            captureStart = captureEnd = state.position;
	            hasPendingContent = false;
	        }
	        if (!is_WHITE_SPACE(ch)) {
	            captureEnd = state.position + 1;
	        }
	        ch = state.input.charCodeAt(++state.position);
	        if (state.position >= state.input.length) {
	            return false;
	        }
	    }
	    captureSegment(state, captureStart, captureEnd, false);
	    if (state.result.startPosition != -1) {
	        return true;
	    }
	    state.kind = _kind;
	    state.result = _result;
	    return false;
	}
	function readSingleQuotedScalar(state, nodeIndent) {
	    var ch, captureStart, captureEnd;
	    ch = state.input.charCodeAt(state.position);
	    if (0x27 !== ch) {
	        return false;
	    }
	    var scalar = ast.newScalar();
	    state.kind = 'scalar';
	    state.result = scalar;
	    scalar.startPosition = state.position;
	    state.position++;
	    captureStart = captureEnd = state.position;
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        //console.log('ch: <' + String.fromCharCode(ch) + '>');
	        if (0x27 === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            ch = state.input.charCodeAt(++state.position);
	            //console.log('next: <' + String.fromCharCode(ch) + '>');
	            scalar.endPosition = state.position;
	            if (0x27 === ch) {
	                captureStart = captureEnd = state.position;
	                state.position++;
	            }
	            else {
	                return true;
	            }
	        }
	        else if (is_EOL(ch)) {
	            captureSegment(state, captureStart, captureEnd, true);
	            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
	            captureStart = captureEnd = state.position;
	        }
	        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	            throwError(state, 'unexpected end of the document within a single quoted scalar');
	        }
	        else {
	            state.position++;
	            captureEnd = state.position;
	            scalar.endPosition = state.position;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}
	function readDoubleQuotedScalar(state, nodeIndent) {
	    var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x22 !== ch) {
	        return false;
	    }
	    state.kind = 'scalar';
	    var scalar = ast.newScalar();
	    scalar.doubleQuoted = true;
	    state.result = scalar;
	    scalar.startPosition = state.position;
	    state.position++;
	    captureStart = captureEnd = state.position;
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        if (0x22 === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            state.position++;
	            scalar.endPosition = state.position;
	            return true;
	        }
	        else if (0x5C === ch) {
	            captureSegment(state, captureStart, state.position, true);
	            ch = state.input.charCodeAt(++state.position);
	            if (is_EOL(ch)) {
	                skipSeparationSpace(state, false, nodeIndent);
	            }
	            else if (ch < 256 && simpleEscapeCheck[ch]) {
	                scalar.value += simpleEscapeMap[ch];
	                state.position++;
	            }
	            else if ((tmp = escapedHexLen(ch)) > 0) {
	                hexLength = tmp;
	                hexResult = 0;
	                for (; hexLength > 0; hexLength--) {
	                    ch = state.input.charCodeAt(++state.position);
	                    if ((tmp = fromHexCode(ch)) >= 0) {
	                        hexResult = (hexResult << 4) + tmp;
	                    }
	                    else {
	                        throwError(state, 'expected hexadecimal character');
	                    }
	                }
	                scalar.value += charFromCodepoint(hexResult);
	                state.position++;
	            }
	            else {
	                throwError(state, 'unknown escape sequence');
	            }
	            captureStart = captureEnd = state.position;
	        }
	        else if (is_EOL(ch)) {
	            captureSegment(state, captureStart, captureEnd, true);
	            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
	            captureStart = captureEnd = state.position;
	        }
	        else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	            throwError(state, 'unexpected end of the document within a double quoted scalar');
	        }
	        else {
	            state.position++;
	            captureEnd = state.position;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}
	function readFlowCollection(state, nodeIndent) {
	    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, keyNode, keyTag, valueNode, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (ch === 0x5B) {
	        terminator = 0x5D; /* ] */
	        isMapping = false;
	        _result = ast.newItems();
	        _result.startPosition = state.position;
	    }
	    else if (ch === 0x7B) {
	        terminator = 0x7D; /* } */
	        isMapping = true;
	        _result = ast.newMap();
	        _result.startPosition = state.position;
	    }
	    else {
	        return false;
	    }
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    ch = state.input.charCodeAt(++state.position);
	    while (0 !== ch) {
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if (ch === terminator) {
	            state.position++;
	            state.tag = _tag;
	            state.anchor = _anchor;
	            state.kind = isMapping ? 'mapping' : 'sequence';
	            state.result = _result;
	            _result.endPosition = state.position;
	            return true;
	        }
	        else if (!readNext) {
	            var p = state.position;
	            throwError(state, 'missed comma between flow collection entries');
	            state.position = p + 1;
	        }
	        keyTag = keyNode = valueNode = null;
	        isPair = isExplicitPair = false;
	        if (0x3F === ch) {
	            following = state.input.charCodeAt(state.position + 1);
	            if (is_WS_OR_EOL(following)) {
	                isPair = isExplicitPair = true;
	                state.position++;
	                skipSeparationSpace(state, true, nodeIndent);
	            }
	        }
	        _line = state.line;
	        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	        keyTag = state.tag;
	        keyNode = state.result;
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if ((isExplicitPair || state.line === _line) && 0x3A === ch) {
	            isPair = true;
	            ch = state.input.charCodeAt(++state.position);
	            skipSeparationSpace(state, true, nodeIndent);
	            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	            valueNode = state.result;
	        }
	        if (isMapping) {
	            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	        }
	        else if (isPair) {
	            var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
	            mp.parent = _result;
	            _result.items.push(mp);
	        }
	        else {
	            keyNode.parent = _result;
	            _result.items.push(keyNode);
	        }
	        _result.endPosition = state.position + 1;
	        skipSeparationSpace(state, true, nodeIndent);
	        ch = state.input.charCodeAt(state.position);
	        if (0x2C === ch) {
	            readNext = true;
	            ch = state.input.charCodeAt(++state.position);
	        }
	        else {
	            readNext = false;
	        }
	    }
	    throwError(state, 'unexpected end of the stream within a flow collection');
	}
	function readBlockScalar(state, nodeIndent) {
	    var captureStart, folding, chomping = CHOMPING_CLIP, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (ch === 0x7C) {
	        folding = false;
	    }
	    else if (ch === 0x3E) {
	        folding = true;
	    }
	    else {
	        return false;
	    }
	    var sc = ast.newScalar();
	    state.kind = 'scalar';
	    state.result = sc;
	    sc.startPosition = state.position;
	    while (0 !== ch) {
	        ch = state.input.charCodeAt(++state.position);
	        if (0x2B === ch || 0x2D === ch) {
	            if (CHOMPING_CLIP === chomping) {
	                chomping = (0x2B === ch) ? CHOMPING_KEEP : CHOMPING_STRIP;
	            }
	            else {
	                throwError(state, 'repeat of a chomping mode identifier');
	            }
	        }
	        else if ((tmp = fromDecimalCode(ch)) >= 0) {
	            if (tmp === 0) {
	                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	            }
	            else if (!detectedIndent) {
	                textIndent = nodeIndent + tmp - 1;
	                detectedIndent = true;
	            }
	            else {
	                throwError(state, 'repeat of an indentation width identifier');
	            }
	        }
	        else {
	            break;
	        }
	    }
	    if (is_WHITE_SPACE(ch)) {
	        do {
	            ch = state.input.charCodeAt(++state.position);
	        } while (is_WHITE_SPACE(ch));
	        if (0x23 === ch) {
	            do {
	                ch = state.input.charCodeAt(++state.position);
	            } while (!is_EOL(ch) && (0 !== ch));
	        }
	    }
	    while (0 !== ch) {
	        readLineBreak(state);
	        state.lineIndent = 0;
	        ch = state.input.charCodeAt(state.position);
	        while ((!detectedIndent || state.lineIndent < textIndent) && (0x20 === ch)) {
	            state.lineIndent++;
	            ch = state.input.charCodeAt(++state.position);
	        }
	        if (!detectedIndent && state.lineIndent > textIndent) {
	            textIndent = state.lineIndent;
	        }
	        if (is_EOL(ch)) {
	            emptyLines++;
	            continue;
	        }
	        // End of the scalar.
	        if (state.lineIndent < textIndent) {
	            // Perform the chomping.
	            if (chomping === CHOMPING_KEEP) {
	                sc.value += common.repeat('\n', emptyLines);
	            }
	            else if (chomping === CHOMPING_CLIP) {
	                if (detectedIndent) {
	                    sc.value += '\n';
	                }
	            }
	            break;
	        }
	        // Folded style: use fancy rules to handle line breaks.
	        if (folding) {
	            // Lines starting with white space characters (more-indented lines) are not folded.
	            if (is_WHITE_SPACE(ch)) {
	                atMoreIndented = true;
	                sc.value += common.repeat('\n', emptyLines + 1);
	            }
	            else if (atMoreIndented) {
	                atMoreIndented = false;
	                sc.value += common.repeat('\n', emptyLines + 1);
	            }
	            else if (0 === emptyLines) {
	                if (detectedIndent) {
	                    sc.value += ' ';
	                }
	            }
	            else {
	                sc.value += common.repeat('\n', emptyLines);
	            }
	        }
	        else if (detectedIndent) {
	            // If current line isn't the first one - count line break from the last content line.
	            sc.value += common.repeat('\n', emptyLines + 1);
	        }
	        else {
	        }
	        detectedIndent = true;
	        emptyLines = 0;
	        captureStart = state.position;
	        while (!is_EOL(ch) && (0 !== ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        captureSegment(state, captureStart, state.position, false);
	    }
	    sc.endPosition = state.position;
	    var i = state.position - 1;
	    var needMinus = false;
	    while (true) {
	        var c = state.input[i];
	        if (c == '\r' || c == '\n') {
	            if (needMinus) {
	                i--;
	            }
	            break;
	        }
	        if (c != ' ' && c != '\t') {
	            break;
	        }
	        i--;
	    }
	    sc.endPosition = i;
	    return true;
	}
	function readBlockSequence(state, nodeIndent) {
	    var _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newItems(), following, detected = false, ch;
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    _result.startPosition = state.position;
	    ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        if (0x2D !== ch) {
	            break;
	        }
	        following = state.input.charCodeAt(state.position + 1);
	        if (!is_WS_OR_EOL(following)) {
	            break;
	        }
	        detected = true;
	        state.position++;
	        if (skipSeparationSpace(state, true, -1)) {
	            if (state.lineIndent <= nodeIndent) {
	                _result.items.push(null);
	                ch = state.input.charCodeAt(state.position);
	                continue;
	            }
	        }
	        _line = state.line;
	        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	        state.result.parent = _result;
	        _result.items.push(state.result);
	        skipSeparationSpace(state, true, -1);
	        ch = state.input.charCodeAt(state.position);
	        if ((state.line === _line || state.lineIndent > nodeIndent) && (0 !== ch)) {
	            throwError(state, 'bad indentation of a sequence entry');
	        }
	        else if (state.lineIndent < nodeIndent) {
	            break;
	        }
	    }
	    _result.endPosition = state.position;
	    if (detected) {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        state.kind = 'sequence';
	        state.result = _result;
	        _result.endPosition = state.position;
	        return true;
	    }
	    return false;
	}
	function readBlockMapping(state, nodeIndent, flowIndent) {
	    var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = ast.newMap(), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
	    _result.startPosition = state.position;
	    if (null !== state.anchor) {
	        _result.anchorId = state.anchor;
	        state.anchorMap[state.anchor] = _result;
	    }
	    ch = state.input.charCodeAt(state.position);
	    while (0 !== ch) {
	        following = state.input.charCodeAt(state.position + 1);
	        _line = state.line; // Save the current line.
	        //
	        // Explicit notation case. There are two separate blocks:
	        // first for the key (denoted by "?") and second for the value (denoted by ":")
	        //
	        if ((0x3F === ch || 0x3A === ch) && is_WS_OR_EOL(following)) {
	            if (0x3F === ch) {
	                if (atExplicitKey) {
	                    storeMappingPair(state, _result, keyTag, keyNode, null);
	                    keyTag = keyNode = valueNode = null;
	                }
	                detected = true;
	                atExplicitKey = true;
	                allowCompact = true;
	            }
	            else if (atExplicitKey) {
	                // i.e. 0x3A/* : */ === character after the explicit key.
	                atExplicitKey = false;
	                allowCompact = true;
	            }
	            else {
	                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
	            }
	            state.position += 1;
	            ch = following;
	        }
	        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
	            if (state.line === _line) {
	                ch = state.input.charCodeAt(state.position);
	                while (is_WHITE_SPACE(ch)) {
	                    ch = state.input.charCodeAt(++state.position);
	                }
	                if (0x3A === ch) {
	                    ch = state.input.charCodeAt(++state.position);
	                    if (!is_WS_OR_EOL(ch)) {
	                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	                    }
	                    if (atExplicitKey) {
	                        storeMappingPair(state, _result, keyTag, keyNode, null);
	                        keyTag = keyNode = valueNode = null;
	                    }
	                    detected = true;
	                    atExplicitKey = false;
	                    allowCompact = false;
	                    keyTag = state.tag;
	                    keyNode = state.result;
	                }
	                else if (detected) {
	                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');
	                }
	                else {
	                    state.tag = _tag;
	                    state.anchor = _anchor;
	                    return true; // Keep the result of `composeNode`.
	                }
	            }
	            else if (detected) {
	                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
	                while (state.position > 0) {
	                    ch = state.input.charCodeAt(--state.position);
	                    if (is_EOL(ch)) {
	                        state.position++;
	                        break;
	                    }
	                }
	            }
	            else {
	                state.tag = _tag;
	                state.anchor = _anchor;
	                return true; // Keep the result of `composeNode`.
	            }
	        }
	        else {
	            break;
	        }
	        //
	        // Common reading code for both explicit and implicit notations.
	        //
	        if (state.line === _line || state.lineIndent > nodeIndent) {
	            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	                if (atExplicitKey) {
	                    keyNode = state.result;
	                }
	                else {
	                    valueNode = state.result;
	                }
	            }
	            if (!atExplicitKey) {
	                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
	                keyTag = keyNode = valueNode = null;
	            }
	            skipSeparationSpace(state, true, -1);
	            ch = state.input.charCodeAt(state.position);
	        }
	        if (state.lineIndent > nodeIndent && (0 !== ch)) {
	            throwError(state, 'bad indentation of a mapping entry');
	        }
	        else if (state.lineIndent < nodeIndent) {
	            break;
	        }
	    }
	    //
	    // Epilogue.
	    //
	    // Special case: last mapping's node contains only the key in explicit notation.
	    if (atExplicitKey) {
	        storeMappingPair(state, _result, keyTag, keyNode, null);
	    }
	    // Expose the resulting mapping.
	    if (detected) {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        state.kind = 'mapping';
	        state.result = _result;
	    }
	    return detected;
	}
	function readTagProperty(state) {
	    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x21 !== ch) {
	        return false;
	    }
	    if (null !== state.tag) {
	        throwError(state, 'duplication of a tag property');
	    }
	    ch = state.input.charCodeAt(++state.position);
	    if (0x3C === ch) {
	        isVerbatim = true;
	        ch = state.input.charCodeAt(++state.position);
	    }
	    else if (0x21 === ch) {
	        isNamed = true;
	        tagHandle = '!!';
	        ch = state.input.charCodeAt(++state.position);
	    }
	    else {
	        tagHandle = '!';
	    }
	    _position = state.position;
	    if (isVerbatim) {
	        do {
	            ch = state.input.charCodeAt(++state.position);
	        } while (0 !== ch && 0x3E !== ch);
	        if (state.position < state.length) {
	            tagName = state.input.slice(_position, state.position);
	            ch = state.input.charCodeAt(++state.position);
	        }
	        else {
	            throwError(state, 'unexpected end of the stream within a verbatim tag');
	        }
	    }
	    else {
	        while (0 !== ch && !is_WS_OR_EOL(ch)) {
	            if (0x21 === ch) {
	                if (!isNamed) {
	                    tagHandle = state.input.slice(_position - 1, state.position + 1);
	                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	                        throwError(state, 'named tag handle cannot contain such characters');
	                    }
	                    isNamed = true;
	                    _position = state.position + 1;
	                }
	                else {
	                    throwError(state, 'tag suffix cannot contain exclamation marks');
	                }
	            }
	            ch = state.input.charCodeAt(++state.position);
	        }
	        tagName = state.input.slice(_position, state.position);
	        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	            throwError(state, 'tag suffix cannot contain flow indicator characters');
	        }
	    }
	    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	        throwError(state, 'tag name cannot contain such characters: ' + tagName);
	    }
	    if (isVerbatim) {
	        state.tag = tagName;
	    }
	    else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	        state.tag = state.tagMap[tagHandle] + tagName;
	    }
	    else if ('!' === tagHandle) {
	        state.tag = '!' + tagName;
	    }
	    else if ('!!' === tagHandle) {
	        state.tag = 'tag:yaml.org,2002:' + tagName;
	    }
	    else {
	        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	    }
	    return true;
	}
	function readAnchorProperty(state) {
	    var _position, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x26 !== ch) {
	        return false;
	    }
	    if (null !== state.anchor) {
	        throwError(state, 'duplication of an anchor property');
	    }
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	    }
	    if (state.position === _position) {
	        throwError(state, 'name of an anchor node must contain at least one character');
	    }
	    state.anchor = state.input.slice(_position, state.position);
	    return true;
	}
	function readAlias(state) {
	    var _position, alias, len = state.length, input = state.input, ch;
	    ch = state.input.charCodeAt(state.position);
	    if (0x2A !== ch) {
	        return false;
	    }
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;
	    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	    }
	    if (state.position <= _position) {
	        throwError(state, 'name of an alias node must contain at least one character');
	        state.position = _position + 1;
	    }
	    alias = state.input.slice(_position, state.position);
	    if (!state.anchorMap.hasOwnProperty(alias)) {
	        throwError(state, 'unidentified alias "' + alias + '"');
	        if (state.position <= _position) {
	            state.position = _position + 1;
	        }
	    }
	    state.result = ast.newAnchorRef(alias, _position, state.position, state.anchorMap[alias]);
	    skipSeparationSpace(state, true, -1);
	    return true;
	}
	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent, _result;
	    state.tag = null;
	    state.anchor = null;
	    state.kind = null;
	    state.result = null;
	    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
	    if (allowToSeek) {
	        if (skipSeparationSpace(state, true, -1)) {
	            atNewLine = true;
	            if (state.lineIndent > parentIndent) {
	                indentStatus = 1;
	            }
	            else if (state.lineIndent === parentIndent) {
	                indentStatus = 0;
	            }
	            else if (state.lineIndent < parentIndent) {
	                indentStatus = -1;
	            }
	        }
	    }
	    if (1 === indentStatus) {
	        while (readTagProperty(state) || readAnchorProperty(state)) {
	            if (skipSeparationSpace(state, true, -1)) {
	                atNewLine = true;
	                allowBlockCollections = allowBlockStyles;
	                if (state.lineIndent > parentIndent) {
	                    indentStatus = 1;
	                }
	                else if (state.lineIndent === parentIndent) {
	                    indentStatus = 0;
	                }
	                else if (state.lineIndent < parentIndent) {
	                    indentStatus = -1;
	                }
	            }
	            else {
	                allowBlockCollections = false;
	            }
	        }
	    }
	    if (allowBlockCollections) {
	        allowBlockCollections = atNewLine || allowCompact;
	    }
	    if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
	        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	            flowIndent = parentIndent;
	        }
	        else {
	            flowIndent = parentIndent + 1;
	        }
	        blockIndent = state.position - state.lineStart;
	        if (1 === indentStatus) {
	            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
	                hasContent = true;
	            }
	            else {
	                if ((allowBlockScalars && readBlockScalar(state, flowIndent)) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
	                    hasContent = true;
	                }
	                else if (readAlias(state)) {
	                    hasContent = true;
	                    if (null !== state.tag || null !== state.anchor) {
	                        throwError(state, 'alias node should not have any properties');
	                    }
	                }
	                else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	                    hasContent = true;
	                    if (null === state.tag) {
	                        state.tag = '?';
	                    }
	                }
	                if (null !== state.anchor) {
	                    state.anchorMap[state.anchor] = state.result;
	                    state.result.anchorId = state.anchor;
	                }
	            }
	        }
	        else if (0 === indentStatus) {
	            // Special case: block sequences are allowed to have same indentation level as the parent.
	            // http://www.yaml.org/spec/1.2/spec.html#id2799784
	            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	        }
	    }
	    if (null !== state.tag && '!' !== state.tag) {
	        if (state.tag == "!include") {
	            if (!state.result) {
	                state.result = ast.newScalar();
	                state.result.startPosition = state.position;
	                state.result.endPosition = state.position;
	                throwError(state, "!include without value");
	            }
	            state.result.kind = 5 /* INCLUDE_REF */;
	        }
	        else if ('?' === state.tag) {
	            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
	                type = state.implicitTypes[typeIndex];
	                // Implicit resolving is not allowed for non-scalar types, and '?'
	                // non-specific tag is only assigned to plain scalars. So, it isn't
	                // needed to check for 'kind' conformity.
	                var vl = state.result['value'];
	                if (type.resolve(vl)) {
	                    state.result.valueObject = type.construct(state.result['value']);
	                    state.tag = type.tag;
	                    if (null !== state.anchor) {
	                        state.result.anchorId = state.anchor;
	                        state.anchorMap[state.anchor] = state.result;
	                    }
	                    break;
	                }
	            }
	        }
	        else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
	            type = state.typeMap[state.tag];
	            if (null !== state.result && type.kind !== state.kind) {
	                throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	            }
	            if (!type.resolve(state.result)) {
	                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	            }
	            else {
	                state.result = type.construct(state.result);
	                if (null !== state.anchor) {
	                    state.result.anchorId = state.anchor;
	                    state.anchorMap[state.anchor] = state.result;
	                }
	            }
	        }
	        else {
	            throwWarning(state, 'unknown tag !<' + state.tag + '>');
	        }
	    }
	    return null !== state.tag || null !== state.anchor || hasContent;
	}
	function readDocument(state) {
	    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
	    state.version = null;
	    state.checkLineBreaks = state.legacy;
	    state.tagMap = {};
	    state.anchorMap = {};
	    while (0 !== (ch = state.input.charCodeAt(state.position))) {
	        skipSeparationSpace(state, true, -1);
	        ch = state.input.charCodeAt(state.position);
	        if (state.lineIndent > 0 || 0x25 !== ch) {
	            break;
	        }
	        hasDirectives = true;
	        ch = state.input.charCodeAt(++state.position);
	        _position = state.position;
	        while (0 !== ch && !is_WS_OR_EOL(ch)) {
	            ch = state.input.charCodeAt(++state.position);
	        }
	        directiveName = state.input.slice(_position, state.position);
	        directiveArgs = [];
	        if (directiveName.length < 1) {
	            throwError(state, 'directive name must not be less than one character in length');
	        }
	        while (0 !== ch) {
	            while (is_WHITE_SPACE(ch)) {
	                ch = state.input.charCodeAt(++state.position);
	            }
	            if (0x23 === ch) {
	                do {
	                    ch = state.input.charCodeAt(++state.position);
	                } while (0 !== ch && !is_EOL(ch));
	                break;
	            }
	            if (is_EOL(ch)) {
	                break;
	            }
	            _position = state.position;
	            while (0 !== ch && !is_WS_OR_EOL(ch)) {
	                ch = state.input.charCodeAt(++state.position);
	            }
	            directiveArgs.push(state.input.slice(_position, state.position));
	        }
	        if (0 !== ch) {
	            readLineBreak(state);
	        }
	        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	            directiveHandlers[directiveName](state, directiveName, directiveArgs);
	        }
	        else {
	            throwWarning(state, 'unknown document directive "' + directiveName + '"');
	            state.position++;
	        }
	    }
	    skipSeparationSpace(state, true, -1);
	    if (0 === state.lineIndent && 0x2D === state.input.charCodeAt(state.position) && 0x2D === state.input.charCodeAt(state.position + 1) && 0x2D === state.input.charCodeAt(state.position + 2)) {
	        state.position += 3;
	        skipSeparationSpace(state, true, -1);
	    }
	    else if (hasDirectives) {
	        throwError(state, 'directives end mark is expected');
	    }
	    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	    skipSeparationSpace(state, true, -1);
	    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	    }
	    state.documents.push(state.result);
	    if (state.position === state.lineStart && testDocumentSeparator(state)) {
	        if (0x2E === state.input.charCodeAt(state.position)) {
	            state.position += 3;
	            skipSeparationSpace(state, true, -1);
	        }
	        return;
	    }
	    if (state.position < (state.length - 1)) {
	        throwError(state, 'end of the stream or a document separator is expected');
	    }
	    else {
	        return;
	    }
	}
	function loadDocuments(input, options) {
	    input = String(input);
	    options = options || {};
	    if (input.length !== 0) {
	        // Add tailing `\n` if not exists
	        if (0x0A !== input.charCodeAt(input.length - 1) && 0x0D !== input.charCodeAt(input.length - 1)) {
	            input += '\n';
	        }
	        // Strip BOM
	        if (input.charCodeAt(0) === 0xFEFF) {
	            input = input.slice(1);
	        }
	    }
	    var state = new State(input, options);
	    if (PATTERN_NON_PRINTABLE.test(state.input)) {
	        throwError(state, 'the stream contains non-printable characters');
	    }
	    // Use 0 as string terminator. That significantly simplifies bounds check.
	    state.input += '\0';
	    while (0x20 === state.input.charCodeAt(state.position)) {
	        state.lineIndent += 1;
	        state.position += 1;
	    }
	    while (state.position < (state.length - 1)) {
	        var q = state.position;
	        readDocument(state);
	        if (state.position <= q) {
	            for (; state.position < state.length - 1; state.position++) {
	                var c = state.input.charAt(state.position);
	                if (c == '\n') {
	                    break;
	                }
	            }
	        }
	    }
	    state.documents.forEach(function (x) { return x.errors = state.errors; });
	    return state.documents;
	}
	function loadAll(input, iterator, options) {
	    var documents = loadDocuments(input, options), index, length;
	    for (index = 0, length = documents.length; index < length; index += 1) {
	        iterator(documents[index]);
	    }
	}
	exports.loadAll = loadAll;
	function load(input, options) {
	    var documents = loadDocuments(input, options), index, length;
	    if (0 === documents.length) {
	        /*eslint-disable no-undefined*/
	        return undefined;
	    }
	    else if (1 === documents.length) {
	        //root node always takes whole file
	        documents[0].endPosition = input.length;
	        return documents[0];
	    }
	    var e = new YAMLException('expected a single document in the stream, but found more');
	    e.mark = new Mark("", "", 0, 0, 0);
	    e.mark.position = documents[0].endPosition;
	    documents[0].errors.push(e);
	    //it is an artifact which is caused by the fact that we are checking next char before stopping parse
	    return documents[0];
	}
	exports.load = load;
	function safeLoadAll(input, output, options) {
	    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoadAll = safeLoadAll;
	function safeLoad(input, options) {
	    return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeLoad = safeLoad;
	module.exports.loadAll = loadAll;
	module.exports.load = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad = safeLoad;


/***/ },
/* 13 */
/***/ function(module, exports) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	function isNothing(subject) {
	    return (typeof subject === 'undefined') || (null === subject);
	}
	exports.isNothing = isNothing;
	function isObject(subject) {
	    return (typeof subject === 'object') && (null !== subject);
	}
	exports.isObject = isObject;
	function toArray(sequence) {
	    if (Array.isArray(sequence)) {
	        return sequence;
	    }
	    else if (isNothing(sequence)) {
	        return [];
	    }
	    return [sequence];
	}
	exports.toArray = toArray;
	function extend(target, source) {
	    var index, length, key, sourceKeys;
	    if (source) {
	        sourceKeys = Object.keys(source);
	        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	            key = sourceKeys[index];
	            target[key] = source[key];
	        }
	    }
	    return target;
	}
	exports.extend = extend;
	function repeat(string, count) {
	    var result = '', cycle;
	    for (cycle = 0; cycle < count; cycle += 1) {
	        result += string;
	    }
	    return result;
	}
	exports.repeat = repeat;
	function isNegativeZero(number) {
	    return (0 === number) && (Number.NEGATIVE_INFINITY === 1 / number);
	}
	exports.isNegativeZero = isNegativeZero;


/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';
	var YAMLException = (function () {
	    function YAMLException(reason, mark) {
	        if (mark === void 0) { mark = null; }
	        this.name = 'YAMLException';
	        this.reason = reason;
	        this.mark = mark;
	        this.message = this.toString(false);
	    }
	    YAMLException.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = false; }
	        var result;
	        result = 'JS-YAML: ' + (this.reason || '(unknown reason)');
	        if (!compact && this.mark) {
	            result += ' ' + this.mark.toString();
	        }
	        return result;
	    };
	    return YAMLException;
	})();
	module.exports = YAMLException;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	var common = __webpack_require__(13);
	var Mark = (function () {
	    function Mark(name, buffer, position, line, column) {
	        this.name = name;
	        this.buffer = buffer;
	        this.position = position;
	        this.line = line;
	        this.column = column;
	    }
	    Mark.prototype.getSnippet = function (indent, maxLength) {
	        if (indent === void 0) { indent = 0; }
	        if (maxLength === void 0) { maxLength = 75; }
	        var head, start, tail, end, snippet;
	        if (!this.buffer) {
	            return null;
	        }
	        indent = indent || 4;
	        maxLength = maxLength || 75;
	        head = '';
	        start = this.position;
	        while (start > 0 && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
	            start -= 1;
	            if (this.position - start > (maxLength / 2 - 1)) {
	                head = ' ... ';
	                start += 5;
	                break;
	            }
	        }
	        tail = '';
	        end = this.position;
	        while (end < this.buffer.length && -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
	            end += 1;
	            if (end - this.position > (maxLength / 2 - 1)) {
	                tail = ' ... ';
	                end -= 5;
	                break;
	            }
	        }
	        snippet = this.buffer.slice(start, end);
	        return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
	    };
	    Mark.prototype.toString = function (compact) {
	        if (compact === void 0) { compact = true; }
	        var snippet, where = '';
	        if (this.name) {
	            where += 'in "' + this.name + '" ';
	        }
	        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
	        if (!compact) {
	            snippet = this.getSnippet();
	            if (snippet) {
	                where += ':\n' + snippet;
	            }
	        }
	        return where;
	    };
	    return Mark;
	})();
	module.exports = Mark;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// JS-YAML's default schema for `safeLoad` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on standard YAML's Core schema and includes most of
	// extra types described at YAML tag repository. (http://yaml.org/type/)
	'use strict';
	var Schema = __webpack_require__(17);
	var schema = new Schema({
	    include: [
	        __webpack_require__(19)
	    ],
	    implicit: [
	        __webpack_require__(29),
	        __webpack_require__(30)
	    ],
	    explicit: [
	        __webpack_require__(31),
	        __webpack_require__(33),
	        __webpack_require__(34),
	        __webpack_require__(35)
	    ]
	});
	module.exports = schema;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	/*eslint-disable max-len*/
	var common = __webpack_require__(13);
	var YAMLException = __webpack_require__(14);
	var Type = __webpack_require__(18);
	function compileList(schema, name, result) {
	    var exclude = [];
	    schema.include.forEach(function (includedSchema) {
	        result = compileList(includedSchema, name, result);
	    });
	    schema[name].forEach(function (currentType) {
	        result.forEach(function (previousType, previousIndex) {
	            if (previousType.tag === currentType.tag) {
	                exclude.push(previousIndex);
	            }
	        });
	        result.push(currentType);
	    });
	    return result.filter(function (type, index) {
	        return -1 === exclude.indexOf(index);
	    });
	}
	function compileMap() {
	    var result = {}, index, length;
	    function collectType(type) {
	        result[type.tag] = type;
	    }
	    for (index = 0, length = arguments.length; index < length; index += 1) {
	        arguments[index].forEach(collectType);
	    }
	    return result;
	}
	var Schema = (function () {
	    function Schema(definition) {
	        this.include = definition.include || [];
	        this.implicit = definition.implicit || [];
	        this.explicit = definition.explicit || [];
	        this.implicit.forEach(function (type) {
	            if (type.loadKind && 'scalar' !== type.loadKind) {
	                throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	            }
	        });
	        this.compiledImplicit = compileList(this, 'implicit', []);
	        this.compiledExplicit = compileList(this, 'explicit', []);
	        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
	    }
	    Schema.DEFAULT = null;
	    Schema.create = function createSchema() {
	        var schemas, types;
	        switch (arguments.length) {
	            case 1:
	                schemas = Schema.DEFAULT;
	                types = arguments[0];
	                break;
	            case 2:
	                schemas = arguments[0];
	                types = arguments[1];
	                break;
	            default:
	                throw new YAMLException('Wrong number of arguments for Schema.create function');
	        }
	        schemas = common.toArray(schemas);
	        types = common.toArray(types);
	        if (!schemas.every(function (schema) {
	            return schema instanceof Schema;
	        })) {
	            throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	        }
	        if (!types.every(function (type) {
	            return type instanceof Type;
	        })) {
	            throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	        }
	        return new Schema({
	            include: schemas,
	            explicit: types
	        });
	    };
	    return Schema;
	})();
	module.exports = Schema;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var YAMLException = __webpack_require__(14);
	var TYPE_CONSTRUCTOR_OPTIONS = [
	    'kind',
	    'resolve',
	    'construct',
	    'instanceOf',
	    'predicate',
	    'represent',
	    'defaultStyle',
	    'styleAliases'
	];
	var YAML_NODE_KINDS = [
	    'scalar',
	    'sequence',
	    'mapping'
	];
	function compileStyleAliases(map) {
	    var result = {};
	    if (null !== map) {
	        Object.keys(map).forEach(function (style) {
	            map[style].forEach(function (alias) {
	                result[String(alias)] = style;
	            });
	        });
	    }
	    return result;
	}
	function Type(tag, options) {
	    options = options || {};
	    Object.keys(options).forEach(function (name) {
	        if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
	            throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	        }
	    });
	    // TODO: Add tag format check.
	    this.tag = tag;
	    this.kind = options['kind'] || null;
	    this.resolve = options['resolve'] || function () {
	        return true;
	    };
	    this.construct = options['construct'] || function (data) {
	        return data;
	    };
	    this.instanceOf = options['instanceOf'] || null;
	    this.predicate = options['predicate'] || null;
	    this.represent = options['represent'] || null;
	    this.defaultStyle = options['defaultStyle'] || null;
	    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
	    if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
	        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	    }
	}
	module.exports = Type;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// Standard YAML's Core schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2804923
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, Core schema has no distinctions from JSON schema is JS-YAML.
	'use strict';
	var Schema = __webpack_require__(17);
	module.exports = new Schema({
	    include: [
	        __webpack_require__(20)
	    ]
	});
	//# sourceMappingURL=core.js.map

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// Standard YAML's JSON schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2803231
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, this schema is not such strict as defined in the YAML specification.
	// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.
	'use strict';
	var Schema = __webpack_require__(17);
	module.exports = new Schema({
	    include: [
	        __webpack_require__(21)
	    ],
	    implicit: [
	        __webpack_require__(25),
	        __webpack_require__(26),
	        __webpack_require__(27),
	        __webpack_require__(28)
	    ]
	});
	//# sourceMappingURL=json.js.map

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// Standard YAML's Failsafe schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2802346
	'use strict';
	var Schema = __webpack_require__(17);
	module.exports = new Schema({
	    explicit: [
	        __webpack_require__(22),
	        __webpack_require__(23),
	        __webpack_require__(24)
	    ]
	});
	//# sourceMappingURL=failsafe.js.map

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	module.exports = new Type('tag:yaml.org,2002:str', {
	    kind: 'scalar',
	    construct: function (data) {
	        return null !== data ? data : '';
	    }
	});
	//# sourceMappingURL=str.js.map

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	module.exports = new Type('tag:yaml.org,2002:seq', {
	    kind: 'sequence',
	    construct: function (data) {
	        return null !== data ? data : [];
	    }
	});
	//# sourceMappingURL=seq.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	module.exports = new Type('tag:yaml.org,2002:map', {
	    kind: 'mapping',
	    construct: function (data) {
	        return null !== data ? data : {};
	    }
	});
	//# sourceMappingURL=map.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	function resolveYamlNull(data) {
	    if (null === data) {
	        return true;
	    }
	    var max = data.length;
	    return (max === 1 && data === '~') || (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}
	function constructYamlNull() {
	    return null;
	}
	function isNull(object) {
	    return null === object;
	}
	module.exports = new Type('tag:yaml.org,2002:null', {
	    kind: 'scalar',
	    resolve: resolveYamlNull,
	    construct: constructYamlNull,
	    predicate: isNull,
	    represent: {
	        canonical: function () {
	            return '~';
	        },
	        lowercase: function () {
	            return 'null';
	        },
	        uppercase: function () {
	            return 'NULL';
	        },
	        camelcase: function () {
	            return 'Null';
	        }
	    },
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=null.js.map

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	function resolveYamlBoolean(data) {
	    if (null === data) {
	        return false;
	    }
	    var max = data.length;
	    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) || (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}
	function constructYamlBoolean(data) {
	    return data === 'true' || data === 'True' || data === 'TRUE';
	}
	function isBoolean(object) {
	    return '[object Boolean]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:bool', {
	    kind: 'scalar',
	    resolve: resolveYamlBoolean,
	    construct: constructYamlBoolean,
	    predicate: isBoolean,
	    represent: {
	        lowercase: function (object) {
	            return object ? 'true' : 'false';
	        },
	        uppercase: function (object) {
	            return object ? 'TRUE' : 'FALSE';
	        },
	        camelcase: function (object) {
	            return object ? 'True' : 'False';
	        }
	    },
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=bool.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var common = __webpack_require__(13);
	var Type = __webpack_require__(18);
	function isHexCode(c) {
	    return ((0x30 <= c) && (c <= 0x39)) || ((0x41 <= c) && (c <= 0x46)) || ((0x61 <= c) && (c <= 0x66));
	}
	function isOctCode(c) {
	    return ((0x30 <= c) && (c <= 0x37));
	}
	function isDecCode(c) {
	    return ((0x30 <= c) && (c <= 0x39));
	}
	function resolveYamlInteger(data) {
	    if (null === data) {
	        return false;
	    }
	    var max = data.length, index = 0, hasDigits = false, ch;
	    if (!max) {
	        return false;
	    }
	    ch = data[index];
	    // sign
	    if (ch === '-' || ch === '+') {
	        ch = data[++index];
	    }
	    if (ch === '0') {
	        // 0
	        if (index + 1 === max) {
	            return true;
	        }
	        ch = data[++index];
	        // base 2, base 8, base 16
	        if (ch === 'b') {
	            // base 2
	            index++;
	            for (; index < max; index++) {
	                ch = data[index];
	                if (ch === '_') {
	                    continue;
	                }
	                if (ch !== '0' && ch !== '1') {
	                    return false;
	                }
	                hasDigits = true;
	            }
	            return hasDigits;
	        }
	        if (ch === 'x') {
	            // base 16
	            index++;
	            for (; index < max; index++) {
	                ch = data[index];
	                if (ch === '_') {
	                    continue;
	                }
	                if (!isHexCode(data.charCodeAt(index))) {
	                    return false;
	                }
	                hasDigits = true;
	            }
	            return hasDigits;
	        }
	        for (; index < max; index++) {
	            ch = data[index];
	            if (ch === '_') {
	                continue;
	            }
	            if (!isOctCode(data.charCodeAt(index))) {
	                return false;
	            }
	            hasDigits = true;
	        }
	        return hasDigits;
	    }
	    for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') {
	            continue;
	        }
	        if (ch === ':') {
	            break;
	        }
	        if (!isDecCode(data.charCodeAt(index))) {
	            return false;
	        }
	        hasDigits = true;
	    }
	    if (!hasDigits) {
	        return false;
	    }
	    // if !base60 - done;
	    if (ch !== ':') {
	        return true;
	    }
	    // base60 almost not used, no needs to optimize
	    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}
	function constructYamlInteger(data) {
	    var value = data, sign = 1, ch, base, digits = [];
	    if (value.indexOf('_') !== -1) {
	        value = value.replace(/_/g, '');
	    }
	    ch = value[0];
	    if (ch === '-' || ch === '+') {
	        if (ch === '-') {
	            sign = -1;
	        }
	        value = value.slice(1);
	        ch = value[0];
	    }
	    if ('0' === value) {
	        return 0;
	    }
	    if (ch === '0') {
	        if (value[1] === 'b') {
	            return sign * parseInt(value.slice(2), 2);
	        }
	        if (value[1] === 'x') {
	            return sign * parseInt(value, 16);
	        }
	        return sign * parseInt(value, 8);
	    }
	    if (value.indexOf(':') !== -1) {
	        value.split(':').forEach(function (v) {
	            digits.unshift(parseInt(v, 10));
	        });
	        value = 0;
	        base = 1;
	        digits.forEach(function (d) {
	            value += (d * base);
	            base *= 60;
	        });
	        return sign * value;
	    }
	    return sign * parseInt(value, 10);
	}
	function isInteger(object) {
	    return ('[object Number]' === Object.prototype.toString.call(object)) && (0 === object % 1 && !common.isNegativeZero(object));
	}
	module.exports = new Type('tag:yaml.org,2002:int', {
	    kind: 'scalar',
	    resolve: resolveYamlInteger,
	    construct: constructYamlInteger,
	    predicate: isInteger,
	    represent: {
	        binary: function (object) {
	            return '0b' + object.toString(2);
	        },
	        octal: function (object) {
	            return '0' + object.toString(8);
	        },
	        decimal: function (object) {
	            return object.toString(10);
	        },
	        hexadecimal: function (object) {
	            return '0x' + object.toString(16).toUpperCase();
	        }
	    },
	    defaultStyle: 'decimal',
	    styleAliases: {
	        binary: [2, 'bin'],
	        octal: [8, 'oct'],
	        decimal: [10, 'dec'],
	        hexadecimal: [16, 'hex']
	    }
	});
	//# sourceMappingURL=int.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var common = __webpack_require__(13);
	var Type = __webpack_require__(18);
	var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' + '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' + '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + '|[-+]?\\.(?:inf|Inf|INF)' + '|\\.(?:nan|NaN|NAN))$');
	function resolveYamlFloat(data) {
	    if (null === data) {
	        return false;
	    }
	    var value, sign, base, digits;
	    if (!YAML_FLOAT_PATTERN.test(data)) {
	        return false;
	    }
	    return true;
	}
	function constructYamlFloat(data) {
	    var value, sign, base, digits;
	    value = data.replace(/_/g, '').toLowerCase();
	    sign = '-' === value[0] ? -1 : 1;
	    digits = [];
	    if (0 <= '+-'.indexOf(value[0])) {
	        value = value.slice(1);
	    }
	    if ('.inf' === value) {
	        return (1 === sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
	    }
	    else if ('.nan' === value) {
	        return NaN;
	    }
	    else if (0 <= value.indexOf(':')) {
	        value.split(':').forEach(function (v) {
	            digits.unshift(parseFloat(v, 10));
	        });
	        value = 0.0;
	        base = 1;
	        digits.forEach(function (d) {
	            value += d * base;
	            base *= 60;
	        });
	        return sign * value;
	    }
	    return sign * parseFloat(value, 10);
	}
	function representYamlFloat(object, style) {
	    if (isNaN(object)) {
	        switch (style) {
	            case 'lowercase':
	                return '.nan';
	            case 'uppercase':
	                return '.NAN';
	            case 'camelcase':
	                return '.NaN';
	        }
	    }
	    else if (Number.POSITIVE_INFINITY === object) {
	        switch (style) {
	            case 'lowercase':
	                return '.inf';
	            case 'uppercase':
	                return '.INF';
	            case 'camelcase':
	                return '.Inf';
	        }
	    }
	    else if (Number.NEGATIVE_INFINITY === object) {
	        switch (style) {
	            case 'lowercase':
	                return '-.inf';
	            case 'uppercase':
	                return '-.INF';
	            case 'camelcase':
	                return '-.Inf';
	        }
	    }
	    else if (common.isNegativeZero(object)) {
	        return '-0.0';
	    }
	    return object.toString(10);
	}
	function isFloat(object) {
	    return ('[object Number]' === Object.prototype.toString.call(object)) && (0 !== object % 1 || common.isNegativeZero(object));
	}
	module.exports = new Type('tag:yaml.org,2002:float', {
	    kind: 'scalar',
	    resolve: resolveYamlFloat,
	    construct: constructYamlFloat,
	    predicate: isFloat,
	    represent: representYamlFloat,
	    defaultStyle: 'lowercase'
	});
	//# sourceMappingURL=float.js.map

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + '-([0-9][0-9]?)' + '-([0-9][0-9]?)' + '(?:(?:[Tt]|[ \\t]+)' + '([0-9][0-9]?)' + ':([0-9][0-9])' + ':([0-9][0-9])' + '(?:\\.([0-9]*))?' + '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + '(?::([0-9][0-9]))?))?)?$'); // [11] tz_minute
	function resolveYamlTimestamp(data) {
	    if (null === data) {
	        return false;
	    }
	    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
	    match = YAML_TIMESTAMP_REGEXP.exec(data);
	    if (null === match) {
	        return false;
	    }
	    return true;
	}
	function constructYamlTimestamp(data) {
	    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
	    match = YAML_TIMESTAMP_REGEXP.exec(data);
	    if (null === match) {
	        throw new Error('Date resolve error');
	    }
	    // match: [1] year [2] month [3] day
	    year = +(match[1]);
	    month = +(match[2]) - 1; // JS month starts with 0
	    day = +(match[3]);
	    if (!match[4]) {
	        return new Date(Date.UTC(year, month, day));
	    }
	    // match: [4] hour [5] minute [6] second [7] fraction
	    hour = +(match[4]);
	    minute = +(match[5]);
	    second = +(match[6]);
	    if (match[7]) {
	        fraction = match[7].slice(0, 3);
	        while (fraction.length < 3) {
	            fraction = fraction + '0';
	        }
	        fraction = +fraction;
	    }
	    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
	    if (match[9]) {
	        tz_hour = +(match[10]);
	        tz_minute = +(match[11] || 0);
	        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	        if ('-' === match[9]) {
	            delta = -delta;
	        }
	    }
	    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
	    if (delta) {
	        date.setTime(date.getTime() - delta);
	    }
	    return date;
	}
	function representYamlTimestamp(object /*, style*/) {
	    return object.toISOString();
	}
	module.exports = new Type('tag:yaml.org,2002:timestamp', {
	    kind: 'scalar',
	    resolve: resolveYamlTimestamp,
	    construct: constructYamlTimestamp,
	    instanceOf: Date,
	    represent: representYamlTimestamp
	});
	//# sourceMappingURL=timestamp.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	function resolveYamlMerge(data) {
	    return '<<' === data || null === data;
	}
	module.exports = new Type('tag:yaml.org,2002:merge', {
	    kind: 'scalar',
	    resolve: resolveYamlMerge
	});
	//# sourceMappingURL=merge.js.map

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	/*eslint-disable no-bitwise*/
	// A trick for browserified version.
	// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined
	var NodeBuffer = __webpack_require__(32).Buffer;
	var Type = __webpack_require__(18);
	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
	function resolveYamlBinary(data) {
	    if (null === data) {
	        return false;
	    }
	    var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
	    for (idx = 0; idx < max; idx++) {
	        code = map.indexOf(data.charAt(idx));
	        // Skip CR/LF
	        if (code > 64) {
	            continue;
	        }
	        // Fail on illegal characters
	        if (code < 0) {
	            return false;
	        }
	        bitlen += 6;
	    }
	    // If there are any bits left, source was corrupted
	    return (bitlen % 8) === 0;
	}
	function constructYamlBinary(data) {
	    var code, idx, tailbits, input = data.replace(/[\r\n=]/g, ''), max = input.length, map = BASE64_MAP, bits = 0, result = [];
	    for (idx = 0; idx < max; idx++) {
	        if ((idx % 4 === 0) && idx) {
	            result.push((bits >> 16) & 0xFF);
	            result.push((bits >> 8) & 0xFF);
	            result.push(bits & 0xFF);
	        }
	        bits = (bits << 6) | map.indexOf(input.charAt(idx));
	    }
	    // Dump tail
	    tailbits = (max % 4) * 6;
	    if (tailbits === 0) {
	        result.push((bits >> 16) & 0xFF);
	        result.push((bits >> 8) & 0xFF);
	        result.push(bits & 0xFF);
	    }
	    else if (tailbits === 18) {
	        result.push((bits >> 10) & 0xFF);
	        result.push((bits >> 2) & 0xFF);
	    }
	    else if (tailbits === 12) {
	        result.push((bits >> 4) & 0xFF);
	    }
	    // Wrap into Buffer for NodeJS and leave Array for browser
	    if (NodeBuffer) {
	        return new NodeBuffer(result);
	    }
	    return result;
	}
	function representYamlBinary(object /*, style*/) {
	    var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
	    for (idx = 0; idx < max; idx++) {
	        if ((idx % 3 === 0) && idx) {
	            result += map[(bits >> 18) & 0x3F];
	            result += map[(bits >> 12) & 0x3F];
	            result += map[(bits >> 6) & 0x3F];
	            result += map[bits & 0x3F];
	        }
	        bits = (bits << 8) + object[idx];
	    }
	    // Dump tail
	    tail = max % 3;
	    if (tail === 0) {
	        result += map[(bits >> 18) & 0x3F];
	        result += map[(bits >> 12) & 0x3F];
	        result += map[(bits >> 6) & 0x3F];
	        result += map[bits & 0x3F];
	    }
	    else if (tail === 2) {
	        result += map[(bits >> 10) & 0x3F];
	        result += map[(bits >> 4) & 0x3F];
	        result += map[(bits << 2) & 0x3F];
	        result += map[64];
	    }
	    else if (tail === 1) {
	        result += map[(bits >> 2) & 0x3F];
	        result += map[(bits << 4) & 0x3F];
	        result += map[64];
	        result += map[64];
	    }
	    return result;
	}
	function isBinary(object) {
	    return NodeBuffer && NodeBuffer.isBuffer(object);
	}
	module.exports = new Type('tag:yaml.org,2002:binary', {
	    kind: 'scalar',
	    resolve: resolveYamlBinary,
	    construct: constructYamlBinary,
	    predicate: isBinary,
	    represent: representYamlBinary
	});
	//# sourceMappingURL=binary.js.map

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = require("buffer");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString = Object.prototype.toString;
	function resolveYamlOmap(data) {
	    if (null === data) {
	        return true;
	    }
	    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        pairHasKey = false;
	        if ('[object Object]' !== _toString.call(pair)) {
	            return false;
	        }
	        for (pairKey in pair) {
	            if (_hasOwnProperty.call(pair, pairKey)) {
	                if (!pairHasKey) {
	                    pairHasKey = true;
	                }
	                else {
	                    return false;
	                }
	            }
	        }
	        if (!pairHasKey) {
	            return false;
	        }
	        if (-1 === objectKeys.indexOf(pairKey)) {
	            objectKeys.push(pairKey);
	        }
	        else {
	            return false;
	        }
	    }
	    return true;
	}
	function constructYamlOmap(data) {
	    return null !== data ? data : [];
	}
	module.exports = new Type('tag:yaml.org,2002:omap', {
	    kind: 'sequence',
	    resolve: resolveYamlOmap,
	    construct: constructYamlOmap
	});
	//# sourceMappingURL=omap.js.map

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	var _toString = Object.prototype.toString;
	function resolveYamlPairs(data) {
	    if (null === data) {
	        return true;
	    }
	    var index, length, pair, keys, result, object = data;
	    result = new Array(object.length);
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        if ('[object Object]' !== _toString.call(pair)) {
	            return false;
	        }
	        keys = Object.keys(pair);
	        if (1 !== keys.length) {
	            return false;
	        }
	        result[index] = [keys[0], pair[keys[0]]];
	    }
	    return true;
	}
	function constructYamlPairs(data) {
	    if (null === data) {
	        return [];
	    }
	    var index, length, pair, keys, result, object = data;
	    result = new Array(object.length);
	    for (index = 0, length = object.length; index < length; index += 1) {
	        pair = object[index];
	        keys = Object.keys(pair);
	        result[index] = [keys[0], pair[keys[0]]];
	    }
	    return result;
	}
	module.exports = new Type('tag:yaml.org,2002:pairs', {
	    kind: 'sequence',
	    resolve: resolveYamlPairs,
	    construct: constructYamlPairs
	});
	//# sourceMappingURL=pairs.js.map

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	function resolveYamlSet(data) {
	    if (null === data) {
	        return true;
	    }
	    var key, object = data;
	    for (key in object) {
	        if (_hasOwnProperty.call(object, key)) {
	            if (null !== object[key]) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	function constructYamlSet(data) {
	    return null !== data ? data : {};
	}
	module.exports = new Type('tag:yaml.org,2002:set', {
	    kind: 'mapping',
	    resolve: resolveYamlSet,
	    construct: constructYamlSet
	});
	//# sourceMappingURL=set.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/tsd.d.ts" />
	// JS-YAML's default schema for `load` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on JS-YAML's default safe schema and includes
	// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
	//
	// Also this schema is used as default base schema at `Schema.create` function.
	'use strict';
	var Schema = __webpack_require__(17);
	var schema = new Schema({
	    include: [
	        __webpack_require__(16)
	    ],
	    explicit: [
	        __webpack_require__(37),
	        __webpack_require__(38),
	        __webpack_require__(39)
	    ]
	});
	Schema.DEFAULT = schema;
	module.exports = schema;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	function resolveJavascriptUndefined() {
	    return true;
	}
	function constructJavascriptUndefined() {
	    /*eslint-disable no-undefined*/
	    return undefined;
	}
	function representJavascriptUndefined() {
	    return '';
	}
	function isUndefined(object) {
	    return 'undefined' === typeof object;
	}
	module.exports = new Type('tag:yaml.org,2002:js/undefined', {
	    kind: 'scalar',
	    resolve: resolveJavascriptUndefined,
	    construct: constructJavascriptUndefined,
	    predicate: isUndefined,
	    represent: representJavascriptUndefined
	});
	//# sourceMappingURL=undefined.js.map

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../../typings/tsd.d.ts" />
	'use strict';
	var Type = __webpack_require__(18);
	function resolveJavascriptRegExp(data) {
	    if (null === data) {
	        return false;
	    }
	    if (0 === data.length) {
	        return false;
	    }
	    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
	    // if regexp starts with '/' it can have modifiers and must be properly closed
	    // `/foo/gim` - modifiers tail can be maximum 3 chars
	    if ('/' === regexp[0]) {
	        if (tail) {
	            modifiers = tail[1];
	        }
	        if (modifiers.length > 3) {
	            return false;
	        }
	        // if expression starts with /, is should be properly terminated
	        if (regexp[regexp.length - modifiers.length - 1] !== '/') {
	            return false;
	        }
	        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	    }
	    try {
	        var dummy = new RegExp(regexp, modifiers);
	        return true;
	    }
	    catch (error) {
	        return false;
	    }
	}
	function constructJavascriptRegExp(data) {
	    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
	    // `/foo/gim` - tail can be maximum 4 chars
	    if ('/' === regexp[0]) {
	        if (tail) {
	            modifiers = tail[1];
	        }
	        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	    }
	    return new RegExp(regexp, modifiers);
	}
	function representJavascriptRegExp(object /*, style*/) {
	    var result = '/' + object.source + '/';
	    if (object.global) {
	        result += 'g';
	    }
	    if (object.multiline) {
	        result += 'm';
	    }
	    if (object.ignoreCase) {
	        result += 'i';
	    }
	    return result;
	}
	function isRegExp(object) {
	    return '[object RegExp]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:js/regexp', {
	    kind: 'scalar',
	    resolve: resolveJavascriptRegExp,
	    construct: constructJavascriptRegExp,
	    predicate: isRegExp,
	    represent: representJavascriptRegExp
	});
	//# sourceMappingURL=regexp.js.map

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../../typings/tsd.d.ts" />
	'use strict';
	var esprima = __webpack_require__(40);
	// Browserified version does not have esprima
	//
	// 1. For node.js just require module as deps
	// 2. For browser try to require mudule via external AMD system.
	//    If not found - try to fallback to window.esprima. If not
	//    found too - then fail to parse.
	//
	var Type = __webpack_require__(18);
	function resolveJavascriptFunction(data) {
	    if (null === data) {
	        return false;
	    }
	    try {
	        var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
	        if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0]['expression'].type) {
	            return false;
	        }
	        return true;
	    }
	    catch (err) {
	        return false;
	    }
	}
	function constructJavascriptFunction(data) {
	    /*jslint evil:true*/
	    var source = '(' + data + ')', ast = esprima.parse(source, { range: true }), params = [], body;
	    if ('Program' !== ast.type || 1 !== ast.body.length || 'ExpressionStatement' !== ast.body[0].type || 'FunctionExpression' !== ast.body[0]['expression'].type) {
	        throw new Error('Failed to resolve function');
	    }
	    ast.body[0]['expression'].params.forEach(function (param) {
	        params.push(param.name);
	    });
	    body = ast.body[0]['expression'].body.range;
	    // Esprima's ranges include the first '{' and the last '}' characters on
	    // function expressions. So cut them out.
	    /*eslint-disable no-new-func*/
	    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
	}
	function representJavascriptFunction(object /*, style*/) {
	    return object.toString();
	}
	function isFunction(object) {
	    return '[object Function]' === Object.prototype.toString.call(object);
	}
	module.exports = new Type('tag:yaml.org,2002:js/function', {
	    kind: 'scalar',
	    resolve: resolveJavascriptFunction,
	    construct: constructJavascriptFunction,
	    predicate: isFunction,
	    represent: representJavascriptFunction
	});
	//# sourceMappingURL=function.js.map

/***/ },
/* 40 */
/***/ function(module, exports) {

	module.exports = require("esprima");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../typings/tsd.d.ts" />
	'use strict';
	/*eslint-disable no-use-before-define*/
	var common = __webpack_require__(13);
	var YAMLException = __webpack_require__(14);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(36);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(16);
	var _toString = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var CHAR_TAB = 0x09; /* Tab */
	var CHAR_LINE_FEED = 0x0A; /* LF */
	var CHAR_CARRIAGE_RETURN = 0x0D; /* CR */
	var CHAR_SPACE = 0x20; /* Space */
	var CHAR_EXCLAMATION = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE = 0x22; /* " */
	var CHAR_SHARP = 0x23; /* # */
	var CHAR_PERCENT = 0x25; /* % */
	var CHAR_AMPERSAND = 0x26; /* & */
	var CHAR_SINGLE_QUOTE = 0x27; /* ' */
	var CHAR_ASTERISK = 0x2A; /* * */
	var CHAR_COMMA = 0x2C; /* , */
	var CHAR_MINUS = 0x2D; /* - */
	var CHAR_COLON = 0x3A; /* : */
	var CHAR_GREATER_THAN = 0x3E; /* > */
	var CHAR_QUESTION = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */
	var CHAR_VERTICAL_LINE = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */
	var ESCAPE_SEQUENCES = {};
	ESCAPE_SEQUENCES[0x00] = '\\0';
	ESCAPE_SEQUENCES[0x07] = '\\a';
	ESCAPE_SEQUENCES[0x08] = '\\b';
	ESCAPE_SEQUENCES[0x09] = '\\t';
	ESCAPE_SEQUENCES[0x0A] = '\\n';
	ESCAPE_SEQUENCES[0x0B] = '\\v';
	ESCAPE_SEQUENCES[0x0C] = '\\f';
	ESCAPE_SEQUENCES[0x0D] = '\\r';
	ESCAPE_SEQUENCES[0x1B] = '\\e';
	ESCAPE_SEQUENCES[0x22] = '\\"';
	ESCAPE_SEQUENCES[0x5C] = '\\\\';
	ESCAPE_SEQUENCES[0x85] = '\\N';
	ESCAPE_SEQUENCES[0xA0] = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';
	var DEPRECATED_BOOLEANS_SYNTAX = [
	    'y',
	    'Y',
	    'yes',
	    'Yes',
	    'YES',
	    'on',
	    'On',
	    'ON',
	    'n',
	    'N',
	    'no',
	    'No',
	    'NO',
	    'off',
	    'Off',
	    'OFF'
	];
	function compileStyleMap(schema, map) {
	    var result, keys, index, length, tag, style, type;
	    if (null === map) {
	        return {};
	    }
	    result = {};
	    keys = Object.keys(map);
	    for (index = 0, length = keys.length; index < length; index += 1) {
	        tag = keys[index];
	        style = String(map[tag]);
	        if ('!!' === tag.slice(0, 2)) {
	            tag = 'tag:yaml.org,2002:' + tag.slice(2);
	        }
	        type = schema.compiledTypeMap[tag];
	        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	            style = type.styleAliases[style];
	        }
	        result[tag] = style;
	    }
	    return result;
	}
	function encodeHex(character) {
	    var string, handle, length;
	    string = character.toString(16).toUpperCase();
	    if (character <= 0xFF) {
	        handle = 'x';
	        length = 2;
	    }
	    else if (character <= 0xFFFF) {
	        handle = 'u';
	        length = 4;
	    }
	    else if (character <= 0xFFFFFFFF) {
	        handle = 'U';
	        length = 8;
	    }
	    else {
	        throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	    }
	    return '\\' + handle + common.repeat('0', length - string.length) + string;
	}
	function State(options) {
	    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
	    this.indent = Math.max(1, (options['indent'] || 2));
	    this.skipInvalid = options['skipInvalid'] || false;
	    this.flowLevel = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
	    this.implicitTypes = this.schema.compiledImplicit;
	    this.explicitTypes = this.schema.compiledExplicit;
	    this.tag = null;
	    this.result = '';
	    this.duplicates = [];
	    this.usedDuplicates = null;
	}
	function indentString(string, spaces) {
	    var ind = common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
	    while (position < length) {
	        next = string.indexOf('\n', position);
	        if (next === -1) {
	            line = string.slice(position);
	            position = length;
	        }
	        else {
	            line = string.slice(position, next + 1);
	            position = next + 1;
	        }
	        if (line.length && line !== '\n') {
	            result += ind;
	        }
	        result += line;
	    }
	    return result;
	}
	function generateNextLine(state, level) {
	    return '\n' + common.repeat(' ', state.indent * level);
	}
	function testImplicitResolving(state, str) {
	    var index, length, type;
	    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	        type = state.implicitTypes[index];
	        if (type.resolve(str)) {
	            return true;
	        }
	    }
	    return false;
	}
	function StringBuilder(source) {
	    this.source = source;
	    this.result = '';
	    this.checkpoint = 0;
	}
	StringBuilder.prototype.takeUpTo = function (position) {
	    var er;
	    if (position < this.checkpoint) {
	        er = new Error('position should be > checkpoint');
	        er.position = position;
	        er.checkpoint = this.checkpoint;
	        throw er;
	    }
	    this.result += this.source.slice(this.checkpoint, position);
	    this.checkpoint = position;
	    return this;
	};
	StringBuilder.prototype.escapeChar = function () {
	    var character, esc;
	    character = this.source.charCodeAt(this.checkpoint);
	    esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
	    this.result += esc;
	    this.checkpoint += 1;
	    return this;
	};
	StringBuilder.prototype.finish = function () {
	    if (this.source.length > this.checkpoint) {
	        this.takeUpTo(this.source.length);
	    }
	};
	function writeScalar(state, object, level) {
	    var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;
	    if (0 === object.length) {
	        state.dump = "''";
	        return;
	    }
	    if (object.indexOf("!include") == 0) {
	        state.dump = "" + object; //FIXME
	        return;
	    }
	    if (object.indexOf("!$$$novalue") == 0) {
	        state.dump = ""; //FIXME
	        return;
	    }
	    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
	        state.dump = "'" + object + "'";
	        return;
	    }
	    simple = true;
	    first = object.length ? object.charCodeAt(0) : 0;
	    spaceWrap = (CHAR_SPACE === first || CHAR_SPACE === object.charCodeAt(object.length - 1));
	    // Simplified check for restricted first characters
	    // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
	    if (CHAR_MINUS === first || CHAR_QUESTION === first || CHAR_COMMERCIAL_AT === first || CHAR_GRAVE_ACCENT === first) {
	        simple = false;
	    }
	    // can only use > and | if not wrapped in spaces.
	    if (spaceWrap) {
	        simple = false;
	        folded = false;
	        literal = false;
	    }
	    else {
	        folded = true;
	        literal = true;
	    }
	    single = true;
	    double = new StringBuilder(object);
	    sawLineFeed = false;
	    linePosition = 0;
	    longestLine = 0;
	    indent = state.indent * level;
	    max = 80;
	    if (indent < 40) {
	        max -= indent;
	    }
	    else {
	        max = 40;
	    }
	    for (position = 0; position < object.length; position++) {
	        character = object.charCodeAt(position);
	        if (simple) {
	            // Characters that can never appear in the simple scalar
	            if (!simpleChar(character)) {
	                simple = false;
	            }
	            else {
	                continue;
	            }
	        }
	        if (single && character === CHAR_SINGLE_QUOTE) {
	            single = false;
	        }
	        escapeSeq = ESCAPE_SEQUENCES[character];
	        hexEsc = needsHexEscape(character);
	        if (!escapeSeq && !hexEsc) {
	            continue;
	        }
	        if (character !== CHAR_LINE_FEED && character !== CHAR_DOUBLE_QUOTE && character !== CHAR_SINGLE_QUOTE) {
	            folded = false;
	            literal = false;
	        }
	        else if (character === CHAR_LINE_FEED) {
	            sawLineFeed = true;
	            single = false;
	            if (position > 0) {
	                previous = object.charCodeAt(position - 1);
	                if (previous === CHAR_SPACE) {
	                    literal = false;
	                    folded = false;
	                }
	            }
	            if (folded) {
	                lineLength = position - linePosition;
	                linePosition = position;
	                if (lineLength > longestLine) {
	                    longestLine = lineLength;
	                }
	            }
	        }
	        if (character !== CHAR_DOUBLE_QUOTE) {
	            single = false;
	        }
	        double.takeUpTo(position);
	        double.escapeChar();
	    }
	    if (simple && testImplicitResolving(state, object)) {
	        simple = false;
	    }
	    modifier = '';
	    if (folded || literal) {
	        trailingLineBreaks = 0;
	        if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
	            trailingLineBreaks += 1;
	            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
	                trailingLineBreaks += 1;
	            }
	        }
	        if (trailingLineBreaks === 0) {
	            modifier = '-';
	        }
	        else if (trailingLineBreaks === 2) {
	            modifier = '+';
	        }
	    }
	    if (literal && longestLine < max) {
	        folded = false;
	    }
	    // If it's literally one line, then don't bother with the literal.
	    // We may still want to do a fold, though, if it's a super long line.
	    if (!sawLineFeed) {
	        literal = false;
	    }
	    if (simple) {
	        state.dump = object;
	    }
	    else if (single) {
	        state.dump = '\'' + object + '\'';
	    }
	    else if (folded) {
	        result = fold(object, max);
	        state.dump = '>' + modifier + '\n' + indentString(result, indent);
	    }
	    else if (literal) {
	        if (!modifier) {
	            object = object.replace(/\n$/, '');
	        }
	        state.dump = '|' + modifier + '\n' + indentString(object, indent);
	    }
	    else if (double) {
	        double.finish();
	        state.dump = '"' + double.result + '"';
	    }
	    else {
	        throw new Error('Failed to dump scalar value');
	    }
	    return;
	}
	// The `trailing` var is a regexp match of any trailing `\n` characters.
	//
	// There are three cases we care about:
	//
	// 1. One trailing `\n` on the string.  Just use `|` or `>`.
	//    This is the assumed default. (trailing = null)
	// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
	// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
	//
	// In the case of `>+`, these line breaks are *not* doubled (like the line
	// breaks within the string), so it's important to only end with the exact
	// same number as we started.
	function fold(object, max) {
	    var result = '', position = 0, length = object.length, trailing = /\n+$/.exec(object), newLine;
	    if (trailing) {
	        length = trailing.index + 1;
	    }
	    while (position < length) {
	        newLine = object.indexOf('\n', position);
	        if (newLine > length || newLine === -1) {
	            if (result) {
	                result += '\n\n';
	            }
	            result += foldLine(object.slice(position, length), max);
	            position = length;
	        }
	        else {
	            if (result) {
	                result += '\n\n';
	            }
	            result += foldLine(object.slice(position, newLine), max);
	            position = newLine + 1;
	        }
	    }
	    if (trailing && trailing[0] !== '\n') {
	        result += trailing[0];
	    }
	    return result;
	}
	function foldLine(line, max) {
	    if (line === '') {
	        return line;
	    }
	    var foldRe = /[^\s] [^\s]/g, result = '', prevMatch = 0, foldStart = 0, match = foldRe.exec(line), index, foldEnd, folded;
	    while (match) {
	        index = match.index;
	        // when we cross the max len, if the previous match would've
	        // been ok, use that one, and carry on.  If there was no previous
	        // match on this fold section, then just have a long line.
	        if (index - foldStart > max) {
	            if (prevMatch !== foldStart) {
	                foldEnd = prevMatch;
	            }
	            else {
	                foldEnd = index;
	            }
	            if (result) {
	                result += '\n';
	            }
	            folded = line.slice(foldStart, foldEnd);
	            result += folded;
	            foldStart = foldEnd + 1;
	        }
	        prevMatch = index + 1;
	        match = foldRe.exec(line);
	    }
	    if (result) {
	        result += '\n';
	    }
	    // if we end up with one last word at the end, then the last bit might
	    // be slightly bigger than we wanted, because we exited out of the loop.
	    if (foldStart !== prevMatch && line.length - foldStart > max) {
	        result += line.slice(foldStart, prevMatch) + '\n' + line.slice(prevMatch + 1);
	    }
	    else {
	        result += line.slice(foldStart);
	    }
	    return result;
	}
	// Returns true if character can be found in a simple scalar
	function simpleChar(character) {
	    return CHAR_TAB !== character && CHAR_LINE_FEED !== character && CHAR_CARRIAGE_RETURN !== character && CHAR_COMMA !== character && CHAR_LEFT_SQUARE_BRACKET !== character && CHAR_RIGHT_SQUARE_BRACKET !== character && CHAR_LEFT_CURLY_BRACKET !== character && CHAR_RIGHT_CURLY_BRACKET !== character && CHAR_SHARP !== character && CHAR_AMPERSAND !== character && CHAR_ASTERISK !== character && CHAR_EXCLAMATION !== character && CHAR_VERTICAL_LINE !== character && CHAR_GREATER_THAN !== character && CHAR_SINGLE_QUOTE !== character && CHAR_DOUBLE_QUOTE !== character && CHAR_PERCENT !== character && CHAR_COLON !== character && !ESCAPE_SEQUENCES[character] && !needsHexEscape(character);
	}
	// Returns true if the character code needs to be escaped.
	function needsHexEscape(character) {
	    return !((0x00020 <= character && character <= 0x00007E) || (0x00085 === character) || (0x000A0 <= character && character <= 0x00D7FF) || (0x0E000 <= character && character <= 0x00FFFD) || (0x10000 <= character && character <= 0x10FFFF));
	}
	function writeFlowSequence(state, level, object) {
	    var _result = '', _tag = state.tag, index, length;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        // Write only valid elements.
	        if (writeNode(state, level, object[index], false, false)) {
	            if (0 !== index) {
	                _result += ', ';
	            }
	            _result += state.dump;
	        }
	    }
	    state.tag = _tag;
	    state.dump = '[' + _result + ']';
	}
	function writeBlockSequence(state, level, object, compact) {
	    var _result = '', _tag = state.tag, index, length;
	    for (index = 0, length = object.length; index < length; index += 1) {
	        // Write only valid elements.
	        if (writeNode(state, level + 1, object[index], true, true)) {
	            if (!compact || 0 !== index) {
	                _result += generateNextLine(state, level);
	            }
	            _result += '- ' + state.dump;
	        }
	    }
	    state.tag = _tag;
	    state.dump = _result || '[]'; // Empty sequence if no valid values.
	}
	function writeFlowMapping(state, level, object) {
	    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
	    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	        pairBuffer = '';
	        if (0 !== index) {
	            pairBuffer += ', ';
	        }
	        objectKey = objectKeyList[index];
	        objectValue = object[objectKey];
	        if (!writeNode(state, level, objectKey, false, false)) {
	            continue;
	        }
	        if (state.dump.length > 1024) {
	            pairBuffer += '? ';
	        }
	        pairBuffer += state.dump + ': ';
	        if (!writeNode(state, level, objectValue, false, false)) {
	            continue;
	        }
	        pairBuffer += state.dump;
	        // Both key and value are valid.
	        _result += pairBuffer;
	    }
	    state.tag = _tag;
	    state.dump = '{' + _result + '}';
	}
	function writeBlockMapping(state, level, object, compact) {
	    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
	    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	        pairBuffer = '';
	        if (!compact || 0 !== index) {
	            pairBuffer += generateNextLine(state, level);
	        }
	        objectKey = objectKeyList[index];
	        objectValue = object[objectKey];
	        if (!writeNode(state, level + 1, objectKey, true, true)) {
	            continue;
	        }
	        explicitPair = (null !== state.tag && '?' !== state.tag) || (state.dump && state.dump.length > 1024);
	        if (explicitPair) {
	            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	                pairBuffer += '?';
	            }
	            else {
	                pairBuffer += '? ';
	            }
	        }
	        pairBuffer += state.dump;
	        if (explicitPair) {
	            pairBuffer += generateNextLine(state, level);
	        }
	        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	            continue;
	        }
	        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	            pairBuffer += ':';
	        }
	        else {
	            pairBuffer += ': ';
	        }
	        pairBuffer += state.dump;
	        // Both key and value are valid.
	        _result += pairBuffer;
	    }
	    state.tag = _tag;
	    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}
	function detectType(state, object, explicit) {
	    var _result, typeList, index, length, type, style;
	    typeList = explicit ? state.explicitTypes : state.implicitTypes;
	    for (index = 0, length = typeList.length; index < length; index += 1) {
	        type = typeList[index];
	        if ((type.instanceOf || type.predicate) && (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) && (!type.predicate || type.predicate(object))) {
	            state.tag = explicit ? type.tag : '?';
	            if (type.represent) {
	                style = state.styleMap[type.tag] || type.defaultStyle;
	                if ('[object Function]' === _toString.call(type.represent)) {
	                    _result = type.represent(object, style);
	                }
	                else if (_hasOwnProperty.call(type.represent, style)) {
	                    _result = type.represent[style](object, style);
	                }
	                else {
	                    throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	                }
	                state.dump = _result;
	            }
	            return true;
	        }
	    }
	    return false;
	}
	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact) {
	    state.tag = null;
	    state.dump = object;
	    if (!detectType(state, object, false)) {
	        detectType(state, object, true);
	    }
	    var type = _toString.call(state.dump);
	    if (block) {
	        block = (0 > state.flowLevel || state.flowLevel > level);
	    }
	    if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {
	        compact = false;
	    }
	    var objectOrArray = '[object Object]' === type || '[object Array]' === type, duplicateIndex, duplicate;
	    if (objectOrArray) {
	        duplicateIndex = state.duplicates.indexOf(object);
	        duplicate = duplicateIndex !== -1;
	    }
	    if (duplicate && state.usedDuplicates[duplicateIndex]) {
	        state.dump = '*ref_' + duplicateIndex;
	    }
	    else {
	        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	            state.usedDuplicates[duplicateIndex] = true;
	        }
	        if ('[object Object]' === type) {
	            if (block && (0 !== Object.keys(state.dump).length)) {
	                writeBlockMapping(state, level, state.dump, compact);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
	                }
	            }
	            else {
	                writeFlowMapping(state, level, state.dump);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	                }
	            }
	        }
	        else if ('[object Array]' === type) {
	            if (block && (0 !== state.dump.length)) {
	                writeBlockSequence(state, level, state.dump, compact);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
	                }
	            }
	            else {
	                writeFlowSequence(state, level, state.dump);
	                if (duplicate) {
	                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	                }
	            }
	        }
	        else if ('[object String]' === type) {
	            if ('?' !== state.tag) {
	                writeScalar(state, state.dump, level);
	            }
	        }
	        else {
	            if (state.skipInvalid) {
	                return false;
	            }
	            throw new YAMLException('unacceptable kind of an object to dump ' + type);
	        }
	        if (null !== state.tag && '?' !== state.tag) {
	            state.dump = '!<' + state.tag + '> ' + state.dump;
	        }
	    }
	    return true;
	}
	function getDuplicateReferences(object, state) {
	    var objects = [], duplicatesIndexes = [], index, length;
	    inspectNode(object, objects, duplicatesIndexes);
	    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	        state.duplicates.push(objects[duplicatesIndexes[index]]);
	    }
	    state.usedDuplicates = new Array(length);
	}
	function inspectNode(object, objects, duplicatesIndexes) {
	    var type = _toString.call(object), objectKeyList, index, length;
	    if (null !== object && 'object' === typeof object) {
	        index = objects.indexOf(object);
	        if (-1 !== index) {
	            if (-1 === duplicatesIndexes.indexOf(index)) {
	                duplicatesIndexes.push(index);
	            }
	        }
	        else {
	            objects.push(object);
	            if (Array.isArray(object)) {
	                for (index = 0, length = object.length; index < length; index += 1) {
	                    inspectNode(object[index], objects, duplicatesIndexes);
	                }
	            }
	            else {
	                objectKeyList = Object.keys(object);
	                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	                }
	            }
	        }
	    }
	}
	function dump(input, options) {
	    options = options || {};
	    var state = new State(options);
	    getDuplicateReferences(input, state);
	    if (writeNode(state, 0, input, true, true)) {
	        return state.dump + '\n';
	    }
	    return '';
	}
	exports.dump = dump;
	function safeDump(input, options) {
	    return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}
	exports.safeDump = safeDump;


/***/ },
/* 42 */
/***/ function(module, exports) {

	/// <reference path="../../typings/tsd.d.ts" />
	function isMultiLine(s) {
	    return s && s.indexOf('\n') >= 0;
	}
	exports.isMultiLine = isMultiLine;
	function isMultiLineValue(s) {
	    return isMultiLine(s) && s.length > 2 && s[0] == '|' && (s[1] == '\n' || s[1] == '\r' || s[2] == '\n');
	}
	exports.isMultiLineValue = isMultiLineValue;
	function makeMutiLine(s, lev) {
	    var xbuf = '';
	    if (isMultiLine(s)) {
	        xbuf += '|\n';
	        var lines = splitOnLines(s);
	        for (var i = 0; i < lines.length; i++) {
	            xbuf += indent(lev, lines[i]);
	        }
	    }
	    else {
	        xbuf += s;
	    }
	    return xbuf;
	}
	exports.makeMutiLine = makeMutiLine;
	function fromMutiLine(s) {
	    if (!isMultiLineValue(s))
	        return s;
	    var res = null;
	    var lines = splitOnLines(s);
	    for (var i = 1; i < lines.length; i++) {
	        var line = lines[i];
	        var str = line.substring(2);
	        if (!res)
	            res = str;
	        else
	            res += str;
	    }
	    return res;
	}
	exports.fromMutiLine = fromMutiLine;
	function trimStart(s) {
	    if (!s)
	        return s;
	    var pos = 0;
	    while (pos < s.length) {
	        var ch = s[pos];
	        if (ch != '\r' && ch != '\n' && ch != ' ' && ch != '\t')
	            break;
	        pos++;
	    }
	    return s.substring(pos, s.length);
	}
	exports.trimStart = trimStart;
	function indent(lev, str) {
	    if (str === void 0) { str = ''; }
	    var leading = '';
	    for (var i = 0; i < lev; i++)
	        leading += '  ';
	    return leading + str;
	}
	exports.indent = indent;
	function print(lev, str) {
	    if (str === void 0) { str = ''; }
	    console.log(indent(lev, str));
	}
	exports.print = print;
	function replaceNewlines(s, rep) {
	    if (rep === void 0) { rep = null; }
	    var res = '';
	    for (var i = 0; i < s.length; i++) {
	        var ch = s[i];
	        if (ch == '\r')
	            ch = rep == null ? '\\r' : rep;
	        if (ch == '\n')
	            ch = rep == null ? '\\n' : rep;
	        res += ch;
	    }
	    return res;
	}
	exports.replaceNewlines = replaceNewlines;
	function trimEnd(s) {
	    var pos = s.length;
	    while (pos > 0) {
	        var ch = s[pos - 1];
	        if (ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n')
	            break;
	        pos--;
	    }
	    return s.substring(0, pos);
	}
	exports.trimEnd = trimEnd;
	function splitOnLines(text) {
	    var lines = text.match(/^.*((\r\n|\n|\r)|$)/gm);
	    return lines;
	}
	exports.splitOnLines = splitOnLines;
	function startsWith(s, suffix) {
	    if (!s || !suffix || s.length < suffix.length)
	        return false;
	    for (var i = 0; i < suffix.length; i++) {
	        if (s[i] != suffix[i])
	            return false;
	    }
	    return true;
	}
	exports.startsWith = startsWith;
	function endsWith(s, suffix) {
	    if (!s || !suffix || s.length < suffix.length)
	        return false;
	    for (var i = 0; i < suffix.length; i++) {
	        if (s[s.length - 1 - i] != suffix[suffix.length - 1 - i])
	            return false;
	    }
	    return true;
	}
	exports.endsWith = endsWith;
	var TextRange = (function () {
	    function TextRange(contents, start, end) {
	        this.contents = contents;
	        this.start = start;
	        this.end = end;
	    }
	    TextRange.prototype.text = function () {
	        return this.contents.substring(this.start, this.end);
	    };
	    TextRange.prototype.startpos = function () {
	        return this.start;
	    };
	    TextRange.prototype.endpos = function () {
	        return this.end;
	    };
	    TextRange.prototype.len = function () {
	        return this.end - this.start;
	    };
	    TextRange.prototype.unitText = function () {
	        return this.contents;
	    };
	    TextRange.prototype.withStart = function (start) {
	        return new TextRange(this.contents, start, this.end);
	    };
	    TextRange.prototype.withEnd = function (end) {
	        return new TextRange(this.contents, this.start, end);
	    };
	    TextRange.prototype.sub = function (start, end) {
	        return this.contents.substring(start, end);
	    };
	    TextRange.prototype.trimStart = function () {
	        var pos = this.start;
	        while (pos < this.contents.length - 1) {
	            var ch = this.contents[pos];
	            if (ch != ' ' && ch != '\t')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.trimEnd = function () {
	        var pos = this.end;
	        while (pos > 0) {
	            var ch = this.contents[pos - 1];
	            if (ch != ' ' && ch != '\t')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendToStartOfLine = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var prevchar = this.contents[pos - 1];
	            if (prevchar == '\r' || prevchar == '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendAnyUntilNewLines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar == '\r' || nextchar == '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpacesUntilNewLines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != ' ' || nextchar == '\r' || nextchar == '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpaces = function () {
	        var pos = this.end;
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != ' ')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendSpacesBack = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var nextchar = this.contents[pos - 1];
	            if (nextchar != ' ')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendCharIfAny = function (ch) {
	        var pos = this.end;
	        if (pos < this.contents.length - 1 && this.contents[pos] == ch) {
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendCharIfAnyBack = function (ch) {
	        var pos = this.start;
	        if (pos > 0 && this.contents[pos - 1] == ch) {
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.extendToNewlines = function () {
	        var pos = this.end;
	        if (pos > 0) {
	            var last = this.contents[pos - 1];
	            if (last == '\n')
	                return this;
	        }
	        while (pos < this.contents.length - 1) {
	            var nextchar = this.contents[pos];
	            if (nextchar != '\r' && nextchar != '\n')
	                break;
	            pos++;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.extendUntilNewlinesBack = function () {
	        var pos = this.start;
	        while (pos > 0) {
	            var nextchar = this.contents[pos - 1];
	            if (nextchar == '\r' || nextchar == '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, pos, this.end);
	    };
	    TextRange.prototype.reduceNewlinesEnd = function () {
	        var pos = this.end;
	        while (pos > this.start) {
	            var last = this.contents[pos - 1];
	            if (last != '\r' && last != '\n')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.reduceSpaces = function () {
	        var pos = this.end;
	        while (pos > this.start) {
	            var last = this.contents[pos - 1];
	            if (last != ' ')
	                break;
	            pos--;
	        }
	        return new TextRange(this.contents, this.start, pos);
	    };
	    TextRange.prototype.replace = function (text) {
	        return this.sub(0, this.start) + text + this.sub(this.end, this.unitText().length);
	    };
	    TextRange.prototype.remove = function () {
	        return this.sub(0, this.start) + this.sub(this.end, this.unitText().length);
	    };
	    return TextRange;
	})();
	exports.TextRange = TextRange;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../../typings/tsd.d.ts" />
	var HttpResponse = __webpack_require__(48);
	__webpack_require__(49);
	__webpack_require__(50);
	var lru = __webpack_require__(51);
	var globalCache = lru(50);
	//Function('', fs.readFileSync(require.resolve('./lib/worker.js'), 'utf8'));
	function doRequest(method, url, options) {
	    return null; //FIXME we need a better way to do it for now turn of support of fetching from url
	}
	function readFromCacheOrGet(url) {
	    var res = globalCache.get(url);
	    if (res) {
	        if (res == readFromCacheOrGet) {
	            return null;
	        }
	        return res;
	    }
	    try {
	        var res = doRequest("GET", url, { timeout: 3000, socketTimeout: 5000, retry: true });
	        res = new Buffer(res.body.data).toString();
	        globalCache.set(url, res);
	        return res;
	    }
	    catch (e) {
	        globalCache.set(url, readFromCacheOrGet);
	        return null;
	    }
	}
	exports.readFromCacheOrGet = readFromCacheOrGet;
	function readFromCacheOrGetAsync(url) {
	    return null;
	}
	exports.readFromCacheOrGetAsync = readFromCacheOrGetAsync;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(44).Buffer))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	var base64 = __webpack_require__(45)
	var ieee754 = __webpack_require__(46)
	var isArray = __webpack_require__(47)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(44).Buffer, (function() { return this; }())))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 46 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 47 */
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = require("http-response-object");

/***/ },
/* 49 */
/***/ function(module, exports) {

	module.exports = require("concat-stream");

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = require("then-request");

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = require("lrucache");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var XMLHttpRequestConstructor = __webpack_require__(53).XMLHttpRequest;
	function buildXHR() {
	    var x = new XMLHttpRequestConstructor;
	    return x;
	}
	var SimpleExecutor = (function () {
	    function SimpleExecutor() {
	    }
	    SimpleExecutor.prototype.execute = function (req, doAppendParams) {
	        if (doAppendParams === void 0) { doAppendParams = true; }
	        var xhr = buildXHR();
	        var url = req.url;
	        if (doAppendParams) {
	            url = this.appendParams(req, req.url);
	        }
	        xhr.open(req.method, url, false);
	        this.doRequest(req, xhr);
	        //rheaders=xhr.getAllResponseHeaders();
	        var status = xhr.status;
	        if (status > 300 && status < 400) {
	            var locHeader = xhr.getResponseHeader('location');
	            if (locHeader) {
	                req.url = locHeader;
	                return this.execute(req, false);
	            }
	        }
	        var response = {
	            status: status,
	            statusText: xhr.statusText,
	            headers: xhr.getAllResponseHeaders().split('\n').map(function (x) {
	                var ind = x.indexOf(':');
	                return {
	                    name: x.substring(0, ind).trim(),
	                    value: x.substring(ind + 1).trim()
	                };
	            }),
	            content: {
	                text: xhr.responseText,
	                mimeType: xhr.responseType
	            }
	        };
	        return response;
	    };
	    SimpleExecutor.prototype.appendParams = function (req, url) {
	        var gotQueryParams = (req.queryString && req.queryString.length > 0);
	        if (gotQueryParams) {
	            url = url + '?';
	            var arr = [];
	            if (gotQueryParams) {
	                arr = arr.concat(req.queryString.map(function (q) {
	                    return encodeURIComponent(q.name) + '=' + encodeURIComponent(q.value);
	                }));
	            }
	            url += arr.join('&');
	        }
	        return url;
	    };
	    SimpleExecutor.prototype.log = function (varName, value) {
	    };
	    SimpleExecutor.prototype.executeAsync = function (req, doAppendParams) {
	        if (doAppendParams === void 0) { doAppendParams = true; }
	        var xhr = buildXHR();
	        var url = req.url;
	        if (doAppendParams) {
	            url = this.appendParams(req, req.url);
	        }
	        var outer = this;
	        return new Promise(function (resolve, reject) {
	            xhr.open(req.method, url, true);
	            xhr.onload = function () {
	                //rheaders=xhr.getAllResponseHeaders();
	                var status = xhr.status;
	                if (status > 300 && status < 400) {
	                    var locHeader = xhr.getResponseHeader('location');
	                    if (locHeader) {
	                        req.url = locHeader;
	                        return outer.executeAsync(req, false);
	                    }
	                }
	                var response = {
	                    status: status,
	                    statusText: xhr.statusText,
	                    headers: xhr.getAllResponseHeaders().split('\n').map(function (x) {
	                        var ind = x.indexOf(':');
	                        return {
	                            name: x.substring(0, ind).trim(),
	                            value: x.substring(ind + 1).trim()
	                        };
	                    }),
	                    content: {
	                        text: xhr.responseText,
	                        mimeType: xhr.responseType
	                    }
	                };
	                resolve(response);
	            };
	            xhr.onerror = function () {
	                reject(Error("Network Error"));
	            };
	            outer.doRequest(req, xhr);
	        });
	    };
	    SimpleExecutor.prototype.doRequest = function (req, xhr) {
	        // Make the request
	        if (req.headers) {
	            req.headers.forEach(function (x) { return xhr.setRequestHeader(x.name, x.value); });
	        }
	        if (req.postData) {
	            if (req.postData.params) {
	                var body = req.postData.params.map(function (p) { return encodeURIComponent(p.name) + '=' + encodeURIComponent(p.value); }).join('&');
	                xhr.send(body);
	            }
	            else {
	                xhr.send(req.postData.text);
	            }
	        }
	        else {
	            xhr.send();
	        }
	    };
	    return SimpleExecutor;
	})();
	exports.SimpleExecutor = SimpleExecutor;


/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = require("xmlhttprequest");

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var _ = __webpack_require__(4);
	var Opt = __webpack_require__(55);
	exports.defined = function (x) { return (x !== null) && (x !== undefined); };
	/**
	 * Arrays of Objects are common in RAML08.
	 * @param x
	 * @returns {{}}
	 */
	function flattenArrayOfObjects(x) {
	    var res = {};
	    x.forEach(function (v) { return Object.keys(v).forEach(function (k) { return res[k] = v[k]; }); });
	    return res;
	}
	exports.flattenArrayOfObjects = flattenArrayOfObjects;
	function find(xs, f) {
	    return new Opt(_.find(xs || [], f));
	}
	exports.find = find;
	exports.isInstance = function (v, C) { return (v instanceof C) ? [v] : []; };
	exports.ifInstanceOf = function (v, C, f) { return (v instanceof C) ? f(v) : null; };
	function toTuples(map) {
	    return Object.keys(map).map(function (k) { return [k, map[k]]; });
	}
	exports.toTuples = toTuples;
	function fromTuples(tuples) {
	    var obj = {};
	    tuples.forEach(function (x) { return obj[x[0]] = x[1]; });
	    return obj;
	}
	exports.fromTuples = fromTuples;
	exports.collectInstancesOf = function (xs, C) { return tap([], function (res) { return xs.forEach(function (v) { return exports.ifInstanceOf(v, C, function (x) { return res.push(x); }); }); }); };
	exports.collectInstancesOfInMap = function (map, C) {
	    return Object.keys(map).map(function (k) { return [k, map[k]]; }).filter(function (x) { return x[1] instanceof C; }).map(function (x) { return x; });
	};
	exports.asArray = function (v) { return exports.defined(v) ? ((v instanceof Array) ? v : [v]) : []; };
	exports.shallowCopy = function (obj) { return tap({}, function (copy) { return Object.keys(obj).forEach(function (k) { return copy[k] = obj[k]; }); }); };
	exports.flatMap = function (xs, f) { return exports.flatten(xs.map(f)); };
	exports.flatten = function (xss) { return Array.prototype.concat.apply([], xss); };
	exports.takeWhile = function (xs, f) { return tap([], function (res) {
	    for (var i = 0; i < xs.length; i++) {
	        if (!f(xs[i]))
	            break;
	        res.push(xs[i]);
	    }
	}); };
	function tap(v, f) {
	    f(v);
	    return v;
	}
	exports.tap = tap;
	function kv(obj, iter) {
	    if (typeof obj === 'object')
	        Object.keys(obj).forEach(function (k) { return iter(k, obj[k]); });
	}
	exports.kv = kv;
	function indexed(objects, key, delKey) {
	    if (delKey === void 0) { delKey = false; }
	    var obj = {};
	    objects.forEach(function (original) {
	        var copy = exports.shallowCopy(original);
	        if (delKey)
	            delete copy[key];
	        obj[original[key]] = copy;
	    });
	    return obj;
	}
	exports.indexed = indexed;
	function stringEndsWith(str, search) {
	    var dif = str.length - search.length;
	    return dif >= 0 && str.lastIndexOf(search) === dif;
	}
	exports.stringEndsWith = stringEndsWith;
	function stringStartsWith(str, search) {
	    return str.length - search.length >= 0 && str.substring(0, search.length) === search;
	}
	exports.stringStartsWith = stringStartsWith;
	function lazypropkeyfilter(k) {
	    return k[k.length - 1] == "_"; // ends with underscore
	}
	exports.lazypropkeyfilter = lazypropkeyfilter;
	function lazyprop(obj, key, func) {
	    var result, ready = false;
	    obj[key] = function () {
	        if (!ready) {
	            ready = true;
	            result = func.apply(obj);
	        }
	        return result;
	    };
	}
	function lazyprops(obj, keyfilter) {
	    if (keyfilter === void 0) { keyfilter = lazypropkeyfilter; }
	    for (var k in obj) {
	        if (keyfilter(k)) {
	            exports.ifInstanceOf(obj[k], Function, function (vf) { return (vf.length === 0) ? lazyprop(obj, k, vf) : null; });
	        }
	    }
	}
	exports.lazyprops = lazyprops;
	function iff(v, f) {
	    if (v !== undefined)
	        f(v);
	}
	exports.iff = iff;
	function isRAMLUrl(str) {
	    if (typeof str !== 'string' || str == '')
	        return false;
	    return stringEndsWith(str, ".raml");
	}
	exports.isRAMLUrl = isRAMLUrl;
	function getAllRequiredExternalModulesFromCode(code) {
	    var match;
	    var mods = [];
	    // both quoting styles
	    var r1 = new RegExp("require\\('([^']+)'\\)", "gi");
	    while (match = r1.exec(code)) {
	        mods.push(match[1]);
	    }
	    var r2 = new RegExp('require\\("([^"]+)"\\)', "gi");
	    while (match = r2.exec(code)) {
	        mods.push(match[1]);
	    }
	    mods = _.unique(mods).filter(function (x) { return x != ""; });
	    mods.sort();
	    return mods;
	}
	exports.getAllRequiredExternalModulesFromCode = getAllRequiredExternalModulesFromCode;
	exports.serial = (function () {
	    var i = 0;
	    return function () { return i++; };
	})();
	function isEssential(arg) {
	    return typeof arg !== 'undefined' && arg != null;
	}
	exports.isEssential = isEssential;
	function firstToUpper(q) {
	    if (q.length == 0) {
	        return q;
	    }
	    return q.charAt(0).toUpperCase() + q.substr(1);
	}
	exports.firstToUpper = firstToUpper;
	function updateObject(source, target, addNewFields) {
	    if (addNewFields === void 0) { addNewFields = false; }
	    var keySet = Object.keys(target);
	    if (addNewFields) {
	        var map = {};
	        keySet.forEach(function (x) { return map[x] = true; });
	        Object.keys(source).forEach(function (x) { return map[x] = true; });
	        keySet = Object.keys(map);
	    }
	    keySet.forEach(function (x) {
	        var value = source[x];
	        if (value instanceof Object) {
	            if (!target[x]) {
	                target[x] = {};
	            }
	            updateObject(value, target[x], true);
	        }
	        else if (value != undefined) {
	            target[x] = source[x];
	        }
	    });
	}
	exports.updateObject = updateObject;
	;
	/**
	 * In 'str' replace all occurences of 'map' keys to their values.
	 */
	function replaceMap(str, map) {
	    Object.keys(map).forEach(function (x) { return str = replace(str, x, map[x]); });
	    return str;
	}
	exports.replaceMap = replaceMap;
	/**
	 * Replace all occurences of 'x' in 'str' to 'r' without thinking if 'x' can be passed without
	 * escaping as argument to RegExp constructor
	 */
	function replace(str, x, r) {
	    var result = '';
	    var prev = 0;
	    for (var i = str.indexOf(x); i < str.length && i >= 0; i = str.indexOf(x, prev)) {
	        result += str.substring(prev, i);
	        result += r;
	        prev = i + x.length;
	    }
	    result += str.substring(prev, str.length);
	    return result;
	}
	exports.replace = replace;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../typings/tsd.d.ts" />
	var invariant = __webpack_require__(56);
	var exists = function (v) { return (v != null); };
	var globalEmptyOpt;
	var Opt = (function () {
	    function Opt(_value) {
	        var _this = this;
	        this._value = _value;
	        this._isDefined = false;
	        this._isEmpty = true;
	        this._arr = undefined;
	        this.getOrThrow = function () {
	            invariant(_this._isDefined, 'Opt is empty. Use `Opt#getOrElse` or check `Opt#isDefined`.');
	            return _this._value;
	        };
	        this.value = function () { return _this._value; };
	        this.isDefined = function () { return _this._isDefined; };
	        this.isEmpty = function () { return _this._isEmpty; };
	        this.toArray = function () { return _this._arr || (_this._arr = _this._isDefined ? [_this._value] : []); };
	        this.getOrElse = function (v) { return _this._isDefined ? _this._value : v; };
	        this.getOrElseF = function (v) { return _this._isDefined ? _this._value : v(); };
	        this.map = function (f) { return _this._isEmpty ? Opt.empty() : new Opt(f(_this._value)); };
	        this.flatMap = function (f) { return _this.map(f).getOrElse(Opt.empty()); };
	        this.equals = function (other) {
	            invariant(other instanceof Opt, 'Expected other to be an `Opt`, but got `%s`', typeof other);
	            return (_this._isDefined === other.isDefined()) && (_this._value === other.value());
	        };
	        if (exists(this._value)) {
	            this._isDefined = true;
	            this._isEmpty = false;
	        }
	    }
	    Opt.prototype.forEach = function (fn) {
	        if (this.isDefined()) {
	            fn(this._value);
	        }
	    };
	    /**
	     * You can always create an empty option by hand just by calling new Opt<T>()
	     * but calling this method will return a global instance instead of allocating a new one each time
	     */
	    Opt.empty = function () { return (globalEmptyOpt || (globalEmptyOpt = new Opt())); };
	    return Opt;
	})();
	module.exports = Opt;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	var invariant = function(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error(
	        'Minified exception occurred; use the non-minified dev environment ' +
	        'for the full error message and additional helpful warnings.'
	      );
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(
	        'Invariant Violation: ' +
	        format.replace(/%s/g, function() { return args[argIndex++]; })
	      );
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};

	module.exports = invariant;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)))

/***/ },
/* 57 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var yaml = __webpack_require__(7);
	var json = __webpack_require__(60);
	var stringify = __webpack_require__(61);
	var Error = __webpack_require__(14);
	var impl = __webpack_require__(6);
	var util = __webpack_require__(54);
	var universes = __webpack_require__(62);
	var LowLevelProxyNode = (function () {
	    function LowLevelProxyNode(_parent, _transformer) {
	        this._parent = _parent;
	        this._transformer = _transformer;
	    }
	    LowLevelProxyNode.prototype.actual = function () {
	        if (this._original) {
	            return this._original.actual();
	        }
	        return this;
	    };
	    LowLevelProxyNode.prototype.transformer = function () {
	        return this._transformer;
	    };
	    LowLevelProxyNode.prototype.original = function () {
	        return this._original;
	    };
	    LowLevelProxyNode.prototype.start = function () {
	        return this._original.start();
	    };
	    LowLevelProxyNode.prototype.end = function () {
	        return this._original.end();
	    };
	    LowLevelProxyNode.prototype.value = function () {
	        throw new Error('The method must be overridden');
	    };
	    LowLevelProxyNode.prototype.includeErrors = function () {
	        return this._original.includeErrors();
	    };
	    LowLevelProxyNode.prototype.includePath = function () {
	        return this._original.includePath();
	    };
	    LowLevelProxyNode.prototype.setKeyOverride = function (_key) {
	        this._keyOverride = _key;
	    };
	    LowLevelProxyNode.prototype.key = function () {
	        if (this._keyOverride) {
	            return this._keyOverride;
	        }
	        return this._original.key();
	    };
	    LowLevelProxyNode.prototype.children = function () {
	        throw new Error('The method must be overridden');
	    };
	    LowLevelProxyNode.prototype.parent = function () {
	        return this._parent;
	    };
	    LowLevelProxyNode.prototype.unit = function () {
	        return this._original.unit();
	    };
	    LowLevelProxyNode.prototype.anchorId = function () {
	        return this._original.anchorId();
	    };
	    LowLevelProxyNode.prototype.errors = function () {
	        return this._original.errors();
	    };
	    LowLevelProxyNode.prototype.anchoredFrom = function () {
	        return this._original.anchoredFrom();
	    };
	    LowLevelProxyNode.prototype.includedFrom = function () {
	        return this._original.includedFrom();
	    };
	    LowLevelProxyNode.prototype.visit = function (v) {
	        if (v(this)) {
	            this.children().forEach(function (x) { return x.visit(v); });
	        }
	    };
	    //TODO
	    LowLevelProxyNode.prototype.addChild = function (n) {
	    };
	    //TODO
	    LowLevelProxyNode.prototype.execute = function (cmd) {
	    };
	    //TODO
	    LowLevelProxyNode.prototype.dump = function () {
	        return null;
	    };
	    //TODO
	    LowLevelProxyNode.prototype.dumpToObject = function () {
	        return json.serialize(this);
	    };
	    LowLevelProxyNode.prototype.keyStart = function () {
	        return this._original.keyStart();
	    };
	    LowLevelProxyNode.prototype.keyEnd = function () {
	        return this._original.keyEnd();
	    };
	    LowLevelProxyNode.prototype.valueStart = function () {
	        return this._original.valueStart();
	    };
	    LowLevelProxyNode.prototype.valueEnd = function () {
	        return this._original.valueEnd();
	    };
	    LowLevelProxyNode.prototype.isValueLocal = function () {
	        return this._original.isValueLocal();
	    };
	    LowLevelProxyNode.prototype.kind = function () {
	        return this._original.kind();
	    };
	    LowLevelProxyNode.prototype.valueKind = function () {
	        return this._original.valueKind();
	    };
	    LowLevelProxyNode.prototype.show = function (msg) {
	        this._original.show(msg);
	    };
	    LowLevelProxyNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    LowLevelProxyNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    LowLevelProxyNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    LowLevelProxyNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    LowLevelProxyNode.prototype.text = function (unitText) {
	        throw new Error("not implemented");
	    };
	    LowLevelProxyNode.prototype.copy = function () {
	        throw new Error("not implemented");
	    };
	    LowLevelProxyNode.prototype.markup = function (json) {
	        throw new Error("not implemented");
	    };
	    LowLevelProxyNode.prototype.nodeDefinition = function () {
	        return impl.getDefinitionForLowLevelNode(this);
	    };
	    return LowLevelProxyNode;
	})();
	exports.LowLevelProxyNode = LowLevelProxyNode;
	var LowLevelCompositeNode = (function (_super) {
	    __extends(LowLevelCompositeNode, _super);
	    function LowLevelCompositeNode(node, parent, transformer, fromMainTree) {
	        if (fromMainTree === void 0) { fromMainTree = true; }
	        _super.call(this, parent, transformer);
	        this.fromMainTree = fromMainTree;
	        this._adoptedNodes = [];
	        var originalParent = this.parent() ? this.parent().original() : null;
	        this._original = new LowLevelValueTransformingNode(node, originalParent, transformer);
	        this._adoptedNodes.push(this.original());
	    }
	    LowLevelCompositeNode.prototype.adoptedNodes = function () {
	        return this._adoptedNodes;
	    };
	    LowLevelCompositeNode.prototype.original = function () {
	        return this._original;
	    };
	    LowLevelCompositeNode.prototype.parent = function () {
	        return this._parent;
	    };
	    LowLevelCompositeNode.prototype.adopt = function (node, transformer) {
	        if (!transformer) {
	            transformer = this._transformer;
	        }
	        var originalParent = this.parent() ? this.parent().original() : null;
	        var tNode = new LowLevelValueTransformingNode(node, originalParent, transformer);
	        this._adoptedNodes.push(tNode);
	        if (this._children) {
	            this._children.forEach(function (x) { return x._parent = null; });
	        }
	        this._children = null;
	        if (this.highLevelNode()) {
	            this.highLevelNode().resetChildren();
	        }
	    };
	    LowLevelCompositeNode.prototype.value = function () {
	        var valuableNodes = this._adoptedNodes.filter(function (x) { return x.value(); });
	        if (valuableNodes.length > 0) {
	            return valuableNodes[0].value();
	        }
	        return this._original.value();
	    };
	    LowLevelCompositeNode.prototype.children = function () {
	        var _this = this;
	        if (this._children) {
	            return this._children;
	        }
	        var result = [];
	        var canBeMap = false;
	        var canBeSeq = false;
	        this._adoptedNodes.forEach(function (x) {
	            if (x.children() && x.children().length > 0) {
	                canBeSeq = true;
	                if (x.children()[0].key()) {
	                    canBeMap = true;
	                }
	            }
	        });
	        if (canBeMap) {
	            result = this.collectChildrenWithKeys();
	        }
	        else if (canBeSeq) {
	            result = this.collectChildrenWithKeys();
	            var map = {};
	            this._adoptedNodes.forEach(function (x, i) { return x.children().filter(function (y) { return !y.key(); }).forEach(function (y) {
	                var key = _this.buildKey(y);
	                if (i>0&&map[key]) {
	                    return;
	                }
	                map[key] = true;
	                var transformer = x.transformer() ? x.transformer() : _this.transformer();
	                var ch = (y instanceof LowLevelValueTransformingNode) ? y.original() : y;
	                result.push(new LowLevelCompositeNode(ch, _this, transformer, i == 0));
	            }); });
	        }
	        else {
	            result = [];
	        }
	        this._children = result;
	        return result;
	    };
	    LowLevelCompositeNode.prototype.buildKey = function (y) {
	        var obj = json.serialize(y);
	        var def = this.nodeDefinition();
	        if (def && (def.key() == universes.Universe08.TraitRef || def.key() == universes.Universe08.ResourceTypeRef || def.key() == universes.Universe10.TraitRef || def.key() == universes.Universe10.ResourceTypeRef)) {
	            if (typeof obj == 'object') {
	                var keys = Object.keys(obj);
	                if (keys.length > 0) {
	                    obj = keys[0];
	                }
	            }
	        }
	        return stringify(obj);
	    };
	    LowLevelCompositeNode.prototype.collectChildrenWithKeys = function () {
	        var _this = this;
	        var result = [];
	        var m = {};
	        this._adoptedNodes.forEach(function (x, i) {
	            x.original().children().forEach(function (y) {
	                var key = y.key();
	                if (!key) {
	                    return;
	                }
	                if (util.stringEndsWith(key, '?')) {
	                    key = key.substring(0, key.length - 1);
	                }
	                var arr = m[key];
	                if (!arr) {
	                    arr = [];
	                    m[key] = arr;
	                }
	                arr.push({ node: y, transformer: x.transformer(), fromOriginalTree: _this.fromMainTree && i == 0 });
	            });
	        });
	        Object.keys(m).forEach(function (key) {
	            var arr = m[key];
	            var allOptional = true;
	            var hasChildFromOriginalTree = false;
	            arr.forEach(function (x) {
	                allOptional = allOptional && util.stringEndsWith(x.node.key(), '?');
	                hasChildFromOriginalTree = hasChildFromOriginalTree || x.fromOriginalTree;
	            });
	            if (hasChildFromOriginalTree || !allOptional) {
	                var originalTransformer = arr[0].transformer ? arr[0].transformer : _this.transformer();
	                var originalChild = new LowLevelCompositeNode(arr[0].node, _this, originalTransformer, hasChildFromOriginalTree);
	                for (var i = 1; i < arr.length; i++) {
	                    originalChild.adopt(arr[i].node, arr[i].transformer);
	                }
	                result.push(originalChild);
	            }
	        });
	        return result;
	    };
	    LowLevelCompositeNode.prototype.valueKind = function () {
	        if (this._original.kind() != 1 /* MAPPING */) {
	            return null;
	        }
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            if (node.value()) {
	                return node.valueKind();
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.includePath = function () {
	        for (var i = 0; i < this._adoptedNodes.length; i++) {
	            var node = this._adoptedNodes[i];
	            if (node.value()) {
	                return node.includePath();
	            }
	        }
	        return null;
	    };
	    LowLevelCompositeNode.prototype.key = function () {
	        var keys = this._adoptedNodes.map(function (x) { return x.key(); }).filter(function (x) { return x != null && !util.stringEndsWith(x, '?'); });
	        if (keys.length > 0) {
	            return keys[0];
	        }
	        return _super.prototype.key.call(this);
	    };
	    return LowLevelCompositeNode;
	})(LowLevelProxyNode);
	exports.LowLevelCompositeNode = LowLevelCompositeNode;
	var LowLevelValueTransformingNode = (function (_super) {
	    __extends(LowLevelValueTransformingNode, _super);
	    function LowLevelValueTransformingNode(node, parent, transformer) {
	        _super.call(this, parent, transformer);
	        this._original = node;
	    }
	    LowLevelValueTransformingNode.prototype.value = function () {
	        var val = this.original().value();
	        var t = this.transformer();
	        if (t) {
	            val = t.transform(val);
	            if (t.error()) {
	                var msg = t.error();
	                console.log(t.error());
	            }
	        }
	        return val;
	    };
	    LowLevelValueTransformingNode.prototype.children = function () {
	        var _this = this;
	        return this.original().children().map(function (x) { return new LowLevelValueTransformingNode(x, _this, _this._transformer); });
	    };
	    LowLevelValueTransformingNode.prototype.parent = function () {
	        return this._parent;
	    };
	    return LowLevelValueTransformingNode;
	})(LowLevelProxyNode);
	exports.LowLevelValueTransformingNode = LowLevelValueTransformingNode;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	/**
	 * Created by kor on 05/05/15.
	 */
	var Error = __webpack_require__(14);
	var yaml = __webpack_require__(7);
	var util = __webpack_require__(54);
	var llImpl = __webpack_require__(6);
	var CompilationUnit = (function () {
	    function CompilationUnit(_absolutePath, _path, _content, _project, _isTopoLevel, serializeOptions) {
	        if (serializeOptions === void 0) { serializeOptions = {}; }
	        this._absolutePath = _absolutePath;
	        this._path = _path;
	        this._content = _content;
	        this._project = _project;
	        this._isTopoLevel = _isTopoLevel;
	        this.serializeOptions = serializeOptions;
	        this._node = new AstNode(this, JSON.parse(this._content), null, serializeOptions);
	    }
	    CompilationUnit.prototype.absolutePath = function () {
	        return this._absolutePath;
	    };
	    CompilationUnit.prototype.clone = function () {
	        return null;
	    };
	    CompilationUnit.prototype.contents = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.lexerErrors = function () {
	        return [];
	    };
	    CompilationUnit.prototype.path = function () {
	        return this._content;
	    };
	    CompilationUnit.prototype.isTopLevel = function () {
	        return this._isTopoLevel;
	    };
	    CompilationUnit.prototype.ast = function () {
	        return this._node;
	    };
	    CompilationUnit.prototype.isDirty = function () {
	        return true;
	    };
	    CompilationUnit.prototype.getIncludeNodes = function () {
	        return [];
	    };
	    CompilationUnit.prototype.resolveAsync = function (p) {
	        return null;
	    };
	    CompilationUnit.prototype.isRAMLUnit = function () {
	        return true;
	    };
	    CompilationUnit.prototype.project = function () {
	        return this._project;
	    };
	    CompilationUnit.prototype.updateContent = function (newContent) {
	    };
	    CompilationUnit.prototype.ramlVersion = function () {
	        throw new Error('not implemented');
	    };
	    CompilationUnit.prototype.resolve = function (p) {
	        return null;
	    }; // TODO FIXME 
	    return CompilationUnit;
	})();
	exports.CompilationUnit = CompilationUnit;
	//export interface IProject{
	//    units():ICompilationUnit[];//returns units with apis in this folder
	//
	//    execute(cmd:CompositeCommand)
	//
	//    executeTextChange(textCommand:TextChangeCommand);//this may result in broken nodes?
	//
	//    addListener(listener:IASTListener);
	//
	//    removeListener(listener:IASTListener)
	//
	//    addTextChangeListener(listener:ITextChangeCommandListener);
	//    removeTextChangeListener(listener:ITextChangeCommandListener);
	//}
	//export interface IASTListener{
	//    (delta:ASTDelta)
	//}
	//
	//export interface ITextChangeCommandListener{
	//    (delta:TextChangeCommand)
	//}
	//export class ASTDelta{
	//    commands:ASTChangeCommand[]
	//}
	//export interface ASTVisitor{
	//    (node:ILowLevelASTNode):boolean
	//}
	var AstNode = (function () {
	    function AstNode(_unit, _object, _parent, options, _key) {
	        var _this = this;
	        if (options === void 0) { options = {}; }
	        this._unit = _unit;
	        this._object = _object;
	        this._parent = _parent;
	        this.options = options;
	        this._key = _key;
	        if (this._object instanceof Object) {
	            Object.keys(this._object).forEach(function (x) {
	                var u = unescapeKey(x, _this.options);
	                if (u != x) {
	                    var val = _this._object[x];
	                    delete _this._object[x];
	                    _this._object[u] = val;
	                }
	            });
	        }
	    }
	    AstNode.prototype.start = function () {
	        return -1;
	    };
	    AstNode.prototype.end = function () {
	        return -1;
	    };
	    AstNode.prototype.value = function () {
	        return this._object;
	    };
	    AstNode.prototype.actual = function () {
	        return this._object;
	    };
	    AstNode.prototype.includeErrors = function () {
	        return [];
	    };
	    AstNode.prototype.includePath = function () {
	        return null;
	    };
	    AstNode.prototype.key = function () {
	        return this._key;
	    };
	    AstNode.prototype.children = function () {
	        var _this = this;
	        if (!this._object) {
	            return [];
	        }
	        if (Array.isArray(this._object)) {
	            return this._object.map(function (x) { return new AstNode(_this._unit, x, _this, _this.options); });
	        }
	        else if (this._object instanceof Object) {
	            return Object.keys(this._object).map(function (x) { return new AstNode(_this._unit, _this._object[x], _this, _this.options, x); });
	        }
	        else {
	            return [];
	        }
	    };
	    AstNode.prototype.parent = function () {
	        return this._parent;
	    };
	    AstNode.prototype.unit = function () {
	        return this._unit;
	    };
	    AstNode.prototype.anchorId = function () {
	        return null;
	    };
	    AstNode.prototype.errors = function () {
	        return [];
	    };
	    AstNode.prototype.anchoredFrom = function () {
	        return this;
	    };
	    AstNode.prototype.includedFrom = function () {
	        return this;
	    };
	    AstNode.prototype.visit = function (v) {
	        if (v(this)) {
	            this.children().forEach(function (x) { return x.visit(v); });
	        }
	    };
	    AstNode.prototype.dumpToObject = function () {
	        return this._object;
	    };
	    AstNode.prototype.addChild = function (n) {
	    };
	    AstNode.prototype.execute = function (cmd) {
	    };
	    AstNode.prototype.dump = function () {
	        return JSON.stringify(this._object);
	    };
	    AstNode.prototype.keyStart = function () {
	        return -1;
	    };
	    AstNode.prototype.keyEnd = function () {
	        return -1;
	    };
	    AstNode.prototype.valueStart = function () {
	        return -1;
	    };
	    AstNode.prototype.valueEnd = function () {
	        return -1;
	    };
	    AstNode.prototype.isValueLocal = function () {
	        return true;
	    };
	    AstNode.prototype.kind = function () {
	        if (Array.isArray(this._object)) {
	            return 3 /* SEQ */;
	        }
	        else if (this._object instanceof Object) {
	            return 2 /* MAP */;
	        }
	        else {
	            return 0 /* SCALAR */;
	        }
	    };
	    AstNode.prototype.valueKind = function () {
	        return null;
	    };
	    AstNode.prototype.show = function (msg) {
	    };
	    AstNode.prototype.setHighLevelParseResult = function (highLevelParseResult) {
	        this._highLevelParseResult = highLevelParseResult;
	    };
	    AstNode.prototype.highLevelParseResult = function () {
	        return this._highLevelParseResult;
	    };
	    AstNode.prototype.setHighLevelNode = function (highLevel) {
	        this._highLevelNode = highLevel;
	    };
	    AstNode.prototype.highLevelNode = function () {
	        return this._highLevelNode;
	    };
	    AstNode.prototype.text = function (unitText) {
	        throw new Error("not implemented");
	    };
	    AstNode.prototype.copy = function () {
	        throw new Error("not implemented");
	    };
	    AstNode.prototype.markup = function (json) {
	        throw new Error("not implemented");
	    };
	    AstNode.prototype.nodeDefinition = function () {
	        return llImpl.getDefinitionForLowLevelNode(this);
	    };
	    return AstNode;
	})();
	exports.AstNode = AstNode;
	function serialize(node, options) {
	    if (options === void 0) { options = {}; }
	    if (node.children().length == 0) {
	        if (node.value()) {
	            return node.value();
	        }
	        return '';
	    }
	    if (!node.children()[0].key()) {
	        var arr = [];
	        node.children().forEach(function (x) {
	            arr.push(serialize(x, options));
	        });
	        return arr;
	    }
	    else {
	        var obj = {};
	        node.children().forEach(function (x) {
	            obj[escapeKey(x.key(), options)] = serialize(x, options);
	        });
	        if (options && options.writeErroes) {
	            var errors = collectErrors(node);
	            obj['__$errors__'] = errors;
	        }
	        return obj;
	    }
	}
	exports.serialize = serialize;
	function collectErrors(node) {
	    var errors = [].concat(node.errors());
	    node.children().forEach(function (ch) {
	        var children = ch.children();
	        if (children.length == 0) {
	            ch.errors().forEach(function (e) { return errors.push(e); });
	            return;
	        }
	        if (!children[0].key()) {
	            children.forEach(function (x) {
	                if (x.children().length == 0) {
	                    x.errors().forEach(function (e) { return errors.push(e); });
	                }
	            });
	        }
	    });
	    return errors;
	}
	function escapeKey(key, options) {
	    if (!options || !key) {
	        return key;
	    }
	    if (options.escapeNumericKeys && key.replace(/\d/g, '').trim().length == 0) {
	        return '__$EscapedKey$__' + key;
	    }
	    return key;
	}
	function unescapeKey(key, options) {
	    if (!key) {
	        return key;
	    }
	    if (options.escapeNumericKeys && util.stringStartsWith(key, '__$EscapedKey$__') && key.substring('__$EscapedKey$__'.length).replace(/\d/g, '').trim().length == 0) {
	        return key.substring('__$EscapedKey$__'.length);
	    }
	    return key;
	}


/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = require("json-stable-stringify");

/***/ },
/* 62 */
/***/ function(module, exports) {

	var Universes = {
	    "Universe08": {
	        "GlobalSchema": {
	            "name": "GlobalSchema",
	            "properties": {
	                "key": {
	                    "name": "key"
	                },
	                "value": {
	                    "name": "value"
	                }
	            }
	        },
	        "Api": {
	            "name": "Api",
	            "properties": {
	                "title": {
	                    "name": "title"
	                },
	                "version": {
	                    "name": "version"
	                },
	                "baseUri": {
	                    "name": "baseUri"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "mediaType": {
	                    "name": "mediaType"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "documentation": {
	                    "name": "documentation"
	                }
	            }
	        },
	        "DocumentationItem": {
	            "name": "DocumentationItem",
	            "properties": {
	                "title": {
	                    "name": "title"
	                },
	                "content": {
	                    "name": "content"
	                }
	            }
	        },
	        "ValueType": {
	            "name": "ValueType",
	            "properties": {}
	        },
	        "StringType": {
	            "name": "StringType",
	            "properties": {}
	        },
	        "NumberType": {
	            "name": "NumberType",
	            "properties": {}
	        },
	        "BooleanType": {
	            "name": "BooleanType",
	            "properties": {}
	        },
	        "Referencable": {
	            "name": "Referencable",
	            "properties": {}
	        },
	        "Reference": {
	            "name": "Reference",
	            "properties": {}
	        },
	        "DeclaresDynamicType": {
	            "name": "DeclaresDynamicType",
	            "properties": {}
	        },
	        "UriTemplate": {
	            "name": "UriTemplate",
	            "properties": {}
	        },
	        "RelativeUri": {
	            "name": "RelativeUri",
	            "properties": {}
	        },
	        "FullUriTemplate": {
	            "name": "FullUriTemplate",
	            "properties": {}
	        },
	        "FixedUri": {
	            "name": "FixedUri",
	            "properties": {}
	        },
	        "MarkdownString": {
	            "name": "MarkdownString",
	            "properties": {}
	        },
	        "SchemaString": {
	            "name": "SchemaString",
	            "properties": {}
	        },
	        "JSonSchemaString": {
	            "name": "JSonSchemaString",
	            "properties": {}
	        },
	        "XMLSchemaString": {
	            "name": "XMLSchemaString",
	            "properties": {}
	        },
	        "ExampleString": {
	            "name": "ExampleString",
	            "properties": {}
	        },
	        "StatusCode": {
	            "name": "StatusCode",
	            "properties": {}
	        },
	        "JSONExample": {
	            "name": "JSONExample",
	            "properties": {}
	        },
	        "XMLExample": {
	            "name": "XMLExample",
	            "properties": {}
	        },
	        "ResourceTypeRef": {
	            "name": "ResourceTypeRef",
	            "properties": {}
	        },
	        "TraitRef": {
	            "name": "TraitRef",
	            "properties": {}
	        },
	        "SecuritySchemaPart": {
	            "name": "SecuritySchemaPart",
	            "properties": {}
	        },
	        "SecuritySchemaSettings": {
	            "name": "SecuritySchemaSettings",
	            "properties": {}
	        },
	        "OAuth1SecuritySchemeSettings": {
	            "name": "OAuth1SecuritySchemeSettings",
	            "properties": {
	                "requestTokenUri": {
	                    "name": "requestTokenUri"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri"
	                },
	                "tokenCredentialsUri": {
	                    "name": "tokenCredentialsUri"
	                }
	            }
	        },
	        "OAuth2SecuritySchemeSettings": {
	            "name": "OAuth2SecuritySchemeSettings",
	            "properties": {
	                "accessTokenUri": {
	                    "name": "accessTokenUri"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri"
	                },
	                "authorizationGrants": {
	                    "name": "authorizationGrants"
	                },
	                "scopes": {
	                    "name": "scopes"
	                }
	            }
	        },
	        "SecuritySchemaRef": {
	            "name": "SecuritySchemaRef",
	            "properties": {}
	        },
	        "SecuritySchema": {
	            "name": "SecuritySchema",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "MethodBase": {
	            "name": "MethodBase",
	            "properties": {
	                "responses": {
	                    "name": "responses"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                }
	            }
	        },
	        "Trait": {
	            "name": "Trait",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                }
	            }
	        },
	        "ResourceType": {
	            "name": "ResourceType",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "methods": {
	                    "name": "methods"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                }
	            }
	        },
	        "Method": {
	            "name": "Method",
	            "properties": {
	                "method": {
	                    "name": "method"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                }
	            }
	        },
	        "Resource": {
	            "name": "Resource",
	            "properties": {
	                "relativeUri": {
	                    "name": "relativeUri"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                },
	                "methods": {
	                    "name": "methods"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters"
	                }
	            }
	        },
	        "Parameter": {
	            "name": "Parameter",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "repeat": {
	                    "name": "repeat"
	                }
	            }
	        },
	        "StrElement": {
	            "name": "StrElement",
	            "properties": {
	                "pattern": {
	                    "name": "pattern"
	                },
	                "enum": {
	                    "name": "enum"
	                },
	                "minLength": {
	                    "name": "minLength"
	                },
	                "maxLength": {
	                    "name": "maxLength"
	                }
	            }
	        },
	        "BooleanElement": {
	            "name": "BooleanElement",
	            "properties": {}
	        },
	        "NumberElement": {
	            "name": "NumberElement",
	            "properties": {
	                "minimum": {
	                    "name": "minimum"
	                },
	                "maximum": {
	                    "name": "maximum"
	                }
	            }
	        },
	        "IntegerElement": {
	            "name": "IntegerElement",
	            "properties": {}
	        },
	        "DateElement": {
	            "name": "DateElement",
	            "properties": {}
	        },
	        "FileElement": {
	            "name": "FileElement",
	            "properties": {}
	        },
	        "HasNormalParameters": {
	            "name": "HasNormalParameters",
	            "properties": {
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "headers": {
	                    "name": "headers"
	                }
	            }
	        },
	        "ParameterLocation": {
	            "name": "ParameterLocation",
	            "properties": {}
	        },
	        "RAMLLanguageElement": {
	            "name": "RAMLLanguageElement",
	            "properties": {
	                "description": {
	                    "name": "description"
	                }
	            }
	        },
	        "RAMLSimpleElement": {
	            "name": "RAMLSimpleElement",
	            "properties": {}
	        },
	        "DeclarationWithoutAnotations": {
	            "name": "DeclarationWithoutAnotations",
	            "properties": {}
	        },
	        "MimeTypeModel": {
	            "name": "MimeTypeModel",
	            "properties": {
	                "type": {
	                    "name": "type"
	                },
	                "tree": {
	                    "name": "tree"
	                },
	                "subtype": {
	                    "name": "subtype"
	                },
	                "suffix": {
	                    "name": "suffix"
	                },
	                "parameters": {
	                    "name": "parameters"
	                }
	            }
	        },
	        "MimeType": {
	            "name": "MimeType",
	            "properties": {}
	        },
	        "BodyLike": {
	            "name": "BodyLike",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "formParameters": {
	                    "name": "formParameters"
	                }
	            }
	        },
	        "XMLBody": {
	            "name": "XMLBody",
	            "properties": {
	                "schema": {
	                    "name": "schema"
	                }
	            }
	        },
	        "JSONBody": {
	            "name": "JSONBody",
	            "properties": {
	                "schema": {
	                    "name": "schema"
	                }
	            }
	        },
	        "Response": {
	            "name": "Response",
	            "properties": {
	                "code": {
	                    "name": "code"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "body": {
	                    "name": "body"
	                }
	            }
	        }
	    },
	    "Universe10": {
	        "GlobalSchema": {
	            "name": "GlobalSchema",
	            "properties": {
	                "key": {
	                    "name": "key"
	                },
	                "value": {
	                    "name": "value"
	                }
	            }
	        },
	        "ImportDeclaration": {
	            "name": "ImportDeclaration",
	            "properties": {
	                "key": {
	                    "name": "key"
	                },
	                "value": {
	                    "name": "value"
	                }
	            }
	        },
	        "Library": {
	            "name": "Library",
	            "properties": {
	                "usage": {
	                    "name": "usage"
	                }
	            }
	        },
	        "LibraryBase": {
	            "name": "LibraryBase",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "schemas": {
	                    "name": "schemas"
	                },
	                "types": {
	                    "name": "types"
	                },
	                "traits": {
	                    "name": "traits"
	                },
	                "resourceTypes": {
	                    "name": "resourceTypes"
	                },
	                "annotationTypes": {
	                    "name": "annotationTypes"
	                },
	                "securitySchemaTypes": {
	                    "name": "securitySchemaTypes"
	                },
	                "securitySchemes": {
	                    "name": "securitySchemes"
	                },
	                "uses": {
	                    "name": "uses"
	                }
	            }
	        },
	        "Overlay": {
	            "name": "Overlay",
	            "properties": {
	                "usage": {
	                    "name": "usage"
	                },
	                "masterRef": {
	                    "name": "masterRef"
	                },
	                "title": {
	                    "name": "title"
	                }
	            }
	        },
	        "Extension": {
	            "name": "Extension",
	            "properties": {
	                "usage": {
	                    "name": "usage"
	                },
	                "masterRef": {
	                    "name": "masterRef"
	                },
	                "title": {
	                    "name": "title"
	                }
	            }
	        },
	        "Api": {
	            "name": "Api",
	            "properties": {
	                "title": {
	                    "name": "title"
	                },
	                "version": {
	                    "name": "version"
	                },
	                "baseUri": {
	                    "name": "baseUri"
	                },
	                "baseUriParameters": {
	                    "name": "baseUriParameters"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "mediaType": {
	                    "name": "mediaType"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "documentation": {
	                    "name": "documentation"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                },
	                "securitySchemaTypes": {
	                    "name": "securitySchemaTypes"
	                }
	            }
	        },
	        "DocumentationItem": {
	            "name": "DocumentationItem",
	            "properties": {
	                "title": {
	                    "name": "title"
	                },
	                "content": {
	                    "name": "content"
	                }
	            }
	        },
	        "ScriptSpec": {
	            "name": "ScriptSpec",
	            "properties": {
	                "language": {
	                    "name": "language"
	                },
	                "content": {
	                    "name": "content"
	                }
	            }
	        },
	        "ApiDescription": {
	            "name": "ApiDescription",
	            "properties": {
	                "apiFiles": {
	                    "name": "apiFiles"
	                },
	                "script": {
	                    "name": "script"
	                },
	                "type": {
	                    "name": "type"
	                }
	            }
	        },
	        "CallbackAPIDescription": {
	            "name": "CallbackAPIDescription",
	            "properties": {
	                "callbackFor": {
	                    "name": "callbackFor"
	                }
	            }
	        },
	        "RAMLProject": {
	            "name": "RAMLProject",
	            "properties": {
	                "relatedProjects": {
	                    "name": "relatedProjects"
	                },
	                "declaredApis": {
	                    "name": "declaredApis"
	                },
	                "license": {
	                    "name": "license"
	                },
	                "overview": {
	                    "name": "overview"
	                },
	                "url": {
	                    "name": "url"
	                }
	            }
	        },
	        "ValueType": {
	            "name": "ValueType",
	            "properties": {}
	        },
	        "StringType": {
	            "name": "StringType",
	            "properties": {}
	        },
	        "NumberType": {
	            "name": "NumberType",
	            "properties": {}
	        },
	        "BooleanType": {
	            "name": "BooleanType",
	            "properties": {}
	        },
	        "Referencable": {
	            "name": "Referencable",
	            "properties": {}
	        },
	        "Reference": {
	            "name": "Reference",
	            "properties": {}
	        },
	        "DeclaresDynamicType": {
	            "name": "DeclaresDynamicType",
	            "properties": {}
	        },
	        "UriTemplate": {
	            "name": "UriTemplate",
	            "properties": {}
	        },
	        "StatusCode": {
	            "name": "StatusCode",
	            "properties": {}
	        },
	        "ramlexpression": {
	            "name": "ramlexpression",
	            "properties": {}
	        },
	        "RelativeUri": {
	            "name": "RelativeUri",
	            "properties": {}
	        },
	        "FullUriTemplate": {
	            "name": "FullUriTemplate",
	            "properties": {}
	        },
	        "FixedUri": {
	            "name": "FixedUri",
	            "properties": {}
	        },
	        "ContentType": {
	            "name": "ContentType",
	            "properties": {}
	        },
	        "ValidityExpression": {
	            "name": "ValidityExpression",
	            "properties": {}
	        },
	        "MarkdownString": {
	            "name": "MarkdownString",
	            "properties": {}
	        },
	        "DateFormatSpec": {
	            "name": "DateFormatSpec",
	            "properties": {}
	        },
	        "FunctionalInterface": {
	            "name": "FunctionalInterface",
	            "properties": {}
	        },
	        "SchemaString": {
	            "name": "SchemaString",
	            "properties": {}
	        },
	        "ExampleString": {
	            "name": "ExampleString",
	            "properties": {}
	        },
	        "JSonSchemaString": {
	            "name": "JSonSchemaString",
	            "properties": {}
	        },
	        "XMLSchemaString": {
	            "name": "XMLSchemaString",
	            "properties": {}
	        },
	        "ScriptingHook": {
	            "name": "ScriptingHook",
	            "properties": {}
	        },
	        "RAMLPointer": {
	            "name": "RAMLPointer",
	            "properties": {}
	        },
	        "RAMLSelector": {
	            "name": "RAMLSelector",
	            "properties": {}
	        },
	        "ResourceTypeRef": {
	            "name": "ResourceTypeRef",
	            "properties": {}
	        },
	        "TraitRef": {
	            "name": "TraitRef",
	            "properties": {}
	        },
	        "SecuritySchemaPart": {
	            "name": "SecuritySchemaPart",
	            "properties": {
	                "headers": {
	                    "name": "headers"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "responses": {
	                    "name": "responses"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "SecuritySchemaHook": {
	            "name": "SecuritySchemaHook",
	            "properties": {
	                "parameters": {
	                    "name": "parameters"
	                },
	                "script": {
	                    "name": "script"
	                }
	            }
	        },
	        "SecuritySchemaHookScript": {
	            "name": "SecuritySchemaHookScript",
	            "properties": {}
	        },
	        "SecuritySchemaType": {
	            "name": "SecuritySchemaType",
	            "properties": {
	                "requiredSettings": {
	                    "name": "requiredSettings"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                }
	            }
	        },
	        "SecuritySchemaSettings": {
	            "name": "SecuritySchemaSettings",
	            "properties": {}
	        },
	        "OAuth1SecuritySchemeSettings": {
	            "name": "OAuth1SecuritySchemeSettings",
	            "properties": {
	                "requestTokenUri": {
	                    "name": "requestTokenUri"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri"
	                },
	                "tokenCredentialsUri": {
	                    "name": "tokenCredentialsUri"
	                },
	                "signatures": {
	                    "name": "signatures"
	                }
	            }
	        },
	        "OAuth2SecuritySchemeSettings": {
	            "name": "OAuth2SecuritySchemeSettings",
	            "properties": {
	                "accessTokenUri": {
	                    "name": "accessTokenUri"
	                },
	                "authorizationUri": {
	                    "name": "authorizationUri"
	                },
	                "authorizationGrants": {
	                    "name": "authorizationGrants"
	                },
	                "scopes": {
	                    "name": "scopes"
	                }
	            }
	        },
	        "PassThroughSettings": {
	            "name": "PassThroughSettings",
	            "properties": {
	                "queryParameterName": {
	                    "name": "queryParameterName"
	                },
	                "headerName": {
	                    "name": "headerName"
	                }
	            }
	        },
	        "SecuritySchemaRef": {
	            "name": "SecuritySchemaRef",
	            "properties": {}
	        },
	        "SecuritySchema": {
	            "name": "SecuritySchema",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "describedBy": {
	                    "name": "describedBy"
	                },
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "Oath2": {
	            "name": "Oath2",
	            "properties": {
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "Oath1": {
	            "name": "Oath1",
	            "properties": {
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "PassThrough": {
	            "name": "PassThrough",
	            "properties": {
	                "settings": {
	                    "name": "settings"
	                }
	            }
	        },
	        "Basic": {
	            "name": "Basic",
	            "properties": {}
	        },
	        "Digest": {
	            "name": "Digest",
	            "properties": {}
	        },
	        "Custom": {
	            "name": "Custom",
	            "properties": {}
	        },
	        "MethodBase": {
	            "name": "MethodBase",
	            "properties": {
	                "responses": {
	                    "name": "responses"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "protocols": {
	                    "name": "protocols"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                }
	            }
	        },
	        "Trait": {
	            "name": "Trait",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "uses": {
	                    "name": "uses"
	                }
	            }
	        },
	        "ResourceBase": {
	            "name": "ResourceBase",
	            "properties": {
	                "methods": {
	                    "name": "methods"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                },
	                "uriParameters": {
	                    "name": "uriParameters"
	                }
	            }
	        },
	        "ResourceType": {
	            "name": "ResourceType",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "uses": {
	                    "name": "uses"
	                }
	            }
	        },
	        "ResourceTypeOrTrait": {
	            "name": "ResourceTypeOrTrait",
	            "properties": {
	                "usage": {
	                    "name": "usage"
	                },
	                "uses": {
	                    "name": "uses"
	                },
	                "parameters": {
	                    "name": "parameters"
	                }
	            }
	        },
	        "Method": {
	            "name": "Method",
	            "properties": {
	                "signature": {
	                    "name": "signature"
	                },
	                "method": {
	                    "name": "method"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "queryString": {
	                    "name": "queryString"
	                },
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "is": {
	                    "name": "is"
	                },
	                "annotations": {
	                    "name": "annotations"
	                },
	                "securedBy": {
	                    "name": "securedBy"
	                }
	            }
	        },
	        "Resource": {
	            "name": "Resource",
	            "properties": {
	                "signature": {
	                    "name": "signature"
	                },
	                "relativeUri": {
	                    "name": "relativeUri"
	                },
	                "resources": {
	                    "name": "resources"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "FileParameter": {
	            "name": "FileParameter",
	            "properties": {
	                "fileTypes": {
	                    "name": "fileTypes"
	                },
	                "minLength": {
	                    "name": "minLength"
	                },
	                "maxLength": {
	                    "name": "maxLength"
	                }
	            }
	        },
	        "HasNormalParameters": {
	            "name": "HasNormalParameters",
	            "properties": {
	                "queryParameters": {
	                    "name": "queryParameters"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "queryString": {
	                    "name": "queryString"
	                }
	            }
	        },
	        "RAMLLanguageElement": {
	            "name": "RAMLLanguageElement",
	            "properties": {
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "RAMLSimpleElement": {
	            "name": "RAMLSimpleElement",
	            "properties": {}
	        },
	        "AnnotationType": {
	            "name": "AnnotationType",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "parameters": {
	                    "name": "parameters"
	                },
	                "allowMultiple": {
	                    "name": "allowMultiple"
	                },
	                "allowedTargets": {
	                    "name": "allowedTargets"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                }
	            }
	        },
	        "AnnotationRef": {
	            "name": "AnnotationRef",
	            "properties": {}
	        },
	        "AnnotationTarget": {
	            "name": "AnnotationTarget",
	            "properties": {}
	        },
	        "Annotation": {
	            "name": "Annotation",
	            "properties": {
	                "name": {
	                    "name": "name"
	                }
	            }
	        },
	        "ExampleSpec": {
	            "name": "ExampleSpec",
	            "properties": {
	                "content": {
	                    "name": "content"
	                },
	                "strict": {
	                    "name": "strict"
	                },
	                "name": {
	                    "name": "name"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "DataElementProperty": {
	            "name": "DataElementProperty",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "required": {
	                    "name": "required"
	                }
	            }
	        },
	        "DataElement": {
	            "name": "DataElement",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "xml": {
	                    "name": "xml"
	                },
	                "facets": {
	                    "name": "facets"
	                },
	                "schema": {
	                    "name": "schema"
	                },
	                "usage": {
	                    "name": "usage"
	                },
	                "type": {
	                    "name": "type"
	                },
	                "location": {
	                    "name": "location"
	                },
	                "locationKind": {
	                    "name": "locationKind"
	                },
	                "default": {
	                    "name": "default"
	                },
	                "example": {
	                    "name": "example"
	                },
	                "examples": {
	                    "name": "examples"
	                },
	                "repeat": {
	                    "name": "repeat"
	                },
	                "required": {
	                    "name": "required"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "ScalarElement": {
	            "name": "ScalarElement",
	            "properties": {
	                "facets": {
	                    "name": "facets"
	                },
	                "enum": {
	                    "name": "enum"
	                }
	            }
	        },
	        "XMLInfo": {
	            "name": "XMLInfo",
	            "properties": {
	                "name": {
	                    "name": "name"
	                },
	                "namespace": {
	                    "name": "namespace"
	                },
	                "prefix": {
	                    "name": "prefix"
	                },
	                "attribute": {
	                    "name": "attribute"
	                },
	                "wrapped": {
	                    "name": "wrapped"
	                }
	            }
	        },
	        "ArrayField": {
	            "name": "ArrayField",
	            "properties": {
	                "uniqueItems": {
	                    "name": "uniqueItems"
	                },
	                "items": {
	                    "name": "items"
	                },
	                "minItems": {
	                    "name": "minItems"
	                },
	                "maxItems": {
	                    "name": "maxItems"
	                }
	            }
	        },
	        "UnionField": {
	            "name": "UnionField",
	            "properties": {
	                "discriminator": {
	                    "name": "discriminator"
	                }
	            }
	        },
	        "DataElementRef": {
	            "name": "DataElementRef",
	            "properties": {}
	        },
	        "ObjectField": {
	            "name": "ObjectField",
	            "properties": {
	                "properties": {
	                    "name": "properties"
	                },
	                "minProperties": {
	                    "name": "minProperties"
	                },
	                "maxProperties": {
	                    "name": "maxProperties"
	                },
	                "additionalProperties": {
	                    "name": "additionalProperties"
	                },
	                "patternProperties": {
	                    "name": "patternProperties"
	                },
	                "discriminator": {
	                    "name": "discriminator"
	                },
	                "discriminatorValue": {
	                    "name": "discriminatorValue"
	                }
	            }
	        },
	        "StrElement": {
	            "name": "StrElement",
	            "properties": {
	                "pattern": {
	                    "name": "pattern"
	                },
	                "minLength": {
	                    "name": "minLength"
	                },
	                "maxLength": {
	                    "name": "maxLength"
	                },
	                "enum": {
	                    "name": "enum"
	                }
	            }
	        },
	        "BooleanElement": {
	            "name": "BooleanElement",
	            "properties": {}
	        },
	        "ValueElement": {
	            "name": "ValueElement",
	            "properties": {}
	        },
	        "NumberElement": {
	            "name": "NumberElement",
	            "properties": {
	                "minimum": {
	                    "name": "minimum"
	                },
	                "maximum": {
	                    "name": "maximum"
	                },
	                "enum": {
	                    "name": "enum"
	                },
	                "format": {
	                    "name": "format"
	                },
	                "multipleOf": {
	                    "name": "multipleOf"
	                }
	            }
	        },
	        "IntegerElement": {
	            "name": "IntegerElement",
	            "properties": {
	                "format": {
	                    "name": "format"
	                }
	            }
	        },
	        "RAMLPointerElement": {
	            "name": "RAMLPointerElement",
	            "properties": {
	                "target": {
	                    "name": "target"
	                }
	            }
	        },
	        "pointer": {
	            "name": "pointer",
	            "properties": {}
	        },
	        "RAMLExpression": {
	            "name": "RAMLExpression",
	            "properties": {}
	        },
	        "ScriptHookElement": {
	            "name": "ScriptHookElement",
	            "properties": {
	                "declaredIn": {
	                    "name": "declaredIn"
	                },
	                "interfaceName": {
	                    "name": "interfaceName"
	                }
	            }
	        },
	        "SchemaElement": {
	            "name": "SchemaElement",
	            "properties": {}
	        },
	        "DateElement": {
	            "name": "DateElement",
	            "properties": {
	                "dateFormat": {
	                    "name": "dateFormat"
	                }
	            }
	        },
	        "ModelLocation": {
	            "name": "ModelLocation",
	            "properties": {}
	        },
	        "LocationKind": {
	            "name": "LocationKind",
	            "properties": {}
	        },
	        "MimeTypeModel": {
	            "name": "MimeTypeModel",
	            "properties": {
	                "type": {
	                    "name": "type"
	                },
	                "tree": {
	                    "name": "tree"
	                },
	                "subtype": {
	                    "name": "subtype"
	                },
	                "suffix": {
	                    "name": "suffix"
	                },
	                "parameters": {
	                    "name": "parameters"
	                }
	            }
	        },
	        "MimeType": {
	            "name": "MimeType",
	            "properties": {}
	        },
	        "Response": {
	            "name": "Response",
	            "properties": {
	                "code": {
	                    "name": "code"
	                },
	                "headers": {
	                    "name": "headers"
	                },
	                "body": {
	                    "name": "body"
	                },
	                "displayName": {
	                    "name": "displayName"
	                },
	                "description": {
	                    "name": "description"
	                },
	                "annotations": {
	                    "name": "annotations"
	                }
	            }
	        },
	        "Status": {
	            "name": "Status",
	            "properties": {
	                "code": {
	                    "name": "code"
	                },
	                "message": {
	                    "name": "message"
	                }
	            }
	        },
	        "AuthentificationState": {
	            "name": "AuthentificationState",
	            "properties": {}
	        },
	        "AuthentificationParameters": {
	            "name": "AuthentificationParameters",
	            "properties": {}
	        },
	        "AuthData": {
	            "name": "AuthData",
	            "properties": {
	                "authentificationParameters": {
	                    "name": "authentificationParameters"
	                }
	            }
	        },
	        "ParameterSpec": {
	            "name": "ParameterSpec",
	            "properties": {}
	        },
	        "PromptSpec": {
	            "name": "PromptSpec",
	            "properties": {}
	        },
	        "UserResponse": {
	            "name": "UserResponse",
	            "properties": {}
	        },
	        "QueryListener": {
	            "name": "QueryListener",
	            "properties": {}
	        },
	        "EndPoint": {
	            "name": "EndPoint",
	            "properties": {}
	        },
	        "EndPointSpec": {
	            "name": "EndPointSpec",
	            "properties": {
	                "url": {
	                    "name": "url"
	                },
	                "needToSendResponse": {
	                    "name": "needToSendResponse"
	                }
	            }
	        },
	        "SecurityEnvironment": {
	            "name": "SecurityEnvironment",
	            "properties": {}
	        },
	        "AuthentificationManager": {
	            "name": "AuthentificationManager",
	            "properties": {}
	        },
	        "SchemeInfo": {
	            "name": "SchemeInfo",
	            "properties": {
	                "parameterSpec": {
	                    "name": "parameterSpec"
	                }
	            }
	        },
	        "SecurityScheme": {
	            "name": "SecurityScheme",
	            "properties": {}
	        },
	        "SecurityAwareApiClient": {
	            "name": "SecurityAwareApiClient",
	            "properties": {}
	        },
	        "SecuritySchemeHook": {
	            "name": "SecuritySchemeHook",
	            "properties": {}
	        }
	    }
	};
	module.exports = Universes;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(3);
	var hl = __webpack_require__(2);
	var _ = __webpack_require__(4);
	var typeExpression = __webpack_require__(64);
	var search = __webpack_require__(65);
	var linter = __webpack_require__(72);
	var schema = __webpack_require__(73);
	function validate(str, node, cb) {
	    var x = str.trim();
	    if (x.length > 0) {
	        try {
	            if (x.charAt(0) == "{") {
	                schema.getJSONSchema(str);
	                //this is json schema
	                return;
	            }
	            if (x.charAt(0) == "<") {
	                schema.getXMLSchema(str);
	                //this is xsd schema
	                return;
	            }
	        }
	        catch (e) {
	            cb.accept(linter.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node));
	        }
	    }
	    var result = typeExpression.parse(str);
	    validateNode(result, node, cb);
	}
	exports.validate = validate;
	function getType(node, expression, defined, toRuntime) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    if (!expression) {
	        return node.definition().universe().getType("StrElement");
	    }
	    if (toRuntime) {
	        if (buildInsRuntime[expression]) {
	            var sm = node.definition().universe().getType(buildInsRuntime[expression]);
	            return sm;
	        }
	    }
	    if (buildIns[expression]) {
	        var qm = node.definition().universe().getType(buildIns[expression]);
	        return qm;
	    }
	    try {
	        var vl = expression;
	        vl = vl.trim();
	        if (vl.charAt(0) == '{') {
	            return null;
	        }
	        if (vl.charAt(0) == '<') {
	            return null;
	        }
	        var result = typeExpression.parse(expression);
	    }
	    catch (e) {
	        return null;
	    }
	    return deriveType(node, result, toRuntime, defined);
	}
	exports.getType = getType;
	/**
	 * Only use it for example validaation at this point, lets think about it after release.
	 * @param node
	 * @param expression
	 * @param defined
	 * @param toRuntime
	 * @returns {any}
	 */
	function getType2(node, expression, defined, toRuntime) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    if (!expression) {
	        return node.definition().universe().getType("StrElement");
	    }
	    if (toRuntime) {
	        if (buildInsRuntime[expression]) {
	            var sm = node.definition().universe().getType(buildInsRuntime[expression]);
	            if (sm) {
	                var ret = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, "", "");
	                ret._superTypes.push(sm);
	                return ret;
	            }
	        }
	    }
	    if (buildIns[expression]) {
	        var qm = node.definition().universe().getType(buildIns[expression]);
	        if (qm) {
	            var ret = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, "", "");
	            ret._superTypes.push(qm);
	            return ret;
	        }
	    }
	    try {
	        var vl = expression;
	        vl = vl.trim();
	        if (vl.charAt(0) == '{') {
	            return null;
	        }
	        if (vl.charAt(0) == '<') {
	            return null;
	        }
	        var result = typeExpression.parse(expression);
	    }
	    catch (e) {
	        return null;
	    }
	    return deriveType(node, result, toRuntime, defined);
	}
	exports.getType2 = getType2;
	var buildIns = {
	    string: "StrElement",
	    number: "NumberElement",
	    integer: "IntegerElement",
	    date: "DateElement",
	    object: "ObjectField",
	    boolean: "BooleanElement",
	    value: "ValueElement",
	    file: "FileParameter"
	};
	var buildInsRuntime = {
	    string: "string",
	    number: "number",
	    integer: "integer",
	    date: "date",
	    object: "ObjectField",
	    boolean: "boolean",
	    value: "string",
	    file: "file"
	};
	var counter = 0;
	function deriveType(node, r, toRuntime, defining) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    if (defining === void 0) { defining = {}; }
	    if (r.type == "union") {
	        var u = r;
	        var left = deriveType(node, u.first, toRuntime, defining);
	        var right = deriveType(node, u.rest, toRuntime, defining);
	        var ut = node.definition().universe().getType("UnionField");
	        var union = new defs.Union("Union" + (counter++), node.definition().universe(), "");
	        union._superTypes.push(ut);
	        union.left = left;
	        union.right = right;
	        return union;
	    }
	    if (r.type == 'responses') {
	        var res = r;
	        var result = null;
	        res.codes.forEach(function (t) {
	            var tp = deriveType(node, t.expr, toRuntime, defining);
	            if (tp) {
	                if (!result) {
	                    result = tp;
	                }
	                else {
	                    var union = new defs.Union("Union" + (counter++), node.definition().universe(), "");
	                    union.left = result;
	                    union.right = tp;
	                    result = tp;
	                }
	            }
	        });
	        return result;
	    }
	    if (r.type == 'parens') {
	        var ex = r;
	        return deriveType(node, ex.expr, toRuntime, defining);
	    }
	    if (r.type == 'name') {
	        var l = r;
	        var val = l.value;
	        var ind = val.lastIndexOf("[]");
	        if (ind != -1 && ind == val.length - 2) {
	            val = val.substr(0, val.length - 2); //FIXME Should be in PEG
	        }
	        if (l.arr > 0) {
	            var types = search.subTypesWithLocals(node.definition().universe().getType("DataElement"), node);
	            var tp = _.find(types, function (x) {
	                var c = x.nameId() == val;
	                if (!c) {
	                    if (x instanceof defs.AbstractType) {
	                        var at = x;
	                        at.getAliases().forEach(function (y) {
	                            if (y == val) {
	                                c = true;
	                            }
	                        });
	                    }
	                }
	                return c;
	            });
	            if (!tp) {
	                //TOD make it simpler
	                if (toRuntime || true) {
	                    //it is always runtime model when we are here
	                    if (buildInsRuntime[val]) {
	                        tp = node.definition().universe().getType(buildInsRuntime[val]);
	                    }
	                }
	                else if (buildIns[val]) {
	                    tp = node.definition().universe().getType(buildIns[val]);
	                }
	            }
	            if (!tp) {
	                tp = new defs.ValueType("String", node.definition().universe(), "");
	            }
	            var at = node.definition().universe().getType("ArrayField");
	            var arr = new defs.Array(tp.nameId() + "[]", node.definition().universe(), "");
	            arr._superTypes.push(at);
	            arr.component = tp;
	            arr.dimensions = l.arr;
	            return arr;
	        }
	        if (toRuntime) {
	            if (buildInsRuntime[val]) {
	                return node.definition().universe().getType(buildInsRuntime[val]);
	            }
	        }
	        if (buildIns[val]) {
	            return node.definition().universe().getType(buildIns[val]);
	        }
	        var de = node.definition().universe().getType("DataElement");
	        if (!de) {
	            de = node.definition().universe().getType("GlobalSchema");
	        }
	        //if (defining[val]){
	        //    return defining[val];
	        //}
	        var qm = search.subTypesWithName(val, node, defining);
	        if (qm) {
	            return qm;
	        }
	        //return null;
	        de = node.definition().universe().getType("GlobalSchema");
	        return search.schemasWithName(val, node, defining);
	    }
	    return null;
	}
	exports.deriveType = deriveType;
	function nodeToString(r) {
	    if (r.type == "union") {
	        var u = r;
	        return nodeToString(u.first) + "|" + nodeToString(u.rest);
	    }
	    if (r.type == "responses") {
	        var res = r;
	        var rs = "{";
	        for (var i = 0; i < res.codes.length; i++) {
	            rs += res.codes[i].code;
	            rs += ":";
	            rs += nodeToString(res.codes[i].expr);
	            if (i != res.codes.length - 1) {
	                rs += ",";
	            }
	        }
	        rs += '}';
	        return rs;
	    }
	    if (r.type == 'parens') {
	        var ex = r;
	        var pr = "(" + nodeToString(ex.expr) + ")";
	        if (ex.arr) {
	            pr += "[]";
	        }
	        return pr;
	    }
	    if (r.type == 'name') {
	        var l = r;
	        var val = l.value;
	        var pr = val;
	        if (l.arr) {
	            pr += "[]";
	        }
	        return pr;
	    }
	}
	exports.nodeToString = nodeToString;
	function validateNode(r, node, cb) {
	    if (r.type == "union") {
	        var u = r;
	        validateNode(u.first, node, cb);
	        validateNode(u.rest, node, cb);
	    }
	    if (r.type == "responses") {
	        var res = r;
	        res.codes.forEach(function (x) {
	            var v = x.code;
	            for (var i = 0; i < v.length; i++) {
	                var c = v[i];
	                if (!_.find(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'x', 'X'], function (x) { return x == c; })) {
	                    cb.accept(linter.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Status code should be 3 digits number with optional 'x' as wildcards", node));
	                    return;
	                }
	            }
	            validateNode(x.expr, node, cb);
	        });
	    }
	    if (r.type == 'parens') {
	        var ex = r;
	        validateNode(ex.expr, node, cb);
	    }
	    if (r.type == 'name') {
	        var l = r;
	        var val = l.value;
	        if (val.lastIndexOf("[]") != -1) {
	            val = val.substr(0, val.length - 2); //FIXME Should be in PEG
	        }
	        var pr = node.property();
	        if (pr.isValidValue(val, node.parent())) {
	            return;
	        }
	        var values = pr.enumValues(node.parent());
	        values = values.map(function (x) {
	            var tp = x.indexOf("<");
	            if (tp != -1) {
	                return x.substring(0, tp);
	            }
	            return x;
	        });
	        if (l.params) {
	            l.params.forEach(function (x) {
	                validateNode(x, node, cb);
	            });
	        }
	        values.push("number");
	        values.push("integer");
	        values.push("file");
	        values.push("boolean");
	        values.push("any");
	        values.push("date");
	        values.push("void");
	        values.push("string");
	        values.push("value");
	        if (!_.find(values, function (x) { return x == val; })) {
	            cb.accept(linter.createIssue(0 /* UNRESOLVED_REFERENCE */, "Unresolved reference:" + val, node));
	            return true;
	        }
	    }
	}
	exports.validateNode = validateNode;


/***/ },
/* 64 */
/***/ function(module, exports) {

	var parser = (function () {
	    "use strict";
	    /*
	     * Generated by PEG.js 0.9.0.
	     *
	     * http://pegjs.org/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() {
	            this.constructor = child;
	        }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function peg$SyntaxError(message, expected, found, location) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.location = location;
	        this.name = "SyntaxError";
	        if (typeof Error.captureStackTrace === "function") {
	            Error.captureStackTrace(this, peg$SyntaxError);
	        }
	    }
	    peg$subclass(peg$SyntaxError, Error);
	    function peg$parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, parser = this, peg$FAILED = {}, peg$startRuleFunctions = { Term: peg$parseTerm }, peg$startRuleFunction = peg$parseTerm, peg$c0 = "|", peg$c1 = { type: "literal", value: "|", description: "\"|\"" }, peg$c2 = function (first, rest) {
	            return rest ? { "type": "union", "first": first, "rest": rest[3] } : first;
	        }, peg$c3 = "(", peg$c4 = { type: "literal", value: "(", description: "\"(\"" }, peg$c5 = ")", peg$c6 = { type: "literal", value: ")", description: "\")\"" }, peg$c7 = "[]", peg$c8 = { type: "literal", value: "[]", description: "\"[]\"" }, peg$c9 = function (expr, arr) {
	            return { "type": "parens", "expr": expr, "arr": arr.length };
	        }, peg$c10 = "<", peg$c11 = { type: "literal", value: "<", description: "\"<\"" }, peg$c12 = ">", peg$c13 = { type: "literal", value: ">", description: "\">\"" }, peg$c14 = function (first, other) {
	            return [first].concat(other);
	        }, peg$c15 = ",", peg$c16 = { type: "literal", value: ",", description: "\",\"" }, peg$c17 = function (r) {
	            return r;
	        }, peg$c18 = { type: "other", description: "name" }, peg$c19 = function (r, tp, c) {
	            return { "type": "name", "params": tp, "value": r.join(""), "arr": (c.length) };
	        }, peg$c20 = { type: "other", description: "whitespace" }, peg$c21 = /^[ \t\n\r]/, peg$c22 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" }, peg$c23 = /^[A-Z]/, peg$c24 = { type: "class", value: "[A-Z]", description: "[A-Z]" }, peg$c25 = "_", peg$c26 = { type: "literal", value: "_", description: "\"_\"" }, peg$c27 = "-", peg$c28 = { type: "literal", value: "-", description: "\"-\"" }, peg$c29 = ".", peg$c30 = { type: "literal", value: ".", description: "\".\"" }, peg$c31 = /^[a-z]/, peg$c32 = { type: "class", value: "[a-z]", description: "[a-z]" }, peg$c33 = /^[0-9]/, peg$c34 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1, seenCR: false }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$savedPos, peg$currPos);
	        }
	        function location() {
	            return peg$computeLocation(peg$savedPos, peg$currPos);
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function error(message) {
	            throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));
	        }
	        function peg$computePosDetails(pos) {
	            var details = peg$posDetailsCache[pos], p, ch;
	            if (details) {
	                return details;
	            }
	            else {
	                p = pos - 1;
	                while (!peg$posDetailsCache[p]) {
	                    p--;
	                }
	                details = peg$posDetailsCache[p];
	                details = {
	                    line: details.line,
	                    column: details.column,
	                    seenCR: details.seenCR
	                };
	                while (p < pos) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                    p++;
	                }
	                peg$posDetailsCache[pos] = details;
	                return details;
	            }
	        }
	        function peg$computeLocation(startPos, endPos) {
	            var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
	            return {
	                start: {
	                    offset: startPos,
	                    line: startPosDetails.line,
	                    column: startPosDetails.column
	                },
	                end: {
	                    offset: endPos,
	                    line: endPosDetails.line,
	                    column: endPosDetails.column
	                }
	            };
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, found, location) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) {
	                        return ch.charCodeAt(0).toString(16).toUpperCase();
	                    }
	                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
	                        return '\\x0' + hex(ch);
	                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
	                        return '\\x' + hex(ch);
	                    }).replace(/[\u0100-\u0FFF]/g, function (ch) {
	                        return '\\u0' + hex(ch);
	                    }).replace(/[\u1000-\uFFFF]/g, function (ch) {
	                        return '\\u' + hex(ch);
	                    });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);
	        }
	        function peg$parseTerm() {
	            var s0, s1, s2, s3, s4, s5, s6, s7;
	            s0 = peg$currPos;
	            s1 = peg$parse_();
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseFactor();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$currPos;
	                    s4 = peg$parse_();
	                    if (s4 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 124) {
	                            s5 = peg$c0;
	                            peg$currPos++;
	                        }
	                        else {
	                            s5 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c1);
	                            }
	                        }
	                        if (s5 !== peg$FAILED) {
	                            s6 = peg$parse_();
	                            if (s6 !== peg$FAILED) {
	                                s7 = peg$parseTerm();
	                                if (s7 !== peg$FAILED) {
	                                    s4 = [s4, s5, s6, s7];
	                                    s3 = s4;
	                                }
	                                else {
	                                    peg$currPos = s3;
	                                    s3 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s3;
	                                s3 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s3;
	                            s3 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s3;
	                        s3 = peg$FAILED;
	                    }
	                    if (s3 === peg$FAILED) {
	                        s3 = null;
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c2(s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseFactor() {
	            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 40) {
	                s1 = peg$c3;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c4);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parse_();
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseTerm();
	                    if (s3 !== peg$FAILED) {
	                        s4 = peg$parse_();
	                        if (s4 !== peg$FAILED) {
	                            if (input.charCodeAt(peg$currPos) === 41) {
	                                s5 = peg$c5;
	                                peg$currPos++;
	                            }
	                            else {
	                                s5 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c6);
	                                }
	                            }
	                            if (s5 !== peg$FAILED) {
	                                s6 = [];
	                                s7 = peg$currPos;
	                                s8 = peg$parse_();
	                                if (s8 !== peg$FAILED) {
	                                    if (input.substr(peg$currPos, 2) === peg$c7) {
	                                        s9 = peg$c7;
	                                        peg$currPos += 2;
	                                    }
	                                    else {
	                                        s9 = peg$FAILED;
	                                        if (peg$silentFails === 0) {
	                                            peg$fail(peg$c8);
	                                        }
	                                    }
	                                    if (s9 !== peg$FAILED) {
	                                        s8 = [s8, s9];
	                                        s7 = s8;
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                else {
	                                    peg$currPos = s7;
	                                    s7 = peg$FAILED;
	                                }
	                                while (s7 !== peg$FAILED) {
	                                    s6.push(s7);
	                                    s7 = peg$currPos;
	                                    s8 = peg$parse_();
	                                    if (s8 !== peg$FAILED) {
	                                        if (input.substr(peg$currPos, 2) === peg$c7) {
	                                            s9 = peg$c7;
	                                            peg$currPos += 2;
	                                        }
	                                        else {
	                                            s9 = peg$FAILED;
	                                            if (peg$silentFails === 0) {
	                                                peg$fail(peg$c8);
	                                            }
	                                        }
	                                        if (s9 !== peg$FAILED) {
	                                            s8 = [s8, s9];
	                                            s7 = s8;
	                                        }
	                                        else {
	                                            peg$currPos = s7;
	                                            s7 = peg$FAILED;
	                                        }
	                                    }
	                                    else {
	                                        peg$currPos = s7;
	                                        s7 = peg$FAILED;
	                                    }
	                                }
	                                if (s6 !== peg$FAILED) {
	                                    peg$savedPos = s0;
	                                    s1 = peg$c9(s3, s6);
	                                    s0 = s1;
	                                }
	                                else {
	                                    peg$currPos = s0;
	                                    s0 = peg$FAILED;
	                                }
	                            }
	                            else {
	                                peg$currPos = s0;
	                                s0 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseLiteral();
	            }
	            return s0;
	        }
	        function peg$parseTypeParams() {
	            var s0, s1, s2, s3, s4;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 60) {
	                s1 = peg$c10;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c11);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$parseExtraParam();
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$parseExtraParam();
	                    }
	                    if (s3 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 62) {
	                            s4 = peg$c12;
	                            peg$currPos++;
	                        }
	                        else {
	                            s4 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c13);
	                            }
	                        }
	                        if (s4 !== peg$FAILED) {
	                            peg$savedPos = s0;
	                            s1 = peg$c14(s2, s3);
	                            s0 = s1;
	                        }
	                        else {
	                            peg$currPos = s0;
	                            s0 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseExtraParam() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 44) {
	                s1 = peg$c15;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c16);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTerm();
	                if (s2 !== peg$FAILED) {
	                    peg$savedPos = s0;
	                    s1 = peg$c17(s2);
	                    s0 = s1;
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            return s0;
	        }
	        function peg$parseLiteral() {
	            var s0, s1, s2, s3, s4, s5, s6;
	            peg$silentFails++;
	            s0 = peg$currPos;
	            s1 = [];
	            s2 = peg$parsechar();
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    s2 = peg$parsechar();
	                }
	            }
	            else {
	                s1 = peg$FAILED;
	            }
	            if (s1 !== peg$FAILED) {
	                s2 = peg$parseTypeParams();
	                if (s2 === peg$FAILED) {
	                    s2 = null;
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = [];
	                    s4 = peg$currPos;
	                    s5 = peg$parse_();
	                    if (s5 !== peg$FAILED) {
	                        if (input.substr(peg$currPos, 2) === peg$c7) {
	                            s6 = peg$c7;
	                            peg$currPos += 2;
	                        }
	                        else {
	                            s6 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c8);
	                            }
	                        }
	                        if (s6 !== peg$FAILED) {
	                            s5 = [s5, s6];
	                            s4 = s5;
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    else {
	                        peg$currPos = s4;
	                        s4 = peg$FAILED;
	                    }
	                    while (s4 !== peg$FAILED) {
	                        s3.push(s4);
	                        s4 = peg$currPos;
	                        s5 = peg$parse_();
	                        if (s5 !== peg$FAILED) {
	                            if (input.substr(peg$currPos, 2) === peg$c7) {
	                                s6 = peg$c7;
	                                peg$currPos += 2;
	                            }
	                            else {
	                                s6 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c8);
	                                }
	                            }
	                            if (s6 !== peg$FAILED) {
	                                s5 = [s5, s6];
	                                s4 = s5;
	                            }
	                            else {
	                                peg$currPos = s4;
	                                s4 = peg$FAILED;
	                            }
	                        }
	                        else {
	                            peg$currPos = s4;
	                            s4 = peg$FAILED;
	                        }
	                    }
	                    if (s3 !== peg$FAILED) {
	                        peg$savedPos = s0;
	                        s1 = peg$c19(s1, s2, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c18);
	                }
	            }
	            return s0;
	        }
	        function peg$parse_() {
	            var s0, s1;
	            peg$silentFails++;
	            s0 = [];
	            if (peg$c21.test(input.charAt(peg$currPos))) {
	                s1 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c22);
	                }
	            }
	            while (s1 !== peg$FAILED) {
	                s0.push(s1);
	                if (peg$c21.test(input.charAt(peg$currPos))) {
	                    s1 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                }
	                else {
	                    s1 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c22);
	                    }
	                }
	            }
	            peg$silentFails--;
	            if (s0 === peg$FAILED) {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c20);
	                }
	            }
	            return s0;
	        }
	        function peg$parsechar() {
	            var s0;
	            if (peg$c23.test(input.charAt(peg$currPos))) {
	                s0 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c24);
	                }
	            }
	            if (s0 === peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 95) {
	                    s0 = peg$c25;
	                    peg$currPos++;
	                }
	                else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c26);
	                    }
	                }
	                if (s0 === peg$FAILED) {
	                    if (input.charCodeAt(peg$currPos) === 45) {
	                        s0 = peg$c27;
	                        peg$currPos++;
	                    }
	                    else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c28);
	                        }
	                    }
	                    if (s0 === peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 46) {
	                            s0 = peg$c29;
	                            peg$currPos++;
	                        }
	                        else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) {
	                                peg$fail(peg$c30);
	                            }
	                        }
	                        if (s0 === peg$FAILED) {
	                            if (peg$c31.test(input.charAt(peg$currPos))) {
	                                s0 = input.charAt(peg$currPos);
	                                peg$currPos++;
	                            }
	                            else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) {
	                                    peg$fail(peg$c32);
	                                }
	                            }
	                            if (s0 === peg$FAILED) {
	                                if (peg$c33.test(input.charAt(peg$currPos))) {
	                                    s0 = input.charAt(peg$currPos);
	                                    peg$currPos++;
	                                }
	                                else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) {
	                                        peg$fail(peg$c34);
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
	        }
	    }
	    return {
	        SyntaxError: peg$SyntaxError,
	        parse: peg$parse
	    };
	})();
	module.exports = parser;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(3);
	var hl = __webpack_require__(2);
	var _ = __webpack_require__(4);
	var typeExpression = __webpack_require__(63);
	var hlimpl = __webpack_require__(5);
	var universes = __webpack_require__(62);
	var typeBuilder = __webpack_require__(66);
	//FIXME CORRECTLY STRUCTURE IT
	function resolveRamlPointer(point, path) {
	    var components = path.split(".");
	    var currentNode = point;
	    if (currentNode.definition().isAnnotation()) {
	        currentNode = currentNode.parent();
	    }
	    components.forEach(function (x) {
	        if (currentNode == null) {
	            return;
	        }
	        if (x == '$parent') {
	            currentNode = currentNode.parent();
	            return;
	        }
	        if (x == '$root') {
	            currentNode = currentNode.root();
	            return;
	        }
	        if (x == '$top') {
	            currentNode = exports.declRoot(currentNode);
	            return;
	        }
	        var newEl = _.find(currentNode.elements(), function (y) { return y.name() == x; });
	        currentNode = newEl;
	    });
	    return currentNode;
	}
	exports.resolveRamlPointer = resolveRamlPointer;
	exports.declRoot = function (h) {
	    var declRoot = h;
	    while (true) {
	        if (declRoot.definition().key() == universes.Universe10.Library) {
	            break;
	        }
	        var np = declRoot.parent();
	        if (!np) {
	            break;
	        }
	        declRoot = np;
	    }
	    return declRoot;
	};
	function globalDeclarations(h) {
	    var decl = exports.declRoot(h);
	    return findDeclarations(decl);
	}
	exports.globalDeclarations = globalDeclarations;
	function mark(h, rs) {
	    var n = h.lowLevel();
	    n = n._node ? n._node : n;
	    if (n['mark']) {
	        return rs;
	    }
	    n['mark'] = rs;
	    return null;
	}
	function unmark(h) {
	    var n = h.lowLevel();
	    n = n._node ? n._node : n;
	    delete n['mark'];
	}
	function findDeclarations(h) {
	    var rs = [];
	    var q = mark(h, rs);
	    if (q) {
	    }
	    try {
	        h.elements().forEach(function (x) {
	            if (x.definition().key() == universes.Universe10.Library) {
	                rs = rs.concat(findDeclarations(x));
	            }
	            rs.push(x);
	        });
	        return rs;
	    }
	    finally {
	        unmark(h);
	    }
	}
	exports.findDeclarations = findDeclarations;
	function getIndent2(offset, text) {
	    var spaces = "";
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == ' ' || c == '\t') {
	            if (spaces) {
	                spaces += c;
	            }
	            else {
	                spaces = c;
	            }
	        }
	        else if (c == '\r' || c == '\n') {
	            return spaces;
	        }
	    }
	}
	function deepFindNode(n, offset, end, goToOtherUnits) {
	    if (goToOtherUnits === void 0) { goToOtherUnits = true; }
	    if (n == null) {
	        return null;
	    }
	    if (n.lowLevel()) {
	        //var node:ASTNode=<ASTNode>n;
	        if (n.lowLevel().start() <= offset && n.lowLevel().end() >= end) {
	            if (n instanceof hlimpl.ASTNodeImpl) {
	                var hn = n;
	                var all = goToOtherUnits ? hn.children() : hn.directChildren();
	                for (var i = 0; i < all.length; i++) {
	                    if (!goToOtherUnits && all[i].lowLevel().unit() != n.lowLevel().unit()) {
	                        continue;
	                    }
	                    var node = deepFindNode(all[i], offset, end, goToOtherUnits);
	                    if (node) {
	                        return node;
	                    }
	                }
	                return n;
	            }
	            if (n instanceof hlimpl.ASTPropImpl) {
	                var attr = n;
	                if (!attr.property().isKey()) {
	                    var vl = attr.value();
	                    if (vl instanceof hlimpl.StructuredValue) {
	                        var st = vl;
	                        var hl = st.toHighlevel();
	                        if (hl) {
	                            if (!goToOtherUnits && hl.lowLevel().unit() != n.lowLevel().unit()) {
	                                return null;
	                            }
	                        }
	                        var node = deepFindNode(hl, offset, end, goToOtherUnits);
	                        if (node) {
	                            return node;
	                        }
	                    }
	                    return attr;
	                }
	                return null;
	            }
	            return n;
	        }
	    }
	    return null;
	}
	function getValueAt(text, offset) {
	    var sp = -1;
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
	            sp = i + 1;
	            break;
	        }
	    }
	    var ep = -1;
	    for (var i = offset; i < text.length; i++) {
	        var c = text.charAt(i);
	        if (c == '\r' || c == '\n' || c == ' ' || c == '\t' || c == '"' || c == '\'' || c == ':') {
	            ep = i;
	            break;
	        }
	    }
	    if (sp != -1 && ep != -1) {
	        return text.substring(sp, ep);
	    }
	    return "";
	}
	function extractName(cleaned, offset) {
	    var txt = "";
	    for (var i = offset; i >= 0; i--) {
	        var c = cleaned[i];
	        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
	            break;
	        }
	        txt = c + txt;
	    }
	    for (var i = offset + 1; i < cleaned.length; i++) {
	        var c = cleaned[i];
	        if (c == ' ' || c == '\r' || c == '\n' || c == '|' || c == '[' || c == ']' || c == ':' || c == '(' || c == ')') {
	            break;
	        }
	        txt = txt + c;
	    }
	    return txt;
	}
	exports.extractName = extractName;
	var searchInTheValue = function (offset, content, attr, hlnode, p) {
	    if (p === void 0) { p = attr.property(); }
	    var targets = p.referenceTargets(hlnode);
	    var txt = extractName(content, offset);
	    var t = _.find(targets, function (x) { return hlimpl.qName(x, hlnode) == txt; });
	    if (t) {
	        //TODO EXTRACT COMMON OPEN NODE FUNC
	        return t;
	    }
	    if (attr.property() instanceof defs.UserDefinedProp) {
	        var up = attr.property();
	        return up._node;
	    }
	    return null;
	};
	function findUsages(unit, offset) {
	    var decl = findDeclaration(unit, offset);
	    if (decl) {
	        if (decl instanceof hlimpl.ASTNodeImpl) {
	            var hnode = decl;
	            return { node: hnode, results: hnode.findReferences() };
	        }
	        if (decl instanceof hlimpl.ASTPropImpl) {
	        }
	    }
	    var node = deepFindNode(hl.fromUnit(unit), offset, offset, false);
	    if (node instanceof hlimpl.ASTNodeImpl) {
	        return { node: node, results: node.findReferences() };
	    }
	    if (node instanceof hlimpl.ASTPropImpl) {
	        var prop = node;
	        if (prop.property().canBeValue()) {
	            return { node: prop.parent(), results: prop.parent().findReferences() };
	        }
	    }
	    return { node: null, results: [] };
	}
	exports.findUsages = findUsages;
	function findDeclaration(unit, offset) {
	    var node = deepFindNode(hl.fromUnit(unit), offset, offset, false);
	    var kind = determineCompletionKind(unit.contents(), offset);
	    if (kind == 0 /* VALUE_COMPLETION */) {
	        var hlnode = node;
	        if (node instanceof hlimpl.ASTPropImpl) {
	            var attr = node;
	            if (attr) {
	                if (attr.value()) {
	                    if (attr.value() instanceof hlimpl.StructuredValue) {
	                        var sval = attr.value();
	                        var hlvalue = sval.toHighlevel();
	                        if (hlvalue) {
	                            var newAttr = _.find(hlvalue.attrs(), function (x) { return x.lowLevel().start() < offset && x.lowLevel().end() >= offset; });
	                            if (newAttr) {
	                                return searchInTheValue(offset, unit.contents(), newAttr, hlvalue, attr.property());
	                            }
	                        }
	                    }
	                    else {
	                        return searchInTheValue(offset, unit.contents(), attr, hlnode);
	                    }
	                }
	            }
	        }
	    }
	    if (kind == 1 /* KEY_COMPLETION */ || kind == 6 /* SEQUENCE_KEY_COPLETION */) {
	        var hlnode = node;
	        var pp = node.property();
	        if (pp instanceof defs.UserDefinedProp) {
	            var up = pp;
	            return up.node();
	        }
	        if (node instanceof hlimpl.ASTNodeImpl) {
	            if (hlnode.definition() instanceof defs.UserDefinedClass) {
	                var uc = hlnode.definition();
	                if (uc.isAssignableFrom("DataElement")) {
	                    return node;
	                }
	                return uc.getDeclaringNode();
	            }
	        }
	        if (node instanceof hlimpl.ASTPropImpl) {
	            var pr = node;
	            if (isExampleNodeContent(pr)) {
	                var contentType = findExampleContentType(pr);
	                if (contentType) {
	                    var documentationRoot = parseDocumentationContent(pr, contentType.toRuntime());
	                    if (documentationRoot) {
	                        var node = deepFindNode(documentationRoot, offset, offset);
	                        pp = node.property();
	                        if (pp instanceof defs.UserDefinedProp) {
	                            var up = pp;
	                            return up.node();
	                        }
	                        if (node instanceof hlimpl.ASTNodeImpl) {
	                            if (hlnode.definition() instanceof defs.UserDefinedClass) {
	                                var uc = hlnode.definition();
	                                return uc.getDeclaringNode();
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	    if (kind == 2 /* PATH_COMPLETION */) {
	        var inclpath = getValueAt(unit.contents(), offset);
	        if (inclpath) {
	            var ap = unit.resolve(inclpath);
	            return ap;
	        }
	    }
	}
	exports.findDeclaration = findDeclaration;
	function findExampleContentType(node) {
	    var p = node.parent();
	    if (node.property().nameId() == universes.Universe10.ExampleSpec.properties.content.name) {
	        p = p.parent();
	    }
	    return hlimpl.typeFromNode(p);
	}
	exports.findExampleContentType = findExampleContentType;
	function parseDocumentationContent(attribute, type) {
	    if (!(attribute.value() instanceof hlimpl.StructuredValue)) {
	        return null;
	    }
	    return new hlimpl.ASTNodeImpl(attribute.value().lowLevel(), attribute.parent(), type, attribute.property());
	}
	exports.parseDocumentationContent = parseDocumentationContent;
	function isExampleNodeContent(node) {
	    if (!(node instanceof hlimpl.ASTPropImpl)) {
	        return false;
	    }
	    var property = node;
	    if (universes.Universe10.ExampleSpec.properties.content.name == property.name() && property.isString()) {
	        if (property.parent() instanceof hlimpl.ASTNodeImpl && (universes.Universe10.DataElement.properties.examples.name == property.parent().property().nameId() || universes.Universe10.DataElement.properties.example.name == property.parent().property().nameId())) {
	            if (property.parent().parent() instanceof hlimpl.ASTNodeImpl && property.parent().parent().definition().isAssignableFrom(universes.Universe10.ObjectField.name)) {
	                return true;
	            }
	        }
	    }
	    else if (universes.Universe10.DataElement.properties.example.name == property.name() && property.isString()) {
	        if (property.parent() instanceof hlimpl.ASTNodeImpl && property.parent().definition().isAssignableFrom(universes.Universe10.ObjectField.name)) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.isExampleNodeContent = isExampleNodeContent;
	function determineCompletionKind(text, offset) {
	    var hasIn = false;
	    var hasSeq = false;
	    var canBeInComment = false;
	    var canBeAnnotation = false;
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '(') {
	            canBeAnnotation = true;
	        }
	        else if (canBeAnnotation) {
	            if (c == '\r' || c == '\n') {
	                var hasClosing = false;
	                for (var j = offset - 1; j < text.length; j++) {
	                    var ch = text[j];
	                    if (ch == ')') {
	                        hasClosing = true;
	                    }
	                    if (ch == '\r' || ch == "\n") {
	                        break;
	                    }
	                    if (ch == ':') {
	                        canBeAnnotation = false;
	                        break;
	                    }
	                }
	                if (canBeAnnotation && hasClosing) {
	                    return 5 /* ANNOTATION_COMPLETION */;
	                }
	                else {
	                    break;
	                }
	            }
	            if (c == ' ' || c == '\t') {
	                continue;
	            }
	            else {
	                break;
	            }
	        }
	        else {
	            if (c == '\r' || c == '\n') {
	                break;
	            }
	            if (c == ':') {
	                break;
	            }
	        }
	    }
	    for (var i = offset - 1; i >= 0; i--) {
	        var c = text.charAt(i);
	        if (c == '#') {
	            if (i == 0) {
	                return 4 /* VERSION_COMPLETION */;
	            }
	            return 7 /* INCOMMENT */;
	        }
	        if (c == ':') {
	            if (hasIn) {
	                return 3 /* DIRECTIVE_COMPLETION */;
	            }
	            return 0 /* VALUE_COMPLETION */;
	        }
	        if (c == '\r' || c == '\n') {
	            //check for multiline literal
	            var insideOfMultiline = false;
	            var ind = getIndent2(offset, text);
	            for (var a = i; a > 0; a--) {
	                c = text.charAt(a);
	                //TODO this can be further improved
	                if (c == ':') {
	                    if (insideOfMultiline) {
	                        var ll = getIndent2(a, text);
	                        if (ll.length < ind.length) {
	                            return 0 /* VALUE_COMPLETION */;
	                        }
	                    }
	                    break;
	                }
	                if (c == '|') {
	                    insideOfMultiline = true;
	                    continue;
	                }
	                if (c == '\r' || c == '\n') {
	                    insideOfMultiline = false;
	                }
	                if (c != ' ' && c != '\t') {
	                    insideOfMultiline = false;
	                }
	            }
	            if (hasSeq) {
	                return 6 /* SEQUENCE_KEY_COPLETION */;
	            }
	            return 1 /* KEY_COMPLETION */;
	        }
	        if (c == '-') {
	            hasSeq = true;
	        }
	        if (c == '!') {
	            if (text.indexOf("!include", i) == i) {
	                return 2 /* PATH_COMPLETION */;
	            }
	            if (text.indexOf("!i", i) == i) {
	                hasIn = true;
	            }
	        }
	    }
	}
	exports.determineCompletionKind = determineCompletionKind;
	(function (LocationKind) {
	    LocationKind[LocationKind["VALUE_COMPLETION"] = 0] = "VALUE_COMPLETION";
	    LocationKind[LocationKind["KEY_COMPLETION"] = 1] = "KEY_COMPLETION";
	    LocationKind[LocationKind["PATH_COMPLETION"] = 2] = "PATH_COMPLETION";
	    LocationKind[LocationKind["DIRECTIVE_COMPLETION"] = 3] = "DIRECTIVE_COMPLETION";
	    LocationKind[LocationKind["VERSION_COMPLETION"] = 4] = "VERSION_COMPLETION";
	    LocationKind[LocationKind["ANNOTATION_COMPLETION"] = 5] = "ANNOTATION_COMPLETION";
	    LocationKind[LocationKind["SEQUENCE_KEY_COPLETION"] = 6] = "SEQUENCE_KEY_COPLETION";
	    LocationKind[LocationKind["INCOMMENT"] = 7] = "INCOMMENT";
	})(exports.LocationKind || (exports.LocationKind = {}));
	var LocationKind = exports.LocationKind;
	function resolveReference(point, path) {
	    if (!path) {
	        return null;
	    }
	    var sp = path.split("/");
	    var result = point;
	    for (var i = 0; i < sp.length; i++) {
	        if (sp[i] == '#') {
	            result = point.unit().ast();
	            continue;
	        }
	        result = _.find(result.children(), function (x) { return x.key() == sp[i]; });
	        if (!result) {
	            return null;
	        }
	    }
	    return result;
	}
	exports.resolveReference = resolveReference;
	/**
	 * return all sub types of given type visible from parent node
	 * @param range
	 * @param parentNode
	 * @returns ITypeDefinition[]
	 */
	exports.subTypesWithLocals = function (range, parentNode) {
	    if (range == null) {
	        return [];
	    }
	    var name = range.nameId();
	    parentNode = exports.declRoot(parentNode);
	    var actual = parentNode;
	    if (actual._subTypesCache) {
	        var cached = actual._subTypesCache[name];
	        if (cached) {
	            return cached;
	        }
	    }
	    else {
	        actual._subTypesCache = {};
	    }
	    var result = range.allSubTypes();
	    if (range.getRuntimeExtenders().length > 0 && parentNode) {
	        var decls = globalDeclarations(parentNode);
	        var extenders = range.getRuntimeExtenders();
	        var root = parentNode.root();
	        extenders.forEach(function (x) {
	            var definitionNodes = decls.filter(function (z) {
	                var def = z.definition().allSuperTypes();
	                def.push(z.definition());
	                var rr = (z.definition() == x) || (_.find(def, function (d) { return d == x; }) != null) || (_.find(def, function (d) { return d == range; }) != null);
	                return rr;
	            });
	            result = result.concat(definitionNodes.map(function (x) { return typeBuilder.typeFromNode(x); }));
	        });
	    }
	    result = _.unique(result);
	    actual._subTypesCache[name] = result;
	    return result;
	};
	exports.subTypesWithName = function (tname, parentNode, backup) {
	    parentNode = exports.declRoot(parentNode);
	    var decls = globalDeclarations(parentNode);
	    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() && (x.property().nameId() == universes.Universe10.LibraryBase.properties.types.name); });
	    var result = typeBuilder.typeFromNode(declNode);
	    return result;
	};
	exports.schemasWithName = function (tname, parentNode, backup) {
	    parentNode = exports.declRoot(parentNode);
	    var decls = globalDeclarations(parentNode);
	    var declNode = _.find(decls, function (x) { return hlimpl.qName(x, parentNode) == tname && x.property() && (x.property().nameId() == universes.Universe10.LibraryBase.properties.schemas.name); });
	    var result = typeBuilder.typeFromNode(declNode);
	    return result;
	};
	exports.nodesDeclaringType = function (range, n) {
	    var result = [];
	    if (range.getRuntimeExtenders().length > 0 && n) {
	        var extenders = range.getRuntimeExtenders();
	        var root = n;
	        extenders.forEach(function (x) {
	            var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition() == x; });
	            result = result.concat(definitionNodes);
	        });
	    }
	    var isElementType = !range.isValueType();
	    if (isElementType && range.isInlinedTemplates() && n) {
	        var root = n;
	        //TODO I did not like it it might be written much better
	        var definitionNodes = globalDeclarations(root).filter(function (z) { return z.definition() == range; });
	        result = result.concat(definitionNodes);
	    }
	    else {
	        var root = n;
	        var q = {};
	        range.allSubTypes().forEach(function (x) { return q[x.nameId()] = true; });
	        q[range.nameId()] = true;
	        var definitionNodes = globalDeclarations(root).filter(function (z) { return q[z.definition().nameId()]; });
	        result = result.concat(definitionNodes);
	    }
	    return result;
	};
	function findAllSubTypes(p, n) {
	    var range = p.range();
	    return exports.subTypesWithLocals(range, n);
	}
	exports.findAllSubTypes = findAllSubTypes;
	;
	function possibleNodes(p, c) {
	    if (c) {
	        if (p.isDescriminating()) {
	            var range = p.range();
	            if (range.getRuntimeExtenders().length > 0 && c) {
	                var extenders = range.getRuntimeExtenders();
	                var result = [];
	                extenders.forEach(function (x) {
	                    var definitionNodes = globalDeclarations(c).filter(function (z) { return z.definition() == x; });
	                    result = result.concat(definitionNodes);
	                });
	                return result;
	            }
	            return [];
	        }
	        if (p.isReference()) {
	            return exports.nodesDeclaringType(p.referencesTo(), c);
	        }
	        if (p.range().isValueType()) {
	            var vt = p.range();
	            if (vt.globallyDeclaredBy && vt.globallyDeclaredBy().length > 0) {
	                var definitionNodes = globalDeclarations(c).filter(function (z) { return _.find(vt.globallyDeclaredBy(), function (x) { return x == z.definition(); }) != null; });
	                return definitionNodes;
	            }
	        }
	    }
	    return this._enumOptions;
	}
	function allChildren(node) {
	    var res = [];
	    gather(node, res);
	    return res;
	}
	exports.allChildren = allChildren;
	function gather(node, result) {
	    node.children().forEach(function (x) {
	        result.push(x);
	        gather(x, result);
	    });
	}
	var testUsage = function (ck, x, node, result) {
	    if (ck instanceof defs.UserDefinedClass) {
	        var ud = ck;
	        if (node.isSameNode(ud.getDeclaringNode())) {
	            result.push(x);
	        }
	    }
	    if (ck instanceof defs.Array) {
	        var cmp = ck;
	        testUsage(cmp.component, x, node, result);
	    }
	    if (ck instanceof defs.Union) {
	        var uni = ck;
	        testUsage(uni.left, x, node, result);
	        testUsage(uni.right, x, node, result);
	    }
	};
	function refFinder(root, node, result) {
	    root.elements().forEach(function (x) {
	        refFinder(x, node, result);
	        //console.log(x.name())
	        var ck = x.definition();
	        //testUsage(ck, x, node, result);
	    });
	    root.attrs().forEach(function (a) {
	        var pr = a.property();
	        var vl = a.value();
	        //if (pr.isTypeExpr()){
	        //    typeExpression.
	        //}
	        if (pr instanceof defs.UserDefinedProp) {
	            var up = pr.node();
	            if (up == node) {
	                result.push(a);
	            }
	            else if (up.lowLevel().start() == node.lowLevel().start()) {
	                if (up.lowLevel().unit() == node.lowLevel().unit()) {
	                    result.push(a);
	                }
	            }
	        }
	        if (isExampleNodeContent(a)) {
	            var contentType = findExampleContentType(a);
	            if (contentType) {
	                var documentationRoot = parseDocumentationContent(a, contentType.toRuntime());
	                if (documentationRoot) {
	                    refFinder(documentationRoot, node, result);
	                }
	            }
	        }
	        else if (pr.isTypeExpr() && typeof vl == "string") {
	            var tpa = typeExpression.getType(root, "" + vl, {});
	            testUsage(tpa, a, node, result);
	            var libraryName = hl.getLibraryName(node);
	            if (libraryName && vl.indexOf(libraryName) != -1) {
	                var referencingLibrary = getLibraryDefiningNode(a);
	                if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                    result.push(a);
	                }
	            }
	        }
	        if (pr.isReference() || pr.isDescriminator()) {
	            if (typeof vl == 'string') {
	                var pn = possibleNodes(pr, root);
	                if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
	                    result.push(a);
	                }
	                var libraryName = hl.getLibraryName(node);
	                if (libraryName && vl.indexOf(libraryName) != -1) {
	                    var referencingLibrary = getLibraryDefiningNode(a);
	                    if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                        result.push(a);
	                    }
	                }
	            }
	            else {
	                var st = vl;
	                if (st) {
	                    var vn = st.valueName();
	                    var pn = possibleNodes(pr, root);
	                    if (_.find(pn, function (x) { return x.name() == vn && x == node; })) {
	                        result.push(a);
	                    }
	                    var hnode = st.toHighlevel();
	                    if (hnode) {
	                        refFinder(hnode, node, result);
	                    }
	                    var libraryName = hl.getLibraryName(node);
	                    if (libraryName && vn.indexOf(libraryName) != -1) {
	                        var referencingLibrary = getLibraryDefiningNode(vl);
	                        if (referencingLibrary && referencingLibrary.lowLevel().start() == node.lowLevel().start()) {
	                            result.push(a);
	                        }
	                    }
	                }
	            }
	        }
	        else {
	            var pn = possibleNodes(pr, root);
	            if (_.find(pn, function (x) { return x.name() == vl && x == node; })) {
	                result.push(a);
	            }
	        }
	    });
	}
	exports.refFinder = refFinder;
	/**
	 * Returns library node that definition of the current node is located in, or null
	 * if current node is not defined in a library.
	 */
	function getLibraryDefiningNode(nodeToCheck) {
	    if (!nodeToCheck.lowLevel) {
	        return null;
	    }
	    var lowLevelNode = nodeToCheck.lowLevel();
	    if (!lowLevelNode) {
	        return null;
	    }
	    if (lowLevelNode.key()) {
	        var offset = Math.floor((lowLevelNode.keyEnd() + lowLevelNode.keyStart()) / 2);
	        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
	        if (result)
	            return result;
	    }
	    if (lowLevelNode.value()) {
	        var offset = Math.floor((lowLevelNode.valueEnd() + lowLevelNode.valueStart()) / 2);
	        var result = getLibraryDefiningNodeByOffset(lowLevelNode.unit(), offset);
	        if (result)
	            return result;
	    }
	    return null;
	}
	function getLibraryDefiningNodeByOffset(unit, offset) {
	    var declaration = findDeclaration(unit, offset);
	    if (declaration && hl.asNode(declaration)) {
	        var declarationNode = hl.asNode(declaration);
	        var parent = declarationNode;
	        while (parent) {
	            if (parent.definition().key() == universes.Universe10.Library) {
	                return parent;
	            }
	            parent = parent.parent();
	        }
	    }
	    return null;
	}


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(3);
	var _ = __webpack_require__(4);
	var typeExpression = __webpack_require__(63);
	var universes = __webpack_require__(62);
	var hlimpl = __webpack_require__(5);
	var ts2Def = __webpack_require__(67);
	var linter = __webpack_require__(72);
	function templateFields(node, d) {
	    var u = node.root().definition().universe();
	    node.children().forEach(function (x) { return templateFields(x, d); });
	    if (node instanceof hlimpl.ASTPropImpl) {
	        var prop = node;
	        //TODO RECURSIVE PARAMETERS
	        var v = prop.value();
	        if (typeof v == 'string') {
	            var strV = v;
	            handleValue(strV, d, prop, false, u);
	        }
	        else {
	            node.lowLevel().visit(function (x) {
	                if (x.value()) {
	                    var strV = x.value() + "";
	                    handleValue(strV, d, prop, true, u);
	                }
	                return true;
	            });
	        }
	    }
	    else if (node instanceof hlimpl.BasicASTNode) {
	        var v = node.lowLevel().value();
	        if (typeof v == 'string') {
	            var strV = v;
	            handleValue(strV, d, null, false, u);
	        }
	        else {
	            node.lowLevel().visit(function (x) {
	                if (x.value()) {
	                    var strV = x.value() + "";
	                    handleValue(strV, d, null, true, u);
	                }
	                return true;
	            });
	        }
	    }
	}
	var handleValue = function (strV, d, prop, allwaysString, u) {
	    var ps = 0;
	    while (true) {
	        var pos = strV.indexOf("<<", ps);
	        if (pos != -1) {
	            var end = strV.indexOf(">>", pos);
	            var isFull = pos == 0 && end == strV.length - 2;
	            var parameterUsage = strV.substring(pos + 2, end);
	            ps = pos + 2;
	            var directiveIndex = parameterUsage.indexOf("|");
	            if (directiveIndex != -1) {
	                parameterUsage = parameterUsage.substring(0, directiveIndex);
	            }
	            parameterUsage = parameterUsage.trim();
	            if (parameterUsage == "resourcePathName" || parameterUsage == "methodName" || parameterUsage == "resourcePath") {
	                continue;
	            }
	            var q = d[parameterUsage];
	            var r = (prop) ? prop.property().range() : null;
	            if (prop) {
	                if (prop.property().nameId() == universes.Universe10.DataElement.properties.type.name || prop.property().nameId() == universes.Universe10.DataElement.properties.schema.name) {
	                    if (prop.property().domain().key() == universes.Universe10.DataElement) {
	                        r = u.getType(universes.Universe10.SchemaString.name);
	                    }
	                }
	            }
	            if (!isFull || allwaysString) {
	                r = u.getType(universes.Universe10.StringType.name);
	            }
	            //FIX ME NOT WHOLE TEMPLATES
	            if (q) {
	                q.push({
	                    tp: r,
	                    attr: prop
	                });
	            }
	            else {
	                d[parameterUsage] = [{
	                    tp: r,
	                    attr: prop
	                }];
	            }
	        }
	        else
	            break;
	    }
	};
	function objectField(node) {
	    var de = node.definition().universe().getType(universes.Universe10.ObjectField.name);
	    return de;
	}
	function typeFromNode(node) {
	    if (!node) {
	        return null;
	    }
	    if (node.associatedType()) {
	        return node.associatedType();
	    }
	    var u = node.lowLevel().unit();
	    var upath = u ? u.path() : "";
	    if (node.property() && node.property().nameId() == universes.Universe10.LibraryBase.properties.annotationTypes.name) {
	        var result = new defs.AnnotationType(node.name(), node.definition().universe(), node, upath, "");
	    }
	    else {
	        var result = new defs.UserDefinedClass(node.name(), node.definition().universe(), node, upath, "");
	    }
	    node.setAssociatedType(result);
	    //result.setDeclaringNode(node);
	    var def = node.definition();
	    if (def.isInlinedTemplates()) {
	        var usages = {};
	        templateFields(node, usages);
	        Object.keys(usages).forEach(function (x) {
	            var prop = new defs.UserDefinedProp(x);
	            //prop._node=node;
	            prop.withDomain(result);
	            var tp = _.unique(usages[x]).map(function (x) { return x.tp; }).filter(function (x) { return x && x.nameId() != universes.Universe08.StringType.name; });
	            prop.withRange(tp.length == 1 ? tp[0] : node.definition().universe().getType(universes.Universe08.StringType.name));
	            prop.withRequired(true);
	            if (usages[x].length > 0) {
	                prop._node = usages[x][0].attr;
	            }
	            prop.unmerge();
	        });
	        var keyProp = new defs.UserDefinedProp("key");
	        //prop._node=node;
	        keyProp.withDomain(result);
	        keyProp.withKey(true);
	        keyProp._node = node;
	        keyProp.withFromParentKey(true);
	        keyProp.withRange(node.definition().universe().getType(universes.Universe08.StringType.name));
	    }
	    else if (def.getReferenceIs()) {
	        if (def.universe().version() == "RAML08") {
	            result.withAllowAny();
	        }
	        var p = def.property(def.getReferenceIs());
	        if (p) {
	            p.range().properties().forEach(function (x) {
	                var prop = new defs.Property(x.nameId());
	                prop.unmerge();
	                prop.withDomain(result);
	                prop.withRange(x.range());
	                prop.withMultiValue(x.isMultiValue());
	            });
	        }
	    }
	    else {
	        var rp = def.findMembersDeterminer();
	        if (rp) {
	            var elements = node.elementsOfKind(rp.nameId());
	            elements.forEach(function (x) {
	                var prop = elementToProp(x);
	                prop.withDomain(result);
	            });
	        }
	        //here we should found correct inheritance chain
	        var types = node.attributes("type");
	        var schema = node.attributes("schema");
	        types = types.concat(schema);
	        if (node.definition().key() === universes.Universe08.GlobalSchema || node.definition().key() === universes.Universe10.GlobalSchema) {
	            var vl = node.attributes("value");
	            types = types.concat(vl);
	        }
	        var tp = types.length != 0;
	        types.forEach(function (tp) {
	            var vl = tp.value();
	            if (typeof vl == 'string' && vl) {
	                vl = vl.trim();
	                if (vl.charAt(0) == '{') {
	                    var et = new defs.ExternalType(node.name(), node.definition().universe(), upath, "");
	                    et.schemaString = vl;
	                    et.node = node;
	                    var de = objectField(node);
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                    result._superTypes.push(et);
	                }
	                if (vl.charAt(0) == '<') {
	                    var et = new defs.ExternalType(node.name(), node.definition().universe(), upath, "");
	                    et.schemaString = vl;
	                    et.node = node;
	                    var de = objectField(node);
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                    result._superTypes.push(et);
	                }
	            }
	            var types = {};
	            types[result.nameId()] = result;
	            var at = null;
	            if (vl != result.nameId()) {
	                at = typeExpression.getType(node.parent(), vl, types);
	            }
	            else {
	            }
	            if (at) {
	                result._superTypes.push(at);
	            }
	        });
	        result.addRequirement("type", node.name());
	        if (def.getExtendedType()) {
	            result._superTypes.push(def.getExtendedType());
	        }
	        {
	            //Adding runtime properties for object types TODO it should be done in more elegant way
	            var prop = _.find(node.lowLevel().children(), function (x) { return x.key() == "properties"; });
	            if (prop) {
	                var de = objectField(node);
	                if (de) {
	                    result._superTypes.push(de);
	                }
	            }
	            else {
	                if (node.property() && node.property().nameId() == universes.Universe10.Method.properties.body.name) {
	                    var de = objectField(node);
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                }
	                else if (!tp) {
	                    var de = node.definition().universe().getType(universes.Universe10.StrElement.name);
	                    if (de && node.definition().key() != universes.Universe08.BodyLike && node.definition().key() != universes.Universe10.AnnotationType) {
	                        result._superTypes.push(de);
	                    }
	                }
	                if (result._superTypes.length == 0) {
	                    var de = node.definition().universe().getType(universes.Universe10.DataElement.name);
	                    if (de) {
	                        result._superTypes.push(de);
	                    }
	                }
	            }
	            var pn = objectField(node);
	            if (pn) {
	                node.lowLevel().children().forEach(function (x) {
	                    if (x.key() == "facets") {
	                        return;
	                    }
	                    if (x.key() == "annotations") {
	                        return;
	                    }
	                    if (x.key() == "parameters") {
	                        return;
	                    }
	                    if (!pn.property(x.key())) {
	                        result.fixFacet(x.key(), x);
	                    }
	                });
	            }
	        }
	    }
	    return result;
	}
	exports.typeFromNode = typeFromNode;
	function parsePropertyName(name) {
	    var v = { name: "", regexp: null };
	    if (name.length > 2) {
	        name = name.substr(1, name.length - 2);
	        var pos = name.lastIndexOf("#");
	        if (pos != -1) {
	            v.name = name.substr(pos + 1);
	            v.regexp = name.substr(0, pos);
	        }
	        else {
	            v.regexp = name;
	        }
	    }
	    return v;
	}
	exports.parsePropertyName = parsePropertyName;
	function libraryLocation(definition) {
	    var node = definition.getDeclaringNode();
	    var result = null;
	    if (node != null) {
	        var library = node.parent();
	        if (library) {
	            var libraryAnnotations = library.attributes("annotations");
	            libraryAnnotations.forEach(function (x) {
	                var value = x.value();
	                if (value instanceof hlimpl.StructuredValue) {
	                    if (value.lowLevel().key() == "(LibraryLocation)") {
	                        var hlv = value.toHighlevel(library);
	                        if (hlv) {
	                            result = valueOf(hlv);
	                        }
	                    }
	                }
	            });
	        }
	    }
	    return result;
	}
	exports.libraryLocation = libraryLocation;
	function valueOf(hl) {
	    if (hl) {
	        var vl = hl.attr("value");
	        if (vl) {
	            return vl.value();
	        }
	    }
	    return null;
	}
	exports.valueOf = valueOf;
	var scriptToValidator = {};
	var loophole = __webpack_require__(79);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	var ValidatorHolder = (function () {
	    function ValidatorHolder() {
	    }
	    ValidatorHolder.prototype.register = function (mm) {
	        this._result = mm;
	    };
	    return ValidatorHolder;
	})();
	function aquireValidator(value) {
	    if (value) {
	        var nm = scriptToValidator[value];
	        if (nm) {
	            if (nm == aquireValidator) {
	                return null;
	            }
	            return nm;
	        }
	        try {
	            var holder = new ValidatorHolder();
	            evalInSandbox(value, holder, []);
	            if (holder._result) {
	                scriptToValidator[value] = holder._result;
	                return holder._result;
	            }
	            else {
	                scriptToValidator[value] = aquireValidator;
	            }
	        }
	        catch (e) {
	            scriptToValidator[value] = aquireValidator;
	        }
	    }
	    return null;
	}
	exports.aquireValidator = aquireValidator;
	function elementToProp(e, toRuntime) {
	    if (toRuntime === void 0) { toRuntime = false; }
	    var nm = e.name();
	    var optional = false;
	    if (nm && nm.length > 0 && nm.charAt(nm.length - 1) == '?') {
	        nm = nm.substr(0, nm.length - 1);
	        optional = true;
	    }
	    var result = new defs.UserDefinedProp(nm);
	    result._node = e;
	    try {
	        var description = e.attr("description");
	        if (description) {
	            var dsv = "" + description.value();
	            result.withDescription(dsv);
	        }
	        var dn = e.attr("displayName");
	        if (dn) {
	            var dsv = "" + dn.value();
	            result.withDisplayName(dsv);
	        }
	        var example = e.attr("example");
	        if (example) {
	            var obj = new linter.ExampleValidator().parseObject(example, {
	                begin: function () {
	                },
	                end: function () {
	                },
	                accept: function (f) {
	                }
	            }, false);
	            result.setDefaultVal(obj);
	        }
	        else {
	            var exampleElements = e.elementsOfKind("examples");
	            exampleElements.forEach(function (x) {
	                var cnt = x.attr("content");
	                if (cnt) {
	                    var obj = new linter.ExampleValidator().parseObject(cnt, {
	                        begin: function () {
	                        },
	                        end: function () {
	                        },
	                        accept: function (f) {
	                        }
	                    }, false);
	                    result.setDefaultVal(obj);
	                }
	            });
	        }
	    }
	    catch (e) {
	        console.log(e); //TODO remove me
	    }
	    var annotations = e.attributes("annotations");
	    annotations.forEach(function (annotation) {
	        var value = annotation.value();
	        if (value instanceof hlimpl.StructuredValue) {
	            var highLevel = value.toHighlevel(e);
	            if (highLevel) {
	                var definition = highLevel.definition();
	                if (definition.nameId() == "FacetInstanceValidator") {
	                    var node = definition.getDeclaringNode();
	                    var ll = libraryLocation(definition);
	                    if (ll == "http://raml.org/library/common.raml") {
	                        var value = valueOf(highLevel);
	                        var facetValidator = aquireValidator(value);
	                        if (facetValidator) {
	                            result.setFacetValidator(facetValidator);
	                        }
	                    }
	                }
	            }
	        }
	    });
	    if (nm.length > 0) {
	        if (nm[0] == '[') {
	            optional = true;
	            var info = parsePropertyName(nm);
	            if (info.regexp) {
	                result.withKeyRegexp(info.regexp);
	            }
	            else {
	                result.withKeyRestriction("");
	            }
	            if (info.name) {
	                result.withDescription(info.name);
	            }
	            result.withMultiValue();
	        }
	        else {
	            result.unmerge();
	        }
	    }
	    var props = e.definition().properties();
	    var tp = e.attr("type");
	    if (tp) {
	        var typeName = tp.value();
	        if (typeName == "any") {
	            result.withMultiValue(true);
	            var rm = new defs.NodeClass("ObjectField", e.definition().universe(), "", "");
	            rm.withAllowAny();
	            result.withRange(rm);
	        }
	        else {
	            var tpv = typeExpression.getType(e, typeName, {}, true);
	            if (tpv) {
	                tpv = tpv.toRuntime();
	                if (tpv instanceof defs.Array) {
	                    var at = tpv;
	                    //FIXME
	                    at._af = {};
	                    //var fs=tpv.getFixedFacets();
	                    //for (var i in fs){
	                    //    at._af[i]=fs[i];
	                    //}
	                    at.findFacets(e, at._af);
	                }
	            }
	            result.withRange(tpv);
	        }
	    }
	    //FIXME Literals
	    if (nm == "value" && e.parent() && e.parent().definition().isAssignableFrom(universes.Universe10.AnnotationType.name)) {
	        result.withCanBeValue();
	    }
	    e.definition().allProperties().forEach(function (p) {
	        if (p.nameId() != universes.Universe10.DataElement.properties.type.name) {
	            if (p.describesAnnotation()) {
	                var annotationName = p.describedAnnotation();
	                var args = [];
	                var vl = e.attributes(p.nameId()).map(function (a) { return a.value(); });
	                if (vl.length == 1) {
	                    args.push(vl[0]);
	                }
	                else {
	                    args.push(vl);
	                }
	                //TODO ANNOTATIONS WITH MULTIPLE ARGUMENTS
	                var an = {
	                    name: annotationName,
	                    arguments: args
	                };
	                ts2Def.recordAnnotation(result, an);
	            }
	        }
	    });
	    if (optional) {
	        result.withRequired(false);
	    }
	    var vn = _.find(e.lowLevel().children(), function (x) { return x.key() == "properties"; });
	    if (vn) {
	        var of = e.definition().universe().getType(universes.Universe10.ObjectField.name);
	        var node = new hlimpl.ASTNodeImpl(e.lowLevel(), e.parent(), of, result);
	        var epath = e.lowLevel().unit();
	        var nc = new defs.UserDefinedClass("", of.universe(), node, epath ? epath.path() : "", "");
	        nc._superTypes.push(of);
	        result.withRange(nc.toRuntime());
	    }
	    if (result.range() == null) {
	        result.withRange(new defs.ValueType("String", e.definition().universe(), ""));
	    }
	    if (result.range().key() == universes.Universe10.ObjectField) {
	        var rm = new defs.NodeClass(universes.Universe10.ObjectField.name, result.range().universe(), "", "");
	        rm.withAllowAny();
	        result.withRange(rm);
	    }
	    return result;
	}
	exports.elementToProp = elementToProp;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	/// <reference path="../../../typings/tsd.d.ts" />
	var tsStruct = __webpack_require__(68);
	var def = __webpack_require__(3);
	var _ = __webpack_require__(4);
	var khttp = __webpack_require__(71);
	var FieldWrapper = (function () {
	    function FieldWrapper(_field, _clazz) {
	        this._field = _field;
	        this._clazz = _clazz;
	    }
	    FieldWrapper.prototype.name = function () {
	        return this._field.name;
	    };
	    FieldWrapper.prototype.range = function () {
	        return this._clazz.getModule().typeFor(this._field.type, this._clazz);
	    };
	    FieldWrapper.prototype.isMultiValue = function () {
	        return this._field.type.typeKind == 1 /* ARRAY */;
	    };
	    FieldWrapper.prototype.isKey = function () {
	        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.key"; }) != null;
	    };
	    FieldWrapper.prototype.isSimpleValue = function () {
	        return _.find(this._field.annotations, function (x) { return x.name == "MetaModel.value"; }) != null;
	    };
	    FieldWrapper.prototype.annotations = function () {
	        return this._field.annotations;
	    };
	    return FieldWrapper;
	})();
	var FieldConstraint = (function () {
	    function FieldConstraint(_field, _clazz) {
	        this._field = _field;
	        this._clazz = _clazz;
	    }
	    FieldConstraint.prototype.name = function () {
	        return this._field.name;
	    };
	    FieldConstraint.prototype.value = function () {
	        return this._field.valueConstraint;
	    };
	    return FieldConstraint;
	})();
	var ClassWrapper = (function () {
	    function ClassWrapper(_clazz, mw) {
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    ClassWrapper.prototype.typeMeta = function () {
	        return this._clazz.annotations;
	    };
	    ClassWrapper.prototype.path = function () {
	        return this.mw.path();
	    };
	    ClassWrapper.prototype.getModule = function () {
	        return this.mw;
	    };
	    ClassWrapper.prototype.typeArgs = function () {
	        return this._clazz.typeParameters;
	    };
	    ClassWrapper.prototype.typConstraints = function () {
	        var _this = this;
	        return this._clazz.typeParameterConstraint.map(function (x) {
	            if (x) {
	                return _this.mw.classForName(x);
	            }
	            return null;
	        });
	    };
	    ClassWrapper.prototype.methods = function () {
	        return this._clazz.methods;
	    };
	    ClassWrapper.prototype.name = function () {
	        return this._clazz.name;
	    };
	    ClassWrapper.prototype.members = function () {
	        var _this = this;
	        return this._clazz.fields.filter(function (x) { return x.valueConstraint == null; }).map(function (x) { return new FieldWrapper(x, _this); });
	    };
	    ClassWrapper.prototype.constraints = function () {
	        var _this = this;
	        return this._clazz.fields.filter(function (x) { return x.valueConstraint != null; }).map(function (x) { return new FieldConstraint(x, _this); });
	    };
	    ClassWrapper.prototype.isSubTypeOf = function (of) {
	        if (this == of) {
	            return true;
	        }
	        var _res = false;
	        this.getAllSuperTypes().forEach(function (x) {
	            if (!_res) {
	                _res = _res || x.isSubTypeOf(of);
	            }
	        });
	        return _res;
	    };
	    ClassWrapper.prototype.getExtendsClauses = function () {
	        return this._clazz.extends;
	    };
	    ClassWrapper.prototype.getSuperTypes = function () {
	        var _this = this;
	        var result = [];
	        this._clazz.extends.forEach(function (x) {
	            var tp = _this.mw.classForName(x.typeName);
	            if (tp) {
	                result.push(tp);
	            }
	        });
	        return result;
	    };
	    ClassWrapper.prototype.getAllSuperTypes = function () {
	        var _this = this;
	        var result = [];
	        this._clazz.extends.forEach(function (x) {
	            var tp = _this.mw.classForName(x.typeName);
	            if (tp) {
	                var mm = tp.getAllSuperTypes();
	                result.push(tp);
	                result.concat(mm);
	            }
	        });
	        return _.unique(result);
	    };
	    ClassWrapper.prototype.annotationOverridings = function () {
	        return this._clazz.annotationOverridings;
	    };
	    return ClassWrapper;
	})();
	var AbstractSimpleWrapper = (function () {
	    function AbstractSimpleWrapper() {
	    }
	    AbstractSimpleWrapper.prototype.members = function () {
	        return []; //this._clazz.members.map(x=>new FieldWrapper(x,this))
	    };
	    AbstractSimpleWrapper.prototype.methods = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.isSubTypeOf = function (of) {
	        return false;
	    };
	    AbstractSimpleWrapper.prototype.getSuperTypes = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.getAllSuperTypes = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.name = function () {
	        return null;
	    };
	    AbstractSimpleWrapper.prototype.constraints = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.typeMeta = function () {
	        return [];
	    };
	    AbstractSimpleWrapper.prototype.getModule = function () {
	        throw new Error("Not implemented");
	    };
	    AbstractSimpleWrapper.prototype.annotationOverridings = function () {
	        return {};
	    };
	    return AbstractSimpleWrapper;
	})();
	var EnumWrapper = (function (_super) {
	    __extends(EnumWrapper, _super);
	    function EnumWrapper(_clazz, mw) {
	        _super.call(this);
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    EnumWrapper.prototype.getModule = function () {
	        return this.mw;
	    };
	    EnumWrapper.prototype.values = function () {
	        return this._clazz.members;
	    };
	    EnumWrapper.prototype.name = function () {
	        return this._clazz.name;
	    };
	    return EnumWrapper;
	})(AbstractSimpleWrapper);
	var UnionWrapper = (function (_super) {
	    __extends(UnionWrapper, _super);
	    function UnionWrapper(_clazz, mw) {
	        _super.call(this);
	        this._clazz = _clazz;
	        this.mw = mw;
	    }
	    UnionWrapper.prototype.elements = function () {
	        return this._clazz;
	    };
	    UnionWrapper.prototype.name = function () {
	        return this._clazz.map(function (x) { return x.name(); }).join("|");
	    };
	    return UnionWrapper;
	})(AbstractSimpleWrapper);
	var ModuleWrapper = (function () {
	    function ModuleWrapper(_univers) {
	        var _this = this;
	        this._univers = _univers;
	        this.name2Class = {};
	        this.namespaceToMod = {};
	        this._classes = [];
	        _univers.classes.forEach(function (x) {
	            var c = new ClassWrapper(x, _this);
	            _this._classes.push(c);
	            _this.name2Class[x.name] = c;
	            if (x.moduleName) {
	                //FIXME
	                _this.name2Class[x.moduleName + "." + x.name] = c;
	            }
	        });
	        _univers.enumDeclarations.forEach(function (x) {
	            var c = new EnumWrapper(x, _this);
	            _this._classes.push(c);
	            _this.name2Class[x.name] = c;
	        });
	    }
	    ModuleWrapper.prototype.typeFor = function (t, ow) {
	        var _this = this;
	        switch (t.typeKind) {
	            case 0 /* BASIC */:
	                var bt = t;
	                var typeName = bt.typeName;
	                if (typeName == "string") {
	                    typeName = "StringType";
	                }
	                if (typeName == "number") {
	                    typeName = "NumberType";
	                }
	                if (typeName == "boolean") {
	                    typeName = "BooleanType";
	                }
	                var ti = _.indexOf(ow.typeArgs(), typeName);
	                if (ti != -1) {
	                    var cnst = ow.typConstraints()[ti];
	                    if (!cnst) {
	                        return this.classForName("ValueType");
	                    }
	                    return cnst;
	                }
	                return this.classForName(typeName);
	            case 2 /* UNION */:
	                var ut = t;
	                return new UnionWrapper(ut.options.map(function (x) { return _this.typeFor(x, ow); }), this);
	            case 1 /* ARRAY */:
	                var at = t;
	                return this.typeFor(at.base, ow);
	        }
	        return null;
	    };
	    ModuleWrapper.prototype.path = function () {
	        return this._univers.name;
	    };
	    ModuleWrapper.prototype.classForName = function (name, stack) {
	        var _this = this;
	        if (stack === void 0) { stack = {}; }
	        if (!name) {
	            return null;
	        }
	        var result = this.name2Class[name];
	        if (!result && !stack[this.path()]) {
	            stack[this.path()] = this;
	            var nmsp = name.indexOf(".");
	            if (nmsp != -1) {
	                var actualMod = this.namespaceToMod[name.substring(0, nmsp)];
	                if (!actualMod) {
	                    throw new Error();
	                }
	                return actualMod.classForName(name.substring(nmsp + 1), stack);
	            }
	            Object.keys(this.namespaceToMod).forEach(function (x) {
	                if (x != "MetaModel") {
	                    var nm = _this.namespaceToMod[x].classForName(name, stack);
	                    if (nm) {
	                        result = nm;
	                    }
	                }
	            });
	        }
	        return result;
	    };
	    ModuleWrapper.prototype.classes = function () {
	        return this._classes;
	    };
	    return ModuleWrapper;
	})();
	var wrapperToType = function (range, u) {
	    if (range) {
	        var rangeType;
	        if (range instanceof UnionWrapper) {
	            var uw = range;
	            rangeType = new def.UnionType(uw.elements().map(function (x) { return wrapperToType(x, u); }));
	        }
	        else {
	            rangeType = u.type(range.name());
	        }
	        return rangeType;
	    }
	    else {
	        return;
	    }
	};
	var registerClasses = function (m, u) {
	    var valueType = m.classForName("ValueType");
	    m.classes().forEach(function (x) {
	        if (x instanceof EnumWrapper) {
	            var et = new def.EnumType(x.name(), u, x.getModule().path());
	            et.values = x.values();
	            u.register(et);
	            return;
	        }
	        if (x.isSubTypeOf(valueType)) {
	            var st = x.getAllSuperTypes();
	            st.push(x);
	            var refTo = null;
	            var scriptingHook = null;
	            st.forEach(function (t) {
	                var cs = t.getExtendsClauses();
	                cs.forEach(function (z) {
	                    if (z.typeKind == 0 /* BASIC */) {
	                        var bas = z;
	                        if (bas.basicName == 'Reference') {
	                            var of = bas.typeArguments[0];
	                            refTo = of.typeName;
	                        }
	                        if (bas.basicName == 'ScriptingHook') {
	                            var of = bas.typeArguments[0];
	                            scriptingHook = of.basicName;
	                        }
	                    }
	                });
	            });
	            if (refTo) {
	                //console.log("New reference type" + x.name())
	                var ref = new def.ReferenceType(x.name(), x.getModule().path(), refTo, u);
	                u.register(ref);
	            }
	            if (scriptingHook) {
	                //console.log("New scripting hook " + x.name())
	                var sc = new def.ScriptingHookType(x.name(), x.getModule().path(), scriptingHook, u);
	                u.register(sc);
	            }
	            var vt = new def.ValueType(x.name(), u, x.getModule().path());
	            u.register(vt);
	        }
	        else {
	            var gt = new def.NodeClass(x.name(), u, x.getModule().path());
	            u.register(gt);
	        }
	    });
	};
	var registerHierarchy = function (m, u) {
	    m.classes().forEach(function (x) {
	        x.getSuperTypes().forEach(function (y) {
	            var tp0 = u.type(x.name());
	            var tp1 = u.type(y.name());
	            if (!tp0 || !tp1) {
	                var tp0 = u.type(x.name());
	                var tp1 = u.type(y.name());
	                throw new Error();
	            }
	            u.registerSuperClass(tp0, tp1);
	        });
	    });
	};
	var registerEverything = function (m, u) {
	    m.classes().forEach(function (x) {
	        var tp = u.type(x.name());
	        x.typeMeta().forEach(function (a) {
	            if (a.name == 'MetaModel.declaresSubTypeOf') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.setExtendedTypeName(a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.nameAtRuntime') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.setNameAtRuntime(a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.description') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withDescription(a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.inlinedTemplates') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.setInlinedTemplates(true);
	            }
	            if (a.name == 'MetaModel.requireValue') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
	            }
	            if (a.name == 'MetaModel.referenceIs') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withReferenceIs("" + a.arguments[0]);
	            }
	            //MetaModel.referenceIs
	            if (a.name == 'MetaModel.actuallyExports') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withActuallyExports("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.convertsToGlobalOfType') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withConvertsToGlobal("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.allowAny') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withAllowAny();
	            }
	            if (a.name == 'MetaModel.allowQuestion') {
	                var rangeType = wrapperToType(x, u);
	                rangeType.withAllowQuestion();
	            }
	            if (a.name == 'MetaModel.functionalDescriminator') {
	                var r1 = wrapperToType(x, u);
	                r1.withFunctionalDescriminator("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.alias') {
	                var at = wrapperToType(x, u);
	                at.addAlias("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.consumesRefs') {
	                var at = wrapperToType(x, u);
	                at.setConsumesRefs(true);
	            }
	            if (a.name == 'MetaModel.canInherit') {
	                var nc = wrapperToType(x, u);
	                nc.withCanInherit("" + a.arguments[0]);
	            }
	            if (a.name == 'MetaModel.definingPropertyIsEnough') {
	                var nc = wrapperToType(x, u);
	                nc.definingPropertyIsEnough("" + a.arguments[0]);
	            }
	        });
	        x.members().forEach(function (x) {
	            var range = x.range();
	            var rangeType = wrapperToType(range, u);
	            if (rangeType == null) {
	                console.log(range + ":" + x.name());
	            }
	            createProp(x, tp, rangeType);
	        });
	        Object.keys(x.annotationOverridings()).forEach(function (fName) {
	            var arr = [].concat(x.annotationOverridings()[fName]);
	            var map = {};
	            arr.forEach(function (ann) { return map[ann.name] = true; });
	            var targetField;
	            var stArr = x.getSuperTypes();
	            var stMap = {};
	            for (var i = 0; i < stArr.length; i++) {
	                var st = stArr[i];
	                if (stMap[st.name()]) {
	                    continue;
	                }
	                stMap[st.name()] = true;
	                st.getSuperTypes().forEach(function (sst) { return stArr.push(sst); });
	                var arr1 = st.annotationOverridings()[fName];
	                if (arr1) {
	                    arr1.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
	                        map[ann.name] = true;
	                        arr.push(ann);
	                    });
	                }
	                else {
	                    var stFields = st.members();
	                    for (var j = 0; j < stFields.length; j++) {
	                        var stField = stFields[j];
	                        if (stField.name() == fName) {
	                            targetField = stField;
	                            break;
	                        }
	                    }
	                }
	                if (targetField) {
	                    var arr2 = targetField.annotations();
	                    arr2.filter(function (ann) { return !map[ann.name]; }).forEach(function (ann) {
	                        map[ann.name] = true;
	                        arr.push(ann);
	                    });
	                    break;
	                }
	            }
	            if (!targetField) {
	                return;
	            }
	            var range = targetField.range();
	            var rangeType = wrapperToType(range, u);
	            if (rangeType == null) {
	                console.log(range + ":" + x.name());
	            }
	            createProp(targetField, tp, rangeType, arr);
	        });
	        x.methods().forEach(function (x) {
	            var at = tp;
	            at.addMethod(x.name, x.text);
	            //console.log(x.name);
	            //createMember(x, <def.AbstractType>tp, rangeType)
	        });
	        x.constraints().forEach(function (x) {
	            if (x.value().isCallConstraint) {
	                throw new Error();
	            }
	            var mm = x.value();
	            tp.addRequirement(x.name(), "" + mm.value);
	        });
	    });
	    u.types().forEach(function (x) {
	        if (x instanceof def.AbstractType) {
	            var at = x;
	            at.getAliases().forEach(function (y) { return u.registerAlias(y, at); });
	        }
	    });
	};
	var processModule = function (ts, u, used, declared) {
	    if (ts.name.indexOf("metamodel.ts") != -1) {
	        return; //FIXME
	    }
	    if (declared[ts.name]) {
	        return declared[ts.name];
	    }
	    var m = new ModuleWrapper(ts);
	    used[ts.name] = m;
	    declared[ts.name] = m;
	    Object.keys(ts.imports).forEach(function (x) {
	        var pMod = ts.imports[x];
	        if (used[pMod.name]) {
	            m.namespaceToMod[x] = used[pMod.name];
	            return;
	        }
	        var vMod = processModule(pMod, u, used, declared);
	        m.namespaceToMod[x] = vMod;
	    });
	    used[ts.name] = null;
	    return m;
	};
	function toDefSystem(ts) {
	    var u = new def.Universe("");
	    var c = {};
	    processModule(ts, u, {}, c);
	    Object.keys(c).forEach(function (x) {
	        registerClasses(c[x], u);
	    });
	    Object.keys(c).forEach(function (x) {
	        registerHierarchy(c[x], u);
	    });
	    Object.keys(c).forEach(function (x) {
	        registerEverything(c[x], u);
	    });
	    u.types().forEach(function (x) {
	        if (x instanceof def.NodeClass) {
	            var cl = x;
	            cl.properties().forEach(function (y) {
	                var t = y.range();
	                if (!t.isValueType()) {
	                    t.properties().forEach(function (p0) {
	                        if (p0.isKey()) {
	                            var kp = p0.keyPrefix();
	                            if (kp) {
	                                y.withKeyRestriction(kp);
	                                y.merge();
	                            }
	                            var eo = p0.getEnumOptions();
	                            if (eo) {
	                                y.withEnumOptions(eo);
	                                y.merge();
	                            }
	                        }
	                    });
	                }
	            });
	            if (cl.isGlobalDeclaration()) {
	                if (cl.getActuallyExports() && cl.getActuallyExports() != "$self") {
	                    var tp = cl.property(cl.getActuallyExports()).range();
	                    if (tp.isValueType()) {
	                        var vt = tp;
	                        vt.setGloballyDeclaredBy(cl);
	                    }
	                }
	                if (cl.getConvertsToGlobal()) {
	                    var tp = u.getType(cl.getConvertsToGlobal());
	                    if (tp.isValueType()) {
	                        var vt = tp;
	                        vt.setGloballyDeclaredBy(cl);
	                    }
	                }
	            }
	        }
	    });
	    return u;
	}
	exports.toDefSystem = toDefSystem;
	var annotationHandlers = {
	    key: function (a, f) {
	        f.withFromParentKey();
	        f.withKey(true);
	    },
	    value: function (a, f) {
	        f.withFromParentValue();
	    },
	    canBeValue: function (a, f) {
	        f.withCanBeValue();
	    },
	    unmerged: function (a, f) {
	        f.unmerge();
	    },
	    startFrom: function (a, f) {
	        f.withKeyRestriction(a.arguments[0]);
	        f.merge();
	    },
	    oneOf: function (a, f) {
	        f.withEnumOptions(a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    oftenKeys: function (a, f) {
	        f.withOftenKeys(a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    embeddedInMaps: function (a, f) {
	        f.withEmbedMap();
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    system: function (a, f) {
	        f.withSystem(true);
	    },
	    required: function (a, f) {
	        if (a.arguments[0] != 'false') {
	            f.withRequired(true);
	        }
	    },
	    noDirectParse: function (a, f) {
	        if (a.arguments[0] != 'false') {
	            f.withNoDirectParse();
	        }
	    },
	    setsContextValue: function (a, f) {
	        f.addChildValueConstraint(new def.ChildValueConstraint("" + a.arguments[0], "" + a.arguments[1]));
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    defaultValue: function (a, f) {
	        f.setDefaultVal("" + a.arguments[0]);
	    },
	    facetId: function (a, f) {
	        if (a.arguments[0] == "minItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > x.length) {
	                        return "array should contain at least " + f.value() + " items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length < x.length) {
	                        return "array should contain not more then " + f.value() + " items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minProperties") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Object) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > Object.keys(x).length) {
	                        return "object should contain at least " + f.value() + " properties";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxProperties") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Object) {
	                    var length = Number.parseInt("" + f.value());
	                    if (length < Object.keys(x).length) {
	                        return "object should contain not more then " + f.value() + " properties";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "uniqueItems") {
	            f.setFacetValidator(function (x, f) {
	                if (x instanceof Array) {
	                    var length = _.unique(x).length;
	                    if (length < x.length) {
	                        return "array should contain only unique items";
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minLength") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var length = Number.parseInt("" + f.value());
	                    if (length > x.length) {
	                        return "string length should be at least " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maxLength") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var length = Number.parseInt("" + f.value());
	                    if (length < x.length) {
	                        return "string length should be not more then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "minimum") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'string') {
	                    x = parseFloat(x);
	                }
	                if (typeof x == 'number') {
	                    var length = parseFloat(f.value());
	                    if (length > x) {
	                        return "value should be not less then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "maximum") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'string') {
	                    x = parseFloat(x);
	                }
	                if (typeof x == 'number') {
	                    var length = parseFloat(f.value());
	                    if (length < x) {
	                        return "value should be not more then " + length;
	                    }
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "pattern") {
	            f.setFacetValidator(function (x, f) {
	                if (typeof x == 'number' || typeof x == 'boolean') {
	                    x = "" + x;
	                }
	                if (typeof x == 'string') {
	                    var regExp = new RegExp(f.value());
	                    if (!regExp.test(x)) {
	                        return "string should match to " + f.value();
	                    }
	                }
	                return null;
	            });
	        }
	    },
	    extraMetaKey: function (a, f) {
	        if (a.arguments[0] == "statusCodes") {
	            f.withOftenKeys(khttp.statusCodes.map(function (x) { return x.code; }));
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.statusCodes, function (x) { return x.code == name; });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "headers") {
	            f.setValueSuggester(function (x) {
	                if (x.property()) {
	                    var c = x.property().getChildValueConstraints();
	                    if (_.find(c, function (x) {
	                        return x.name == "location" && x.value == "Params.ParameterLocation.HEADERS";
	                    })) {
	                        return khttp.headers.map(function (x) { return x.header; });
	                    }
	                    if (x.property()) {
	                        if (x.property().nameId() == "headers") {
	                            return khttp.headers.map(function (x) { return x.header; });
	                        }
	                    }
	                }
	                return null;
	            });
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.headers, function (x) { return x.header == name; });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	        if (a.arguments[0] == "methods") {
	            f.setValueDocProvider(function (name) {
	                var s = _.find(khttp.methods, function (x) { return x.method == name.toUpperCase(); });
	                if (s) {
	                    return (name + ":" + s.description);
	                }
	                return null;
	            });
	        }
	    },
	    requireValue: function (a, f) {
	        f.withContextRequirement("" + a.arguments[0], "" + a.arguments[1]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    allowMultiple: function (a, f) {
	        f.withMultiValue(true);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    selector: function (a, f) {
	        f.setSelector("" + a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    constraint: function (a, f) {
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    newInstanceName: function (a, f) {
	        f.withNewInstanceName("" + a.arguments[0]);
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    declaringFields: function (a, f) {
	        f.withThisPropertyDeclaresFields();
	        //f.withKeyRestriction(<string>a.arguments[0])
	    },
	    describesAnnotation: function (a, f) {
	        //f.withReferenceParameters();
	        f.withDescribes(a.arguments[0]);
	    },
	    allowNull: function (a, f) {
	        f.withAllowNull();
	    },
	    descriminatingProperty: function (a, f) {
	        //f.withReferenceParameters();
	        f.withDescriminating(true);
	    },
	    description: function (a, f) {
	        f.withDescription("" + a.arguments[0]);
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	    },
	    issue: function (a, f) {
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	        f.withIssue("" + a.arguments[0]);
	    },
	    inherited: function (a, f) {
	        f.withInherited(true);
	    },
	    version: function (a, f) {
	        f.withVersion("" + a.arguments[0]);
	    },
	    needsClarification: function (a, f) {
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	        f.withClarify("" + a.arguments[0]);
	    },
	    thisFeatureCovers: function (a, f) {
	        //f.withReferenceParameters();
	        //f.withDescriminating(true)
	        f.withThisFeatureCovers("" + a.arguments[0]);
	    },
	    selfNode: function (a, f) {
	        f.withSelfNode();
	    },
	    valueRestriction: function (a, f) {
	        f.withValueRewstrinction("" + a.arguments[0], "" + a.arguments[1]);
	    },
	    grammarTokenKind: function (a, f) {
	        f.withPropertyGrammarType("" + a.arguments[0]);
	    },
	    canInherit: function (a, f) {
	        f.withInheritedContextValue("" + a.arguments[0]);
	    },
	    canBeDuplicator: function (a, f) {
	        f.setCanBeDuplicator();
	    },
	    hide: function (a, f) {
	        if (a.arguments.length == 0) {
	            f.setHidden(true);
	        }
	        else {
	            f.setHidden(a.arguments[0]);
	        }
	    },
	    documentationTableLabel: function (a, f) {
	        f.setDocTableName("" + a.arguments[0]);
	    },
	    markdownDescription: function (a, f) {
	        f.setMarkdownDescription("" + a.arguments[0]);
	    },
	    valueDescription: function (a, f) {
	        f.setValueDescription(a.arguments[0] != null ? ("" + a.arguments[0]) : null);
	    }
	};
	function recordAnnotation(p, a) {
	    annotationHandlers[a.name](a, p);
	}
	exports.recordAnnotation = recordAnnotation;
	var processAnnotations = function (x, p, annotations) {
	    if (!annotations) {
	        annotations = x.annotations();
	    }
	    annotations.forEach(function (x) {
	        var nm = x.name.substring(x.name.lastIndexOf(".") + 1);
	        if (!annotationHandlers[nm]) {
	            console.log("Can not find handler for:");
	        }
	        annotationHandlers[nm](x, p);
	    });
	};
	function createProp(x, clazz, t, annotations) {
	    var p = def.prop(x.name(), "", clazz, t);
	    if (x.isMultiValue()) {
	        p.withMultiValue(true);
	    }
	    p.unmerge();
	    if (!t.isValueType()) {
	        t.properties().forEach(function (p0) {
	            if (p0.isKey()) {
	                var kp = p0.keyPrefix();
	                if (kp) {
	                    p.withKeyRestriction(kp);
	                    p.merge();
	                }
	                var eo = p0.getEnumOptions();
	                if (eo) {
	                    p.withEnumOptions(eo);
	                    p.merge();
	                }
	            }
	        });
	    }
	    processAnnotations(x, p, annotations);
	}


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by kor on 08/05/15.
	 */
	/// <reference path="../../../typings/tsd.d.ts" />
	var ts = __webpack_require__(69);
	var tsm = __webpack_require__(70);
	var pth = __webpack_require__(9);
	var fs = __webpack_require__(10);
	function parse(content) {
	    return ts.createSourceFile("sample.ts", content, 0 /* ES3 */, "1.4.1", true);
	}
	var fld = tsm.Matching.field();
	var clazzMatcher = tsm.Matching.classDeclaration();
	var EnumDeclaration = (function () {
	    function EnumDeclaration() {
	    }
	    return EnumDeclaration;
	})();
	exports.EnumDeclaration = EnumDeclaration;
	(function (TypeKind) {
	    TypeKind[TypeKind["BASIC"] = 0] = "BASIC";
	    TypeKind[TypeKind["ARRAY"] = 1] = "ARRAY";
	    TypeKind[TypeKind["UNION"] = 2] = "UNION";
	})(exports.TypeKind || (exports.TypeKind = {}));
	var TypeKind = exports.TypeKind;
	function classDecl(name, isInteface) {
	    return {
	        name: name,
	        methods: [],
	        typeParameters: [],
	        typeParameterConstraint: [],
	        implements: [],
	        fields: [],
	        isInterface: isInteface,
	        annotations: [],
	        extends: [],
	        moduleName: null,
	        annotationOverridings: {}
	    };
	}
	exports.classDecl = classDecl;
	function parseStruct(content, modules, mpth) {
	    var mod = parse(content);
	    var module = { classes: [], aliases: [], enumDeclarations: [], imports: {}, name: mpth };
	    modules[mpth] = module;
	    var currentModule = null;
	    tsm.Matching.visit(mod, function (x) {
	        if (x.kind == 189 /* ModuleDeclaration */) {
	            var cmod = x;
	            currentModule = cmod.name.text;
	        }
	        if (x.kind == 191 /* ImportDeclaration */) {
	            var imp = x;
	            var namespace = imp.name.text;
	            if (namespace == "RamlWrapper") {
	                return;
	            }
	            if (imp.moduleReference.kind != 193 /* ExternalModuleReference */) {
	                throw new Error("Only external module references are supported now");
	            }
	            var path = imp.moduleReference;
	            if (path.expression.kind != 7 /* StringLiteral */) {
	                throw new Error("Only string literals are supported in module references ");
	            }
	            var literal = path.expression;
	            var importPath = literal.text;
	            var absPath = pth.resolve(pth.dirname(mpth) + "/", importPath) + ".ts";
	            if (!fs.existsSync(absPath)) {
	                throw new Error("Path " + importPath + " resolve to " + absPath + "do not exists");
	            }
	            if (!modules[absPath]) {
	                var cnt = fs.readFileSync(absPath).toString();
	                var mod = parseStruct(cnt, modules, absPath);
	            }
	            module.imports[namespace] = modules[absPath];
	        }
	        if (x.kind == 187 /* TypeAliasDeclaration */) {
	            var u = x;
	            var aliasName = u.name.text;
	            var type = buildType(u.type, mpth);
	            module.aliases.push({ name: aliasName, type: type });
	        }
	        if (x.kind == 188 /* EnumDeclaration */) {
	            var e = x;
	            var members = [];
	            e.members.forEach(function (y) {
	                members.push(y['name']['text']);
	            });
	            module.enumDeclarations.push({ name: e.name.text, members: members });
	        }
	        var isInterface = x.kind == 186 /* InterfaceDeclaration */;
	        var isClass = x.kind == 185 /* ClassDeclaration */;
	        if (!isInterface && !isClass) {
	            return;
	        }
	        var c = x;
	        if (c) {
	            var fields = {};
	            var clazz = classDecl(c.name.text, isInterface);
	            clazz.moduleName = currentModule;
	            module.classes.push(clazz);
	            c.members.forEach(function (x) {
	                if (x.kind == 125 /* Method */) {
	                    var md = x;
	                    var aliasName = md.name.text;
	                    var text = content.substring(md.pos, md.end);
	                    clazz.methods.push({ name: aliasName, start: md.pos, end: md.end, text: text });
	                }
	                var field = fld.doMatch(x);
	                if (field) {
	                    var f = buildField(field, mpth);
	                    if (f.name == '$') {
	                        clazz.annotations = f.annotations;
	                    }
	                    else if (f.name.charAt(0) != '$' || f.name == '$ref') {
	                        fields[f.name] = f;
	                        clazz.fields.push(f);
	                    }
	                    else {
	                        var targetField = f.name.substr(1);
	                        var of = fields[targetField];
	                        if (!of) {
	                            if (f.name != '$$') {
	                                //console.log('Overriding annotations for field:'+targetField);
	                                var overridings = clazz.annotationOverridings[targetField];
	                                if (!overridings) {
	                                    overridings = [];
	                                }
	                                clazz.annotationOverridings[targetField] = overridings.concat(f.annotations);
	                            }
	                        }
	                        else {
	                            of.annotations = f.annotations;
	                        }
	                    }
	                }
	            });
	            if (c.typeParameters) {
	                c.typeParameters.forEach(function (x) {
	                    clazz.typeParameters.push(x.name['text']);
	                    if (x.constraint == null) {
	                        clazz.typeParameterConstraint.push(null);
	                    }
	                    else {
	                        clazz.typeParameterConstraint.push(x.constraint['typeName']['text']);
	                    }
	                });
	            }
	            if (c.heritageClauses) {
	                c.heritageClauses.forEach(function (x) {
	                    x.types.forEach(function (y) {
	                        if (x.token == 77 /* ExtendsKeyword */) {
	                            clazz.extends.push(buildType(y, mpth));
	                        }
	                        else if (x.token == 100 /* ImplementsKeyword */) {
	                            clazz.implements.push(buildType(y, mpth));
	                        }
	                        else {
	                            throw new Error("Unknown token class heritage");
	                        }
	                    });
	                });
	            }
	            return tsm.Matching.SKIP;
	        }
	    });
	    return module;
	}
	exports.parseStruct = parseStruct;
	function buildField(f, path) {
	    return {
	        name: f.name['text'],
	        type: buildType(f.type, path),
	        annotations: f.name['text'].charAt(0) == '$' ? buildInitializer(f.initializer) : [],
	        valueConstraint: f.name['text'].charAt(0) != '$' ? buildConstraint(f.initializer) : null,
	        optional: f.questionToken != null
	    };
	}
	function buildConstraint(e) {
	    if (e == null) {
	        return null;
	    }
	    if (e.kind == 145 /* CallExpression */) {
	        return {
	            isCallConstraint: true,
	            value: buildAnnotation(e)
	        };
	    }
	    else {
	        return {
	            isCallConstraint: false,
	            value: parseArg(e)
	        };
	    }
	}
	function buildInitializer(i) {
	    if (i == null) {
	        return [];
	    }
	    if (i.kind == 141 /* ArrayLiteralExpression */) {
	        var arr = i;
	        var annotations = [];
	        arr.elements.forEach(function (x) {
	            annotations.push(buildAnnotation(x));
	        });
	        return annotations;
	    }
	    else {
	        throw new Error("Only Array Literals supported now");
	    }
	}
	function buildAnnotation(e) {
	    if (e.kind == 145 /* CallExpression */) {
	        var call = e;
	        var name = parseName(call.expression);
	        var a = {
	            name: name,
	            arguments: []
	        };
	        call.arguments.forEach(function (x) {
	            a.arguments.push(parseArg(x));
	        });
	        return a;
	    }
	    else {
	        throw new Error("Only call expressions may be annotations");
	    }
	}
	function parseArg(n) {
	    if (n.kind == 7 /* StringLiteral */) {
	        var l = n;
	        return l.text;
	    }
	    if (n.kind == 9 /* NoSubstitutionTemplateLiteral */) {
	        var ls = n;
	        return ls.text;
	    }
	    if (n.kind == 141 /* ArrayLiteralExpression */) {
	        var arr = n;
	        var annotations = [];
	        arr.elements.forEach(function (x) {
	            annotations.push(parseArg(x));
	        });
	        return annotations;
	    }
	    if (n.kind == 93 /* TrueKeyword */) {
	        return true;
	    }
	    if (n.kind == 143 /* PropertyAccessExpression */) {
	        var pa = n;
	        return parseArg(pa.expression) + "." + parseArg(pa.name);
	    }
	    if (n.kind == 63 /* Identifier */) {
	        var ident = n;
	        return ident.text;
	    }
	    if (n.kind == 78 /* FalseKeyword */) {
	        return false;
	    }
	    if (n.kind == 6 /* NumericLiteral */) {
	        var nl = n;
	        return nl.text;
	    }
	    if (n.kind == 157 /* BinaryExpression */) {
	        var bin = n;
	        if (bin.operator = 32 /* PlusToken */) {
	            return parseArg(bin.left) + parseArg(bin.right);
	        }
	    }
	    throw new Error("Unknown value in annotation");
	}
	function parseName(n) {
	    if (n.kind == 63 /* Identifier */) {
	        return n['text'];
	    }
	    if (n.kind == 143 /* PropertyAccessExpression */) {
	        var m = n;
	        return parseName(m.expression) + "." + parseName(m.name);
	    }
	    throw new Error("Only simple identifiers are supported now");
	}
	function basicType(n, path) {
	    var namespaceIndex = n.indexOf(".");
	    var namespace = namespaceIndex != -1 ? n.substring(0, namespaceIndex) : "";
	    var basicName = namespaceIndex != -1 ? n.substring(namespaceIndex + 1) : n;
	    return { typeName: n, nameSpace: namespace, basicName: basicName, typeKind: 0 /* BASIC */, typeArguments: [], modulePath: path };
	}
	function arrayType(b) {
	    return { base: b, typeKind: 1 /* ARRAY */ };
	}
	function unionType(b) {
	    return { options: b, typeKind: 2 /* UNION */ };
	}
	function buildType(t, path) {
	    if (t == null) {
	        return null;
	    }
	    if (t.kind == 118 /* StringKeyword */) {
	        return basicType("string", null);
	    }
	    if (t.kind == 116 /* NumberKeyword */) {
	        return basicType("number", null);
	    }
	    if (t.kind == 110 /* BooleanKeyword */) {
	        return basicType("boolean", null);
	    }
	    if (t.kind == 109 /* AnyKeyword */) {
	        return basicType("any", null);
	    }
	    if (t.kind == 132 /* TypeReference */) {
	        var tr = t;
	        var res = basicType(parseQualified(tr.typeName), path);
	        if (tr.typeArguments) {
	            tr.typeArguments.forEach(function (x) {
	                res.typeArguments.push(buildType(x, path));
	            });
	        }
	        return res;
	    }
	    if (t.kind == 137 /* ArrayType */) {
	        var q = t;
	        return arrayType(buildType(q.elementType, path));
	    }
	    if (t.kind == 139 /* UnionType */) {
	        var ut = t;
	        return unionType(ut.types.map(function (x) { return buildType(x, path); }));
	    }
	    throw new Error("Case not supported" + t.kind);
	}
	exports.buildType = buildType;
	function parseQualified(n) {
	    if (n.kind == 63 /* Identifier */) {
	        return n['text'];
	    }
	    else {
	        var q = n;
	        return parseQualified(q.left) + "." + parseQualified(q.right);
	    }
	}


/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	/// <reference path="../../typings/tsd.d.ts" />
	var ts = __webpack_require__(69);
	/***
	 * This module is designed to match simple patterns on Typescript AST Tree
	 * it functionality mirrors jsASTMatchers which allows you to match on jsAST
	 */
	//TODO RENAME TO MATCHERS
	var Matching;
	(function (Matching) {
	    /**
	     * do match checks the node type and if node type is ok
	     * calls match function otherwise it returns null
	     */
	    var BasicMatcher = (function () {
	        function BasicMatcher() {
	        }
	        BasicMatcher.prototype.match = function (node) {
	            throw new Error();
	        };
	        BasicMatcher.prototype.nodeType = function () {
	            throw new Error();
	        };
	        BasicMatcher.prototype.doMatch = function (n) {
	            if (!n) {
	                return null;
	            }
	            if (this.nodeType() == n.kind) {
	                return this.match(n);
	            }
	        };
	        return BasicMatcher;
	    })();
	    var ClassDeclarationMatcher = (function (_super) {
	        __extends(ClassDeclarationMatcher, _super);
	        function ClassDeclarationMatcher() {
	            _super.call(this);
	        }
	        ClassDeclarationMatcher.prototype.match = function (node) {
	            return node;
	        };
	        ClassDeclarationMatcher.prototype.nodeType = function () {
	            return 185 /* ClassDeclaration */;
	        };
	        return ClassDeclarationMatcher;
	    })(BasicMatcher);
	    var FieldMatcher = (function (_super) {
	        __extends(FieldMatcher, _super);
	        function FieldMatcher() {
	            _super.apply(this, arguments);
	        }
	        FieldMatcher.prototype.match = function (node) {
	            return node;
	        };
	        FieldMatcher.prototype.nodeType = function () {
	            return 124 /* Property */;
	        };
	        return FieldMatcher;
	    })(BasicMatcher);
	    var AssignmentExpressionMatcher = (function (_super) {
	        __extends(AssignmentExpressionMatcher, _super);
	        function AssignmentExpressionMatcher(left, right, tr) {
	            _super.call(this);
	            this.left = left;
	            this.right = right;
	            this.tr = tr;
	        }
	        AssignmentExpressionMatcher.prototype.match = function (node) {
	            if (node.operator == 51 /* EqualsToken */) {
	                if (this.left.doMatch(node.left) && this.right.doMatch(node.right)) {
	                    return this.tr(node);
	                }
	            }
	            return null;
	        };
	        AssignmentExpressionMatcher.prototype.nodeType = function () {
	            return 157 /* BinaryExpression */;
	        };
	        return AssignmentExpressionMatcher;
	    })(BasicMatcher);
	    var VariableDeclarationMatcher = (function (_super) {
	        __extends(VariableDeclarationMatcher, _super);
	        function VariableDeclarationMatcher(left, right, tr) {
	            _super.call(this);
	            this.left = left;
	            this.right = right;
	            this.tr = tr;
	        }
	        VariableDeclarationMatcher.prototype.match = function (node) {
	            if (this.left.doMatch(node.name) && this.right.doMatch(node.initializer)) {
	                return this.tr(node);
	            }
	        };
	        VariableDeclarationMatcher.prototype.nodeType = function () {
	            return 183 /* VariableDeclaration */;
	        };
	        return VariableDeclarationMatcher;
	    })(BasicMatcher);
	    var ExpressionStatementMatcher = (function (_super) {
	        __extends(ExpressionStatementMatcher, _super);
	        function ExpressionStatementMatcher(expression, tr) {
	            _super.call(this);
	            this.expression = expression;
	            this.tr = tr;
	        }
	        ExpressionStatementMatcher.prototype.match = function (node) {
	            var exp = this.expression.doMatch(node.expression);
	            if (exp) {
	                var v = this.tr(node.expression);
	                if (v == true) {
	                    return exp;
	                }
	                return v;
	            }
	            return null;
	        };
	        ExpressionStatementMatcher.prototype.nodeType = function () {
	            return 166 /* ExpressionStatement */;
	        };
	        return ExpressionStatementMatcher;
	    })(BasicMatcher);
	    var SimpleIdentMatcher = (function (_super) {
	        __extends(SimpleIdentMatcher, _super);
	        function SimpleIdentMatcher(val) {
	            _super.call(this);
	            this.val = val;
	        }
	        SimpleIdentMatcher.prototype.match = function (node) {
	            if (node.text == this.val) {
	                return true;
	            }
	            return null;
	        };
	        SimpleIdentMatcher.prototype.nodeType = function () {
	            return 63 /* Identifier */;
	        };
	        return SimpleIdentMatcher;
	    })(BasicMatcher);
	    var TrueMatcher = (function () {
	        function TrueMatcher() {
	        }
	        TrueMatcher.prototype.doMatch = function (node) {
	            return true;
	        };
	        TrueMatcher.prototype.nodeType = function () {
	            return null;
	        };
	        return TrueMatcher;
	    })();
	    var CallExpressionMatcher = (function (_super) {
	        __extends(CallExpressionMatcher, _super);
	        function CallExpressionMatcher(calleeMatcher, tr) {
	            _super.call(this);
	            this.calleeMatcher = calleeMatcher;
	            this.tr = tr;
	        }
	        CallExpressionMatcher.prototype.match = function (node) {
	            if (this.calleeMatcher.doMatch(node.expression)) {
	                return this.tr(node);
	            }
	            return null;
	        };
	        CallExpressionMatcher.prototype.nodeType = function () {
	            return 145 /* CallExpression */;
	        };
	        return CallExpressionMatcher;
	    })(BasicMatcher);
	    Matching.SKIP = {};
	    function visit(n, cb) {
	        var r0 = cb(n);
	        if (r0) {
	            if (r0 == Matching.SKIP) {
	                return null;
	            }
	            return r0;
	        }
	        var r = ts.forEachChild(n, function (x) {
	            var r = visit(x, cb);
	            if (r) {
	                return r;
	            }
	        });
	        return r;
	    }
	    Matching.visit = visit;
	    var PathNode = (function () {
	        function PathNode(name, _base) {
	            this._base = _base;
	            this.arguments = null;
	            this.name = name;
	        }
	        return PathNode;
	    })();
	    var CallPath = (function () {
	        function CallPath(base, _baseNode) {
	            this._baseNode = _baseNode;
	            this.path = [];
	            this.base = base;
	        }
	        CallPath.prototype.start = function () {
	            return this._baseNode.pos;
	        };
	        CallPath.prototype.startLocation = function () {
	            return this._baseNode.getSourceFile().getLineAndCharacterFromPosition(this.start());
	        };
	        CallPath.prototype.endLocation = function () {
	            return this._baseNode.getSourceFile().getLineAndCharacterFromPosition(this.end());
	        };
	        CallPath.prototype.end = function () {
	            var ce = this.path[this.path.length - 1]._callExpression;
	            if (ce) {
	                return ce.end;
	            }
	            return this.start();
	        };
	        CallPath.prototype.toString = function () {
	            return this.path.map(function (x) { return x.name; }).join(".");
	        };
	        return CallPath;
	    })();
	    Matching.CallPath = CallPath;
	    var MemberExpressionMatcher = (function (_super) {
	        __extends(MemberExpressionMatcher, _super);
	        function MemberExpressionMatcher(objectMatcher, propertyMatcher, tr) {
	            _super.call(this);
	            this.objectMatcher = objectMatcher;
	            this.propertyMatcher = propertyMatcher;
	            this.tr = tr;
	        }
	        MemberExpressionMatcher.prototype.match = function (node) {
	            if (this.objectMatcher.doMatch(node.expression) && this.propertyMatcher.doMatch(node.name)) {
	                return this.tr(node);
	            }
	            return null;
	        };
	        MemberExpressionMatcher.prototype.nodeType = function () {
	            return 143 /* PropertyAccessExpression */;
	        };
	        return MemberExpressionMatcher;
	    })(BasicMatcher);
	    function memberFromExp(objMatcher, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        var array = objMatcher.split(".");
	        var result = null;
	        for (var a = 0; a < array.length; a++) {
	            var arg = array[a];
	            var ci = arg.indexOf("(*)");
	            var isCall = false;
	            if (ci != -1) {
	                arg = arg.substr(0, ci);
	                isCall = true;
	            }
	            if (result == null) {
	                result = arg == '*' ? anyNode() : ident(arg);
	            }
	            else {
	                result = new MemberExpressionMatcher(result, arg == '*' ? anyNode() : ident(arg), tr);
	            }
	            if (isCall) {
	                result = new CallExpressionMatcher(result, tr);
	            }
	        }
	        //console.log(result)
	        return result;
	    }
	    Matching.memberFromExp = memberFromExp;
	    var CallBaseMatcher = (function () {
	        function CallBaseMatcher(rootMatcher) {
	            this.rootMatcher = rootMatcher;
	        }
	        CallBaseMatcher.prototype.doMatch = function (node) {
	            var original = node;
	            if (node.kind == 145 /* CallExpression */) {
	                var call = node;
	                var res = this.doMatch(call.expression);
	                if (res) {
	                    if (res.path.length > 0 && res.path[res.path.length - 1].arguments == null) {
	                        res.path[res.path.length - 1].arguments = call.arguments;
	                        res.path[res.path.length - 1]._callExpression = call;
	                        return res;
	                    }
	                    //This case should not exist in type script clients now
	                    //but leaving it here for possible future use at the moment;
	                    //if (res.path.length==0&&call.arguments.length==1){
	                    //    //this is not resource based call!!!
	                    //    if (call.arguments[0].kind==ts.SyntaxKind.StringLiteral){
	                    //        var l:ts.LiteralExpression=<ts.LiteralExpression>call.arguments[0];
	                    //        var url=l.text;
	                    //        var uriPath=url.toString().split("/");
	                    //        uriPath.forEach(x=>res.path.push(
	                    //            new PathNode(x)
	                    //        ))
	                    //        return res;
	                    //    }
	                    //}
	                    return null;
	                }
	            }
	            else if (node.kind == 143 /* PropertyAccessExpression */) {
	                var me = node;
	                var v = this.doMatch(me.expression);
	                if (v) {
	                    if (me.name.kind == 63 /* Identifier */) {
	                        v.path.push(new PathNode(me.name.text, me.name));
	                        return v;
	                    }
	                    return null;
	                }
	            }
	            else if (node.kind == 63 /* Identifier */) {
	                var id = node;
	                if (this.rootMatcher.doMatch(id)) {
	                    return new CallPath(id.text, id);
	                }
	            }
	            return null;
	        };
	        CallBaseMatcher.prototype.nodeType = function () {
	            return null;
	        };
	        return CallBaseMatcher;
	    })();
	    Matching.CallBaseMatcher = CallBaseMatcher;
	    function ident(name) {
	        return new SimpleIdentMatcher(name);
	    }
	    Matching.ident = ident;
	    function anyNode() {
	        return new TrueMatcher();
	    }
	    Matching.anyNode = anyNode;
	    function call(calleeMatcher, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new CallExpressionMatcher(calleeMatcher, tr);
	    }
	    Matching.call = call;
	    function exprStmt(eM, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new ExpressionStatementMatcher(eM, tr);
	    }
	    Matching.exprStmt = exprStmt;
	    function assign(left, right, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new AssignmentExpressionMatcher(left, right, tr);
	    }
	    Matching.assign = assign;
	    function varDecl(left, right, tr) {
	        if (tr === void 0) { tr = function (x) { return true; }; }
	        return new VariableDeclarationMatcher(left, right, tr);
	    }
	    Matching.varDecl = varDecl;
	    function field() {
	        return new FieldMatcher();
	    }
	    Matching.field = field;
	    function classDeclaration() {
	        return new ClassDeclarationMatcher();
	    }
	    Matching.classDeclaration = classDeclaration;
	})(Matching = exports.Matching || (exports.Matching = {}));


/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = require("know-your-http-well");

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var jsyaml = __webpack_require__(6);
	var defs = __webpack_require__(3);
	var hl = __webpack_require__(2);
	var _ = __webpack_require__(4);
	var typeExpression = __webpack_require__(63);
	var def = __webpack_require__(3);
	var hlimpl = __webpack_require__(5);
	var su = __webpack_require__(73);
	var path = __webpack_require__(9);
	var fs = __webpack_require__(10);
	var universes = __webpack_require__(62);
	var mediaTypeParser = __webpack_require__(78);
	var xmlutil = __webpack_require__(74);
	var LinterSettings = (function () {
	    function LinterSettings() {
	        this.validateNotStrictExamples = true;
	    }
	    return LinterSettings;
	})();
	var settings = new LinterSettings();
	var loophole = __webpack_require__(79);
	function evalInSandbox(code, thisArg, args) {
	    return new loophole.Function(code).call(thisArg, args);
	}
	exports.evalInSandbox = evalInSandbox;
	var lintWithFile = function (customLinter, acceptor, astNode) {
	    if (fs.existsSync(customLinter)) {
	        try {
	            var content = fs.readFileSync(customLinter).toString();
	            var factr = new LinterExtensionsImpl(acceptor);
	            evalInSandbox(content, factr, null);
	            factr.visit(astNode);
	        }
	        catch (e) {
	            console.log("Error in custom linter");
	            console.log(e);
	        }
	    }
	};
	function lintNode(astNode, acceptor) {
	    var ps = astNode.lowLevel().unit().absolutePath();
	    var dr = path.dirname(ps);
	    var customLinter = path.resolve(dr, "raml-lint.js");
	    lintWithFile(customLinter, acceptor, astNode);
	    var dir = path.resolve(dr, ".raml");
	    if (fs.existsSync(dir)) {
	        var st = fs.statSync(dir);
	        if (st.isDirectory()) {
	            var files = fs.readdirSync(dir);
	            files.forEach(function (x) {
	                if (x.indexOf("-lint.js") != -1) {
	                    lintWithFile(path.resolve(dir, x), acceptor, astNode);
	                }
	                //console.log(x);
	            });
	        }
	    }
	}
	exports.lintNode = lintNode;
	;
	var LinterExtensionsImpl = (function () {
	    function LinterExtensionsImpl(acceptor) {
	        this.acceptor = acceptor;
	        this.nodes = {};
	    }
	    LinterExtensionsImpl.prototype.error = function (w, message) {
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, w.highLevel()));
	    };
	    LinterExtensionsImpl.prototype.errorOnProperty = function (w, property, message) {
	        var pr = w.highLevel().attr(property);
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, pr));
	    };
	    LinterExtensionsImpl.prototype.warningOnProperty = function (w, property, message) {
	        var pr = w.highLevel().attr(property);
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, pr, true));
	    };
	    LinterExtensionsImpl.prototype.warning = function (w, message) {
	        this.acceptor.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, w.highLevel(), true));
	    };
	    LinterExtensionsImpl.prototype.registerRule = function (nodeType, rule) {
	        var q = this.nodes[nodeType];
	        if (!q) {
	            q = [];
	            this.nodes[nodeType] = q;
	        }
	        q.push(rule);
	    };
	    LinterExtensionsImpl.prototype.visit = function (h) {
	        var _this = this;
	        var nd = h.definition();
	        this.process(nd, h);
	        nd.allSuperTypes().forEach(function (x) { return _this.process(x, h); });
	        h.elements().forEach(function (y) { return _this.visit(y); });
	    };
	    LinterExtensionsImpl.prototype.process = function (d, h) {
	        var _this = this;
	        if (d instanceof def.NodeClass) {
	            if (!d.getDeclaringNode()) {
	                var rules = this.nodes[d.nameId()];
	                if (rules) {
	                    rules.forEach(function (x) { return x(h.wrapperNode(), _this); });
	                }
	            }
	        }
	    };
	    return LinterExtensionsImpl;
	})();
	exports.LinterExtensionsImpl = LinterExtensionsImpl;
	var StackNode = (function () {
	    function StackNode() {
	    }
	    StackNode.prototype.toString = function () {
	        if (this.prev) {
	            return this.value + "." + this.prev.toString();
	        }
	        return this.value;
	    };
	    StackNode.prototype.last = function () {
	        if (this.prev) {
	            return this.prev.last();
	        }
	        return this;
	    };
	    return StackNode;
	})();
	var TypeValidator = (function () {
	    function TypeValidator(node) {
	        this.node = node;
	    }
	    TypeValidator.prototype.validate = function (obj, t, cb, strict) {
	        if (t instanceof def.Array) {
	            this.validateArray(obj, t, cb, strict);
	        }
	        else if (t instanceof def.Union) {
	            this.validateUnion(obj, t, cb, strict);
	        }
	        else if (t instanceof def.NodeClass) {
	            this.validateClass(obj, t, cb, strict);
	        }
	        else if (t instanceof def.ValueType) {
	            this.validateValue(obj, t, cb, strict);
	        }
	        else {
	            throw new Error("Not supported case");
	        }
	    };
	    TypeValidator.prototype.createIssue = function (c, message, node, w) {
	        if (w === void 0) { w = false; }
	        var result = hlimpl.createIssue(c, message, node, w);
	        if (this.stack) {
	            var ll = this.findNode(this.stack.last(), this.node.lowLevel());
	            if (ll && ll != node.lowLevel()) {
	                if (ll.unit() == node.root().lowLevel().unit()) {
	                    if (ll.keyStart() > 0 && ll.keyEnd() > 0) {
	                        result.start = ll.keyStart();
	                        result.end = ll.keyEnd();
	                    }
	                }
	            }
	        }
	        return result;
	    };
	    TypeValidator.prototype.findNode = function (c, q) {
	        var key = "" + c.value;
	        if (typeof c.value == 'number') {
	            var m = q.children();
	            if (m[c.value]) {
	                var node = m[c.value];
	                if (c.next) {
	                    return this.findNode(c.next, node);
	                }
	            }
	            return q;
	        }
	        var node = _.find(q.children(), function (x) { return x.key() == key; });
	        if (node) {
	            if (c.next) {
	                return this.findNode(c.next, node);
	            }
	            return node;
	        }
	        else {
	            return q;
	        }
	    };
	    TypeValidator.prototype.validateClass = function (obj, t, cb, strict) {
	        var _this = this;
	        var supers = t.allSuperTypes();
	        supers.push(t);
	        this.validateFacets(t.isRuntime() ? t : t.toRuntime(), obj, cb, strict);
	        supers.forEach(function (s) {
	            if (s.key() == universes.Universe10.StrElement || s.key() == universes.Universe08.StrElement) {
	                if (typeof obj != 'string' && typeof obj != 'number' && typeof obj != 'boolean') {
	                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "String is expected", _this.node, !strict));
	                }
	            }
	            if (s.key() == universes.Universe10.NumberElement || s.key() == universes.Universe08.NumberElement) {
	                if (typeof obj != 'number') {
	                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Number is expected", _this.node, !strict));
	                }
	            }
	            if (s.key() == universes.Universe10.BooleanElement || s.key() == universes.Universe08.BooleanElement) {
	                var isOk = obj == true || obj == false;
	                if (!isOk) {
	                    cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "boolean is expected", _this.node, !strict));
	                }
	            }
	            if (s instanceof def.Array) {
	                _this.validate(obj, s, cb, strict);
	            }
	            if (s instanceof def.Union) {
	                _this.validate(obj, s, cb, strict);
	            }
	        });
	        var props = t.isRuntime() ? t.allProperties() : t.toRuntime().allProperties();
	        if (!obj) {
	            obj = {};
	        }
	        var handled = {};
	        props.forEach(function (p) {
	            if (!p.isMerged()) {
	                var value = obj[p.nameId()];
	                handled[p.nameId()] = 1;
	                if (!value) {
	                    if (p.isRequired()) {
	                        cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Required property:" + p.nameId() + " is missed", _this.node, !strict));
	                    }
	                }
	                else {
	                    _this.validatePropValue(value, p, cb, strict, p.nameId());
	                }
	            }
	        });
	        props.forEach(function (p) {
	            if (p.isMerged()) {
	                if (p.getKeyRegexp() != null) {
	                    Object.keys(obj).forEach(function (x) {
	                        if (!handled[x]) {
	                            try {
	                                var re = new RegExp(p.getKeyRegexp());
	                                if (re.test(x)) {
	                                    var n = _this.node;
	                                    _this.validatePropValue(obj[x], p, cb, strict, x);
	                                    handled[x] = 1;
	                                }
	                            }
	                            catch (e) {
	                            }
	                        }
	                    });
	                }
	            }
	        });
	        props.forEach(function (p) {
	            if (p.isMerged()) {
	                if (p.keyPrefix() != null) {
	                    Object.keys(obj).forEach(function (x) {
	                        if (!handled[x]) {
	                            _this.validatePropValue(obj[x], p, cb, strict, x);
	                            handled[x] = 1;
	                        }
	                    });
	                }
	            }
	        });
	        if (typeof obj == 'object' && props.length > 0) {
	            Object.keys(obj).forEach(function (x) {
	                if (!handled[x]) {
	                    try {
	                        _this.pushStack(x);
	                        cb.accept(_this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unknown property:" + x, _this.node, !strict));
	                    }
	                    finally {
	                        if (_this.stack) {
	                            _this.stack = _this.stack.prev;
	                        }
	                    }
	                }
	            });
	        }
	    };
	    TypeValidator.prototype.validateFacets = function (t, obj, cb, strict) {
	        var rof = t.getRepresentationOf();
	        var fixedFacets = t.getFixedFacets();
	        if (rof) {
	            t = rof;
	            if (t instanceof def.UserDefinedClass) {
	                fixedFacets = t.getFixedFacets();
	            }
	        }
	        for (var facetKey in fixedFacets) {
	            var facet = t.facet(facetKey);
	            if (facet) {
	                var facetValue = fixedFacets[facetKey];
	                var facetValidator = facet.getFacetValidator();
	                if (facetValidator) {
	                    try {
	                        var result = facetValidator(obj, facetValue);
	                        if (typeof result == "string") {
	                            cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + result, this.node, !strict));
	                        }
	                    }
	                    catch (e) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, this.node, !strict));
	                    }
	                }
	            }
	        }
	    };
	    TypeValidator.prototype.validatePropValue = function (value, p, cb, strict, key) {
	        this.pushStack(key);
	        try {
	            this.validate(value, p.range(), cb, strict);
	            var enumValues = p.enumValues(null);
	            if (enumValues) {
	                if (typeof enumValues == 'string') {
	                    if (enumValues != value) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + p.nameId() + " should be one of " + enumValues, this.node, !strict));
	                    }
	                }
	                else if (enumValues.length > 0) {
	                    if (!_.find(enumValues, function (x) { return x == value; })) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + p.nameId() + " should be one of " + enumValues, this.node, !strict));
	                    }
	                }
	            }
	        }
	        finally {
	            if (this.stack) {
	                this.stack = this.stack.prev;
	            }
	        }
	    };
	    TypeValidator.prototype.pushStack = function (key) {
	        if (!this.stack) {
	            this.stack = new StackNode();
	            this.stack.value = key;
	        }
	        else {
	            var pn = new StackNode();
	            pn.prev = this.stack;
	            this.stack.next = pn;
	            this.stack = pn;
	            this.stack.value = key;
	        }
	    };
	    TypeValidator.prototype.validateArray = function (obj, t, cb, strict) {
	        var _this = this;
	        if (!(obj instanceof Array)) {
	            obj = [obj];
	        }
	        if (obj instanceof Array) {
	            var arr = obj;
	            this.validateFacets(t, obj, cb, strict);
	            var num = 0;
	            arr.forEach(function (x) {
	                try {
	                    _this.pushStack(num++);
	                    _this.validate(x, t.component, cb, strict);
	                }
	                finally {
	                    if (_this.stack) {
	                        _this.stack = _this.stack.prev;
	                    }
	                }
	            });
	        }
	    };
	    TypeValidator.prototype.validateUnion = function (obj, t, cb, strict) {
	        //FIXME
	    };
	    TypeValidator.prototype.validateValue = function (obj, t, cb, strict) {
	        //FIXME
	        if (t.key() == universes.Universe08.NumberType || t.key() == universes.Universe10.NumberType) {
	            if (typeof obj != 'number') {
	                var qqq = parseFloat(obj);
	                if (!qqq) {
	                    if (isNaN(qqq)) {
	                        cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Number is expected", this.node, !strict));
	                    }
	                }
	            }
	        }
	        if (t.key() == universes.Universe08.BooleanType || t.key() == universes.Universe10.BooleanType) {
	            if (typeof obj != 'boolean') {
	                if (obj != 'true' && obj != 'false') {
	                    cb.accept(this.createIssue(7 /* INVALID_VALUE_SCHEMA */, "boolean is expected", this.node, !strict));
	                }
	            }
	        }
	    };
	    return TypeValidator;
	})();
	exports.TypeValidator = TypeValidator;
	var NormalValidator = (function () {
	    function NormalValidator() {
	    }
	    NormalValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (node.parent().allowsQuestion() && node.property().isKey()) {
	            if (vl != null && vl.length > 0 && vl.charAt(vl.length - 1) == '?') {
	                vl = vl.substr(0, vl.length - 1);
	            }
	        }
	        var pr = node.property();
	        var range = pr.range();
	        if (range instanceof def.NodeClass) {
	            var nc = range;
	            var rof = nc.getRepresentationOf();
	            if (rof) {
	                nc = rof;
	            }
	            var ff = nc.getFixedFacets();
	            for (var fc in ff) {
	                var facet = nc.facet(fc);
	                if (facet) {
	                    var val = facet.getFacetValidator();
	                    if (val) {
	                        try {
	                            var qq = vl;
	                            if (pr.range().isArray()) {
	                                try {
	                                    qq = node.parent().lowLevel().dumpToObject()[node.parent().name()][pr.nameId()];
	                                }
	                                catch (e) {
	                                }
	                            }
	                            var res = val(qq, ff[fc]);
	                            if (typeof res == 'string') {
	                                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + res, node));
	                            }
	                        }
	                        catch (e) {
	                            cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node));
	                        }
	                    }
	                }
	            }
	        }
	        var v = cb;
	        var validation = pr.range().isValid(node.parent(), vl, pr);
	        if (validation instanceof Error) {
	            if (!validation.canBeRef) {
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
	                validation = null;
	                return;
	            }
	        }
	        if (!validation || validation instanceof Error) {
	            if (pr.nameId() != 'value') {
	                if (!checkReference(pr, node, vl, v)) {
	                    if (pr.nameId() == universes.Universe10.DataElement.properties.schema.name || universes.Universe10.DataElement.properties.type.name) {
	                        if (vl && vl.trim() && (pr.domain().key() == universes.Universe08.BodyLike || pr.domain().key() == universes.Universe10.DataElement)) {
	                            var testSchema = vl.trim().charAt(0); //FIXME
	                            if (testSchema != '{' && testSchema != '<') {
	                                return;
	                            }
	                        }
	                    }
	                    var decl = node.findReferencedValue();
	                    if (decl instanceof Error) {
	                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, decl.message, node));
	                    }
	                    if (!decl) {
	                        if (vl) {
	                            if (pr.nameId() == universes.Universe10.DataElement.properties.schema.name) {
	                                var z = vl.trim();
	                                if (z.charAt(0) != '{' && z.charAt(0) != '<') {
	                                    if (vl.indexOf('|') != -1 || vl.indexOf('[]') != -1 || vl.indexOf("(") != -1) {
	                                        return;
	                                    }
	                                }
	                            }
	                        }
	                        if (validation instanceof Error && vl) {
	                            v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
	                            validation = null;
	                            return;
	                        }
	                        v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, "Empty value is not allowed here", node));
	                    }
	                }
	            }
	            else {
	                var vl = node.value();
	                var message = "Invalid value schema:" + vl;
	                if (validation instanceof Error) {
	                    message = validation.message;
	                }
	                v.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, message, node));
	            }
	        }
	        var values = pr.enumOptions();
	        if (values) {
	            if (typeof values == 'string') {
	                if (values != vl) {
	                    if (vl && (vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe08.SecuritySchema.properties.type.name) {
	                    }
	                    else {
	                        v.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Invalid value:" + vl + " allowed values are:" + values, node));
	                    }
	                }
	            }
	            else if (values.length > 0) {
	                if (!_.find(values, function (x) { return x == vl; })) {
	                    if (vl && (vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe08.SecuritySchema.properties.type.name) {
	                    }
	                    else {
	                        v.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Invalid value:" + vl + " allowed values are:" + values.join(","), node));
	                    }
	                }
	            }
	        }
	    };
	    return NormalValidator;
	})();
	exports.NormalValidator = NormalValidator;
	var UriValidator = (function () {
	    function UriValidator() {
	    }
	    UriValidator.prototype.validate = function (node, cb) {
	        try {
	            new UrlParameterNameValidator().parseUrl(node.value());
	        }
	        catch (e) {
	            cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, e.message, node, false));
	        }
	    };
	    return UriValidator;
	})();
	exports.UriValidator = UriValidator;
	var MediaTypeValidator = (function () {
	    function MediaTypeValidator() {
	    }
	    MediaTypeValidator.prototype.validate = function (node, cb) {
	        try {
	            var v = node.value();
	            if (!v) {
	                return;
	            }
	            if (v == "*/*") {
	                return;
	            }
	            if (v.indexOf("/*") == v.length - 2) {
	                v = v.substring(0, v.length - 2) + "/xxx";
	            }
	            if (v == "body") {
	                if (node.parent().parent()) {
	                    var ppc = node.parent().parent().definition().key();
	                    if (ppc === universes.Universe08.Response || ppc === universes.Universe10.Response || node.parent().parent().definition().isAssignableFrom(universes.Universe10.MethodBase.name)) {
	                        v = node.parent().computedValue("mediaType");
	                    }
	                }
	            }
	            var res = mediaTypeParser.parse(v);
	            var types = {
	                application: 1,
	                audio: 1,
	                example: 1,
	                image: 1,
	                message: 1,
	                model: 1,
	                multipart: 1,
	                text: 1,
	                video: 1
	            };
	            if (!types[res.type]) {
	                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unknown media type 'type'", node));
	            }
	        }
	        catch (e) {
	            cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "" + e.message, node));
	        }
	        if (node.value() && node.value() == ("multipart/form-data") || node.value() == ("application/x-www-form-urlencoded")) {
	            if (node.parent() && node.parent().parent() && node.parent().parent().property()) {
	                if (node.parent().parent().property().nameId() == universes.Universe10.MethodBase.properties.responses.name) {
	                    cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Form related media types can not be used in responses", node));
	                }
	            }
	        }
	        return;
	    };
	    return MediaTypeValidator;
	})();
	exports.MediaTypeValidator = MediaTypeValidator;
	//export class SignatureValidator implements PropertyValidator{
	//    validate(node:hl.IAttribute,cb:hl.ValidationAcceptor){
	//        var vl=node.value();
	//        var q = vl?vl.trim():"";
	//        if (q.length > 0 ) {
	//            try {
	//                //ramlSignature.validate(vl, node, cb);
	//            }catch (e){
	//                cb.accept(hlimpl.createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA,"Error during signature parse:"+e.message,node))
	//            }
	//            return;
	//        }
	//        return;
	//    }
	//}
	var UrlParameterNameValidator = (function () {
	    function UrlParameterNameValidator() {
	    }
	    UrlParameterNameValidator.prototype.checkBaseUri = function (node, c, vl, v) {
	        var bu = c.root().attr("baseUri");
	        if (bu) {
	            var tnv = bu.value();
	            try {
	                var pNames = this.parseUrl(tnv);
	                if (!_.find(pNames, function (x) { return x == vl; })) {
	                    v.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter", node));
	                }
	            }
	            catch (e) {
	            }
	        }
	        else {
	            v.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter", node));
	        }
	    };
	    UrlParameterNameValidator.prototype.parseUrl = function (value) {
	        var result = [];
	        var temp = "";
	        var inPar = false;
	        var count = 0;
	        for (var a = 0; a < value.length; a++) {
	            var c = value[a];
	            if (c == '{') {
	                count++;
	                inPar = true;
	                continue;
	            }
	            if (c == '}') {
	                count--;
	                inPar = false;
	                result.push(temp);
	                temp = "";
	                continue;
	            }
	            if (inPar) {
	                temp += c;
	            }
	        }
	        if (count > 0) {
	            throw new Error("Unmatched '{'");
	        }
	        if (count < 0) {
	            throw new Error("Unmatched '}'");
	        }
	        return result;
	    };
	    UrlParameterNameValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (node.parent().property().nameId() == universes.Universe10.Api.properties.baseUri.name) {
	            var c = node.parent().parent();
	            this.checkBaseUri(node, c, vl, cb);
	            return;
	        }
	        var c = node.parent().parent();
	        var tn = c.name();
	        if (c.definition().key() === universes.Universe10.Api || c.definition().key() === universes.Universe08.Api) {
	            this.checkBaseUri(node, c, vl, cb);
	            return;
	        }
	        try {
	            var pNames = this.parseUrl(tn);
	            if (!_.find(pNames, function (x) { return x == vl; })) {
	                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Unused url parameter '" + vl + "'", node));
	            }
	        }
	        catch (e) {
	        }
	    };
	    return UrlParameterNameValidator;
	})();
	exports.UrlParameterNameValidator = UrlParameterNameValidator;
	function checkReference(pr, astNode, vl, cb) {
	    if (!vl) {
	        return;
	    }
	    if (vl == 'null') {
	        if (pr.isAllowNull()) {
	            return;
	        }
	    }
	    try {
	        if (typeof vl == 'string') {
	            if (pr.domain().key() == universes.Universe10.DataElement) {
	                if (pr.nameId() == universes.Universe10.DataElement.properties.type.name || pr.nameId() == universes.Universe10.ArrayField.properties.items.name) {
	                    typeExpression.validate(vl, astNode, cb);
	                    return false;
	                }
	            }
	            if (pr.range().key() == universes.Universe08.SchemaString || pr.range().key() == universes.Universe10.SchemaString) {
	                if (pr.range().universe().version() == "RAML10") {
	                    if (pr.range() instanceof defs.ValueType) {
	                        typeExpression.validate(vl, astNode, cb);
	                        return false;
	                    }
	                }
	            }
	            if (pr.nameId() == universes.Universe10.DataElement.properties.schema.name || pr.nameId() == universes.Universe10.DataElement.properties.type.name) {
	                if (pr.domain().key() == universes.Universe08.BodyLike || pr.domain().key() == universes.Universe10.DataElement) {
	                    var q = vl.trim();
	                    if (q.length > 0 && q.charAt(0) != '{' && q.charAt(0) != '<') {
	                        typeExpression.validate(vl, astNode, cb);
	                        return false;
	                    }
	                    return;
	                }
	            }
	        }
	    }
	    catch (e) {
	        cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Syntax error:" + e.message, astNode));
	    }
	    var valid = pr.isValidValue(vl, astNode.parent());
	    if (!valid) {
	        if (typeof vl == 'string') {
	            if ((vl.indexOf("x-") == 0) && pr.nameId() == universes.Universe10.DataElement.properties.type.name) {
	                return true;
	            }
	        }
	        cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Unresolved reference:" + vl, astNode));
	        return true;
	    }
	    return false;
	}
	exports.checkReference = checkReference;
	;
	var SchemaOrTypeValidator = (function () {
	    function SchemaOrTypeValidator() {
	    }
	    SchemaOrTypeValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        if (vl instanceof hlimpl.StructuredValue) {
	            //already validated in scalar
	            //cb.accept(createIssue(hl.IssueCode.UNRESOLVED_REFERENCE,"Type expression is expected here",node));
	            return;
	        }
	        if (!vl) {
	            vl = "";
	        }
	        try {
	            typeExpression.validate(vl, node, cb);
	        }
	        catch (e) {
	            cb.accept(createIssue(0 /* UNRESOLVED_REFERENCE */, "Syntax error:" + e.message, node));
	        }
	    };
	    return SchemaOrTypeValidator;
	})();
	exports.SchemaOrTypeValidator = SchemaOrTypeValidator;
	var DescriminatorOrReferenceValidator = (function () {
	    function DescriminatorOrReferenceValidator() {
	    }
	    DescriminatorOrReferenceValidator.prototype.validate = function (node, cb) {
	        var vl = node.value();
	        var valueKey = vl;
	        var pr = node.property();
	        if (typeof vl == 'string') {
	            checkReference(pr, node, vl, cb);
	            if (pr.range() instanceof defs.ReferenceType) {
	                var t = pr.range();
	                if (true) {
	                    var mockNode = jsyaml.createNode("" + vl);
	                    mockNode._actualNode().startPosition = node.lowLevel().valueStart();
	                    mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
	                    var stv = new hlimpl.StructuredValue(mockNode, node.parent(), node.property());
	                    var hn = stv.toHighlevel();
	                    if (hn) {
	                        hn.validate(cb);
	                    }
	                }
	            }
	        }
	        else {
	            var st = vl;
	            if (st) {
	                valueKey = st.valueName();
	                var vn = st.valueName();
	                if (!checkReference(pr, node, vn, cb)) {
	                    var hnode = st.toHighlevel();
	                    if (hnode)
	                        hnode.validate(cb);
	                }
	            }
	            else {
	                valueKey = null;
	            }
	        }
	        if (valueKey) {
	            var validation = pr.range().isValid(node.parent(), valueKey, pr);
	            if (validation instanceof Error) {
	                cb.accept(createIssue(7 /* INVALID_VALUE_SCHEMA */, validation.message, node));
	                validation = null;
	            }
	        }
	    };
	    return DescriminatorOrReferenceValidator;
	})();
	exports.DescriminatorOrReferenceValidator = DescriminatorOrReferenceValidator;
	/**
	 * validates examples
	 */
	var ExampleValidator = (function () {
	    function ExampleValidator() {
	    }
	    ExampleValidator.prototype.validate = function (node, cb) {
	        //check if we expect to do strict validation
	        var strictValidation = this.isStrict(node);
	        if (!strictValidation) {
	            if (!settings.validateNotStrictExamples) {
	                return;
	            }
	        }
	        var pObj = this.parseObject(node, cb, strictValidation);
	        if (!pObj) {
	            return;
	        }
	        var schema = this.aquireSchema(node);
	        if (schema) {
	            schema.validate(pObj, cb, strictValidation);
	        }
	    };
	    ExampleValidator.prototype.aquireSchema = function (node) {
	        var sp = node.parent().definition().isAssignableFrom("DataElement");
	        if (node.name() == "example") {
	            if (node.parent().property().nameId() == universes.Universe10.LibraryBase.properties.types.name) {
	                sp = false;
	            }
	            if (node.parent().parent()) {
	                var ppc = node.parent().parent().definition().key();
	                if (ppc == universes.Universe08.Method || ppc == universes.Universe10.Method) {
	                    if (node.parent().property().nameId() == universes.Universe10.Method.properties.queryParameters.name) {
	                    }
	                    else {
	                        sp = true;
	                    }
	                }
	                if (ppc == universes.Universe08.Response || ppc == universes.Universe10.Response) {
	                    sp = true;
	                }
	            }
	        }
	        if (node.parent().definition().key() == universes.Universe08.BodyLike || sp) {
	            //FIXME MULTIPLE INHERITANCE
	            var sa = node.parent().attr("schema");
	            if (!sa) {
	                sa = node.parent().attr("type");
	            }
	            if (sa) {
	                var val = sa.value();
	                if (val instanceof hlimpl.StructuredValue) {
	                    return null;
	                }
	                var strVal = ("" + val).trim();
	                var so = null;
	                if (strVal.charAt(0) == "{") {
	                    try {
	                        so = su.getJSONSchema(strVal);
	                    }
	                    catch (e) {
	                        return null;
	                    }
	                }
	                if (strVal.charAt(0) == "<") {
	                    try {
	                        so = su.getXMLSchema(strVal);
	                    }
	                    catch (e) {
	                        return null;
	                    }
	                }
	                if (so) {
	                    return {
	                        validate: function (pObje, cb, strict) {
	                            try {
	                                so.validateObject(pObje);
	                            }
	                            catch (e) {
	                                cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Example does not conforms to schema:" + e.message, node, !strict));
	                                return;
	                            }
	                            //validate using classical schema;
	                        }
	                    };
	                }
	                else {
	                    //lets try to get schema from type
	                    if (strVal.length > 0) {
	                        var tp = typeExpression.getType2(node.parent(), strVal, {});
	                        if (tp) {
	                            return {
	                                validate: function (pObje, cb, strict) {
	                                    new TypeValidator(node).validate(pObje, tp, cb, strict);
	                                    //validate using typeExpression;
	                                }
	                            };
	                        }
	                    }
	                }
	            }
	        }
	        return this.getSchemaFromModel(node);
	    };
	    ExampleValidator.prototype.getSchemaFromModel = function (node) {
	        var p = node.parent();
	        if (node.property().nameId() == universes.Universe10.ExampleSpec.properties.content.name) {
	            p = p.parent();
	        }
	        var tp = hlimpl.typeFromNode(p);
	        if (tp) {
	            return {
	                validate: function (pObje, cb, strict) {
	                    new TypeValidator(node).validate(pObje, tp, cb, strict);
	                    //validate using typeExpression;
	                }
	            };
	        }
	        return null;
	    };
	    ExampleValidator.prototype.toObject = function (h, v, cb) {
	        var res = v.lowLevel().dumpToObject(true);
	        this.testDublication(h, v.lowLevel(), cb);
	        if (res["example"]) {
	            return res["example"];
	        }
	        if (res["content"]) {
	            return res["content"];
	        }
	    };
	    ExampleValidator.prototype.testDublication = function (h, v, cb) {
	        var _this = this;
	        var map = {};
	        v.children().forEach(function (x) {
	            if (x.key()) {
	                if (map[x.key()]) {
	                    cb.accept(createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "Keys should be unique", new hlimpl.BasicASTNode(x, h.parent())));
	                }
	                map[x.key()] = x;
	            }
	            _this.testDublication(h, x, cb);
	        });
	    };
	    ExampleValidator.prototype.parseObject = function (node, cb, strictValidation) {
	        var pObj = null;
	        var vl = node.value();
	        var mediaType = getMediaType(node);
	        if (vl instanceof hlimpl.StructuredValue) {
	            //validate in context of type/schema
	            pObj = this.toObject(node, vl, cb);
	        }
	        else {
	            if (mediaType) {
	                if (isJson(mediaType)) {
	                    try {
	                        pObj = JSON.parse(vl);
	                    }
	                    catch (e) {
	                        cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse JSON:" + e.message, node, !strictValidation));
	                        return;
	                    }
	                }
	                if (isXML(mediaType)) {
	                    try {
	                        pObj = xmlutil(vl);
	                    }
	                    catch (e) {
	                        cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse XML:" + e.message, node, !strictValidation));
	                        return;
	                    }
	                }
	            }
	            else {
	                try {
	                    pObj = JSON.parse(vl);
	                }
	                catch (e) {
	                    if (vl.trim().indexOf("<") == 0) {
	                        try {
	                            pObj = xmlutil(vl);
	                        }
	                        catch (e) {
	                            cb.accept(hlimpl.createIssue(7 /* INVALID_VALUE_SCHEMA */, "Can not parse XML:" + e.message, node, !strictValidation));
	                            return;
	                        }
	                    }
	                    else {
	                        //cb.accept(hlimpl.createIssue(hl.IssueCode.INVALID_VALUE_SCHEMA, "Can not parse JSON:" + e.message, node, !strictValidation));
	                        return vl;
	                    }
	                }
	            }
	        }
	        return pObj;
	    };
	    ExampleValidator.prototype.isStrict = function (node) {
	        var strictValidation = false;
	        var strict = node.parent().attr("strict");
	        if (strict) {
	            if (strict.value() == 'true') {
	                strictValidation = true;
	            }
	        }
	        return strictValidation;
	    };
	    return ExampleValidator;
	})();
	exports.ExampleValidator = ExampleValidator;
	function isJson(s) {
	    return s.indexOf("json") != -1;
	}
	function isXML(s) {
	    return s.indexOf("xml") != -1;
	}
	function getMediaType(node) {
	    var vl = getMediaType2(node);
	    if (vl == 'body') {
	        var rootMedia = node.root().attr("mediaType");
	        if (rootMedia) {
	            return rootMedia.value();
	        }
	        return null;
	    }
	    return vl;
	}
	function getMediaType2(node) {
	    if (node.parent()) {
	        var pc = node.parent().definition();
	        if (pc.key() == universes.Universe08.BodyLike) {
	            return node.parent().name();
	        }
	        if (node.parent().parent()) {
	            var ppc = node.parent().parent().definition().key();
	            if (ppc == universes.Universe08.Response || ppc == universes.Universe10.Response) {
	                if (node.parent().property().nameId() == universes.Universe08.Response.properties.headers.name) {
	                    return null;
	                }
	                return node.parent().name();
	            }
	            if (ppc == universes.Universe08.Method || ppc == universes.Universe10.Method) {
	                if (node.parent().property().nameId() == universes.Universe10.Method.properties.queryParameters.name || node.parent().property().nameId() == universes.Universe10.Method.properties.headers.name) {
	                    return null;
	                }
	                return node.parent().name();
	            }
	        }
	    }
	    return null;
	}
	var localError = function (node, c, w, message, p, prop) {
	    var st = node.lowLevel().start();
	    var et = node.lowLevel().end();
	    if (node.lowLevel().key() && node.lowLevel().keyStart()) {
	        var ks = node.lowLevel().keyStart();
	        if (ks > 0) {
	            st = ks;
	        }
	        var ke = node.lowLevel().keyEnd();
	        if (ke > 0) {
	            et = ke;
	        }
	    }
	    if (et < st) {
	        et = st + 1; //FIXME
	    }
	    if (prop && !prop.isMerged() && node.parent() == null) {
	        var nm = _.find(node.lowLevel().children(), function (x) { return x.key() == prop.nameId(); });
	        if (nm) {
	            var ks = nm.keyStart();
	            var ke = nm.keyEnd();
	            if (ks > 0 && ke > ks) {
	                st = ks;
	                et = ke;
	            }
	        }
	    }
	    return {
	        code: c,
	        isWarning: w,
	        message: message,
	        node: node,
	        start: st,
	        end: et,
	        path: p ? (node.lowLevel().unit() ? node.lowLevel().unit().path() : "") : null,
	        extras: [],
	        unit: node ? node.lowLevel().unit() : null
	    };
	};
	function createIssue(c, message, node, w) {
	    if (w === void 0) { w = false; }
	    //console.log(node.name()+node.lowLevel().start()+":"+node.id());
	    var original = null;
	    var pr = null;
	    if (node) {
	        pr = node.property();
	        if (node.lowLevel().unit() != node.root().lowLevel().unit()) {
	            original = localError(node, c, w, message, true, pr);
	            var v = node.lowLevel().unit();
	            if (v) {
	                message = message + " " + v.path();
	            }
	            while (node.lowLevel().unit() != node.root().lowLevel().unit()) {
	                pr = node.property();
	                node = node.parent();
	            }
	        }
	    }
	    if (original) {
	        if (node.property() && node.property().nameId() == universes.Universe10.LibraryBase.properties.uses.name && node.parent() != null) {
	            pr = node.property(); //FIXME there should be other cases
	            node = node.parent();
	        }
	    }
	    var error = localError(node, c, w, message, false, pr);
	    if (original) {
	        error.extras.push(original);
	    }
	    //console.log(error.start+":"+error.end)
	    return error;
	}
	exports.createIssue = createIssue;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var xmlutil = __webpack_require__(74);
	var lru = __webpack_require__(51);
	var ZSchema = __webpack_require__(76);
	var ValidationResult = (function () {
	    function ValidationResult() {
	    }
	    return ValidationResult;
	})();
	exports.ValidationResult = ValidationResult;
	var globalCache = lru(400);
	var useLint = true;
	var JSONSchemaObject = (function () {
	    function JSONSchemaObject(schema) {
	        this.schema = schema;
	        if (!schema || schema.trim().length == 0 || schema.trim().charAt(0) != '{') {
	            throw new Error("Invalid JSON schema content");
	        }
	        var jsonSchemaObject;
	        try {
	            var jsonSchemaObject = JSON.parse(schema);
	        }
	        catch (err) {
	            throw new Error("It is not JSON schema");
	        }
	        if (!jsonSchemaObject) {
	            return;
	        }
	        try {
	            var api = __webpack_require__(77);
	            jsonSchemaObject = api.v4(jsonSchemaObject);
	        }
	        catch (e) {
	            throw new Error('Can not parse schema' + schema);
	        }
	        delete jsonSchemaObject['$schema'];
	        delete jsonSchemaObject['required'];
	        this.jsonSchema = jsonSchemaObject;
	    }
	    JSONSchemaObject.prototype.getType = function () {
	        return "source.json";
	    };
	    JSONSchemaObject.prototype.validateObject = function (object) {
	        //TODO Validation of objects
	        //xmlutil(content);
	        this.validate(JSON.stringify(object));
	    };
	    JSONSchemaObject.prototype.validate = function (content) {
	        var key = content + this.schema;
	        var c = globalCache.get(key);
	        if (c) {
	            if (c instanceof Error) {
	                throw c;
	            }
	            return;
	        }
	        var validator = new ZSchema();
	        var valid = validator.validate(JSON.parse(content), this.jsonSchema);
	        var errors = validator.getLastErrors();
	        if (errors && errors.length > 0) {
	            var res = new Error("Content is not valid according to schema:" + errors.map(function (x) { return x.message + " " + x.params; }).join(", "));
	            res.errors = errors;
	            globalCache.set(key, res);
	            throw res;
	        }
	        globalCache.set(key, 1);
	    };
	    return JSONSchemaObject;
	})();
	exports.JSONSchemaObject = JSONSchemaObject;
	var XMLSchemaObject = (function () {
	    function XMLSchemaObject(schema) {
	        this.schema = schema;
	        if (schema.charAt(0) != '<') {
	            throw new Error("Invalid JSON schema");
	        }
	        xmlutil(schema);
	    }
	    XMLSchemaObject.prototype.getType = function () {
	        return "text.xml";
	    };
	    XMLSchemaObject.prototype.validate = function (content) {
	        xmlutil(content);
	    };
	    XMLSchemaObject.prototype.validateObject = function (object) {
	        //TODO Validation of objects
	        //xmlutil(content);
	    };
	    return XMLSchemaObject;
	})();
	exports.XMLSchemaObject = XMLSchemaObject;
	function getJSONSchema(content) {
	    var rs = useLint ? globalCache.get(content) : false;
	    if (rs) {
	        return rs;
	    }
	    var res = new JSONSchemaObject(content);
	    globalCache.set(content, res);
	    return res;
	}
	exports.getJSONSchema = getJSONSchema;
	function getXMLSchema(content) {
	    var rs = useLint ? globalCache.get(content) : false;
	    if (rs) {
	        return rs;
	    }
	    var res = new XMLSchemaObject(content);
	    if (useLint) {
	        globalCache.set(content, res);
	    }
	}
	exports.getXMLSchema = getXMLSchema;
	function createSchema(content) {
	    var rs = useLint ? globalCache.get(content) : false;
	    if (rs) {
	        return rs;
	    }
	    try {
	        var res = new JSONSchemaObject(content);
	        if (useLint) {
	            globalCache.set(content, res);
	        }
	        return res;
	    }
	    catch (e) {
	        try {
	            var res = new XMLSchemaObject(content);
	            if (useLint) {
	                globalCache.set(content, res);
	            }
	            return res;
	        }
	        catch (e) {
	            if (useLint) {
	                globalCache.set(content, new Error("Can not parse schema"));
	            }
	            return null;
	        }
	    }
	}
	exports.createSchema = createSchema;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var DomParser = __webpack_require__(75);
	function xmlToJson(xml) {
	    // Create the return object
	    var obj = {};
	    if (xml.nodeType == 1) {
	        // do attributes
	        if (xml.attributes.length > 0) {
	            for (var j = 0; j < xml.attributes.length; j++) {
	                var attribute = xml.attributes.item(j);
	                obj["@" + attribute.nodeName] = attribute.nodeValue;
	            }
	        }
	    }
	    else if (xml.nodeType == 3) {
	        obj = xml.nodeValue;
	    }
	    // do children
	    if (xml.hasChildNodes()) {
	        for (var i = 0; i < xml.childNodes.length; i++) {
	            var item = xml.childNodes.item(i);
	            var nodeName = item.nodeName;
	            if (nodeName == undefined) {
	                continue;
	            }
	            if (typeof (obj[nodeName]) == "undefined") {
	                obj[nodeName] = xmlToJson(item);
	            }
	            else {
	                if (typeof (obj[nodeName].push) == "undefined") {
	                    var old = obj[nodeName];
	                    obj[nodeName] = [];
	                    obj[nodeName].push(old);
	                }
	                obj[nodeName].push(xmlToJson(item));
	            }
	        }
	    }
	    return obj;
	}
	;
	function cleanupText(j) {
	    for (var p in j) {
	        if (typeof (j[p]) == "object") {
	            for (var k in j[p]) {
	                if (k == '#text') {
	                    var txt = j[p]['#text'];
	                    if (typeof (txt) != 'string') {
	                        txt = txt.join("");
	                    }
	                    txt = txt.trim();
	                    if (txt.length == 0) {
	                        delete j[p]['#text'];
	                    }
	                }
	            }
	            cleanupText(j[p]);
	        }
	    }
	    return j;
	}
	function cleanupJson(j) {
	    for (var p in j) {
	        if (typeof (j[p]) == "object") {
	            var keys = Object.keys(j[p]);
	            if (keys.length == 1) {
	                if (keys[0] == '#text') {
	                    j[p] = j[p]['#text'];
	                }
	            }
	            cleanupJson(j[p]);
	        }
	    }
	    return j;
	}
	function parseXML(value) {
	    var v = new DomParser.DOMParser();
	    var parsed = v.parseFromString(value);
	    return cleanupJson(cleanupText(xmlToJson(parsed)));
	}
	module.exports = parseXML;


/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = require("xmldom");

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = require("z-schema");

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = require("json-schema-compatibility");

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = require("media-typer");

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = require("loophole");

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var defs = __webpack_require__(3);
	var _ = __webpack_require__(4);
	var yaml = __webpack_require__(7);
	var typeExpression = __webpack_require__(63);
	var def = __webpack_require__(3);
	var hlimpl = __webpack_require__(5);
	var search = __webpack_require__(65);
	var universes = __webpack_require__(62);
	var KeyMatcher = (function () {
	    function KeyMatcher(_props) {
	        this._props = _props;
	        this.parentValue = _.find(_props, function (x) { return x.isFromParentValue(); });
	        this.parentKey = _.find(_props, function (x) { return x.isFromParentKey(); });
	        this.canBeValue = _.find(_props, function (x) { return x.canBeValue(); });
	    }
	    KeyMatcher.prototype.match = function (key) {
	        var _this = this;
	        var _res = null;
	        var lastPref = "";
	        this._props.forEach(function (p) {
	            if (p.isSystem()) {
	                return;
	            }
	            if (p != _this.parentValue && p != _this.parentKey && p.matchKey(key)) {
	                if (p.keyPrefix() != null) {
	                    if (p.keyPrefix().length >= lastPref.length) {
	                        lastPref = p.keyPrefix();
	                        _res = p;
	                    }
	                }
	                else {
	                    _res = p;
	                    lastPref = p.nameId();
	                }
	            }
	        });
	        return _res;
	    };
	    return KeyMatcher;
	})();
	var deep = 0;
	function getAllOptions(c) {
	    if (deep > 20) {
	        return [];
	    }
	    deep++;
	    try {
	        var result = [];
	        var tp = c.leftType();
	        if (tp) {
	            result.push(tp);
	        }
	        var r = c.rightType();
	        if (r) {
	            if (r.isUnion()) {
	                var options = getAllOptions(r.union());
	                result = result.concat(options);
	            }
	            else {
	                result.push(r);
	            }
	        }
	        return result;
	    }
	    finally {
	        deep--;
	    }
	}
	var ad = 0;
	var BasicNodeBuilder = (function () {
	    function BasicNodeBuilder() {
	        this.shouldDescriminate = false;
	    }
	    BasicNodeBuilder.prototype.process = function (node, childrenToAdopt) {
	        var _this = this;
	        var nn = node.lowLevel();
	        var cha = nn._node ? nn._node : nn;
	        try {
	            if (cha['currentChildren']) {
	                return cha['currentChildren'];
	            }
	            if (!node.definition()) {
	                return;
	            }
	            if (node.parent() == null && (!this.shouldDescriminate)) {
	                this.shouldDescriminate = true;
	                try {
	                    var children = this.process(node, childrenToAdopt);
	                    var ts = node;
	                    ts._children = children;
	                    var t = doDescrimination(node);
	                    if (t) {
	                        ts.patchType(t);
	                    }
	                    var children = this.process(node, childrenToAdopt);
	                    ts._children = children;
	                }
	                finally {
	                    this.shouldDescriminate = false;
	                }
	            }
	            if (node.definition().isUnion()) {
	                if (node.definition().isRuntime()) {
	                    var optins = getAllOptions(node.definition().union());
	                    var actualResult = null;
	                    var bestResult = null;
	                    var bestType = null;
	                    var bestCount = 1000;
	                    var llnode = node;
	                    optins.forEach(function (x) {
	                        if (!actualResult) {
	                            //TODO ADD UNION + Descriminator
	                            if (x instanceof def.NodeClass && !x.isUnionType()) {
	                                var tp = llnode.patchType(x);
	                                if (ad == 0) {
	                                    ad++;
	                                    try {
	                                        var result = _this.process(node, childrenToAdopt);
	                                        var uc = 0;
	                                        for (var i = 0; i < result.length; i++) {
	                                            if (result[i].isUnknown()) {
	                                                uc++;
	                                            }
	                                        }
	                                        if (uc == 0) {
	                                            actualResult = result;
	                                        }
	                                        if (bestCount > uc) {
	                                            bestCount = uc;
	                                            bestResult = result;
	                                            bestType = x;
	                                        }
	                                    }
	                                    finally {
	                                        ad--;
	                                    }
	                                }
	                            }
	                        }
	                    });
	                    if (actualResult) {
	                        return actualResult;
	                    }
	                    if (bestResult) {
	                        llnode.patchType(bestType);
	                    }
	                }
	            }
	            var km = new KeyMatcher(node.definition().allProperties());
	            var aNode = node;
	            var allowsQuestion = aNode._allowQuestion || node.definition().getAllowQuestion();
	            var res = [];
	            //cha['currentChildren']=res;
	            if (km.parentKey) {
	                if (node.lowLevel().key()) {
	                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentKey.range(), km.parentKey, true));
	                }
	            }
	            if (node.lowLevel().value()) {
	                if (km.parentValue) {
	                    res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.parentValue.range(), km.parentValue));
	                }
	                else if (km.canBeValue) {
	                    var s = node.lowLevel().value();
	                    if (typeof s == 'string' && s.trim().length > 0) {
	                        if (km.canBeValue.nameId() == universes.Universe10.Resource.properties.signature.name) {
	                            if (s.trim().charAt(0) == '(') {
	                                //TODO BETTER DECITION current one prevents completion from working correctly
	                                //in few other cases
	                                res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
	                            }
	                        }
	                        else {
	                            res.push(new hlimpl.ASTPropImpl(node.lowLevel(), node, km.canBeValue.range(), km.canBeValue));
	                        }
	                    }
	                }
	            }
	            else {
	                if (km.canBeValue && km.canBeValue.range() instanceof def.NodeClass) {
	                    var ch = new hlimpl.ASTNodeImpl(node.lowLevel(), aNode, km.canBeValue.range(), km.canBeValue);
	                    return [ch];
	                }
	            }
	            aNode._children = res;
	            if (!aNode.definition().isUserDefined()) {
	                if (aNode.definition().key() == universes.Universe08.Api || aNode.definition().key() == universes.Universe10.Api) {
	                    var uses = childrenToAdopt.filter(function (x) { return x.key() == "uses"; });
	                    res = this.processChildren(uses, aNode, res, allowsQuestion, km);
	                    var types = childrenToAdopt.filter(function (x) { return x.key() == "types"; });
	                    res = this.processChildren(types, aNode, res, allowsQuestion, km);
	                    var other = childrenToAdopt.filter(function (x) { return (x.key() != "types" && x.key() != "uses"); });
	                    res = this.processChildren(other, aNode, res, allowsQuestion, km);
	                }
	                else {
	                    res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
	                }
	            }
	            else {
	                res = this.processChildren(childrenToAdopt, aNode, res, allowsQuestion, km);
	            }
	            aNode._children = res;
	            return res;
	        }
	        finally {
	            if (ch) {
	                delete cha['currentChildren'];
	            }
	        }
	    };
	    BasicNodeBuilder.prototype.processChildren = function (childrenToAdopt, aNode, res, allowsQuestion, km) {
	        childrenToAdopt.forEach(function (x) {
	            var key = x.key();
	            if (allowsQuestion) {
	                if (key != null && key.charAt(key.length - 1) == '?') {
	                    key = key.substr(0, key.length - 1);
	                }
	            }
	            var p = km.match(key);
	            if (p != null) {
	                var range = p.range();
	                if (p.isAnnotation() && key != "annotations") {
	                    var pi = new hlimpl.ASTPropImpl(x, aNode, range, p);
	                    res.push(pi);
	                    return;
	                }
	                var um = false;
	                var multyValue = p.isMultiValue();
	                if (range instanceof def.Array) {
	                    var at = range;
	                    multyValue = true;
	                    range = at.component;
	                    um = true;
	                }
	                else if (range.isArray()) {
	                    multyValue = true;
	                    um = true;
	                }
	                //TODO DESCRIMINATORS
	                if (range.isValueType()) {
	                    var ch = x.children();
	                    var seq = (x.valueKind() == 3 /* SEQ */);
	                    if ((seq && ch.length > 0 || ch.length > 1) && multyValue) {
	                        ch.forEach(function (y) {
	                            var pi = new hlimpl.ASTPropImpl(y, aNode, range, p);
	                            res.push(pi);
	                        });
	                    }
	                    else {
	                        if (p.isInherited()) {
	                            aNode.setComputed(p.nameId(), x.value());
	                        }
	                        res.push(new hlimpl.ASTPropImpl(x, aNode, range, p));
	                    }
	                    //}
	                    return;
	                }
	                else {
	                    var rs = [];
	                    //now we need determine actual type
	                    aNode._children = res;
	                    if (!p.isMerged()) {
	                        if (multyValue) {
	                            if (p.isEmbedMap()) {
	                                var chld = x.children();
	                                if (chld.length == 0) {
	                                    if (x.value()) {
	                                        var bnode = new hlimpl.BasicASTNode(x, aNode);
	                                        bnode.knownProperty = p;
	                                        res.push(bnode);
	                                    }
	                                }
	                                chld.forEach(function (y) {
	                                    //TODO TRACK GROUP KEY
	                                    var cld = y.children();
	                                    if (!y.key() && cld.length == 1) {
	                                        var node = new hlimpl.ASTNodeImpl(cld[0], aNode, range, p);
	                                        node._allowQuestion = allowsQuestion;
	                                        rs.push(node);
	                                    }
	                                    else {
	                                        if (aNode.universe().version() == "RAML10") {
	                                            var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                            node._allowQuestion = allowsQuestion;
	                                            rs.push(node);
	                                        }
	                                        else {
	                                            var bnode = new hlimpl.BasicASTNode(y, aNode);
	                                            res.push(bnode);
	                                            if (y.key()) {
	                                                bnode.needSequence = true;
	                                            }
	                                        }
	                                    }
	                                });
	                            }
	                            else {
	                                var filter = {};
	                                var inherited = [];
	                                if (range instanceof defs.NodeClass) {
	                                    var nc = range;
	                                    if (nc.getCanInherit().length > 0) {
	                                        nc.getCanInherit().forEach(function (v) {
	                                            var vl = aNode.computedValue(v);
	                                            if (vl && p.nameId() == universes.Universe10.Response.properties.body.name) {
	                                                if (!_.find(x.children(), function (x) { return x.key() == vl; })) {
	                                                    //we can create inherited node;
	                                                    var pc = aNode.parent().definition().key();
	                                                    var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
	                                                    if (pc == universes.Universe10.MethodBase || pc == universes.Universe08.MethodBase) {
	                                                        node.setComputed("form", "true"); //FIXME
	                                                    }
	                                                    var t = descriminate(p, aNode, node);
	                                                    if (t) {
	                                                        node.patchType(t);
	                                                    }
	                                                    var ch = node.children();
	                                                    //this are false unknowns actual unknowns will be reported by parent node
	                                                    node._children = ch.filter(function (x) { return !x.isUnknown(); });
	                                                    node._allowQuestion = allowsQuestion;
	                                                    inherited.push(node);
	                                                    node.children().forEach(function (x) {
	                                                        if (x.property().isKey()) {
	                                                            var atr = x;
	                                                            atr._computed = true;
	                                                            return;
	                                                        }
	                                                        if (x.isElement()) {
	                                                            if (!x.property().isMerged()) {
	                                                                filter[x.property().nameId()] = true;
	                                                            }
	                                                        }
	                                                        if (x.property().isAnnotation()) {
	                                                            var atr = x;
	                                                            var vl = atr.value();
	                                                            var strVal = "";
	                                                            if (vl instanceof hlimpl.StructuredValue) {
	                                                                strVal = vl.valueName();
	                                                            }
	                                                            else {
	                                                                strVal = "" + vl;
	                                                            }
	                                                            filter["(" + strVal + ")"] = true;
	                                                        }
	                                                        else {
	                                                            filter[x.name()] = true;
	                                                        }
	                                                    });
	                                                    node._computed = true;
	                                                }
	                                            }
	                                        });
	                                    }
	                                }
	                                var parsed = [];
	                                x.children().forEach(function (y) {
	                                    if (filter[y.key()]) {
	                                        return;
	                                    }
	                                    var node = new hlimpl.ASTNodeImpl(y, aNode, range, p);
	                                    var dc = p.domain().key();
	                                    if (p.nameId() == "body" && (dc == universes.Universe08.MethodBase || dc == universes.Universe10.MethodBase)) {
	                                        node.setComputed("form", "true"); //FIXME
	                                    }
	                                    node._allowQuestion = allowsQuestion;
	                                    parsed.push(node);
	                                });
	                                if (parsed.length > 0) {
	                                    parsed.forEach(function (x) { return rs.push(x); });
	                                }
	                                else {
	                                    inherited.forEach(function (x) { return rs.push(x); });
	                                }
	                            }
	                        }
	                        else {
	                            //var y=x.children()[0];
	                            rs.push(new hlimpl.ASTNodeImpl(x, aNode, range, p));
	                        }
	                    }
	                    else {
	                        var node = new hlimpl.ASTNodeImpl(x, aNode, range, p);
	                        node._allowQuestion = allowsQuestion;
	                        rs.push(node);
	                    }
	                    aNode._children = aNode._children.concat(rs);
	                    res = res.concat(rs);
	                    rs.forEach(function (x) {
	                        var rt = descriminate(p, aNode, x);
	                        if (rt && rt != x.definition()) {
	                            x.patchType(rt);
	                        }
	                        x._associatedDef = null;
	                        p.childRestrictions().forEach(function (y) {
	                            x.setComputed(y.name, y.value);
	                        });
	                        var def = x.definition();
	                    });
	                }
	            }
	            else {
	                res.push(new hlimpl.BasicASTNode(x, aNode));
	            }
	        });
	        return res;
	    };
	    return BasicNodeBuilder;
	})();
	exports.BasicNodeBuilder = BasicNodeBuilder;
	function desc1(p, parent, x) {
	    var tp = x.attr("type");
	    var value = "";
	    if (tp) {
	        var mn = {};
	        var c = new def.NodeClass(x.name(), x.definition().universe(), "");
	        c.setDeclaringNode(x);
	        c._superTypes.push(x.definition().universe().getType(universes.Universe10.DataElement.name));
	        mn[tp.value()] = c;
	        var newType = typeExpression.getType(parent ? parent : x, tp.value(), mn);
	        if (newType instanceof def.Array) {
	            newType.setDeclaringNode(x);
	        }
	        return newType;
	    }
	    else {
	        if (p) {
	            if (p.nameId() == "body" || _.find(x.lowLevel().children(), function (x) { return x.key() == "properties"; })) {
	                return x.definition().universe().getType(universes.Universe10.ObjectField.name);
	            }
	        }
	        return x.definition().universe().getType(universes.Universe10.StrElement.name);
	    }
	    return null;
	}
	function doDescrimination(node) {
	    return descriminate(node.property(), node.parent(), node);
	}
	exports.doDescrimination = doDescrimination;
	function descriminate(p, parent, x) {
	    var n = x.lowLevel();
	    if (p) {
	        if (p.nameId() == universes.Universe10.LibraryBase.properties.uses.name && p.range().nameId() == universes.Universe10.Library.name) {
	        }
	    }
	    var range = p ? p.range().nameId() : x.definition().nameId();
	    if (n._node && n._node['descriminate']) {
	        return null;
	    }
	    if (n._node) {
	        n._node['descriminate'] = 1;
	    }
	    try {
	        if (range == universes.Universe10.DataElement.name) {
	            var res = desc1(p, parent, x);
	            //FIXME (think about it later)
	            if (p) {
	                if (res != null && ((p.nameId() == "body" || p.nameId() == "headers") || p.nameId() == "queryParameters")) {
	                    var ares = new defs.UserDefinedClass(x.lowLevel().key(), res.universe(), x, x.lowLevel().unit() ? x.lowLevel().unit().path() : "", "");
	                    ares._superTypes.push(res);
	                    return ares;
	                }
	            }
	            if (res) {
	                return res;
	            }
	        }
	        //generic case;
	        var rt = null;
	        if (p && parent) {
	            var types = search.findAllSubTypes(p, parent);
	            if (types.length > 0) {
	                types.forEach(function (y) {
	                    if (!rt) {
	                        if (y.match(x, rt)) {
	                            rt = y;
	                        }
	                    }
	                });
	            }
	            return rt;
	        }
	    }
	    finally {
	        if (n._node) {
	            delete n._node['descriminate'];
	        }
	    }
	}
	;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	var factory10 = __webpack_require__(82);
	var factory08 = __webpack_require__(83);
	function buildWrapperNode(node) {
	    var ramlVersion = node.definition().universe().version();
	    if (ramlVersion == 'RAML10') {
	        return factory10.buildWrapperNode(node);
	    }
	    else if (ramlVersion == 'RAML08') {
	        return factory08.buildWrapperNode(node);
	    }
	    return null;
	}
	exports.buildWrapperNode = buildWrapperNode;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(1);
	/***
	 * @hidden
	 * Build Wrapper node corresponding to the High Level node
	 ***/
	function buildWrapperNode(node) {
	    var nodeClassName = node.definition().nameId();
	    var wrapperConstructor = classMap[nodeClassName];
	    if (!wrapperConstructor) {
	        var m = node.definition().allSuperTypes();
	        var wr = null;
	        for (var i = 0; i < m.length; i++) {
	            var nm = m[i].nameId();
	            wrapperConstructor = classMap[nm];
	            if (nm == "DataElement") {
	                wr = nm;
	                continue;
	            }
	            if (nm == "RAMLLanguageElement") {
	                continue;
	            }
	            if (wrapperConstructor) {
	                break;
	            }
	        }
	        if (!wrapperConstructor) {
	            wr = nm;
	        }
	    }
	    if (!wrapperConstructor) {
	        wrapperConstructor = classMap["RAMLLanguageElement"];
	    }
	    return wrapperConstructor(node);
	}
	exports.buildWrapperNode = buildWrapperNode;
	var classMap = {
	    "AnnotationRef": function (x) {
	        return new RamlWrapper.AnnotationRefImpl(x);
	    },
	    "AnnotationTarget": function (x) {
	        return new RamlWrapper.AnnotationTargetImpl(x);
	    },
	    "AnnotationType": function (x) {
	        return new RamlWrapper.AnnotationTypeImpl(x);
	    },
	    "Api": function (x) {
	        return new RamlWrapper.ApiImpl(x);
	    },
	    "ApiDescription": function (x) {
	        return new RamlWrapper.ApiDescriptionImpl(x);
	    },
	    "ArrayField": function (x) {
	        return new RamlWrapper.ArrayFieldImpl(x);
	    },
	    "Basic": function (x) {
	        return new RamlWrapper.BasicImpl(x);
	    },
	    "BooleanElement": function (x) {
	        return new RamlWrapper.BooleanElementImpl(x);
	    },
	    "BooleanType": function (x) {
	        return new RamlWrapper.BooleanTypeImpl(x);
	    },
	    "CallbackAPIDescription": function (x) {
	        return new RamlWrapper.CallbackAPIDescriptionImpl(x);
	    },
	    "ContentType": function (x) {
	        return new RamlWrapper.ContentTypeImpl(x);
	    },
	    "Custom": function (x) {
	        return new RamlWrapper.CustomImpl(x);
	    },
	    "DataElement": function (x) {
	        return new RamlWrapper.DataElementImpl(x);
	    },
	    "DataElementRef": function (x) {
	        return new RamlWrapper.DataElementRefImpl(x);
	    },
	    "DateElement": function (x) {
	        return new RamlWrapper.DateElementImpl(x);
	    },
	    "DateFormatSpec": function (x) {
	        return new RamlWrapper.DateFormatSpecImpl(x);
	    },
	    "Digest": function (x) {
	        return new RamlWrapper.DigestImpl(x);
	    },
	    "DocumentationItem": function (x) {
	        return new RamlWrapper.DocumentationItemImpl(x);
	    },
	    "ExampleSpec": function (x) {
	        return new RamlWrapper.ExampleSpecImpl(x);
	    },
	    "ExampleString": function (x) {
	        return new RamlWrapper.ExampleStringImpl(x);
	    },
	    "Extension": function (x) {
	        return new RamlWrapper.ExtensionImpl(x);
	    },
	    "FileParameter": function (x) {
	        return new RamlWrapper.FileParameterImpl(x);
	    },
	    "FixedUri": function (x) {
	        return new RamlWrapper.FixedUriImpl(x);
	    },
	    "FullUriTemplate": function (x) {
	        return new RamlWrapper.FullUriTemplateImpl(x);
	    },
	    "FunctionalInterface": function (x) {
	        return new RamlWrapper.FunctionalInterfaceImpl(x);
	    },
	    "GlobalSchema": function (x) {
	        return new RamlWrapper.GlobalSchemaImpl(x);
	    },
	    "HasNormalParameters": function (x) {
	        return new RamlWrapper.HasNormalParametersImpl(x);
	    },
	    "ImportDeclaration": function (x) {
	        return new RamlWrapper.ImportDeclarationImpl(x);
	    },
	    "IntegerElement": function (x) {
	        return new RamlWrapper.IntegerElementImpl(x);
	    },
	    "JSonSchemaString": function (x) {
	        return new RamlWrapper.JSonSchemaStringImpl(x);
	    },
	    "Library": function (x) {
	        return new RamlWrapper.LibraryImpl(x);
	    },
	    "LibraryBase": function (x) {
	        return new RamlWrapper.LibraryBaseImpl(x);
	    },
	    "LocationKind": function (x) {
	        return new RamlWrapper.LocationKindImpl(x);
	    },
	    "MarkdownString": function (x) {
	        return new RamlWrapper.MarkdownStringImpl(x);
	    },
	    "Method": function (x) {
	        return new RamlWrapper.MethodImpl(x);
	    },
	    "MethodBase": function (x) {
	        return new RamlWrapper.MethodBaseImpl(x);
	    },
	    "MimeType": function (x) {
	        return new RamlWrapper.MimeTypeImpl(x);
	    },
	    "ModelLocation": function (x) {
	        return new RamlWrapper.ModelLocationImpl(x);
	    },
	    "NumberElement": function (x) {
	        return new RamlWrapper.NumberElementImpl(x);
	    },
	    "NumberType": function (x) {
	        return new RamlWrapper.NumberTypeImpl(x);
	    },
	    "OAuth1SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x);
	    },
	    "OAuth2SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x);
	    },
	    "Oath1": function (x) {
	        return new RamlWrapper.Oath1Impl(x);
	    },
	    "Oath2": function (x) {
	        return new RamlWrapper.Oath2Impl(x);
	    },
	    "ObjectField": function (x) {
	        return new RamlWrapper.ObjectFieldImpl(x);
	    },
	    "Overlay": function (x) {
	        return new RamlWrapper.OverlayImpl(x);
	    },
	    "PassThrough": function (x) {
	        return new RamlWrapper.PassThroughImpl(x);
	    },
	    "PassThroughSettings": function (x) {
	        return new RamlWrapper.PassThroughSettingsImpl(x);
	    },
	    "RAMLExpression": function (x) {
	        return new RamlWrapper.RAMLExpressionImpl(x);
	    },
	    "RAMLLanguageElement": function (x) {
	        return new RamlWrapper.RAMLLanguageElementImpl(x);
	    },
	    "RAMLPointer": function (x) {
	        return new RamlWrapper.RAMLPointerImpl(x);
	    },
	    "RAMLPointerElement": function (x) {
	        return new RamlWrapper.RAMLPointerElementImpl(x);
	    },
	    "RAMLProject": function (x) {
	        return new RamlWrapper.RAMLProjectImpl(x);
	    },
	    "RAMLSelector": function (x) {
	        return new RamlWrapper.RAMLSelectorImpl(x);
	    },
	    "RAMLSimpleElement": function (x) {
	        return new RamlWrapper.RAMLSimpleElementImpl(x);
	    },
	    "Reference": function (x) {
	        return new RamlWrapper.ReferenceImpl(x);
	    },
	    "RelativeUri": function (x) {
	        return new RamlWrapper.RelativeUriImpl(x);
	    },
	    "Resource": function (x) {
	        return new RamlWrapper.ResourceImpl(x);
	    },
	    "ResourceBase": function (x) {
	        return new RamlWrapper.ResourceBaseImpl(x);
	    },
	    "ResourceType": function (x) {
	        return new RamlWrapper.ResourceTypeImpl(x);
	    },
	    "ResourceTypeRef": function (x) {
	        return new RamlWrapper.ResourceTypeRefImpl(x);
	    },
	    "Response": function (x) {
	        return new RamlWrapper.ResponseImpl(x);
	    },
	    "SchemaElement": function (x) {
	        return new RamlWrapper.SchemaElementImpl(x);
	    },
	    "SchemaString": function (x) {
	        return new RamlWrapper.SchemaStringImpl(x);
	    },
	    "ScriptHookElement": function (x) {
	        return new RamlWrapper.ScriptHookElementImpl(x);
	    },
	    "ScriptSpec": function (x) {
	        return new RamlWrapper.ScriptSpecImpl(x);
	    },
	    "ScriptingHook": function (x) {
	        return new RamlWrapper.ScriptingHookImpl(x);
	    },
	    "SecuritySchema": function (x) {
	        return new RamlWrapper.SecuritySchemaImpl(x);
	    },
	    "SecuritySchemaHookScript": function (x) {
	        return new RamlWrapper.SecuritySchemaHookScriptImpl(x);
	    },
	    "SecuritySchemaPart": function (x) {
	        return new RamlWrapper.SecuritySchemaPartImpl(x);
	    },
	    "SecuritySchemaRef": function (x) {
	        return new RamlWrapper.SecuritySchemaRefImpl(x);
	    },
	    "SecuritySchemaSettings": function (x) {
	        return new RamlWrapper.SecuritySchemaSettingsImpl(x);
	    },
	    "SecuritySchemaType": function (x) {
	        return new RamlWrapper.SecuritySchemaTypeImpl(x);
	    },
	    "StatusCode": function (x) {
	        return new RamlWrapper.StatusCodeImpl(x);
	    },
	    "StrElement": function (x) {
	        return new RamlWrapper.StrElementImpl(x);
	    },
	    "StringType": function (x) {
	        return new RamlWrapper.StringTypeImpl(x);
	    },
	    "Trait": function (x) {
	        return new RamlWrapper.TraitImpl(x);
	    },
	    "TraitRef": function (x) {
	        return new RamlWrapper.TraitRefImpl(x);
	    },
	    "UnionField": function (x) {
	        return new RamlWrapper.UnionFieldImpl(x);
	    },
	    "UriTemplate": function (x) {
	        return new RamlWrapper.UriTemplateImpl(x);
	    },
	    "ValidityExpression": function (x) {
	        return new RamlWrapper.ValidityExpressionImpl(x);
	    },
	    "ValueElement": function (x) {
	        return new RamlWrapper.ValueElementImpl(x);
	    },
	    "ValueType": function (x) {
	        return new RamlWrapper.ValueTypeImpl(x);
	    },
	    "XMLInfo": function (x) {
	        return new RamlWrapper.XMLInfoImpl(x);
	    },
	    "XMLSchemaString": function (x) {
	        return new RamlWrapper.XMLSchemaStringImpl(x);
	    },
	    "pointer": function (x) {
	        return new RamlWrapper.pointerImpl(x);
	    },
	    "ramlexpression": function (x) {
	        return new RamlWrapper.ramlexpressionImpl(x);
	    }
	};


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(84);
	/***
	 * @hidden
	 * Build Wrapper node corresponding to the High Level node
	 ***/
	function buildWrapperNode(node) {
	    var nodeClassName = node.definition().nameId();
	    var wrapperConstructor = classMap[nodeClassName];
	    if (!wrapperConstructor) {
	        var m = node.definition().allSuperTypes();
	        var wr = null;
	        for (var i = 0; i < m.length; i++) {
	            var nm = m[i].nameId();
	            wrapperConstructor = classMap[nm];
	            if (nm == "DataElement") {
	                wr = nm;
	                continue;
	            }
	            if (nm == "RAMLLanguageElement") {
	                continue;
	            }
	            if (wrapperConstructor) {
	                break;
	            }
	        }
	        if (!wrapperConstructor) {
	            wr = nm;
	        }
	    }
	    if (!wrapperConstructor) {
	        wrapperConstructor = classMap["RAMLLanguageElement"];
	    }
	    return wrapperConstructor(node);
	}
	exports.buildWrapperNode = buildWrapperNode;
	var classMap = {
	    "Api": function (x) {
	        return new RamlWrapper.ApiImpl(x);
	    },
	    "BodyLike": function (x) {
	        return new RamlWrapper.BodyLikeImpl(x);
	    },
	    "BooleanElement": function (x) {
	        return new RamlWrapper.BooleanElementImpl(x);
	    },
	    "BooleanType": function (x) {
	        return new RamlWrapper.BooleanTypeImpl(x);
	    },
	    "DateElement": function (x) {
	        return new RamlWrapper.DateElementImpl(x);
	    },
	    "DocumentationItem": function (x) {
	        return new RamlWrapper.DocumentationItemImpl(x);
	    },
	    "ExampleString": function (x) {
	        return new RamlWrapper.ExampleStringImpl(x);
	    },
	    "FileElement": function (x) {
	        return new RamlWrapper.FileElementImpl(x);
	    },
	    "FixedUri": function (x) {
	        return new RamlWrapper.FixedUriImpl(x);
	    },
	    "FullUriTemplate": function (x) {
	        return new RamlWrapper.FullUriTemplateImpl(x);
	    },
	    "GlobalSchema": function (x) {
	        return new RamlWrapper.GlobalSchemaImpl(x);
	    },
	    "HasNormalParameters": function (x) {
	        return new RamlWrapper.HasNormalParametersImpl(x);
	    },
	    "IntegerElement": function (x) {
	        return new RamlWrapper.IntegerElementImpl(x);
	    },
	    "JSONBody": function (x) {
	        return new RamlWrapper.JSONBodyImpl(x);
	    },
	    "JSONExample": function (x) {
	        return new RamlWrapper.JSONExampleImpl(x);
	    },
	    "JSonSchemaString": function (x) {
	        return new RamlWrapper.JSonSchemaStringImpl(x);
	    },
	    "MarkdownString": function (x) {
	        return new RamlWrapper.MarkdownStringImpl(x);
	    },
	    "Method": function (x) {
	        return new RamlWrapper.MethodImpl(x);
	    },
	    "MethodBase": function (x) {
	        return new RamlWrapper.MethodBaseImpl(x);
	    },
	    "MimeType": function (x) {
	        return new RamlWrapper.MimeTypeImpl(x);
	    },
	    "NumberElement": function (x) {
	        return new RamlWrapper.NumberElementImpl(x);
	    },
	    "NumberType": function (x) {
	        return new RamlWrapper.NumberTypeImpl(x);
	    },
	    "OAuth1SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth1SecuritySchemeSettingsImpl(x);
	    },
	    "OAuth2SecuritySchemeSettings": function (x) {
	        return new RamlWrapper.OAuth2SecuritySchemeSettingsImpl(x);
	    },
	    "Parameter": function (x) {
	        return new RamlWrapper.ParameterImpl(x);
	    },
	    "ParameterLocation": function (x) {
	        return new RamlWrapper.ParameterLocationImpl(x);
	    },
	    "RAMLLanguageElement": function (x) {
	        return new RamlWrapper.RAMLLanguageElementImpl(x);
	    },
	    "RAMLSimpleElement": function (x) {
	        return new RamlWrapper.RAMLSimpleElementImpl(x);
	    },
	    "Reference": function (x) {
	        return new RamlWrapper.ReferenceImpl(x);
	    },
	    "RelativeUri": function (x) {
	        return new RamlWrapper.RelativeUriImpl(x);
	    },
	    "Resource": function (x) {
	        return new RamlWrapper.ResourceImpl(x);
	    },
	    "ResourceType": function (x) {
	        return new RamlWrapper.ResourceTypeImpl(x);
	    },
	    "ResourceTypeRef": function (x) {
	        return new RamlWrapper.ResourceTypeRefImpl(x);
	    },
	    "Response": function (x) {
	        return new RamlWrapper.ResponseImpl(x);
	    },
	    "SchemaString": function (x) {
	        return new RamlWrapper.SchemaStringImpl(x);
	    },
	    "SecuritySchema": function (x) {
	        return new RamlWrapper.SecuritySchemaImpl(x);
	    },
	    "SecuritySchemaPart": function (x) {
	        return new RamlWrapper.SecuritySchemaPartImpl(x);
	    },
	    "SecuritySchemaRef": function (x) {
	        return new RamlWrapper.SecuritySchemaRefImpl(x);
	    },
	    "SecuritySchemaSettings": function (x) {
	        return new RamlWrapper.SecuritySchemaSettingsImpl(x);
	    },
	    "StatusCode": function (x) {
	        return new RamlWrapper.StatusCodeImpl(x);
	    },
	    "StrElement": function (x) {
	        return new RamlWrapper.StrElementImpl(x);
	    },
	    "StringType": function (x) {
	        return new RamlWrapper.StringTypeImpl(x);
	    },
	    "Trait": function (x) {
	        return new RamlWrapper.TraitImpl(x);
	    },
	    "TraitRef": function (x) {
	        return new RamlWrapper.TraitRefImpl(x);
	    },
	    "UriTemplate": function (x) {
	        return new RamlWrapper.UriTemplateImpl(x);
	    },
	    "ValueType": function (x) {
	        return new RamlWrapper.ValueTypeImpl(x);
	    },
	    "XMLBody": function (x) {
	        return new RamlWrapper.XMLBodyImpl(x);
	    },
	    "XMLExample": function (x) {
	        return new RamlWrapper.XMLExampleImpl(x);
	    },
	    "XMLSchemaString": function (x) {
	        return new RamlWrapper.XMLSchemaStringImpl(x);
	    }
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var hl = __webpack_require__(2);
	var json2lowlevel = __webpack_require__(60);
	var core = __webpack_require__(85);
	var apiLoader = __webpack_require__(86);
	var helper = __webpack_require__(96);
	var RAMLLanguageElementImpl = (function (_super) {
	    __extends(RAMLLanguageElementImpl, _super);
	    function RAMLLanguageElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLLanguageElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLLanguageElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLLanguageElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLLanguageElementImpl.prototype.getKind = function () {
	        return "RAMLLanguageElement";
	    };
	    /***
	     * The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]
	     ***/
	    RAMLLanguageElementImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return RAMLLanguageElementImpl;
	})(core.BasicNodeImpl);
	exports.RAMLLanguageElementImpl = RAMLLanguageElementImpl;
	var ValueTypeImpl = (function () {
	    function ValueTypeImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ValueTypeImpl.prototype.wrapperClassName = function () {
	        return "ValueTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ValueTypeImpl.prototype.getKind = function () {
	        return "ValueType";
	    };
	    /***
	     * @return String representation of the node value
	     ***/
	    ValueTypeImpl.prototype.value = function () {
	        return this.attr.value();
	    };
	    /***
	     * @return Underlying High Level attribute node
	     ***/
	    ValueTypeImpl.prototype.highLevel = function () {
	        return this.attr;
	    };
	    return ValueTypeImpl;
	})();
	exports.ValueTypeImpl = ValueTypeImpl;
	var NumberTypeImpl = (function (_super) {
	    __extends(NumberTypeImpl, _super);
	    function NumberTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    NumberTypeImpl.prototype.wrapperClassName = function () {
	        return "NumberTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    NumberTypeImpl.prototype.getKind = function () {
	        return "NumberType";
	    };
	    return NumberTypeImpl;
	})(ValueTypeImpl);
	exports.NumberTypeImpl = NumberTypeImpl;
	var BooleanTypeImpl = (function (_super) {
	    __extends(BooleanTypeImpl, _super);
	    function BooleanTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    BooleanTypeImpl.prototype.wrapperClassName = function () {
	        return "BooleanTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    BooleanTypeImpl.prototype.getKind = function () {
	        return "BooleanType";
	    };
	    return BooleanTypeImpl;
	})(ValueTypeImpl);
	exports.BooleanTypeImpl = BooleanTypeImpl;
	var ReferenceImpl = (function () {
	    function ReferenceImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ReferenceImpl.prototype.wrapperClassName = function () {
	        return "ReferenceImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ReferenceImpl.prototype.getKind = function () {
	        return "Reference";
	    };
	    /***
	     * @return StructuredValue object representing the node value
	     ***/
	    ReferenceImpl.prototype.value = function () {
	        return core.toStructuredValue(this.attr);
	    };
	    return ReferenceImpl;
	})();
	exports.ReferenceImpl = ReferenceImpl;
	var ResourceTypeRefImpl = (function (_super) {
	    __extends(ResourceTypeRefImpl, _super);
	    function ResourceTypeRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceTypeRefImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceTypeRefImpl.prototype.getKind = function () {
	        return "ResourceTypeRef";
	    };
	    return ResourceTypeRefImpl;
	})(ReferenceImpl);
	exports.ResourceTypeRefImpl = ResourceTypeRefImpl;
	var TraitRefImpl = (function (_super) {
	    __extends(TraitRefImpl, _super);
	    function TraitRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    TraitRefImpl.prototype.wrapperClassName = function () {
	        return "TraitRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    TraitRefImpl.prototype.getKind = function () {
	        return "TraitRef";
	    };
	    return TraitRefImpl;
	})(ReferenceImpl);
	exports.TraitRefImpl = TraitRefImpl;
	var SecuritySchemaRefImpl = (function (_super) {
	    __extends(SecuritySchemaRefImpl, _super);
	    function SecuritySchemaRefImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaRefImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaRefImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaRefImpl.prototype.getKind = function () {
	        return "SecuritySchemaRef";
	    };
	    return SecuritySchemaRefImpl;
	})(ReferenceImpl);
	exports.SecuritySchemaRefImpl = SecuritySchemaRefImpl;
	var StringTypeImpl = (function (_super) {
	    __extends(StringTypeImpl, _super);
	    function StringTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    StringTypeImpl.prototype.wrapperClassName = function () {
	        return "StringTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    StringTypeImpl.prototype.getKind = function () {
	        return "StringType";
	    };
	    return StringTypeImpl;
	})(ValueTypeImpl);
	exports.StringTypeImpl = StringTypeImpl;
	/***
	 * This type currently serves both for absolute and relative urls
	 ***/
	var UriTemplateImpl = (function (_super) {
	    __extends(UriTemplateImpl, _super);
	    function UriTemplateImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    UriTemplateImpl.prototype.wrapperClassName = function () {
	        return "UriTemplateImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    UriTemplateImpl.prototype.getKind = function () {
	        return "UriTemplate";
	    };
	    return UriTemplateImpl;
	})(StringTypeImpl);
	exports.UriTemplateImpl = UriTemplateImpl;
	/***
	 * This  type describes relative uri templates
	 ***/
	var RelativeUriImpl = (function (_super) {
	    __extends(RelativeUriImpl, _super);
	    function RelativeUriImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RelativeUriImpl.prototype.wrapperClassName = function () {
	        return "RelativeUriImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RelativeUriImpl.prototype.getKind = function () {
	        return "RelativeUri";
	    };
	    return RelativeUriImpl;
	})(UriTemplateImpl);
	exports.RelativeUriImpl = RelativeUriImpl;
	/***
	 * This  type describes absolute uri templates
	 ***/
	var FullUriTemplateImpl = (function (_super) {
	    __extends(FullUriTemplateImpl, _super);
	    function FullUriTemplateImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FullUriTemplateImpl.prototype.wrapperClassName = function () {
	        return "FullUriTemplateImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FullUriTemplateImpl.prototype.getKind = function () {
	        return "FullUriTemplate";
	    };
	    return FullUriTemplateImpl;
	})(UriTemplateImpl);
	exports.FullUriTemplateImpl = FullUriTemplateImpl;
	/***
	 * This  type describes fixed uris
	 ***/
	var FixedUriImpl = (function (_super) {
	    __extends(FixedUriImpl, _super);
	    function FixedUriImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FixedUriImpl.prototype.wrapperClassName = function () {
	        return "FixedUriImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FixedUriImpl.prototype.getKind = function () {
	        return "FixedUri";
	    };
	    return FixedUriImpl;
	})(StringTypeImpl);
	exports.FixedUriImpl = FixedUriImpl;
	/***
	 * Schema at this moment only two subtypes are supported (json schema and xsd)
	 ***/
	var SchemaStringImpl = (function (_super) {
	    __extends(SchemaStringImpl, _super);
	    function SchemaStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SchemaStringImpl.prototype.wrapperClassName = function () {
	        return "SchemaStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SchemaStringImpl.prototype.getKind = function () {
	        return "SchemaString";
	    };
	    return SchemaStringImpl;
	})(StringTypeImpl);
	exports.SchemaStringImpl = SchemaStringImpl;
	/***
	 * JSON schema
	 ***/
	var JSonSchemaStringImpl = (function (_super) {
	    __extends(JSonSchemaStringImpl, _super);
	    function JSonSchemaStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    JSonSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "JSonSchemaStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    JSonSchemaStringImpl.prototype.getKind = function () {
	        return "JSonSchemaString";
	    };
	    return JSonSchemaStringImpl;
	})(SchemaStringImpl);
	exports.JSonSchemaStringImpl = JSonSchemaStringImpl;
	/***
	 * XSD schema
	 ***/
	var XMLSchemaStringImpl = (function (_super) {
	    __extends(XMLSchemaStringImpl, _super);
	    function XMLSchemaStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    XMLSchemaStringImpl.prototype.wrapperClassName = function () {
	        return "XMLSchemaStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    XMLSchemaStringImpl.prototype.getKind = function () {
	        return "XMLSchemaString";
	    };
	    return XMLSchemaStringImpl;
	})(SchemaStringImpl);
	exports.XMLSchemaStringImpl = XMLSchemaStringImpl;
	var ExampleStringImpl = (function (_super) {
	    __extends(ExampleStringImpl, _super);
	    function ExampleStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ExampleStringImpl.prototype.wrapperClassName = function () {
	        return "ExampleStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ExampleStringImpl.prototype.getKind = function () {
	        return "ExampleString";
	    };
	    return ExampleStringImpl;
	})(StringTypeImpl);
	exports.ExampleStringImpl = ExampleStringImpl;
	var JSONExampleImpl = (function (_super) {
	    __extends(JSONExampleImpl, _super);
	    function JSONExampleImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    JSONExampleImpl.prototype.wrapperClassName = function () {
	        return "JSONExampleImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    JSONExampleImpl.prototype.getKind = function () {
	        return "JSONExample";
	    };
	    return JSONExampleImpl;
	})(ExampleStringImpl);
	exports.JSONExampleImpl = JSONExampleImpl;
	var XMLExampleImpl = (function (_super) {
	    __extends(XMLExampleImpl, _super);
	    function XMLExampleImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    XMLExampleImpl.prototype.wrapperClassName = function () {
	        return "XMLExampleImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    XMLExampleImpl.prototype.getKind = function () {
	        return "XMLExample";
	    };
	    return XMLExampleImpl;
	})(ExampleStringImpl);
	exports.XMLExampleImpl = XMLExampleImpl;
	var StatusCodeImpl = (function (_super) {
	    __extends(StatusCodeImpl, _super);
	    function StatusCodeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    StatusCodeImpl.prototype.wrapperClassName = function () {
	        return "StatusCodeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    StatusCodeImpl.prototype.getKind = function () {
	        return "StatusCode";
	    };
	    return StatusCodeImpl;
	})(StringTypeImpl);
	exports.StatusCodeImpl = StatusCodeImpl;
	/***
	 * This sub type of the string represents mime types
	 ***/
	var MimeTypeImpl = (function (_super) {
	    __extends(MimeTypeImpl, _super);
	    function MimeTypeImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MimeTypeImpl.prototype.wrapperClassName = function () {
	        return "MimeTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MimeTypeImpl.prototype.getKind = function () {
	        return "MimeType";
	    };
	    return MimeTypeImpl;
	})(StringTypeImpl);
	exports.MimeTypeImpl = MimeTypeImpl;
	/***
	 * Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0
	 ***/
	var MarkdownStringImpl = (function (_super) {
	    __extends(MarkdownStringImpl, _super);
	    function MarkdownStringImpl(attr) {
	        _super.call(this, attr);
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MarkdownStringImpl.prototype.wrapperClassName = function () {
	        return "MarkdownStringImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MarkdownStringImpl.prototype.getKind = function () {
	        return "MarkdownString";
	    };
	    return MarkdownStringImpl;
	})(StringTypeImpl);
	exports.MarkdownStringImpl = MarkdownStringImpl;
	/***
	 * Declares globally referenceable security schema definition
	 ***/
	var SecuritySchemaImpl = (function (_super) {
	    __extends(SecuritySchemaImpl, _super);
	    function SecuritySchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaImpl.prototype.getKind = function () {
	        return "SecuritySchema";
	    };
	    SecuritySchemaImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    SecuritySchemaImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them.
	     ***/
	    SecuritySchemaImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /***
	     * @hidden
	     * Set type value
	     ***/
	    SecuritySchemaImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /***
	     * The description attribute MAY be used to describe a securitySchemes property.
	     ***/
	    SecuritySchemaImpl.prototype.description = function () {
	        return _super.prototype.attribute.call(this, 'description', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    /***
	     * The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.
	     * This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation.
	     ***/
	    SecuritySchemaImpl.prototype.describedBy = function () {
	        return _super.prototype.element.call(this, 'describedBy');
	    };
	    /***
	     * The settings attribute MAY be used to provide security schema-specific information. Depending on the value of the type parameter, its attributes can vary.
	     * The following lists describe the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the Security Scheme type. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, an so on.
	     ***/
	    SecuritySchemaImpl.prototype.settings = function () {
	        return _super.prototype.element.call(this, 'settings');
	    };
	    return SecuritySchemaImpl;
	})(RAMLLanguageElementImpl);
	exports.SecuritySchemaImpl = SecuritySchemaImpl;
	var RAMLSimpleElementImpl = (function (_super) {
	    __extends(RAMLSimpleElementImpl, _super);
	    function RAMLSimpleElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createRAMLSimpleElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    RAMLSimpleElementImpl.prototype.wrapperClassName = function () {
	        return "RAMLSimpleElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    RAMLSimpleElementImpl.prototype.getKind = function () {
	        return "RAMLSimpleElement";
	    };
	    return RAMLSimpleElementImpl;
	})(core.BasicNodeImpl);
	exports.RAMLSimpleElementImpl = RAMLSimpleElementImpl;
	/***
	 * Content of the schema
	 ***/
	var GlobalSchemaImpl = (function (_super) {
	    __extends(GlobalSchemaImpl, _super);
	    function GlobalSchemaImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createGlobalSchema(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    GlobalSchemaImpl.prototype.wrapperClassName = function () {
	        return "GlobalSchemaImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    GlobalSchemaImpl.prototype.getKind = function () {
	        return "GlobalSchema";
	    };
	    /***
	     * Name of the global schema, used to refer on schema content
	     ***/
	    GlobalSchemaImpl.prototype.key = function () {
	        return _super.prototype.attribute.call(this, 'key', this.toString);
	    };
	    /***
	     * @hidden
	     * Set key value
	     ***/
	    GlobalSchemaImpl.prototype.setKey = function (param) {
	        this.highLevel().attrOrCreate("key").setValue("" + param);
	        return this;
	    };
	    /***
	     * Content of the schema
	     ***/
	    GlobalSchemaImpl.prototype.value = function () {
	        return _super.prototype.attribute.call(this, 'value', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    return GlobalSchemaImpl;
	})(RAMLSimpleElementImpl);
	exports.GlobalSchemaImpl = GlobalSchemaImpl;
	var DocumentationItemImpl = (function (_super) {
	    __extends(DocumentationItemImpl, _super);
	    function DocumentationItemImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDocumentationItem(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DocumentationItemImpl.prototype.wrapperClassName = function () {
	        return "DocumentationItemImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DocumentationItemImpl.prototype.getKind = function () {
	        return "DocumentationItem";
	    };
	    /***
	     * title of documentation section
	     ***/
	    DocumentationItemImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /***
	     * @hidden
	     * Set title value
	     ***/
	    DocumentationItemImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /***
	     * Content of documentation section
	     ***/
	    DocumentationItemImpl.prototype.content = function () {
	        return _super.prototype.attribute.call(this, 'content', function (attr) { return new MarkdownStringImpl(attr); });
	    };
	    return DocumentationItemImpl;
	})(RAMLSimpleElementImpl);
	exports.DocumentationItemImpl = DocumentationItemImpl;
	var SecuritySchemaSettingsImpl = (function (_super) {
	    __extends(SecuritySchemaSettingsImpl, _super);
	    function SecuritySchemaSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaSettingsImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaSettingsImpl.prototype.getKind = function () {
	        return "SecuritySchemaSettings";
	    };
	    return SecuritySchemaSettingsImpl;
	})(RAMLSimpleElementImpl);
	exports.SecuritySchemaSettingsImpl = SecuritySchemaSettingsImpl;
	var OAuth1SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth1SecuritySchemeSettingsImpl, _super);
	    function OAuth1SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth1SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth1SecuritySchemeSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.getKind = function () {
	        return "OAuth1SecuritySchemeSettings";
	    };
	    /***
	     * The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.requestTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'requestTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * The URI of the Token Request endpoint as defined in RFC5849 Section 2.3
	     ***/
	    OAuth1SecuritySchemeSettingsImpl.prototype.tokenCredentialsUri = function () {
	        return _super.prototype.attribute.call(this, 'tokenCredentialsUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    return OAuth1SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth1SecuritySchemeSettingsImpl = OAuth1SecuritySchemeSettingsImpl;
	var OAuth2SecuritySchemeSettingsImpl = (function (_super) {
	    __extends(OAuth2SecuritySchemeSettingsImpl, _super);
	    function OAuth2SecuritySchemeSettingsImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createOAuth2SecuritySchemeSettings(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.wrapperClassName = function () {
	        return "OAuth2SecuritySchemeSettingsImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.getKind = function () {
	        return "OAuth2SecuritySchemeSettings";
	    };
	    /***
	     * The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.accessTokenUri = function () {
	        return _super.prototype.attribute.call(this, 'accessTokenUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationUri = function () {
	        return _super.prototype.attribute.call(this, 'authorizationUri', function (attr) { return new FixedUriImpl(attr); });
	    };
	    /***
	     * A list of the Authorization grants supported by the API As defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of: code, token, owner or credentials.
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.authorizationGrants = function () {
	        return _super.prototype.attributes.call(this, 'authorizationGrants', this.toString);
	    };
	    /***
	     * @hidden
	     * Set authorizationGrants value
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setAuthorizationGrants = function (param) {
	        this.highLevel().attrOrCreate("authorizationGrants").setValue("" + param);
	        return this;
	    };
	    /***
	     * A list of scopes supported by the API as defined in RFC6749 [RFC6749] Section 3.3
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.scopes = function () {
	        return _super.prototype.attributes.call(this, 'scopes', this.toString);
	    };
	    /***
	     * @hidden
	     * Set scopes value
	     ***/
	    OAuth2SecuritySchemeSettingsImpl.prototype.setScopes = function (param) {
	        this.highLevel().attrOrCreate("scopes").setValue("" + param);
	        return this;
	    };
	    return OAuth2SecuritySchemeSettingsImpl;
	})(SecuritySchemaSettingsImpl);
	exports.OAuth2SecuritySchemeSettingsImpl = OAuth2SecuritySchemeSettingsImpl;
	var SecuritySchemaPartImpl = (function (_super) {
	    __extends(SecuritySchemaPartImpl, _super);
	    function SecuritySchemaPartImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createSecuritySchemaPart(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    SecuritySchemaPartImpl.prototype.wrapperClassName = function () {
	        return "SecuritySchemaPartImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    SecuritySchemaPartImpl.prototype.getKind = function () {
	        return "SecuritySchemaPart";
	    };
	    return SecuritySchemaPartImpl;
	})(RAMLSimpleElementImpl);
	exports.SecuritySchemaPartImpl = SecuritySchemaPartImpl;
	var ResourceTypeImpl = (function (_super) {
	    __extends(ResourceTypeImpl, _super);
	    function ResourceTypeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResourceType(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceTypeImpl.prototype.wrapperClassName = function () {
	        return "ResourceTypeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceTypeImpl.prototype.getKind = function () {
	        return "ResourceType";
	    };
	    /***
	     * Name of the resource type
	     ***/
	    ResourceTypeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    ResourceTypeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    ResourceTypeImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    ResourceTypeImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    /***
	     * Methods that are part of this resource type definition
	     ***/
	    ResourceTypeImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /***
	     * Instantiation of applyed traits
	     ***/
	    ResourceTypeImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * Instantiation of applyed resource type
	     ***/
	    ResourceTypeImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /***
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     ***/
	    ResourceTypeImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * Uri parameters of this resource
	     ***/
	    ResourceTypeImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    return ResourceTypeImpl;
	})(RAMLLanguageElementImpl);
	exports.ResourceTypeImpl = ResourceTypeImpl;
	var HasNormalParametersImpl = (function (_super) {
	    __extends(HasNormalParametersImpl, _super);
	    function HasNormalParametersImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createHasNormalParameters(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    HasNormalParametersImpl.prototype.wrapperClassName = function () {
	        return "HasNormalParametersImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    HasNormalParametersImpl.prototype.getKind = function () {
	        return "HasNormalParameters";
	    };
	    /***
	     * An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property
	     ***/
	    HasNormalParametersImpl.prototype.queryParameters = function () {
	        return _super.prototype.elements.call(this, 'queryParameters');
	    };
	    HasNormalParametersImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    HasNormalParametersImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * Headers that allowed at this position
	     ***/
	    HasNormalParametersImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    return HasNormalParametersImpl;
	})(RAMLLanguageElementImpl);
	exports.HasNormalParametersImpl = HasNormalParametersImpl;
	var ParameterImpl = (function (_super) {
	    __extends(ParameterImpl, _super);
	    function ParameterImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createParameter(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ParameterImpl.prototype.wrapperClassName = function () {
	        return "ParameterImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ParameterImpl.prototype.getKind = function () {
	        return "Parameter";
	    };
	    /***
	     * name of the parameter
	     ***/
	    ParameterImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    ParameterImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    ParameterImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    ParameterImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string.
	     ***/
	    ParameterImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', this.toString);
	    };
	    /***
	     * @hidden
	     * Set type value
	     ***/
	    ParameterImpl.prototype.setType = function (param) {
	        this.highLevel().attrOrCreate("type").setValue("" + param);
	        return this;
	    };
	    /***
	     * Location of the parameter (can not be edited by user)
	     ***/
	    ParameterImpl.prototype.location = function () {
	        return _super.prototype.attribute.call(this, 'location', function (attr) { return new ParameterLocationImpl(attr); });
	    };
	    /***
	     * Set to true if parameter is required
	     ***/
	    ParameterImpl.prototype.required = function () {
	        return _super.prototype.attribute.call(this, 'required', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set required value
	     ***/
	    ParameterImpl.prototype.setRequired = function (param) {
	        this.highLevel().attrOrCreate("required").setValue("" + param);
	        return this;
	    };
	    /***
	     * The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value.
	     ***/
	    ParameterImpl.prototype["default"] = function () {
	        return _super.prototype.attribute.call(this, 'default', this.toString);
	    };
	    /***
	     * @hidden
	     * Set default value
	     ***/
	    ParameterImpl.prototype.setDefault = function (param) {
	        this.highLevel().attrOrCreate("default").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property.
	     ***/
	    ParameterImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', this.toString);
	    };
	    /***
	     * @hidden
	     * Set example value
	     ***/
	    ParameterImpl.prototype.setExample = function (param) {
	        this.highLevel().attrOrCreate("example").setValue("" + param);
	        return this;
	    };
	    /***
	     * The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated.
	     ***/
	    ParameterImpl.prototype.repeat = function () {
	        return _super.prototype.attribute.call(this, 'repeat', this.toBoolean);
	    };
	    /***
	     * @hidden
	     * Set repeat value
	     ***/
	    ParameterImpl.prototype.setRepeat = function (param) {
	        this.highLevel().attrOrCreate("repeat").setValue("" + param);
	        return this;
	    };
	    return ParameterImpl;
	})(RAMLLanguageElementImpl);
	exports.ParameterImpl = ParameterImpl;
	var ParameterLocationImpl = (function () {
	    function ParameterLocationImpl(attr) {
	        this.attr = attr;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ParameterLocationImpl.prototype.wrapperClassName = function () {
	        return "ParameterLocationImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ParameterLocationImpl.prototype.getKind = function () {
	        return "ParameterLocation";
	    };
	    return ParameterLocationImpl;
	})();
	exports.ParameterLocationImpl = ParameterLocationImpl;
	/***
	 * Value must be a string
	 ***/
	var StrElementImpl = (function (_super) {
	    __extends(StrElementImpl, _super);
	    function StrElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createStrElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    StrElementImpl.prototype.wrapperClassName = function () {
	        return "StrElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    StrElementImpl.prototype.getKind = function () {
	        return "StrElement";
	    };
	    /***
	     * (Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity.
	     ***/
	    StrElementImpl.prototype.pattern = function () {
	        return _super.prototype.attribute.call(this, 'pattern', this.toString);
	    };
	    /***
	     * @hidden
	     * Set pattern value
	     ***/
	    StrElementImpl.prototype.setPattern = function (param) {
	        this.highLevel().attrOrCreate("pattern").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error.
	     ***/
	    StrElementImpl.prototype.enum = function () {
	        return _super.prototype.attributes.call(this, 'enum', this.toString);
	    };
	    /***
	     * @hidden
	     * Set enum value
	     ***/
	    StrElementImpl.prototype.setEnum = function (param) {
	        this.highLevel().attrOrCreate("enum").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters.
	     ***/
	    StrElementImpl.prototype.minLength = function () {
	        return _super.prototype.attribute.call(this, 'minLength', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minLength value
	     ***/
	    StrElementImpl.prototype.setMinLength = function (param) {
	        this.highLevel().attrOrCreate("minLength").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters.
	     ***/
	    StrElementImpl.prototype.maxLength = function () {
	        return _super.prototype.attribute.call(this, 'maxLength', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maxLength value
	     ***/
	    StrElementImpl.prototype.setMaxLength = function (param) {
	        this.highLevel().attrOrCreate("maxLength").setValue("" + param);
	        return this;
	    };
	    return StrElementImpl;
	})(ParameterImpl);
	exports.StrElementImpl = StrElementImpl;
	/***
	 * Value must be a boolean
	 ***/
	var BooleanElementImpl = (function (_super) {
	    __extends(BooleanElementImpl, _super);
	    function BooleanElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBooleanElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    BooleanElementImpl.prototype.wrapperClassName = function () {
	        return "BooleanElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    BooleanElementImpl.prototype.getKind = function () {
	        return "BooleanElement";
	    };
	    return BooleanElementImpl;
	})(ParameterImpl);
	exports.BooleanElementImpl = BooleanElementImpl;
	/***
	 * Value MUST be a number. Indicate floating point numbers as defined by YAML.
	 ***/
	var NumberElementImpl = (function (_super) {
	    __extends(NumberElementImpl, _super);
	    function NumberElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createNumberElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    NumberElementImpl.prototype.wrapperClassName = function () {
	        return "NumberElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    NumberElementImpl.prototype.getKind = function () {
	        return "NumberElement";
	    };
	    /***
	     * (Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value.
	     ***/
	    NumberElementImpl.prototype.minimum = function () {
	        return _super.prototype.attribute.call(this, 'minimum', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set minimum value
	     ***/
	    NumberElementImpl.prototype.setMinimum = function (param) {
	        this.highLevel().attrOrCreate("minimum").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value.
	     ***/
	    NumberElementImpl.prototype.maximum = function () {
	        return _super.prototype.attribute.call(this, 'maximum', this.toNumber);
	    };
	    /***
	     * @hidden
	     * Set maximum value
	     ***/
	    NumberElementImpl.prototype.setMaximum = function (param) {
	        this.highLevel().attrOrCreate("maximum").setValue("" + param);
	        return this;
	    };
	    return NumberElementImpl;
	})(ParameterImpl);
	exports.NumberElementImpl = NumberElementImpl;
	/***
	 * Value MUST be a integer.
	 ***/
	var IntegerElementImpl = (function (_super) {
	    __extends(IntegerElementImpl, _super);
	    function IntegerElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createIntegerElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    IntegerElementImpl.prototype.wrapperClassName = function () {
	        return "IntegerElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    IntegerElementImpl.prototype.getKind = function () {
	        return "IntegerElement";
	    };
	    return IntegerElementImpl;
	})(NumberElementImpl);
	exports.IntegerElementImpl = IntegerElementImpl;
	/***
	 * Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616].
	 ***/
	var DateElementImpl = (function (_super) {
	    __extends(DateElementImpl, _super);
	    function DateElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createDateElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    DateElementImpl.prototype.wrapperClassName = function () {
	        return "DateElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    DateElementImpl.prototype.getKind = function () {
	        return "DateElement";
	    };
	    return DateElementImpl;
	})(ParameterImpl);
	exports.DateElementImpl = DateElementImpl;
	/***
	 * (Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly.
	 ***/
	var FileElementImpl = (function (_super) {
	    __extends(FileElementImpl, _super);
	    function FileElementImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createFileElement(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    FileElementImpl.prototype.wrapperClassName = function () {
	        return "FileElementImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    FileElementImpl.prototype.getKind = function () {
	        return "FileElement";
	    };
	    return FileElementImpl;
	})(ParameterImpl);
	exports.FileElementImpl = FileElementImpl;
	var MethodBaseImpl = (function (_super) {
	    __extends(MethodBaseImpl, _super);
	    function MethodBaseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethodBase(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MethodBaseImpl.prototype.wrapperClassName = function () {
	        return "MethodBaseImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MethodBaseImpl.prototype.getKind = function () {
	        return "MethodBase";
	    };
	    /***
	     * Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties.
	     ***/
	    MethodBaseImpl.prototype.responses = function () {
	        return _super.prototype.elements.call(this, 'responses');
	    };
	    /***
	     * Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.
	     * Resources CAN have alternate representations. For example, an API might support both JSON and XML representations.
	     * A method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type.
	     ***/
	    MethodBaseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /***
	     * Instantiation of applyed traits
	     ***/
	    MethodBaseImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * A list of the security schemas to apply, these must be defined in the securitySchemes declaration.
	     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     * Security schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     ***/
	    MethodBaseImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    return MethodBaseImpl;
	})(HasNormalParametersImpl);
	exports.MethodBaseImpl = MethodBaseImpl;
	var ResponseImpl = (function (_super) {
	    __extends(ResponseImpl, _super);
	    function ResponseImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResponse(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResponseImpl.prototype.wrapperClassName = function () {
	        return "ResponseImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResponseImpl.prototype.getKind = function () {
	        return "Response";
	    };
	    /***
	     * Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code.
	     ***/
	    ResponseImpl.prototype.code = function () {
	        return _super.prototype.attribute.call(this, 'code', function (attr) { return new StatusCodeImpl(attr); });
	    };
	    /***
	     * An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property.
	     * API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data.
	     *
	     * In the following example, the header x-metadata-{?} is used to send metadata that has been saved with the media.
	     ***/
	    ResponseImpl.prototype.headers = function () {
	        return _super.prototype.elements.call(this, 'headers');
	    };
	    /***
	     * Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined.
	     * For APIs without a priori knowledge of the response types for their responses, "* /*" MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if "* /*" is used.
	     ***/
	    ResponseImpl.prototype.body = function () {
	        return _super.prototype.elements.call(this, 'body');
	    };
	    /***
	     * true for codes < 400 and false otherwise
	     ***/
	    ResponseImpl.prototype.isOkRange = function () {
	        return helper.isOkRange(this);
	    };
	    return ResponseImpl;
	})(RAMLLanguageElementImpl);
	exports.ResponseImpl = ResponseImpl;
	var BodyLikeImpl = (function (_super) {
	    __extends(BodyLikeImpl, _super);
	    function BodyLikeImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createBodyLike(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    BodyLikeImpl.prototype.wrapperClassName = function () {
	        return "BodyLikeImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    BodyLikeImpl.prototype.getKind = function () {
	        return "BodyLike";
	    };
	    /***
	     * Mime type of the request or response body
	     ***/
	    BodyLikeImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    BodyLikeImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    /***
	     * The structure of a request or response body MAY be further specified by the schema property under the appropriate media type.
	     *
	     * The schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data.
	     *
	     * All parsers of RAML MUST be able to interpret JSON Schema [JSON_SCHEMA] and XML Schema [XML_SCHEMA].
	     *
	     * Schema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline.
	     * Alternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property (see Named Parameters, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type.
	     ***/
	    BodyLikeImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new SchemaStringImpl(attr); });
	    };
	    /***
	     * Documentation generators MUST use body properties' example attributes to generate example invocations.
	     *
	     * This example shows example attributes for two body property media types.
	     ***/
	    BodyLikeImpl.prototype.example = function () {
	        return _super.prototype.attribute.call(this, 'example', function (attr) { return new ExampleStringImpl(attr); });
	    };
	    /***
	     * Web forms REQUIRE special encoding and custom declaration.
	     * If the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting.
	     * The formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes
	     ***/
	    BodyLikeImpl.prototype.formParameters = function () {
	        return _super.prototype.elements.call(this, 'formParameters');
	    };
	    return BodyLikeImpl;
	})(RAMLLanguageElementImpl);
	exports.BodyLikeImpl = BodyLikeImpl;
	/***
	 * Needed to set connection between xml related mime types and xsd schema
	 ***/
	var XMLBodyImpl = (function (_super) {
	    __extends(XMLBodyImpl, _super);
	    function XMLBodyImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createXMLBody(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    XMLBodyImpl.prototype.wrapperClassName = function () {
	        return "XMLBodyImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    XMLBodyImpl.prototype.getKind = function () {
	        return "XMLBody";
	    };
	    /***
	     * XSD Schema
	     ***/
	    XMLBodyImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new XMLSchemaStringImpl(attr); });
	    };
	    return XMLBodyImpl;
	})(BodyLikeImpl);
	exports.XMLBodyImpl = XMLBodyImpl;
	/***
	 * Needed to set connection between json related mime types and json schema
	 ***/
	var JSONBodyImpl = (function (_super) {
	    __extends(JSONBodyImpl, _super);
	    function JSONBodyImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createJSONBody(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    JSONBodyImpl.prototype.wrapperClassName = function () {
	        return "JSONBodyImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    JSONBodyImpl.prototype.getKind = function () {
	        return "JSONBody";
	    };
	    /***
	     * JSON Schema
	     ***/
	    JSONBodyImpl.prototype.schema = function () {
	        return _super.prototype.attribute.call(this, 'schema', function (attr) { return new JSonSchemaStringImpl(attr); });
	    };
	    return JSONBodyImpl;
	})(BodyLikeImpl);
	exports.JSONBodyImpl = JSONBodyImpl;
	var TraitImpl = (function (_super) {
	    __extends(TraitImpl, _super);
	    function TraitImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createTrait(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    TraitImpl.prototype.wrapperClassName = function () {
	        return "TraitImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    TraitImpl.prototype.getKind = function () {
	        return "Trait";
	    };
	    /***
	     * Name of the trait
	     ***/
	    TraitImpl.prototype.name = function () {
	        return _super.prototype.attribute.call(this, 'name', this.toString);
	    };
	    /***
	     * @hidden
	     * Set name value
	     ***/
	    TraitImpl.prototype.setName = function (param) {
	        this.highLevel().attrOrCreate("name").setValue("" + param);
	        return this;
	    };
	    TraitImpl.prototype.usage = function () {
	        return _super.prototype.attribute.call(this, 'usage', this.toString);
	    };
	    /***
	     * @hidden
	     * Set usage value
	     ***/
	    TraitImpl.prototype.setUsage = function (param) {
	        this.highLevel().attrOrCreate("usage").setValue("" + param);
	        return this;
	    };
	    return TraitImpl;
	})(MethodBaseImpl);
	exports.TraitImpl = TraitImpl;
	/***
	 * Method object allows description of http methods
	 ***/
	var MethodImpl = (function (_super) {
	    __extends(MethodImpl, _super);
	    function MethodImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createMethod(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    MethodImpl.prototype.wrapperClassName = function () {
	        return "MethodImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    MethodImpl.prototype.getKind = function () {
	        return "Method";
	    };
	    /***
	     * Method that can be called
	     ***/
	    MethodImpl.prototype.method = function () {
	        return _super.prototype.attribute.call(this, 'method', this.toString);
	    };
	    /***
	     * @hidden
	     * Set method value
	     ***/
	    MethodImpl.prototype.setMethod = function (param) {
	        this.highLevel().attrOrCreate("method").setValue("" + param);
	        return this;
	    };
	    /***
	     * A method can override an API's protocols value for that single method by setting a different value for the fields.
	     ***/
	    MethodImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /***
	     * @hidden
	     * Set protocols value
	     ***/
	    MethodImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /***
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     ***/
	    MethodImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * For methods of Resources returns parent resource. For methods of ResourceTypes returns undefined Opt.
	     ***/
	    MethodImpl.prototype.parentResource = function () {
	        return helper.parentResource(this);
	    };
	    /***
	     * Api owning the resource as a sibling
	     ***/
	    MethodImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /***
	     * // For methods of Resources: `{parent Resource relative path} {methodName}`.
	     * // For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	     * // For other methods throws Exception.
	     ***/
	    MethodImpl.prototype.methodId = function () {
	        return helper.methodId(this);
	    };
	    return MethodImpl;
	})(MethodBaseImpl);
	exports.MethodImpl = MethodImpl;
	var ResourceImpl = (function (_super) {
	    __extends(ResourceImpl, _super);
	    function ResourceImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createResource(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ResourceImpl.prototype.wrapperClassName = function () {
	        return "ResourceImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ResourceImpl.prototype.getKind = function () {
	        return "Resource";
	    };
	    /***
	     * Relative URL of this resource from the parent resource
	     ***/
	    ResourceImpl.prototype.relativeUri = function () {
	        return _super.prototype.attribute.call(this, 'relativeUri', function (attr) { return new RelativeUriImpl(attr); });
	    };
	    /***
	     * Instantiation of applyed resource type
	     ***/
	    ResourceImpl.prototype["type"] = function () {
	        return _super.prototype.attribute.call(this, 'type', function (attr) { return new ResourceTypeRefImpl(attr); });
	    };
	    /***
	     * Instantiation of applyed traits
	     ***/
	    ResourceImpl.prototype.is = function () {
	        return _super.prototype.attributes.call(this, 'is', function (attr) { return new TraitRefImpl(attr); });
	    };
	    /***
	     * securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.
	     * To indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.
	     ***/
	    ResourceImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * Uri parameters of this resource
	     ***/
	    ResourceImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /***
	     * Methods that can be called on this resource
	     ***/
	    ResourceImpl.prototype.methods = function () {
	        return _super.prototype.elements.call(this, 'methods');
	    };
	    /***
	     * Children resources
	     ***/
	    ResourceImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    ResourceImpl.prototype.displayName = function () {
	        return _super.prototype.attribute.call(this, 'displayName', this.toString);
	    };
	    /***
	     * @hidden
	     * Set displayName value
	     ***/
	    ResourceImpl.prototype.setDisplayName = function (param) {
	        this.highLevel().attrOrCreate("displayName").setValue("" + param);
	        return this;
	    };
	    /***
	     * A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level.
	     ***/
	    ResourceImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /***
	     * Path relative to API root
	     ***/
	    ResourceImpl.prototype.completeRelativeUri = function () {
	        return helper.completeRelativeUri(this);
	    };
	    /***
	     * baseUri of owning Api concatenated with completeRelativeUri
	     ***/
	    ResourceImpl.prototype.absoluteUri = function () {
	        return helper.absoluteUri(this);
	    };
	    /***
	     * Parent resource for non top level resources
	     ***/
	    ResourceImpl.prototype.parentResource = function () {
	        return helper.parent(this);
	    };
	    /***
	     * Get child resource by its relative path
	     ***/
	    ResourceImpl.prototype.getChildResource = function (relPath) {
	        return helper.getChildResource(this, relPath);
	    };
	    /***
	     * Get child method by its name
	     ***/
	    ResourceImpl.prototype.getChildMethod = function (method) {
	        return helper.getChildMethod(this, method);
	    };
	    /***
	     * Api owning the resource as a sibling
	     ***/
	    ResourceImpl.prototype.ownerApi = function () {
	        return helper.ownerApi(this);
	    };
	    /***
	     * Retrieve all uri parameters regardless of whether they are described in `uriParameters` or not
	     * //
	     ***/
	    ResourceImpl.prototype.allUriParameters = function () {
	        return helper.uriParameters(this);
	    };
	    /***
	     * Retrieve all absolute uri parameters regardless of whether they are described in
	     * //`baseUriParameters` and `uriParameters` or not
	     ***/
	    ResourceImpl.prototype.absoluteUriParameters = function () {
	        return helper.absoluteUriParameters(this);
	    };
	    return ResourceImpl;
	})(RAMLLanguageElementImpl);
	exports.ResourceImpl = ResourceImpl;
	var ApiImpl = (function (_super) {
	    __extends(ApiImpl, _super);
	    function ApiImpl(nodeOrKey) {
	        _super.call(this, (typeof nodeOrKey == "string") ? createApi(nodeOrKey) : nodeOrKey);
	        this.nodeOrKey = nodeOrKey;
	    }
	    /***
	     * @hidden
	     * @return Actual name of instance class
	     ***/
	    ApiImpl.prototype.wrapperClassName = function () {
	        return "ApiImpl";
	    };
	    /***
	     * @return Actual name of instance interface
	     ***/
	    ApiImpl.prototype.getKind = function () {
	        return "Api";
	    };
	    /***
	     * The title property is a short plain text description of the RESTful API. The title property's value SHOULD be suitable for use as a title for the contained user documentation.
	     ***/
	    ApiImpl.prototype.title = function () {
	        return _super.prototype.attribute.call(this, 'title', this.toString);
	    };
	    /***
	     * @hidden
	     * Set title value
	     ***/
	    ApiImpl.prototype.setTitle = function (param) {
	        this.highLevel().attrOrCreate("title").setValue("" + param);
	        return this;
	    };
	    /***
	     * If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if:
	     * The API itself is not versioned.
	     * The API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change.
	     * The API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, "v3", "v3.0", and "V3" are all allowed, but are not considered to be equal.
	     ***/
	    ApiImpl.prototype.version = function () {
	        return _super.prototype.attribute.call(this, 'version', this.toString);
	    };
	    /***
	     * @hidden
	     * Set version value
	     ***/
	    ApiImpl.prototype.setVersion = function (param) {
	        this.highLevel().attrOrCreate("version").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification [RFC2396] or a Level 1 Template URI as defined in RFC 6570 [RFC6570].
	     * The baseUri property SHOULD only be used as a reference value. API client generators MAY make the baseUri configurable by the API client's users.
	     * If the baseUri value is a Level 1 Template URI, the following reserved base URI parameters are available for replacement:
	     ***/
	    ApiImpl.prototype.baseUri = function () {
	        return _super.prototype.attribute.call(this, 'baseUri', function (attr) { return new FullUriTemplateImpl(attr); });
	    };
	    /***
	     * Base uri parameters are named parameters which described template parameters in the base uri
	     ***/
	    ApiImpl.prototype.baseUriParameters = function () {
	        return _super.prototype.elements.call(this, 'baseUriParameters');
	    };
	    /***
	     * URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters
	     ***/
	    ApiImpl.prototype.uriParameters = function () {
	        return _super.prototype.elements.call(this, 'uriParameters');
	    };
	    /***
	     * A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`.
	     ***/
	    ApiImpl.prototype.protocols = function () {
	        return _super.prototype.attributes.call(this, 'protocols', this.toString);
	    };
	    /***
	     * @hidden
	     * Set protocols value
	     ***/
	    ApiImpl.prototype.setProtocols = function (param) {
	        this.highLevel().attrOrCreate("protocols").setValue("" + param);
	        return this;
	    };
	    /***
	     * (Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type:
	     * One of the following YAML media types:
	     * text/yaml
	     * text/x-yaml
	     * application/yaml
	     * application/x-yaml*
	     * Any type from the list of IANA MIME Media Types, http://www.iana.org/assignments/media-types
	     * A custom type that conforms to the regular expression, "application/[A-Za-z.-0-1]*+?(json|xml)"
	     * For any combination of resource and operation in the API, if a media type is specified as a key of the body property for that resource and operation, or if a media type is specified in the mediaType property, the body MUST be in the specified media types. Moreover, if the client specifies an Accepts header containing multiple media types that are allowed by the specification for the requested resource and operation, the server SHOULD return a body using the media type in the Accepts header's mediaType list.
	     ***/
	    ApiImpl.prototype.mediaType = function () {
	        return _super.prototype.attribute.call(this, 'mediaType', function (attr) { return new MimeTypeImpl(attr); });
	    };
	    /***
	     * To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type.
	     ***/
	    ApiImpl.prototype.schemas = function () {
	        return _super.prototype.elements.call(this, 'schemas');
	    };
	    /***
	     * Declarations of traits used in this API
	     ***/
	    ApiImpl.prototype.traits = function () {
	        return _super.prototype.elements.call(this, 'traits');
	    };
	    /***
	     * A list of the security schemas to apply to all methods, these must be defined in the securitySchemes declaration.
	     ***/
	    ApiImpl.prototype.securedBy = function () {
	        return _super.prototype.attributes.call(this, 'securedBy', function (attr) { return new SecuritySchemaRefImpl(attr); });
	    };
	    /***
	     * Security schemas that can be applied with securedBy
	     ***/
	    ApiImpl.prototype.securitySchemes = function () {
	        return _super.prototype.elements.call(this, 'securitySchemes');
	    };
	    /***
	     * Declaration of resource types used in this API
	     ***/
	    ApiImpl.prototype.resourceTypes = function () {
	        return _super.prototype.elements.call(this, 'resourceTypes');
	    };
	    /***
	     * Resources are identified by their relative URI, which MUST begin with a slash (/).
	     * A resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri.
	     * A resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI.
	     * Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. "/bom/items" may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if "/bom" is itself a resource then "/items" should be a nested resource of "/bom", while "/bom/items" should not be used.
	     ***/
	    ApiImpl.prototype.resources = function () {
	        return _super.prototype.elements.call(this, 'resources');
	    };
	    /***
	     * The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context.
	     * Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared.
	     * To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document.
	     * Documentation-generators MUST process the content field as if it was defined using Markdown [MARKDOWN].
	     *
	     * This example shows an API definition with a single user document.
	     ***/
	    ApiImpl.prototype.documentation = function () {
	        return _super.prototype.elements.call(this, 'documentation');
	    };
	    /***
	     * Equivalent API with traits and resource types expanded
	     ***/
	    ApiImpl.prototype.expandTraitsAndResourceTypes = function () {
	        return helper.expandTraitsAndResourceTypes(this);
	    };
	    /***
	     * Retrieve all traits including those defined in libraries
	     ***/
	    ApiImpl.prototype.allTraits = function () {
	        return helper.allTraits(this);
	    };
	    /***
	     * Retrieve all resource types including those defined in libraries
	     ***/
	    ApiImpl.prototype.allResourceTypes = function () {
	        return helper.allResourceTypes(this);
	    };
	    /***
	     * Get child resource by its relative path
	     ***/
	    ApiImpl.prototype.getChildResource = function (relPath) {
	        return helper.getChildResource(this, relPath);
	    };
	    /***
	     * Retrieve all resources ofthe Api
	     ***/
	    ApiImpl.prototype.allResources = function () {
	        return helper.allResources(this);
	    };
	    /***
	     * Retrieve all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	     * //
	     ***/
	    ApiImpl.prototype.allBaseUriParameters = function () {
	        return helper.baseUriParameters(this);
	    };
	    return ApiImpl;
	})(RAMLLanguageElementImpl);
	exports.ApiImpl = ApiImpl;
	/***
	 * @hidden
	 ***/
	function createApi(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("Api");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLLanguageElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("RAMLLanguageElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchema(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("SecuritySchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchemaPart(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("SecuritySchemaPart");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createRAMLSimpleElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("RAMLSimpleElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createGlobalSchema(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("GlobalSchema");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createDocumentationItem(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("DocumentationItem");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createSecuritySchemaSettings(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("SecuritySchemaSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOAuth1SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("OAuth1SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createOAuth2SecuritySchemeSettings(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("OAuth2SecuritySchemeSettings");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResourceType(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("ResourceType");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createMethod(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("Method");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createMethodBase(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("MethodBase");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createHasNormalParameters(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("HasNormalParameters");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createParameter(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("Parameter");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createStrElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("StrElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createBooleanElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("BooleanElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createNumberElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("NumberElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createIntegerElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("IntegerElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createDateElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("DateElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createFileElement(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("FileElement");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResponse(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("Response");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createBodyLike(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("BodyLike");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createXMLBody(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("XMLBody");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createJSONBody(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("JSONBody");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createTrait(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("Trait");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * @hidden
	 ***/
	function createResource(key) {
	    var universe = hl.universeProvider("RAML08");
	    var nc = universe.getType("Resource");
	    var node = nc.createStubNode(null, key);
	    return node;
	}
	/***
	 * Load API synchronously
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param expand Whether to expand traits and resource types
	 * @return Opt&lt;Api&gt;. Call .isDefined() Opt member to find out if the result actually contains an Api. Call .getOrThrow() Opt member to retrieve the Api.
	 ***/
	function loadApi(apiPath, expand) {
	    if (expand === void 0) { expand = true; }
	    return apiLoader.loadApi08(apiPath, {
	        expandTraitsAndResourceTypes: expand
	    });
	}
	exports.loadApi = loadApi;
	/***
	 * Load API asynchronously
	 * @param apiPath Path to API: local file system path or Web URL
	 * @param expand Whether to expand traits and resource types
	 * @return Promise&lt;Api&gt;
	 ***/
	function loadApiAsync(apiPath, expand) {
	    if (expand === void 0) { expand = true; }
	    return apiLoader.loadApi08Async(apiPath, {
	        expandTraitsAndResourceTypes: expand
	    });
	}
	exports.loadApiAsync = loadApiAsync;
	/***
	 * Turn model node into an object. Should not be relied on for API analysis and manipulation by the parser users.
	 * @param node Model node
	 * @return Stringifyable object representation of the node.
	 ***/
	function toJSON(node, serializeOptions) {
	    return json2lowlevel.serialize(node.highLevel().lowLevel(), serializeOptions);
	}
	exports.toJSON = toJSON;
	;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	var hlImpl = __webpack_require__(5);
	var jsyaml = __webpack_require__(6);
	var json2lowlevel = __webpack_require__(60);
	var BasicNodeImpl = (function () {
	    /***
	     * @hidden
	     */
	    function BasicNodeImpl(_node) {
	        this._node = _node;
	        _node.setWrapperNode(this);
	    }
	    /***
	     * @hidden
	     */
	    BasicNodeImpl.prototype.wrapperClassName = function () {
	        return 'BasicNodeImpl';
	    };
	    BasicNodeImpl.prototype.getKind = function () {
	        return 'BasicNode';
	    };
	    /***
	     * @return Direct ancestor in RAML hierarchy
	     **/
	    BasicNodeImpl.prototype.parent = function () {
	        var parent = this._node.parent();
	        return parent ? parent.wrapperNode() : null;
	    };
	    /***
	     * @hidden
	     * @return Underlying node of the High Level model
	     **/
	    BasicNodeImpl.prototype.highLevel = function () {
	        return this._node;
	    };
	    /***
	     * @hidden
	     ***/
	    BasicNodeImpl.prototype.attributes = function (name, constr) {
	        var attrs = this._node.attributes(name);
	        if (!attrs) {
	            return null;
	        }
	        if (constr) {
	            return attrs.map(function (x) { return constr(x); });
	        }
	        else {
	            return attrs.map(function (x) { return x.value(); });
	        }
	    };
	    /***
	     * @hidden
	     ***/
	    BasicNodeImpl.prototype.attribute = function (name, constr) {
	        var attr = this._node.attr(name);
	        if (!attr) {
	            return null;
	        }
	        if (constr) {
	            return constr(attr);
	        }
	        else {
	            return attr.value();
	        }
	    };
	    /***
	     * @hidden
	     ***/
	    BasicNodeImpl.prototype.elements = function (name) {
	        var elements = this._node.elementsOfKind(name);
	        if (!elements) {
	            return null;
	        }
	        return elements.map(function (x) { return x.wrapperNode(); });
	    };
	    /***
	     * @hidden
	     ***/
	    BasicNodeImpl.prototype.element = function (name) {
	        var element = this._node.element(name);
	        if (!element) {
	            return null;
	        }
	        return element.wrapperNode();
	    };
	    /***
	     * Append node as child
	     * @param node node to be appended
	     ***/
	    BasicNodeImpl.prototype.add = function (node) {
	        this.highLevel().add(node.highLevel());
	    };
	    /***
	     * Append node as property value
	     * @param node node to be set as property value
	     * @param prop name of property to set value for
	     ***/
	    BasicNodeImpl.prototype.addToProp = function (node, prop) {
	        var hl = node.highLevel();
	        var pr = this.highLevel().definition().property(prop);
	        hl._prop = pr;
	        this.highLevel().add(hl);
	    };
	    /***
	     * Remove node from children set
	     * @param node node to be removed
	     ***/
	    BasicNodeImpl.prototype.remove = function (node) {
	        this.highLevel().remove(node.highLevel());
	    };
	    /***
	     * @return YAML string representing the node
	     ***/
	    BasicNodeImpl.prototype.dump = function () {
	        return this.highLevel().dump("yaml");
	    };
	    BasicNodeImpl.prototype.toString = function (attr) {
	        var obj = attr.value();
	        return obj != null ? obj.toString() : obj;
	    };
	    BasicNodeImpl.prototype.toBoolean = function (attr) {
	        var obj = attr.value();
	        return obj != null ? obj.toString() == 'true' : obj;
	    };
	    BasicNodeImpl.prototype.toNumber = function (attr) {
	        var obj = attr.value();
	        if (!obj) {
	            return obj;
	        }
	        try {
	            var nValue = parseFloat(obj.toString());
	            return nValue;
	        }
	        catch (e) {
	        }
	        return Number.MAX_VALUE;
	    };
	    /***
	     * @return Array of errors
	     **/
	    BasicNodeImpl.prototype.errors = function () {
	        var result = [].concat(this._node.errors());
	        this._node.attrs().forEach(function (x) { return result = result.concat(x.errors()); });
	        return result;
	    };
	    /***
	     * @return object representing class of the node
	     **/
	    BasicNodeImpl.prototype.definition = function () {
	        return this.highLevel().definition();
	    };
	    /***
	     * @return for user class instances returns object representing actual user class
	     **/
	    BasicNodeImpl.prototype.runtimeDefinition = function () {
	        return this.highLevel().definition().toRuntime();
	    };
	    BasicNodeImpl.prototype.toJSON = function (serializeOptions) {
	        return json2lowlevel.serialize(this.highLevel().lowLevel(), serializeOptions);
	    };
	    return BasicNodeImpl;
	})();
	exports.BasicNodeImpl = BasicNodeImpl;
	/***
	 * @hidden
	 ***/
	function toStructuredValue(node) {
	    var value = node.value();
	    if (typeof value === 'string') {
	        var mockNode = jsyaml.createNode(value.toString());
	        mockNode._actualNode().startPosition = node.lowLevel().valueStart();
	        mockNode._actualNode().endPosition = node.lowLevel().valueEnd();
	        var stv = new hlImpl.StructuredValue(mockNode, node.parent(), node.property());
	        return stv;
	    }
	    else {
	        return value;
	    }
	}
	exports.toStructuredValue = toStructuredValue;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var RamlWrapper1 = __webpack_require__(1);
	var RamlWrapper08 = __webpack_require__(84);
	var path = __webpack_require__(9);
	var Opt = __webpack_require__(55);
	var jsyaml = __webpack_require__(6);
	var hlimpl = __webpack_require__(5);
	var llimpl = __webpack_require__(6);
	var expander = __webpack_require__(87);
	var util = __webpack_require__(54);
	var universeDef = __webpack_require__(62);
	var universeProvider = __webpack_require__(93);
	function loadApi1(apiPath, options) {
	    var opt = loadApi(apiPath, options);
	    if (!opt.isDefined()) {
	        return Opt.empty();
	    }
	    var api = opt.getOrThrow();
	    if (!(api instanceof RamlWrapper1.ApiImpl)) {
	        return Opt.empty();
	    }
	    return new Opt(api);
	}
	exports.loadApi1 = loadApi1;
	function loadApi08(apiPath, options) {
	    var opt = loadApi(apiPath, options);
	    if (!opt.isDefined()) {
	        return Opt.empty();
	    }
	    var api = opt.getOrThrow();
	    if (!(api instanceof RamlWrapper08.ApiImpl)) {
	        return Opt.empty();
	    }
	    return new Opt(api);
	}
	exports.loadApi08 = loadApi08;
	function loadApi(apiPath, options) {
	    var project = getProject(apiPath, options);
	    var api;
	    var unitName = path.basename(apiPath);
	    var unit = project.unit(unitName);
	    if (unit) {
	        api = toApi(unit, options);
	    }
	    return new Opt(api);
	}
	exports.loadApi = loadApi;
	function loadApi1Async(apiPath, options) {
	    return loadApiAsync(apiPath, options).then(function (x) {
	        if (!x) {
	            return x;
	        }
	        if (!(x instanceof RamlWrapper1.ApiImpl)) {
	            return null;
	        }
	        return x;
	    });
	}
	exports.loadApi1Async = loadApi1Async;
	function loadApi08Async(apiPath, options) {
	    return loadApiAsync(apiPath, options).then(function (x) {
	        if (!x) {
	            return x;
	        }
	        if (!(x instanceof RamlWrapper08.ApiImpl)) {
	            return null;
	        }
	        return x;
	    });
	}
	exports.loadApi08Async = loadApi08Async;
	function loadApiAsync(apiPath, options) {
	    var project = getProject(apiPath, options);
	    var unitName = path.basename(apiPath);
	    return llimpl.fetchIncludesAsync(project, unitName).then(function (x) {
	        return toApi(x, options);
	    });
	}
	exports.loadApiAsync = loadApiAsync;
	function getProject(apiPath, options) {
	    var includeResolver = options && options.includeResolver ? options.includeResolver : null;
	    var httpResolver = options && options.httpResolver ? options.httpResolver : null;
	    var projectRoot = path.dirname(apiPath);
	    var project;
	    if (httpResolver) {
	        project = new jsyaml.Project(projectRoot, includeResolver, httpResolver);
	    }
	    else if (includeResolver) {
	        project = new jsyaml.Project(projectRoot, includeResolver);
	    }
	    else {
	        project = new jsyaml.Project(projectRoot);
	    }
	    return project;
	}
	;
	function toApi(unit, options) {
	    if (!unit) {
	        return null;
	    }
	    var api;
	    var expandTraitsAndResourceTypes = options && (options.expandTraitsAndResourceTypes != null) ? options.expandTraitsAndResourceTypes : true;
	    var contents = unit.contents();
	    if (!util.stringStartsWith(contents, '#%RAML')) {
	        return null;
	    }
	    var ind = contents.indexOf('\n');
	    if (ind < 0) {
	        ind = contents.length;
	    }
	    var verStr = contents.substring('#%RAML'.length, ind).trim();
	    var ramlVersion;
	    var typeName;
	    if (verStr == '0.8') {
	        ramlVersion = 'RAML08';
	        typeName = universeDef.Universe08.Api.name;
	    }
	    else if (verStr == '1.0') {
	        ramlVersion = 'RAML10';
	        typeName = universeDef.Universe10.Api.name;
	    }
	    if (!ramlVersion) {
	        return null;
	    }
	    var universe = universeProvider(ramlVersion);
	    var apiType = universe.type(typeName);
	    api = new RamlWrapper1.ApiImpl(new hlimpl.ASTNodeImpl(unit.ast(), null, apiType, null));
	    if (expandTraitsAndResourceTypes) {
	        api = expander.expandTraitsAndResourceTypes(api);
	    }
	    return api;
	}
	;
	function loadApis1(projectRoot, cacheChildren, expandTraitsAndResourceTypes) {
	    if (cacheChildren === void 0) { cacheChildren = false; }
	    if (expandTraitsAndResourceTypes === void 0) { expandTraitsAndResourceTypes = true; }
	    var universe = universeProvider("RAML10");
	    var apiType = universe.type(universeDef.Universe10.Api.name);
	    var p = new jsyaml.Project(projectRoot);
	    var result = [];
	    p.units().forEach(function (x) {
	        var lowLevel = x.ast();
	        if (cacheChildren) {
	            lowLevel = llimpl.toChildCahcingNode(lowLevel);
	        }
	        var api = new RamlWrapper1.ApiImpl(new hlimpl.ASTNodeImpl(lowLevel, null, apiType, null));
	        if (expandTraitsAndResourceTypes) {
	            api = expander.expandTraitsAndResourceTypes(api);
	        }
	        result.push(api);
	    });
	    return result;
	}
	exports.loadApis1 = loadApis1;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var hlimpl = __webpack_require__(5);
	var proxy = __webpack_require__(59);
	var RamlWrapper = __webpack_require__(1);
	var RamlWrapper08 = __webpack_require__(84);
	var wrapperHelper = __webpack_require__(88);
	var pluralize = __webpack_require__(92);
	var universeProvider = __webpack_require__(93);
	function expandTraitsAndResourceTypes(api) {
	    if (!(api instanceof RamlWrapper.ApiImpl || api instanceof RamlWrapper08.ApiImpl)) {
	        return null;
	    }
	    return new TraitsAndResourceTypesExpander().expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	var TraitsAndResourceTypesExpander = (function () {
	    function TraitsAndResourceTypesExpander() {
	    }
	    TraitsAndResourceTypesExpander.prototype.expandTraitsAndResourceTypes = function (_api) {
	        var _this = this;
	        var isRAML1 = _api instanceof RamlWrapper.ApiImpl;
	        var api = _api;
	        var traits = wrapperHelper.allTraits(api);
	        var resourceTypes = wrapperHelper.allResourceTypes(api);
	        //if ((!traits || traits.length == 0) && (!resourceTypes || resourceTypes.length == 0)) {
	        //    return api;
	        //}
	        var llNode = api.highLevel().lowLevel();
	        this.ramlVersion = _api.highLevel().definition().universe().version();
	        var topComposite = new proxy.LowLevelCompositeNode(llNode, null, null);
	        var apiType = isRAML1 ? universeProvider('RAML10').type('Api') : universeProvider('RAML08').type('Api');
	        var hlNode = new hlimpl.ASTNodeImpl(topComposite, null, apiType, null);
	        var result = isRAML1 ? new RamlWrapper.ApiImpl(hlNode) : new RamlWrapper08.ApiImpl(hlNode);
	        this.traitMap = {};
	        this.resourceTypeMap = {};
	        if (traits) {
	            traits.forEach(function (x) { return _this.traitMap[wrapperHelper.qName(x)] = x; });
	        }
	        if (resourceTypes) {
	            resourceTypes.forEach(function (x) { return _this.resourceTypeMap[wrapperHelper.qName(x)] = x; });
	        }
	        var resources = result.resources();
	        resources.forEach(function (x) { return _this.processResource(x); });
	        return result;
	    };
	    TraitsAndResourceTypesExpander.prototype.processResource = function (resource) {
	        var _this = this;
	        var resourceData = this.collectResourceData(resource);
	        if (resource instanceof RamlWrapper.ResourceImpl) {
	            var mb = resource;
	        }
	        resourceData.filter(function (x) { return x.resourceType != null; }).forEach(function (x) { return resource.highLevel().lowLevel().adopt(x.resourceType.node.highLevel().lowLevel(), x.resourceType.transformer); });
	        var methods = resource.methods();
	        methods.forEach(function (m) {
	            var name = m.method();
	            var map = {};
	            resourceData.forEach(function (x) {
	                var methodTraits = x.methodTraits[name];
	                if (methodTraits) {
	                    methodTraits.forEach(function (x) { return m.highLevel().lowLevel().adopt(x.node.highLevel().lowLevel(), x.transformer); }, true);
	                }
	                var resourceTraits = x.traits;
	                if (resourceTraits) {
	                    resourceTraits.forEach(function (x) { return m.highLevel().lowLevel().adopt(x.node.highLevel().lowLevel(), x.transformer); }, true);
	                }
	            });
	        });
	        var resources = resource.resources();
	        resources.forEach(function (x) { return _this.processResource(x); });
	    };
	    TraitsAndResourceTypesExpander.prototype.collectResourceData = function (obj, arr, transformer) {
	        var _this = this;
	        if (arr === void 0) { arr = []; }
	        var ownTraits = this.extractTraits(obj);
	        var methodTraitsMap = {};
	        var methods = obj.methods();
	        methods.forEach(function (x) {
	            var methodTraits = _this.extractTraits(x);
	            if (methodTraits && methodTraits.length > 0) {
	                methodTraitsMap[x.method()] = methodTraits;
	            }
	        });
	        var rtData;
	        var rt = obj.type();
	        if (rt) {
	            rtData = this.readGenerictData(rt, this.resourceTypeMap, 'resource type', transformer);
	        }
	        arr.push({
	            resourceType: rtData,
	            traits: ownTraits,
	            methodTraits: methodTraitsMap
	        });
	        if (rtData) {
	            this.collectResourceData(rtData.node, arr, rtData.transformer);
	        }
	        return arr;
	    };
	    TraitsAndResourceTypesExpander.prototype.extractTraits = function (obj, _transformer, map) {
	        var _this = this;
	        if (map === void 0) { map = {}; }
	        var arr = [];
	        for (var i = -1; i < arr.length; i++) {
	            var gd = i < 0 ? null : arr[i];
	            var _obj = gd ? gd.node : obj;
	            var transformer = gd ? gd.transformer : _transformer;
	            _obj.is().forEach(function (x) {
	                var traitData = _this.readGenerictData(x, _this.traitMap, 'trait', transformer);
	                if (traitData) {
	                    var name = traitData.name;
	                    if (!map[name]) {
	                        map[name] = true;
	                        arr.push(traitData);
	                    }
	                }
	            });
	        }
	        if (obj instanceof RamlWrapper.MethodImpl) {
	            var mb = obj;
	        }
	        return arr;
	    };
	    TraitsAndResourceTypesExpander.prototype.readGenerictData = function (obj, globalMap, template, transformer) {
	        var value = obj.value();
	        if (typeof (value) == 'string') {
	            if (transformer) {
	                value = transformer.transform(value);
	            }
	            var node = globalMap[value];
	            if (node) {
	                return {
	                    name: value,
	                    transformer: null,
	                    node: node
	                };
	            }
	        }
	        else if (value instanceof hlimpl.StructuredValue) {
	            var sv = value;
	            var name = sv.valueName();
	            var params = {};
	            var node = globalMap[name];
	            //var t = hlimpl.typeFromNode(node.highLevel());
	            if (node) {
	                if (this.ramlVersion == 'RAML08' && transformer) {
	                    sv.children().forEach(function (x) { return params[x.valueName()] = transformer.transform(x.lowLevel().value()); });
	                }
	                else {
	                    sv.children().forEach(function (x) { return params[x.valueName()] = x.lowLevel().value(); });
	                }
	                return {
	                    name: name,
	                    transformer: new ValueTransformer(params, template),
	                    node: node
	                };
	            }
	        }
	        return null;
	    };
	    return TraitsAndResourceTypesExpander;
	})();
	var ValueTransformer = (function () {
	    function ValueTransformer(params, template) {
	        this.params = params;
	        this.template = template;
	    }
	    ValueTransformer.prototype.error = function () {
	        return this.err;
	    };
	    ValueTransformer.prototype.transform = function (obj) {
	        var undefParams = {};
	        if (typeof (obj) === 'string') {
	            var str = obj;
	            var str1 = '';
	            var prev = 0;
	            for (var i = str.indexOf('<<'); i >= 0; i = str.indexOf('<<', prev)) {
	                str1 += str.substring(prev, i);
	                var i0 = i;
	                i += '<<'.length;
	                prev = str.indexOf('>>', i);
	                var paramOccurence = str.substring(i, prev);
	                prev += '>>'.length;
	                var originalString = str.substring(i0, prev);
	                var val;
	                var paramName;
	                if (paramOccurence.match(/\|\s*!\s*singularize\s*$/)) {
	                    var ind = paramOccurence.lastIndexOf('|');
	                    paramName = paramOccurence.substring(0, ind).trim();
	                    val = this.params[paramName];
	                    if (val) {
	                        val = pluralize.singular(val);
	                    }
	                }
	                else if (paramOccurence.match(/\|\s*!\s*pluralize\s*$/)) {
	                    var ind = paramOccurence.lastIndexOf('|');
	                    paramName = paramOccurence.substring(0, ind).trim();
	                    val = this.params[paramName];
	                    if (val) {
	                        val = pluralize.plural(val);
	                    }
	                }
	                else {
	                    paramName = paramOccurence.trim();
	                    val = this.params[paramName];
	                }
	                if (!val) {
	                    undefParams[paramName] = true;
	                    val = originalString;
	                }
	                str1 += val;
	            }
	            var upArr = Object.keys(undefParams);
	            if (upArr.length > 0) {
	                var errStr = upArr.join(', ').trim();
	                this.err = "Undefined " + this.template + " parameter" + (upArr.length > 1 ? 's' : '') + ": " + errStr;
	            }
	            else {
	                this.err = null;
	            }
	            str1 += str.substring(prev, str.length);
	            return str1;
	        }
	        else {
	            return obj;
	        }
	    };
	    return ValueTransformer;
	})();


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(1);
	var ramlPathMatch = __webpack_require__(89);
	var hl = __webpack_require__(2);
	var hlimpl = __webpack_require__(5);
	var universes = __webpack_require__(62);
	var Opt = __webpack_require__(55);
	var util = __webpack_require__(54);
	var typeexpression = __webpack_require__(66);
	var expander = __webpack_require__(87);
	var lowLevelProxy = __webpack_require__(59);
	var search = __webpack_require__(65);
	var ll = __webpack_require__(6);
	var path = __webpack_require__(9);
	function resolveType(p) {
	    var tpe = typeexpression.typeFromNode(p.highLevel());
	    return tpe.toRuntime();
	}
	exports.resolveType = resolveType;
	function load(pth) {
	    var m = new ll.Project(path.dirname(pth));
	    var unit = m.unit(path.basename(pth));
	    if (unit) {
	        if (unit.isRAMLUnit()) {
	            return hl.fromUnit(unit).wrapperNode();
	        }
	    }
	    return null;
	}
	exports.load = load;
	//__$helperMethod__ Path relative to API root
	function completeRelativeUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    return uri;
	}
	exports.completeRelativeUri = completeRelativeUri;
	//__$helperMethod__ Equivalent API with traits and resource types expanded
	function expandTraitsAndResourceTypes(api) {
	    var lowLevelNode = api.highLevel().lowLevel();
	    if (lowLevelNode instanceof lowLevelProxy.LowLevelProxyNode) {
	        return api;
	    }
	    return expander.expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	//__$helperMethod__ baseUri of owning Api concatenated with completeRelativeUri
	function absoluteUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    uri = uri.replace(/\/\//g, '/');
	    var buri = parent.baseUri();
	    var base = buri ? buri.value() : "";
	    base = base ? base : '';
	    if (util.stringEndsWith(base, '/')) {
	        uri = uri.substring(1);
	    }
	    uri = base + uri;
	    return uri;
	}
	exports.absoluteUri = absoluteUri;
	function qName(c) {
	    return hlimpl.qName(c.highLevel(), c.highLevel().root());
	}
	exports.qName = qName;
	//__$helperMethod__ Retrieve all traits including those defined in libraries
	function allTraits(a) {
	    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().key() == universes.Universe08.Trait || x.definition().key() == universes.Universe10.Trait; }).map(function (x) { return x.wrapperNode(); });
	}
	exports.allTraits = allTraits;
	//__$helperMethod__ Retrieve all resource types including those defined in libraries
	function allResourceTypes(a) {
	    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().key() == universes.Universe08.ResourceType || x.definition().key() == universes.Universe10.ResourceType; }).map(function (x) { return x.wrapperNode(); });
	}
	exports.allResourceTypes = allResourceTypes;
	function relativeUriSegments(res) {
	    var result = [];
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        result.push(res.relativeUri().value());
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    return result.reverse();
	}
	exports.relativeUriSegments = relativeUriSegments;
	//__$helperMethod__ For methods of Resources returns parent resource. For methods of ResourceTypes returns undefined Opt.
	function parentResource(method) {
	    if (method.parent() instanceof RamlWrapper.ResourceImpl) {
	        return new Opt(method.parent());
	    }
	    return Opt.empty();
	}
	exports.parentResource = parentResource;
	//__$helperMethod__ Parent resource for non top level resources __$meta__={"name":"parentResource"}
	function parent(resource) {
	    var parent = resource.parent();
	    if (isApi(parent)) {
	        return Opt.empty();
	    }
	    return new Opt(parent);
	}
	exports.parent = parent;
	//__$helperMethod__ Get child resource by its relative path
	function getChildResource(container, relPath) {
	    if (container == null) {
	        return Opt.empty();
	    }
	    var resources = container.resources();
	    if (!resources) {
	        return Opt.empty();
	    }
	    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
	    if (resources.length == 0) {
	        return Opt.empty();
	    }
	    return new Opt(resources[0]);
	}
	exports.getChildResource = getChildResource;
	function getResource(container, path) {
	    if (!container) {
	        return null;
	    }
	    var opt = Opt.empty();
	    for (var i = 0; i < path.length; i++) {
	        opt = getChildResource(container, path[i]);
	        if (!opt.isDefined()) {
	            return opt;
	        }
	        container = opt.getOrThrow();
	    }
	    return opt;
	}
	exports.getResource = getResource;
	//__$helperMethod__ Get child method by its name
	function getChildMethod(resource, method) {
	    if (!resource) {
	        return null;
	    }
	    return resource.methods().filter(function (x) { return x.method() == method; });
	}
	exports.getChildMethod = getChildMethod;
	function getMethod(container, path, method) {
	    var resource = getResource(container, path);
	    return getChildMethod(resource.getOrElse(null), method);
	}
	exports.getMethod = getMethod;
	function isApi(obj) {
	    return (obj['title'] && obj['version'] && obj['baseUri']);
	}
	;
	//__$helperMethod__ Api owning the resource as a sibling
	function ownerApi(method) {
	    var obj = method;
	    while (!isApi(obj)) {
	        obj = obj.parent();
	    }
	    return obj;
	}
	exports.ownerApi = ownerApi;
	//__$helperMethod__
	// For methods of Resources: `{parent Resource relative path} {methodName}`.
	// For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	// For other methods throws Exception.
	function methodId(method) {
	    var parent = method.parent();
	    if (parent instanceof RamlWrapper.ResourceImpl) {
	        return completeRelativeUri(parent) + ' ' + method.method().toLowerCase();
	    }
	    else if (parent instanceof RamlWrapper.ResourceTypeImpl) {
	        return parent.name() + ' ' + method.method().toLowerCase();
	    }
	    throw new Error("Method is supposed to be owned by Resource or ResourceType");
	}
	exports.methodId = methodId;
	//__$helperMethod__ true for codes < 400 and false otherwise
	function isOkRange(response) {
	    return parseInt(response.code().value()) < 400;
	}
	exports.isOkRange = isOkRange;
	//__$helperMethod__  Retrieve all resources ofthe Api
	function allResources(api) {
	    var resources = [];
	    var visitor = function (res) {
	        resources.push(res);
	        res.resources().forEach(function (x) { return visitor(x); });
	    };
	    api.resources().forEach(function (x) { return visitor(x); });
	    return resources;
	}
	exports.allResources = allResources;
	function matchUri(apiRootRelativeUri, resource) {
	    var allParameters = {};
	    var opt = new Opt(resource);
	    while (opt.isDefined()) {
	        var res = opt.getOrThrow();
	        uriParameters(res).forEach(function (x) { return allParameters[x.name()] = new ParamWrapper(x); });
	        opt = parent(res);
	    }
	    var result = ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
	    if (result) {
	        return new Opt(Object.keys(result.params).map(function (x) { return new ParamValue(x, result['params'][x]); }));
	    }
	    return Opt.empty();
	}
	exports.matchUri = matchUri;
	var schemaContentChars = ['{', '<'];
	function schema(body, api) {
	    var schemaNode = body.schema();
	    if (!schemaNode) {
	        return Opt.empty();
	    }
	    var schemaString = schemaNode;
	    var isContent = false;
	    schemaContentChars.forEach(function (x) {
	        try {
	            isContent = isContent || schemaString.indexOf(x) >= 0;
	        }
	        catch (e) {
	        }
	    });
	    var schDef;
	    if (isContent) {
	        schDef = new SchemaDef(schemaString);
	    }
	    else {
	        var globalSchemes = api.schemas().filter(function (x) { return x.key() == schemaString; });
	        if (globalSchemes.length > 0) {
	            schDef = new SchemaDef(globalSchemes[0].value().value(), globalSchemes[0].key());
	        }
	        else {
	            return Opt.empty();
	        }
	    }
	    return new Opt(schDef);
	}
	exports.schema = schema;
	//__$helperMethod__ Retrieve all uri parameters regardless of whether they are described in `uriParameters` or not
	// __$meta__={"name":"allUriParameters"}
	function uriParameters(resource) {
	    var uri = resource.relativeUri().value();
	    var params = resource.uriParameters();
	    return extractParams(params, uri, resource);
	}
	exports.uriParameters = uriParameters;
	//__$helperMethod__ Retrieve all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	//__$meta__={"name":"allBaseUriParameters"}
	function baseUriParameters(api) {
	    var uri = api.baseUri() ? api.baseUri().value() : '';
	    var params = api.baseUriParameters();
	    return extractParams(params, uri, api);
	}
	exports.baseUriParameters = baseUriParameters;
	//__$helperMethod__ Retrieve all absolute uri parameters regardless of whether they are described in
	//`baseUriParameters` and `uriParameters` or not
	function absoluteUriParameters(res) {
	    var params = [];
	    var parent = res;
	    do {
	        res = parent;
	        var uri = res.relativeUri().value();
	        var uriParams = res.uriParameters();
	        params = extractParams(uriParams, uri, res).concat(params);
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    var api = parent;
	    var baseUri = api.baseUri().value();
	    var baseUriParams = api.baseUriParameters();
	    params = extractParams(baseUriParams, baseUri, api).concat(params);
	    return params;
	}
	exports.absoluteUriParameters = absoluteUriParameters;
	function extractParams(params, uri, resource) {
	    if (!uri) {
	        return [];
	    }
	    var describedParams = {};
	    params.forEach(function (x) { return describedParams[x.name()] = x; });
	    var allParams = [];
	    var prev = 0;
	    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
	        prev = uri.indexOf('}', ++i);
	        var paramName = uri.substring(i, prev);
	        if (describedParams[paramName]) {
	            allParams.push(describedParams[paramName]);
	        }
	        else {
	            allParams.push(new HelperUriParam(paramName, resource));
	        }
	    }
	    return allParams;
	}
	;
	var HelperUriParam = (function () {
	    function HelperUriParam(_name, _parent) {
	        this._name = _name;
	        this._parent = _parent;
	    }
	    HelperUriParam.prototype.wrapperClassName = function () {
	        return "HelperUriParam";
	    };
	    HelperUriParam.prototype.getKind = function () {
	        return "HelperUriParam";
	    };
	    HelperUriParam.prototype.name = function () {
	        return this._name;
	    };
	    HelperUriParam.prototype["type"] = function () {
	        return ["string"];
	    };
	    HelperUriParam.prototype.location = function () {
	        return {
	            wrapperClassName: function () { return "HelperModelLocation"; },
	            getKind: function () { return "HelperModelLocation"; }
	        };
	    };
	    HelperUriParam.prototype.locationKind = function () {
	        return {
	            wrapperClassName: function () { return "HelperLocationKind"; },
	            getKind: function () { return "HelperLocationKind"; }
	        };
	    };
	    HelperUriParam.prototype["default"] = function () {
	        return null;
	    };
	    HelperUriParam.prototype.xml = function () {
	        return null;
	    };
	    HelperUriParam.prototype.sendDefaultByClient = function () {
	        return false;
	    };
	    HelperUriParam.prototype.example = function () {
	        return '';
	    };
	    HelperUriParam.prototype.schema = function () {
	        return null;
	    };
	    HelperUriParam.prototype.formParameters = function () {
	        return [];
	    };
	    HelperUriParam.prototype.examples = function () {
	        return [];
	    };
	    HelperUriParam.prototype.repeat = function () {
	        return false;
	    };
	    HelperUriParam.prototype.enum = function () {
	        return [];
	    };
	    HelperUriParam.prototype.collectionFormat = function () {
	        return 'multi';
	    };
	    HelperUriParam.prototype.required = function () {
	        return true;
	    };
	    HelperUriParam.prototype.readOnly = function () {
	        return false;
	    };
	    HelperUriParam.prototype.facets = function () {
	        return [];
	    };
	    HelperUriParam.prototype.scope = function () {
	        return [];
	    };
	    //xml(  ):RamlWrapper.XMLInfo{ return null; }
	    HelperUriParam.prototype.validWhen = function () {
	        return null;
	    };
	    HelperUriParam.prototype.requiredWhen = function () {
	        return null;
	    };
	    HelperUriParam.prototype.displayName = function () {
	        return this._name;
	    };
	    HelperUriParam.prototype.description = function () {
	        return null;
	    };
	    HelperUriParam.prototype.annotations = function () {
	        return [];
	    };
	    HelperUriParam.prototype.usage = function () {
	        return null;
	    };
	    HelperUriParam.prototype.parent = function () {
	        return this._parent;
	    };
	    HelperUriParam.prototype.highLevel = function () {
	        return null;
	    };
	    HelperUriParam.prototype.errors = function () {
	        return [];
	    };
	    HelperUriParam.prototype.definition = function () {
	        return null;
	    };
	    HelperUriParam.prototype.runtimeDefinition = function () {
	        return null;
	    };
	    HelperUriParam.prototype.toJSON = function () {
	        return { "name": this.name() };
	    };
	    return HelperUriParam;
	})();
	exports.HelperUriParam = HelperUriParam;
	var SchemaDef = (function () {
	    function SchemaDef(_content, _name) {
	        this._content = _content;
	        this._name = _name;
	    }
	    SchemaDef.prototype.name = function () {
	        return this._name;
	    };
	    SchemaDef.prototype.content = function () {
	        return this._content;
	    };
	    return SchemaDef;
	})();
	exports.SchemaDef = SchemaDef;
	var ParamValue = (function () {
	    function ParamValue(key, value) {
	        this.key = key;
	        this.value = value;
	    }
	    return ParamValue;
	})();
	exports.ParamValue = ParamValue;
	var ParamWrapper = (function () {
	    function ParamWrapper(_param) {
	        this._param = _param;
	        this.description = _param.description() ? _param.description().value() : this.description;
	        this.displayName = _param.displayName();
	        //        this.enum = _param.enum();
	        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
	        this.example = _param.example();
	        this.repeat = _param.repeat();
	        this.required = _param.required();
	        this.default = _param.default();
	    }
	    return ParamWrapper;
	})();


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../typings/tsd.d.ts" />
	var ramlSanitize = __webpack_require__(90);
	var ramlValidate = __webpack_require__(91);
	var REGEXP_MATCH = {
	    number: '[-+]?\\d+(?:\\.\\d+)?',
	    integer: '[-+]?\\d+',
	    date: '(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), \\d{2} (?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) \\d{4} (?:[0-1]\\d|2[0-3]):[0-5]\\d:[0-5]\\d GMT',
	    boolean: '(?:true|false)'
	};
	var ESCAPE_CHARACTERS = /([.*+?=^!:${}()|[\]\/\\])/g;
	var REGEXP_REPLACE = new RegExp([
	    '([.\\/])?\\{([^}]+)\\}',
	    ESCAPE_CHARACTERS.source
	].join('|'), 'g');
	function toRegExp(path, parameters, keys, options) {
	    var end = options.end !== false;
	    var strict = options.strict;
	    var flags = '';
	    if (!options.sensitive) {
	        flags += 'i';
	    }
	    var route = path.replace(REGEXP_REPLACE, function (match, prefix, key, escape) {
	        if (escape) {
	            return '\\' + escape;
	        }
	        // Push the current key into the keys array.
	        keys.push({
	            name: key,
	            prefix: prefix || '/'
	        });
	        prefix = prefix ? '\\' + prefix : '';
	        // TODO: Support an array of parameters.
	        var param = parameters[key];
	        var capture = param && REGEXP_MATCH[param.type] || '[^' + (prefix || '\\/') + ']+';
	        var optional = param && param.required === false;
	        if (Array.isArray(param.enum) && param.enum.length) {
	            capture = '(?:' + param.enum.map(function (value) {
	                return String(value).replace(ESCAPE_CHARACTERS, '\\$1');
	            }).join('|') + ')';
	        }
	        return prefix + '(' + capture + ')' + (optional ? '?' : '');
	    });
	    var endsWithSlash = path.charAt(path.length - 1) === '/';
	    // In non-strict mode we allow a slash at the end of match. If the path to
	    // match already ends with a slash, we remove it for consistency. The slash
	    // is valid at the end of a path match, not in the middle. This is important
	    // in non-ending mode, where "/test/" shouldn't match "/test//route".
	    if (!strict) {
	        route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
	    }
	    if (end) {
	        route += '$';
	    }
	    else {
	        // In non-ending mode, we need the capturing groups to match as much as
	        // possible by using a positive lookahead to the end or next path segment.
	        route += strict && endsWithSlash ? '' : '(?=\\/|$)';
	    }
	    return new RegExp('^' + route + (end ? '$' : ''), flags);
	}
	function decodeParam(param) {
	    try {
	        return decodeURIComponent(param);
	    }
	    catch (_) {
	        var err = new Error('Failed to decode param "' + param + '"');
	        err.status = 400;
	        throw err;
	    }
	}
	function ramlPathMatch(path, parameters, options) {
	    options = options || {};
	    if (path === '/' && options.end === false) {
	        return truth;
	    }
	    parameters = parameters || {};
	    var keys = [];
	    var re = toRegExp(path, parameters, keys, options);
	    var sanitize = ramlSanitize()(parameters);
	    var validate = ramlValidate()(parameters);
	    return function (pathname) {
	        var m = re.exec(pathname);
	        if (!m) {
	            return false;
	        }
	        if (parameters['mediaTypeExtension']) {
	            if (m.length > 1 && !m[m.length - 1]) {
	                var beforeLast = m[m.length - 2];
	                var ind = beforeLast.lastIndexOf('.');
	                if (ind >= 0) {
	                    m[m.length - 2] = beforeLast.substring(0, ind);
	                    m[m.length - 1] = beforeLast.substring(ind);
	                }
	            }
	        }
	        var path = m[0];
	        var params = {};
	        for (var i = 1; i < m.length; i++) {
	            var key = keys[i - 1];
	            var param = m[i];
	            params[key.name] = param == null ? param : decodeParam(param);
	        }
	        params = sanitize(params);
	        if (!validate(params).valid) {
	            return false;
	        }
	        return {
	            path: path,
	            params: params
	        };
	    };
	}
	function truth(path) {
	    return { path: '', params: {} };
	}
	module.exports = ramlPathMatch;


/***/ },
/* 90 */
/***/ function(module, exports) {

	/// <reference path="../../typings/tsd.d.ts" />
	function isEmpty(value) {
	    return value == null;
	}
	function toString(value) {
	    return isEmpty(value) ? '' : String(value);
	}
	function toBoolean(value) {
	    return [0, false, '', '0', 'false'].indexOf(value) === -1;
	}
	function toNumber(value) {
	    return isFinite(value) ? Number(value) : null;
	}
	function toInteger(value) {
	    return value % 1 === 0 ? Number(value) : null;
	}
	function toDate(value) {
	    return !isNaN(Date.parse(value)) ? new Date(value) : null;
	}
	function toSanitization(parameter, rules, types) {
	    var parameters = Array.isArray(parameter) ? parameter : [parameter];
	    var sanitizations = parameters.map(function (parameter) {
	        var fns = [];
	        var typeSanitization = types[parameter.type];
	        if (typeof typeSanitization === 'function') {
	            fns.push(typeSanitization);
	        }
	        Object.keys(parameter).filter(function (key) {
	            return key !== 'type' && key !== 'repeat' && key !== 'default';
	        }).forEach(function (key) {
	            var fn = rules[key];
	            if (typeof fn === 'function') {
	                fns.push(fn(parameter[key], key));
	            }
	        });
	        function sanitize(value, key, src) {
	            for (var i = 0; i < fns.length; i++) {
	                var fn = fns[i];
	                var value = fn(value, key, src);
	                if (value != null) {
	                    return value;
	                }
	            }
	            return null;
	        }
	        return function (value, key, src) {
	            if (isEmpty(value)) {
	                if (parameter.default != null) {
	                    return sanitize(parameter.default, key, src);
	                }
	                return parameter.repeat && !parameter.required ? [] : value;
	            }
	            if (parameter.repeat) {
	                var values = Array.isArray(value) ? value : [value];
	                values = values.map(function (value) {
	                    return sanitize(value, key, src);
	                });
	                return values.some(isEmpty) ? null : value;
	            }
	            if (Array.isArray(value)) {
	                if (value.length > 1) {
	                    return null;
	                }
	                value = value[0];
	            }
	            return sanitize(value, key, src);
	        };
	    });
	    return function (value, key, src) {
	        for (var i = 0; i < sanitizations.length; i++) {
	            var sanitization = sanitizations[i];
	            var result = sanitization(value, key, src);
	            if (result != null) {
	                return result;
	            }
	        }
	        return value;
	    };
	}
	function sanitize() {
	    var RULES = {};
	    var TYPES = {
	        string: toString,
	        number: toNumber,
	        integer: toInteger,
	        boolean: toBoolean,
	        date: toDate
	    };
	    function rule(parameter) {
	        return toSanitization(parameter, RULES, TYPES);
	    }
	    var sanitize = function (parameterMap) {
	        if (!parameterMap) {
	            return function () {
	                return {};
	            };
	        }
	        var sanitizations = {};
	        Object.keys(parameterMap).forEach(function (key) {
	            sanitizations[key] = sanitize.rule(parameterMap[key]);
	        });
	        return function (src) {
	            src = src || {};
	            var dest = {};
	            // Iterate the sanitized parameters to get a clean model.
	            Object.keys(sanitizations).forEach(function (key) {
	                var value = src[key];
	                var fn = sanitizations[key];
	                if (Object.prototype.hasOwnProperty.call(src, key)) {
	                    dest[key] = fn(value, key, src);
	                }
	            });
	            return dest;
	        };
	    };
	    var s;
	    s = sanitize;
	    s.rule = rule;
	    s.TYPES = TYPES;
	    s.RULES = RULES;
	    return s;
	}
	module.exports = sanitize;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/// <reference path="../../typings/tsd.d.ts" />
	var _toString = Object.prototype.toString;
	function isDateType(check) {
	    return _toString.call(check) === '[object Date]' && !isNaN(check.getTime());
	}
	function isBooleanType(check) {
	    return typeof check === 'boolean';
	}
	function isStringType(check) {
	    return typeof check === 'string';
	}
	function isIntegerType(check) {
	    return typeof check === 'number' && check % 1 === 0;
	}
	function isNumberType(check) {
	    return typeof check === 'number' && isFinite(check);
	}
	function isMinimum(min) {
	    return function (check) {
	        return check >= min;
	    };
	}
	function isMaximum(max) {
	    return function (check) {
	        return check <= max;
	    };
	}
	function isMinimumLength(min) {
	    return function (check) {
	        return Buffer.byteLength(check) >= min;
	    };
	}
	function isMaximumLength(max) {
	    return function (check) {
	        return Buffer.byteLength(check) <= max;
	    };
	}
	function isEnum(values) {
	    if (values && values.length != 0) {
	        return function (check) {
	            return values.indexOf(check) > -1;
	        };
	    }
	    else {
	        return function (check) {
	            return true;
	        };
	    }
	}
	function isPattern(pattern) {
	    var regexp = (typeof pattern === 'string') ? new RegExp(pattern) : pattern;
	    return regexp.test.bind(regexp);
	}
	function toValidationResult(valid, key, value, rule, attr) {
	    return {
	        valid: valid,
	        rule: rule,
	        attr: attr,
	        value: value,
	        key: key
	    };
	}
	function toValidationFunction(parameter, rules) {
	    var validations = [];
	    Object.keys(parameter).forEach(function (name) {
	        var rule = rules[name];
	        if (!rule) {
	            return;
	        }
	        var value = parameter[name];
	        validations.push([name, rule(value, name), value]);
	    });
	    return function (value, key, src) {
	        for (var i = 0; i < validations.length; i++) {
	            var validation = validations[i];
	            var name = validation[0];
	            var fn = validation[1];
	            var attr = validation[2];
	            var valid = fn(value, key, src);
	            if (!valid) {
	                return toValidationResult(false, key, value, name, attr);
	            }
	        }
	        return toValidationResult(true, key, value);
	    };
	}
	function toValidation(parameter, rules, types) {
	    var parameters = Array.isArray(parameter) ? parameter : [parameter];
	    var isOptional = !parameters.length;
	    var simpleValidations = [];
	    var repeatValidations = [];
	    parameters.forEach(function (parameter) {
	        var validation = [parameter.type || 'string', toValidationFunction(parameter, rules)];
	        if (!parameter.required) {
	            isOptional = true;
	        }
	        if (parameter.repeat) {
	            repeatValidations.push(validation);
	        }
	        else {
	            simpleValidations.push(validation);
	        }
	    });
	    return function (value, key, src) {
	        if (value == null) {
	            return toValidationResult(isOptional, key, value, 'required', !isOptional);
	        }
	        var isArray = Array.isArray(value);
	        var values = isArray ? value : [value];
	        var validations = isArray ? repeatValidations : simpleValidations;
	        if (!validations.length) {
	            return toValidationResult(false, key, value, 'repeat', !isArray);
	        }
	        var response = null;
	        var originalValue = value;
	        validations.some(function (validation) {
	            var isValidType = values.every(function (value) {
	                var paramType = validation[0];
	                var isValidType = types[paramType] && types[paramType](value, key, src);
	                if (!isValidType) {
	                    response = toValidationResult(false, key, originalValue, 'type', paramType);
	                }
	                return isValidType;
	            });
	            if (!isValidType) {
	                return false;
	            }
	            values.every(function (value) {
	                var fn = validation[1];
	                response = fn(value, key);
	                return response.valid;
	            });
	            return true;
	        });
	        return response;
	    };
	}
	function validate() {
	    var TYPES = {
	        date: isDateType,
	        number: isNumberType,
	        integer: isIntegerType,
	        boolean: isBooleanType,
	        string: isStringType
	    };
	    var RULES = {
	        minimum: isMinimum,
	        maximum: isMaximum,
	        minLength: isMinimumLength,
	        maxLength: isMaximumLength,
	        'enum': isEnum,
	        pattern: isPattern
	    };
	    function rule(parameter) {
	        return toValidation(parameter, RULES, TYPES);
	    }
	    var v;
	    var validate = function (parameterMap) {
	        if (!parameterMap) {
	            return function (check) {
	                return { valid: true, errors: [] };
	            };
	        }
	        var validations = {};
	        Object.keys(parameterMap).forEach(function (key) {
	            validations[key] = rule(parameterMap[key]);
	        });
	        return function (src) {
	            src = src || {};
	            var errors = Object.keys(validations).map(function (param) {
	                var value = src[param];
	                var fn = validations[param];
	                return fn(value, param, src);
	            }).filter(function (result) {
	                return !result.valid;
	            });
	            return {
	                valid: errors.length === 0,
	                errors: errors
	            };
	        };
	    };
	    v = validate;
	    v.rule = rule;
	    v.TYPES = TYPES;
	    v.RULES = RULES;
	    return v;
	}
	module.exports = validate;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(44).Buffer))

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = require("pluralize");

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, __dirname) {var fs = __webpack_require__(10);
	var path = __webpack_require__(9);
	var tsstruct = __webpack_require__(68);
	var ts2def = __webpack_require__(67);
	var universes = {};
	var locations = {
	    "RAML10": "../spec-1.0/api.ts",
	    "RAML08": "../spec-0.8/api.ts"
	};
	var jsonDefinitions = {
	    "RAML10": __webpack_require__(94),
	    "RAML08": __webpack_require__(95)
	};
	var getUniverse = (function () {
	    var x = function (key) {
	        if (universes[key]) {
	            return universes[key];
	        }
	        var src = getDecl(key);
	        var universe = ts2def.toDefSystem(src);
	        if (universe) {
	            universe.setUniverseVersion(key);
	            universes[key] = universe;
	        }
	        var mediaTypeParser = __webpack_require__(78);
	        global.mediaTypeParser = mediaTypeParser;
	        return universe;
	    };
	    x.availableUniverses = function () {
	        return Object.keys(locations);
	    };
	    x.clean = function () {
	        Object.keys(jsonDefinitions).forEach(function (x) {
	            jsonDefinitions[x] = null;
	            universes[x] = null;
	            fs.writeFileSync(path.resolve(__dirname, "../artifacts/" + x + ".json"), 'null');
	        });
	    };
	    return x;
	})();
	function getDecl(key) {
	    if (jsonDefinitions[key]) {
	        return toModule(jsonDefinitions[key]);
	    }
	    var tsPath = path.resolve(__dirname, locations[key]);
	    var decls = fs.readFileSync(tsPath).toString();
	    var src = tsstruct.parseStruct(decls, {}, tsPath);
	    var arr = toModulesCollection(src);
	    var jsonPath = path.resolve(path.resolve(path.dirname(tsPath), '../artifacts'), key + '.json');
	    fs.writeFileSync(jsonPath, JSON.stringify(arr, null, 2));
	    src = toModule(arr);
	    return src;
	}
	function toModulesCollection(mod, map, arr) {
	    if (map === void 0) { map = {}; }
	    if (arr === void 0) { arr = []; }
	    var name = mod['name'];
	    if (map[name]) {
	        return;
	    }
	    map[name] = mod;
	    arr.push(mod);
	    var imports = mod['imports'];
	    Object.keys(imports).forEach(function (x) {
	        var submod = imports[x];
	        var n = submod['name'];
	        imports[x] = n;
	        toModulesCollection(submod, map, arr);
	    });
	    return arr;
	}
	function toModule(arr) {
	    var main = arr[0];
	    var map = {};
	    arr.forEach(function (x) { return map[x['name']] = x; });
	    arr.forEach(function (x) {
	        var imports = x['imports'];
	        Object.keys(imports).forEach(function (y) {
	            var name = imports[y];
	            imports[y] = map[name];
	        });
	    });
	    return main;
	}
	module.exports = getUniverse;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), "..\\..\\src\\raml1\\definition-system"))

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = [
		{
			"classes": [
				{
					"name": "GlobalSchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the global schema, used to refer on schema content"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the schema"
									]
								},
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.value",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"value"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Content of the schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ImportDeclaration",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name prefix (without dot) used to refer imported declarations"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Library",
								"nameSpace": "",
								"basicName": "Library",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the declared namespace"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Library",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why library exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "LibraryBase",
							"nameSpace": "",
							"basicName": "LibraryBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "LibraryBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "GlobalSchema",
									"nameSpace": "",
									"basicName": "GlobalSchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the types property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "types",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.MODELS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of (data) types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of (data) types for use within this API. See [[raml-10-spec-types|Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map type names to type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "RM.Trait",
									"nameSpace": "RM",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of traits for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map trait names to trait declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "RM.ResourceType",
									"nameSpace": "RM",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of resource types for use within this API"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of resource types for use within this API. See [[raml-10-spec-resource-types-and-traits|Resource Types and Traits]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map resource type names to resource type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotationTypes",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationType",
									"nameSpace": "Decls",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.version",
									"arguments": [
										"MetaModel.RAMLVersion.RAML10"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of annotation types for use by annotations"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of annotation types for use by annotations. See [[raml-10-spec-declaring-annotation-types|Annotation Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map annotation type names to annotation type declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemaTypes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaType",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas types declarations"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchema",
									"nameSpace": "RM",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas declarations"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of security schemes for use within this API."
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"Declarations of security schemes for use within this API. See [[raml-10-spec-security|Security Schemes]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map security scheme names to security scheme declarations; or an array of such objects"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "Library",
									"nameSpace": "",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Importing libraries"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries or a single library"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.internalClass",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Overlay",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why overlay exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "masterRef",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Api",
							"nameSpace": "",
							"basicName": "Api",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Extension",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"contains description of why extension exist"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "masterRef",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Api",
							"nameSpace": "",
							"basicName": "Api",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Api",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Short plain-text label for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "version",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The version of the API, e.g. \"v1\""
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUri",
							"type": {
								"typeName": "Sys.FullUriTemplate",
								"nameSpace": "Sys",
								"basicName": "FullUriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A URI that's to be used as the base of all the resources' URIs. Often used as the base of the URL of each resource, containing the location of the API. Can be a template URI."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"models.ModelLocation.BURI"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Named parameters used in the baseUri (template)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The protocols supported by the API"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array of strings, with each being \"HTTP\" or \"HTTPS\", case-insensitive"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "mediaType",
							"type": {
								"typeName": "Bodies.MimeType",
								"nameSpace": "Bodies",
								"basicName": "MimeType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The default media type to use for request and response bodies (payloads), e.g. \"application/json\""
									]
								},
								{
									"name": "MetaModel.inherited",
									"arguments": []
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Media type string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaRef",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to every resource and method in the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "RM.Resource",
									"nameSpace": "RM",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"/&lt;relativeUri&gt;"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The resources of the API, identified as relative URIs that begin with a slash (/). Every property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property, e.g.: /users, /{groupId}, etc"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "documentation",
							"type": {
								"base": {
									"typeName": "DocumentationItem",
									"nameSpace": "",
									"basicName": "DocumentationItem",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Additional overall documentation for the API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "LibraryBase",
							"nameSpace": "",
							"basicName": "LibraryBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"name": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the API"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this API. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						],
						"securitySchemaTypes": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						]
					}
				},
				{
					"name": "DocumentationItem",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Title of documentation section"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of documentation section"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ScriptSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "language",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ApiDescription",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "apiFiles",
							"type": {
								"base": {
									"typeName": "Api",
									"nameSpace": "",
									"basicName": "Api",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "script",
							"type": {
								"base": {
									"typeName": "ScriptSpec",
									"nameSpace": "",
									"basicName": "ScriptSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"endpoint",
											"callback"
										]
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "CallbackAPIDescription",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "callback"
							},
							"optional": false
						},
						{
							"name": "callbackFor",
							"type": {
								"typeName": "Api",
								"nameSpace": "",
								"basicName": "Api",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ApiDescription",
							"nameSpace": "",
							"basicName": "ApiDescription",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLProject",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "relatedProjects",
							"type": {
								"base": {
									"typeName": "RAMLProject",
									"nameSpace": "",
									"basicName": "RAMLProject",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "declaredApis",
							"type": {
								"base": {
									"typeName": "ApiDescription",
									"nameSpace": "",
									"basicName": "ApiDescription",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "license",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "overview",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "url",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"RM": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts",
				"Decls": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts",
				"Params": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts",
				"Bodies": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts",
				"models": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
		},
		{
			"classes": [
				{
					"name": "SpecPartMetaData",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "RAMLVersion",
					"members": [
						"RAML08",
						"RAML10"
					]
				}
			],
			"imports": {},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts"
		},
		{
			"classes": [
				{
					"name": "ValueType",
					"methods": [
						{
							"name": "parse",
							"start": 87,
							"end": 252,
							"text": "\n    /**\n     * parses inner structure of value type if value type has invalid value you should throw error\n     * with descriptive message\n     */\n    parse():any{}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringType",
					"methods": [
						{
							"name": "value",
							"start": 339,
							"end": 367,
							"text": " value():string{return null}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"string"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"number"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"integer"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"number"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"boolean"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Referencable",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Reference",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DeclaresDynamicType",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "T",
									"nameSpace": "",
									"basicName": "T",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UriTemplate",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This type currently serves both for absolute and relative urls"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StatusCode",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ramlexpression",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RelativeUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes relative uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FullUriTemplate",
					"methods": [
						{
							"name": "validate",
							"start": 2376,
							"end": 3306,
							"text": "\n    //parse():string[]{\n    //    var value=this.value();\n    //    var result=[]\n    //    var temp=\"\";\n    //    var inPar=false;\n    //    var count=0;\n    //    for (var a=0;a<value.length;a++){\n    //        var c=value[a];\n    //        if (c=='{'){\n    //            count++;\n    //            inPar=true;\n    //            continue;\n    //        }\n    //        if (c=='}'){\n    //            count--;\n    //            inPar=false;\n    //            result.push(temp);\n    //            temp=\"\";\n    //            continue;\n    //        }\n    //        if (inPar){\n    //            temp+=c;\n    //        }\n    //    }\n    //    if (count>0){\n    //        throw new Error(\"Unmatched '{'\")\n    //    }\n    //    if (count<0){\n    //        throw new Error(\"Unmatched '}'\")\n    //    }\n    //    return result;\n    //}\n\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes absolute uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FixedUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes fixed uris"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ContentType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ValidityExpression",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MarkdownString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"markdown"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"[GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateFormatSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FunctionalInterface",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaString",
					"methods": [
						{
							"name": "validate",
							"start": 4077,
							"end": 4260,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Schema at this moment only two subtypes are supported (json schema and xsd)"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ExampleString",
					"methods": [
						{
							"name": "validate",
							"start": 4414,
							"end": 4597,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Examples at this moment only two subtypes are supported (json  and xml)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSonSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"json"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"JSON schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"xsd"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"XSD schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ScriptingHook",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"script to inject to tooling environment"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLPointer",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLSelector",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
		},
		{
			"classes": [
				{
					"name": "ResourceTypeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TraitRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaPart",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"headers": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Optional array of headers, documenting the possible headers that could be accepted. See [[raml-10-spec-headers|Headers]] section."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the request header names and whose values describe the values."
								]
							}
						],
						"queryParameters": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Query parameters, used by the schema in order to authorize the request. Mutually exclusive with queryString. See [[raml-10-spec-query-parameters-in-a-query-string|Query Parameters]] section."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the query parameter names and whose values describe the values."
								]
							}
						],
						"queryString": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Specifies the query string, used by the schema in order to authorize the request. Mutually exclusive with queryParameters."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Type name or type declaration"
								]
							}
						],
						"responses": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Optional array of responses, describing the possible responses that could be sent. See [[raml-10-spec-responses|Responses]] section."
								]
							}
						],
						"is": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"securedBy": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the security scheme part"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the security scheme part"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Annotations to be applied to this security scheme part. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See [[raml-10-spec-annotations|the section on annotations]]."
								]
							}
						]
					}
				},
				{
					"name": "SecuritySchemaHook",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "parameters",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "script",
							"type": {
								"typeName": "SecuritySchemaHookScript",
								"nameSpace": "",
								"basicName": "SecuritySchemaHookScript",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Allows customization of security schemeas"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaHookScript",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.ScriptingHook",
							"nameSpace": "Sys",
							"basicName": "ScriptingHook",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "auth.SecuritySchemeHook",
									"nameSpace": "auth",
									"basicName": "SecuritySchemeHook",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requiredSettings",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may declare settings needed to use this type of security security schemas"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.DECLARATIONS"
									]
								},
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemaPart",
								"nameSpace": "",
								"basicName": "SecuritySchemaPart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.\n        This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"SecuritySchemaSettings"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Security schema type allows you to contribute your own security schema type with settings and optinal configurator for plugging into client sdks auth mechanism"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						},
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type"
							]
						}
					],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requestTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tokenCredentialsUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "signatures",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HMAC-SHA1",
											"RSA-SHA1",
											"PLAINTEXT"
										]
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 1.0'"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"description": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"annotations": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"authentificationConfigurator": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						]
					}
				},
				{
					"name": "OAuth2SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "accessTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2. Not required forby implicit grant type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1. Required forby authorization_code and implicit grant types."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"FixedUri"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationGrants",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"A list of the Authorization grants supported by the API as defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of:<br>* authorization_code<br>* password<br>* client_credentials<br>* implicit<br>* refresh_token."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "scopes",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of scopes supported by the security scheme as defined in RFC6749 [RFC6749] Section 3.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 2.0'"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"description": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"annotations": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						],
						"authentificationConfigurator": [
							{
								"name": "MetaModel.hide",
								"arguments": []
							}
						]
					}
				},
				{
					"name": "PassThroughSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameterName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headerName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='PassThrough'"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										""
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"OAuth 1.0",
											"OAuth 2.0",
											"Basic Authentication",
											"Digest Authentication",
											"Pass Through",
											"x-{other}"
										]
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string<br><br>The value MUST be one of<br>* OAuth 1.0,<br>* OAuth 2.0,<br>* Basic Authentication<br>* Digest Authentication<br>* Pass Through<br>* x-&lt;other&gt;"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute MAY be used to describe a security schemes property."
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description MAY be used to describe a securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemaPart",
								"nameSpace": "",
								"basicName": "SecuritySchemaPart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A description of the request components related to Security that are determined by the scheme: the headers, query parameters or responses. As a best practice, even for standard security schemes, API designers SHOULD describe these properties of security schemes.\nIncluding the security scheme description completes an API documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemaSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemaSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The settings attribute MAY be used to provide security scheme-specific information. The required attributes vary depending on the type of security scheme is being declared.\nIt describes the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the security scheme. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, and more."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Oath2",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 2.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth2SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth2SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Oath1",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "OAuth 1.0"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "OAuth1SecuritySchemeSettings",
								"nameSpace": "",
								"basicName": "OAuth1SecuritySchemeSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "PassThrough",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "PassThrough"
							},
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "PassThroughSettings",
								"nameSpace": "",
								"basicName": "PassThroughSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Basic",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Basic Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Digest",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "Digest Authentication"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Custom",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "x-{other}"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchema",
							"nameSpace": "",
							"basicName": "SecuritySchema",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MethodBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "responses",
							"type": {
								"base": {
									"typeName": "Bodies.Response",
									"nameSpace": "Bodies",
									"basicName": "Response",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"response",
										"true"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Response"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Information about the expected responses to a request"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose keys are the HTTP status codes of the responses and whose values describe the responses."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.\nResources CAN have alternate representations. For example, an API might support both JSON and XML representations.\nA method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Ensure that forms spec is consistent with it"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A method can override the protocols specified in the resource or at the API root, by employing this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array of strings of value HTTP or HTTPS, or a single string of such kind, case-insensitive"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Params.HasNormalParameters",
							"nameSpace": "Params",
							"basicName": "HasNormalParameters",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Trait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "api.Library",
									"nameSpace": "api",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may import library locally here it contents is accessible only inside of this trait"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries or a single library"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Method",
									"nameSpace": "",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that are part of this resource type definition"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"The methods available on this resource. See [[raml-10-spec-methods|the section on method properties]]."
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"get?<br>patch?<br>put?<br>post?<br>delete?<br>options?<br>head?"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object describing the method"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the traits to apply to all methods declared (implicitly or explicitly) for this resource. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section. Individual methods may override this declaration"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array, which can contain each of the following elements:<br>* name of unparametrized trait<br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration<br><br>(or a single element of any above kind)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The resource type which this resource inherits. . See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"one of the following elements:<br>* name of unparametrized resource type<br>* a key-value pair with resource type name as key and a map of its parameters as value<br>* inline resource type declaration"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The security schemes that apply to all methods declared (implicitly or explicitly) for this resource."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"array of security scheme names or a single security scheme name"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"models.ModelLocation.URI"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.valueRestriction",
									"arguments": [
										"_.find(<br>&nbsp;&nbsp;relativeUri.templateArguments(),<br>&nbsp;&nbsp;$value.name)",
										"Uri parameter names should match to template names in relative uri"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any URI parameters of this resource"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"object whose property names are the URI parameter names and whose values describe the values"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "api.Library",
									"nameSpace": "api",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may import library locally here it contents is accessible only inside of this resource type"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"decls",
										"true"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "ResourceBase",
							"nameSpace": "",
							"basicName": "ResourceBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceTypeOrTrait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when to use this resource type in a RAML spec"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uses",
							"type": {
								"base": {
									"typeName": "api.Library",
									"nameSpace": "api",
									"basicName": "Library",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"You may import library locally here it contents is accessible only inside of this trait"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of libraries"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parameters",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Optional declaration of the parameters that the resource type employs."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose property names are the parameter names and whose property values describe the parameter data types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Method",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "signature",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "method",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"methods"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"get",
											"put",
											"post",
											"delete",
											"options",
											"head",
											"patch"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Method that can be called"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the method (in the resource's context)."
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the method (in the resource's context)"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"queryString": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Specifies the query string needed by this method. Mutually exclusive with queryParameters."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Type name or type declaration"
								]
							}
						],
						"queryParameters": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Detailed information about any query parameters needed by this method. Mutually exclusive with queryString."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the query parameter names and whose values describe the values."
								]
							}
						],
						"headers": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Detailed information about any request headers needed by this method."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose property names are the request header names and whose values describe the values."
								]
							}
						],
						"body": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"Some methods admit request bodies, which are described by this property."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Object whose properties are either<br>1) media types and whose values are type objects describing the request body for that media type, or<br>2) a type object describing the request body for the default media type specified in the root mediaType property"
								]
							}
						],
						"is": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A list of the traits to apply to this method. See [[raml-10-spec-applying-resource-types-and-traits|Applying Resource Types and Traits]] section."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"array, which can contain each of the following elements:<br>* name of unparametrized trait<br>* a key-value pair with trait name as key and a map of trait parameters as value<br>* inline trait declaration<br><br>(or a single element of any above kind)"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this method. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						],
						"securedBy": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"The security schemes that apply to this method"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Array of security scheme names or a  single security scheme name"
								]
							}
						]
					}
				},
				{
					"name": "Resource",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "signature",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "relativeUri",
							"type": {
								"typeName": "Sys.RelativeUri",
								"nameSpace": "Sys",
								"basicName": "RelativeUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										"/"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Relative URL of this resource from the parent resource"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resource",
									"nameSpace": "",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A nested resource is identified as any property whose name begins with a slash (\"/\") and is therefore treated as a relative URI."
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"/&lt;relativeUri&gt;"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"object describing the nested resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ResourceBase",
							"nameSpace": "",
							"basicName": "ResourceBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the resource."
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the resource."
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this resource. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Params": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts",
				"Bodies": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts",
				"Declarations": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts",
				"models": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts",
				"auth": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\auth.ts",
				"api": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\api.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\methodsAndResources.ts"
		},
		{
			"classes": [
				{
					"name": "FileParameter",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "file"
							},
							"optional": false
						},
						{
							"name": "fileTypes",
							"type": {
								"base": {
									"typeName": "Sys.ContentType",
									"nameSpace": "Sys",
									"basicName": "ContentType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"It should also include a new property: fileTypes, which should be a list of valid content-type strings for the file. The file type */* should be a valid value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The minLength attribute specifies the parameter value's minimum number of bytes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The maxLength attribute specifies the parameter value's maximum number of bytes."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.thisFeatureCovers",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/94"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
							]
						}
					],
					"extends": [
						{
							"typeName": "datamodel.DataElement",
							"nameSpace": "datamodel",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "HasNormalParameters",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameters",
							"type": {
								"base": {
									"typeName": "datamodel.DataElement",
									"nameSpace": "datamodel",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/78"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.QUERY"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New query parameter"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "datamodel.DataElement",
									"nameSpace": "datamodel",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/59"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Headers that allowed at this position"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"It is not clear if this also allowed for resources(check)"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"cover wildcards ({*})"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "queryString",
							"type": {
								"typeName": "datamodel.DataElement",
								"nameSpace": "datamodel",
								"basicName": "DataElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts",
				"datamodel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\parameters.ts"
		},
		{
			"classes": [
				{
					"name": "RAMLLanguageElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The displayName attribute specifies the $self's display name. It is a friendly name used only for display or documentation purposes. If displayName is not specified, it defaults to the element's key (the name of the property itself)."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "annotations",
							"type": {
								"base": {
									"typeName": "Decls.AnnotationRef",
									"nameSpace": "Decls",
									"basicName": "AnnotationRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.version",
									"arguments": [
										"MetaModel.RAMLVersion.RAML10"
									]
								},
								{
									"name": "MetaModel.noDirectParse",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.ANNOTATION"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Most of RAML model elements may have attached annotations decribing additional meta data about this element"
									]
								},
								{
									"name": "MetaModel.documentationTableLabel",
									"arguments": [
										"(&lt;annotationName&gt;)"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"A value corresponding to the declared type of this annotation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLSimpleElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Decls": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts"
		},
		{
			"classes": [
				{
					"name": "AnnotationType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AnnotationType",
									"nameSpace": "",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of this annotation type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instructions on how and when to use this annotation in a RAML spec."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Markdown string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "parameters",
							"type": {
								"base": {
									"typeName": "datamodel.DataElement",
									"nameSpace": "datamodel",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"datamodel.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"datamodel.ModelLocation.ANNOTATION"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of parameters allowed in this annotation type"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose property names are the parameter names the annotation expects and whose values are their data types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "allowMultiple",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Whether multiple instances of annotations of this type may be applied simultaneously at the same location"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "allowedTargets",
							"type": {
								"base": {
									"typeName": "AnnotationTarget",
									"nameSpace": "",
									"basicName": "AnnotationTarget",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"API",
											"DocumentationItem",
											"Resource",
											"Method",
											"Response",
											"RequestBody",
											"ResponseBody",
											"DataElement",
											"NamedExample",
											"ResourceType",
											"Trait",
											"SecurityScheme",
											"SecuritySchemeSettings",
											"AnnotationType",
											"Library",
											"Overlay",
											"Extension"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Restrictions on where annotations of this type can be applied. If this property is specified, annotations of this type may only be applied on a property corresponding to one of the target names specified as the value of this property."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An array of names (or a single name) from the list of Target Names in the [[raml-10-spec-target-locations-table|Target Locations table]]  below. "
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"Annotation"
							]
						}
					],
					"extends": [
						{
							"typeName": "common.RAMLLanguageElement",
							"nameSpace": "common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the annotation"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the annotation"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						]
					}
				},
				{
					"name": "AnnotationRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Annotations allow you to attach information to your API"
							]
						},
						{
							"name": "MetaModel.tags",
							"arguments": [
								[
									"annotations"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "AnnotationType",
									"nameSpace": "",
									"basicName": "AnnotationType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AnnotationTarget",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Elements to which this Annotation can be applied (enum)"
							]
						},
						{
							"name": "MetaModel.tags",
							"arguments": [
								[
									"annotations"
								]
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.ValueType",
							"nameSpace": "Sys",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Annotation",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"datamodel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts",
				"common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
		},
		{
			"classes": [
				{
					"name": "ExampleSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "content",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The example itself"
									]
								},
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "strict",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"By default, examples are validated against any type declaration. Set this to false to allow examples that need not validate."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the example"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the example"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this example. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				},
				{
					"name": "DataElementProperty",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ModelLocation",
								"nameSpace": "",
								"basicName": "ModelLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "locationKind",
							"type": {
								"typeName": "LocationKind",
								"nameSpace": "",
								"basicName": "LocationKind",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Kind of location"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Provides default value for a property"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"any"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Sets if property is optional or not"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"required"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"boolean = true"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DataElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "xml",
							"type": {
								"typeName": "XMLInfo",
								"nameSpace": "",
								"basicName": "XMLInfo",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "facets",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"When extending from a type you can define new facets (which can then be set to concrete values by subtypes)."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schema",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Alias for the type property, for compatibility with RAML 0.8. Deprecated - may be removed in a future RAML version."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Single string denoting the base type or type expression"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.allowMultiple",
									"arguments": []
								},
								{
									"name": "MetaModel.canBeValue",
									"arguments": []
								},
								{
									"name": "MetaModel.defaultValue",
									"arguments": [
										"string"
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A base type which the current type extends, or more generally a type expression."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"string denoting the base type or type expression"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ModelLocation",
								"nameSpace": "",
								"basicName": "ModelLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "locationKind",
							"type": {
								"typeName": "LocationKind",
								"nameSpace": "",
								"basicName": "LocationKind",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Kind of location"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Provides default value for a property"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.selfNode",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An example of an instance of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"* Valid value for this type<br>* String representing the serialized version of a valid value"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "examples",
							"type": {
								"base": {
									"typeName": "ExampleSpec",
									"nameSpace": "",
									"basicName": "ExampleSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"An object containing named examples of instances of this type. This can be used, e.g., by documentation generators to generate sample values for an object of this type. Cannot be present if the examples property is present."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map example names to Example objects (see [[raml-10-spec-examples|Examples]] section); or an array of Example objects."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "repeat",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Sets if property is optional or not"
									]
								},
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"required"
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.canInherit",
							"arguments": [
								"mediaType"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the type"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the type"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this type. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				},
				{
					"name": "ScalarElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "facets",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.declaringFields",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"When extending from a scalar type you can define new facets (which can then be set to concrete values by subtypes)."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map facets names to their types."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Enumeration of possible values for this primitive type. Cannot be used with the file type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Array containing string representations of possible values, or a single string if there is only one possible value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLInfo",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "namespace",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "prefix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "attribute",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "wrapped",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ArrayField",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "array"
							},
							"optional": false
						},
						{
							"name": "uniqueItems",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"uniqueItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Should items in array be unique"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "items",
							"type": {
								"typeName": "DataElement",
								"nameSpace": "",
								"basicName": "DataElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Array component type."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Inline type declaration or type name."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minItems",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Minimum amount of items in array"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"integer ( >= 0 ). Defaults to 0"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxItems",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxItems"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Maximum amount of items in array"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"integer ( >= 0 ). Defaults to undefined."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.alias",
							"arguments": [
								"array"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UnionField",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "discriminator",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.selector",
									"arguments": [
										"*.DataElement"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Type property name to be used as a discriminator or boolean"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "union"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.MODELS"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DataElementRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ObjectField",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "properties",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The properties that instances of this type may or must have."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose keys are the properties' names and whose values are property declarations."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minProperties",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minProperties"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The minimum number of properties allowed for instances of this type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxProperties",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxProperties"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The maximum number of properties allowed for instances of this type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "additionalProperties",
							"type": {
								"typeName": "DataElement",
								"nameSpace": "",
								"basicName": "DataElement",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON schema style syntax for declaring maps"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"JSON schema style syntax for declaring maps. See [[raml-10-spec-map-types|Map Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Inline type declaration or typename"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "patternProperties",
							"type": {
								"base": {
									"typeName": "DataElement",
									"nameSpace": "",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON schema style syntax for declaring key restricted maps"
									]
								},
								{
									"name": "MetaModel.markdownDescription",
									"arguments": [
										"JSON schema style syntax for declaring key restricted maps. See [[raml-10-spec-map-types|Map Types]]."
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"An object whose properties map regular expressions (which are regarded as defining ranges for property names) to types of properties expressed as Inline type declaration or typename."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "discriminator",
							"type": {
								"typeName": "pointer",
								"nameSpace": "",
								"basicName": "pointer",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.selector",
									"arguments": [
										"*.DataElement"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Type property name to be used as discriminator, or boolean"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "discriminatorValue",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The value of discriminator for the type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "object"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.definingPropertyIsEnough",
							"arguments": [
								"properties"
							]
						},
						{
							"name": "MetaModel.setsContextValue",
							"arguments": [
								"field",
								"true"
							]
						},
						{
							"name": "MetaModel.convertsToGlobalOfType",
							"arguments": [
								"SchemaString"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StrElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "pattern",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"pattern"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Regular expression that this string should path"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"regexp"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minLength"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Minimum length of the string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maxLength"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Maximum length of the string"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "string"
							},
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a string"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "boolean"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ValueElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "value"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "number"
							},
							"optional": false
						},
						{
							"name": "minimum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"minimum"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maximum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.facetId",
									"arguments": [
										"maximum"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.describesAnnotation",
									"arguments": [
										"oneOf"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"int32",
											"int64",
											"int",
											"long",
											"float",
											"double",
											"int16",
											"int8"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Value format"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "multipleOf",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A numeric instance is valid against \"multipleOf\" if the result of the division of the instance by this keyword's value is an integer."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a number. Indicate floating point numbers as defined by YAML."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "integer"
							},
							"optional": false
						},
						{
							"name": "format",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"int32",
											"int64",
											"int",
											"long",
											"int16",
											"int8"
										]
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a integer."
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "NumberElement",
							"nameSpace": "",
							"basicName": "NumberElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLPointerElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "pointer"
							},
							"optional": false
						},
						{
							"name": "target",
							"type": {
								"typeName": "Sys.RAMLSelector",
								"nameSpace": "Sys",
								"basicName": "RAMLSelector",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "pointer",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.ValueType",
							"nameSpace": "Sys",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLExpression",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "ramlexpression"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ModelLocation.ANNOTATION"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ScriptHookElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "script"
							},
							"optional": false
						},
						{
							"name": "declaredIn",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Typescript file defining interface which this scrip should comply to"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "interfaceName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the interface which scripts should comply to"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						},
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ModelLocation.ANNOTATION"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "schema"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"locationKind",
								"LocationKind.APISTRUCTURE"
							]
						},
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"SchemaString"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "date"
							},
							"optional": false
						},
						{
							"name": "dateFormat",
							"type": {
								"typeName": "Sys.DateFormatSpec",
								"nameSpace": "Sys",
								"basicName": "DateFormatSpec",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. or according to specified date format"
							]
						},
						{
							"name": "MetaModel.declaresSubTypeOf",
							"arguments": [
								"DataElement"
							]
						}
					],
					"extends": [
						{
							"typeName": "DataElement",
							"nameSpace": "",
							"basicName": "DataElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "ModelLocation",
					"members": [
						"QUERY",
						"HEADERS",
						"URI",
						"FORM",
						"BURI",
						"ANNOTATION",
						"MODEL",
						"SECURITYSCHEMATYPE"
					]
				},
				{
					"name": "LocationKind",
					"members": [
						"APISTRUCTURE",
						"DECLARATIONS",
						"MODELS"
					]
				}
			],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"Bodies": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts",
				"Declarations": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\declarations.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts"
		},
		{
			"classes": [
				{
					"name": "MimeTypeModel",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tree",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "subtype",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "suffix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "parameters",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MimeType",
					"methods": [
						{
							"name": "isForm",
							"start": 401,
							"end": 626,
							"text": "\n    isForm(){\n        if (this.value()==\"application/x-www-form-urlencoded\"||this.value()=='multipart/form-data'){\n            return true;\n        }\n        //TODO USE PARSE\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isXML",
							"start": 626,
							"end": 797,
							"text": "\n\n    isXML(){\n        //TODO USE PARSE\n\n        if (this.value()==\"application/xml\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isJSON",
							"start": 797,
							"end": 970,
							"text": "\n\n    isJSON(){\n        //TODO USE PARSE\n\n        if (this.value()==\"application/json\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This sub type of the string represents mime types"
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.StringType",
							"nameSpace": "Sys",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Response",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "Sys.StatusCode",
								"nameSpace": "Sys",
								"basicName": "StatusCode",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"statusCodes"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
									]
								},
								{
									"name": "MetaModel.hide",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"models.ModelLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"locationKind",
										"models.LocationKind.APISTRUCTURE"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Detailed information about any response headers returned by this method"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose property names are the response header names and whose values describe the values."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "models.DataElement",
									"nameSpace": "models",
									"basicName": "DataElement",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The body of the response: a body declaration"
									]
								},
								{
									"name": "MetaModel.valueDescription",
									"arguments": [
										"Object whose properties are either<br>* Media types and whose values are type objects describing the request body for that media type, or<br>* a type object describing the request body for the default media type specified in the root mediaType property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {
						"displayName": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"An alternate, human-friendly name for the response"
								]
							}
						],
						"description": [
							{
								"name": "MetaModel.description",
								"arguments": [
									"A longer, human-friendly description of the response"
								]
							},
							{
								"name": "MetaModel.valueDescription",
								"arguments": [
									"Markdown string"
								]
							}
						],
						"annotations": [
							{
								"name": "MetaModel.markdownDescription",
								"arguments": [
									"Annotations to be applied to this response. Annotations are any property whose key begins with \"(\" and ends with \")\" and whose name (the part between the beginning and ending parentheses) is a declared annotation name. See the [[raml-10-spec-annotations|section on annotations]]."
								]
							}
						]
					}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts",
				"models": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\datamodel.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\common.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\bodies.ts"
		},
		{
			"classes": [
				{
					"name": "Status",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "StatusCode",
								"nameSpace": "",
								"basicName": "StatusCode",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\auth.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "message",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthentificationState",
					"methods": [
						{
							"name": "testAccessControl",
							"start": 435,
							"end": 564,
							"text": "\n\n    /**\n     * allows to test if method can be accessed\n     * @param req\n     */\n    testAccessControl(req:har.Request):Status"
						},
						{
							"name": "testAccessControl",
							"start": 564,
							"end": 622,
							"text": "\n\n\n    testAccessControl(method:RamlWrapper.Method):Status"
						},
						{
							"name": "status",
							"start": 622,
							"end": 644,
							"text": "\n\n    status():Status;"
						},
						{
							"name": "schemeId",
							"start": 644,
							"end": 667,
							"text": "\n\n    schemeId():string"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthentificationParameters",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthData",
					"methods": [
						{
							"name": "api",
							"start": 754,
							"end": 780,
							"text": "\n    api():RamlWrapper.Api"
						},
						{
							"name": "apiUrl",
							"start": 780,
							"end": 801,
							"text": "\n    apiUrl():string;"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "authentificationParameters",
							"type": {
								"typeName": "AuthentificationParameters",
								"nameSpace": "",
								"basicName": "AuthentificationParameters",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\auth.ts"
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ParameterSpec",
					"methods": [
						{
							"name": "name",
							"start": 887,
							"end": 905,
							"text": "\n    name():string"
						},
						{
							"name": "required",
							"start": 905,
							"end": 929,
							"text": "\n    required():boolean;"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "PromptSpec",
					"methods": [
						{
							"name": "name",
							"start": 1031,
							"end": 1049,
							"text": "\n    name():string"
						},
						{
							"name": "description",
							"start": 1049,
							"end": 1074,
							"text": "\n    description():string"
						},
						{
							"name": "toPrompt",
							"start": 1074,
							"end": 1106,
							"text": "\n    toPrompt():ParameterSpec[];"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UserResponse",
					"methods": [
						{
							"name": "isCancelled",
							"start": 1157,
							"end": 1183,
							"text": "\n    isCancelled():boolean"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "QueryListener",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "EndPoint",
					"methods": [
						{
							"name": "endpointUrl",
							"start": 1265,
							"end": 1290,
							"text": "\n    endpointUrl():string"
						},
						{
							"name": "addListener",
							"start": 1290,
							"end": 1331,
							"text": "\n    addListener(listener:QueryListener);"
						},
						{
							"name": "removeListener",
							"start": 1331,
							"end": 1374,
							"text": "\n    removeListener(listenr:QueryListener);"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "EndPointSpec",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "url",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "needToSendResponse",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecurityEnvironment",
					"methods": [
						{
							"name": "executeHTTPRequest",
							"start": 1481,
							"end": 1635,
							"text": "\n\n    /**\n     * execute authentification step to external service\n     * @param reg\n     */\n    executeHTTPRequest(reg:har.Request):Promise<har.Response>"
						},
						{
							"name": "askForExtraData",
							"start": 1635,
							"end": 1822,
							"text": "\n\n\n    /**\n     * asks for extra parameters( stored in cfg file or asked in dialog)\n     * @param parameterSpec\n     */\n    askForExtraData(parameterSpec:PromptSpec):Promise<UserResponse>"
						},
						{
							"name": "getOrCreateEndPoint",
							"start": 1822,
							"end": 1894,
							"text": "\n\n\n    // create\n    getOrCreateEndPoint(EndPointSpec):Promise<EndPoint>"
						},
						{
							"name": "hasEndpoints",
							"start": 1894,
							"end": 1923,
							"text": "\n\n    hasEndpoints():boolean;"
						},
						{
							"name": "isInteractive",
							"start": 1923,
							"end": 1952,
							"text": "\n    isInteractive():boolean;"
						},
						{
							"name": "isGraphical",
							"start": 1952,
							"end": 1978,
							"text": "\n    isGraphical():boolean"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "AuthentificationManager",
					"methods": [
						{
							"name": "supports",
							"start": 2016,
							"end": 2067,
							"text": "\n\n    supports(client:SecurityEnvironment):boolean;"
						},
						{
							"name": "doAuth",
							"start": 2067,
							"end": 2318,
							"text": "\n\n    /**\n     * performs authentification\n     * everything may happen here even sending horse rider to a new city\n     * or flight to moon\n     * @param env\n     */\n    doAuth(env:SecurityEnvironment,authData:AuthData):Promise<AuthentificationState>"
						},
						{
							"name": "doLogout",
							"start": 2318,
							"end": 2540,
							"text": "\n\n    /**\n     * performs log out\n     * if it is needed to blow a nuke to logout it is possible\n     * @param env\n     */\n    doLogout(env:SecurityEnvironment,authData:AuthentificationState):Promise<AuthentificationState>"
						},
						{
							"name": "addAuthDataToRequest",
							"start": 2540,
							"end": 2780,
							"text": "\n\n\n    /**\n     * performs arbitrary request transform (as a sample might change actual url)\n     * or do complex encoding\n     * @param req\n     */\n    addAuthDataToRequest(req:har.Request,state:AuthentificationState):Promise<har.Response>"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemeInfo",
					"methods": [
						{
							"name": "name",
							"start": 2838,
							"end": 2856,
							"text": "\n    name():string"
						},
						{
							"name": "description",
							"start": 2856,
							"end": 2881,
							"text": "\n    description():string"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "parameterSpec",
							"type": {
								"base": {
									"typeName": "ParameterSpec",
									"nameSpace": "",
									"basicName": "ParameterSpec",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\auth.ts"
								},
								"typeKind": 1
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecurityScheme",
					"methods": [
						{
							"name": "info",
							"start": 2909,
							"end": 2932,
							"text": "\n\n    info():SchemeInfo"
						},
						{
							"name": "id",
							"start": 2932,
							"end": 2948,
							"text": "\n    id():string"
						},
						{
							"name": "needsEndpoints",
							"start": 2948,
							"end": 2978,
							"text": "\n    needsEndpoints():boolean;"
						},
						{
							"name": "isInteractive",
							"start": 2978,
							"end": 3007,
							"text": "\n    isInteractive():boolean;"
						},
						{
							"name": "isGraphical",
							"start": 3007,
							"end": 3126,
							"text": "\n    /***\n     * means that you potentially need to have graphical display to pass it\n     */\n    isGraphical():boolean"
						},
						{
							"name": "createAuthManager",
							"start": 3126,
							"end": 3176,
							"text": "\n\n    createAuthManager():AuthentificationManager;"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecurityAwareApiClient",
					"methods": [
						{
							"name": "api",
							"start": 3213,
							"end": 3239,
							"text": "\n    api():RamlWrapper.Api"
						},
						{
							"name": "securitySchemes",
							"start": 3239,
							"end": 3279,
							"text": "\n\n    securitySchemes():SecurityScheme[]"
						},
						{
							"name": "getOrCreateAuthManager",
							"start": 3279,
							"end": 3349,
							"text": "\n\n    getOrCreateAuthManager(s:SecurityScheme):AuthentificationManager"
						},
						{
							"name": "doAuth",
							"start": 3349,
							"end": 3415,
							"text": "\n\n    doAuth(scheme:SecurityScheme):Promise<AuthentificationState>"
						},
						{
							"name": "doAuthSync",
							"start": 3415,
							"end": 3475,
							"text": "\n    doAuthSync(scheme:SecurityScheme):AuthentificationState"
						},
						{
							"name": "setCurrentAuthData",
							"start": 3475,
							"end": 3531,
							"text": "\n\n\n\n    setCurrentAuthData(state:AuthentificationState);"
						},
						{
							"name": "getCurrentAuthData",
							"start": 3531,
							"end": 3605,
							"text": "//needed for multiple users\n    getCurrentAuthData():AuthentificationState"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemeHook",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "StatusCode",
					"members": [
						"OK",
						"WARNING",
						"ERROR",
						"UNKNOWN",
						"CANCELLED"
					]
				}
			],
			"imports": {
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\systemTypes.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-1.0\\auth.ts"
		}
	];

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports = [
		{
			"classes": [
				{
					"name": "GlobalSchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Sys.SchemaString",
									"nameSpace": "Sys",
									"basicName": "SchemaString",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"fields": [
						{
							"name": "key",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the global schema, used to refer on schema content"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "value",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of the schema"
									]
								},
								{
									"name": "MetaModel.value",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"value"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Content of the schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				},
				{
					"name": "Api",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The title property is a short plain text description of the RESTful API. The title property's value SHOULD be suitable for use as a title for the contained user documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "version",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"If the RAML API definition is targeted to a specific API version, the API definition MUST contain a version property. The version property is OPTIONAL and should not be used if:\nThe API itself is not versioned.\nThe API definition does not change between versions. The API architect can decide whether a change to user documentation elements, but no change to the API's resources, constitutes a version change.\nThe API architect MAY use any versioning scheme so long as version numbers retain the same format. For example, \"v3\", \"v3.0\", and \"V3\" are all allowed, but are not considered to be equal."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUri",
							"type": {
								"typeName": "Sys.FullUriTemplate",
								"nameSpace": "Sys",
								"basicName": "FullUriTemplate",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional during development; Required after implementation) A RESTful API's resources are defined relative to the API's base URI. The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented. After the API is implemented (even a mock implementation) and can be accessed at a service endpoint, the API definition MUST contain a baseUri property. The baseUri property's value MUST conform to the URI specification [RFC2396] or a Level 1 Template URI as defined in RFC 6570 [RFC6570].\n            The baseUri property SHOULD only be used as a reference value. API client generators MAY make the baseUri configurable by the API client's users.\n            If the baseUri value is a Level 1 Template URI, the following reserved base URI parameters are available for replacement:"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/72"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/119"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Overrriding on resource level looks pretty strange"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Base uri parameters are named parameters which described template parameters in the base uri"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Specification is not good enough"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/150"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"URI parameters can be further defined by using the uriParameters property. The use of uriParameters is OPTIONAL. The uriParameters property MUST be a map in which each key MUST be the name of the URI parameter as defined in the baseUri property. The uriParameters CANNOT contain a key named version because it is a reserved URI parameter name. The value of the uriParameters property is itself a map that specifies  the property's attributes as named parameters"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Duplicate of base uri parameters"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/61"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Not clear how it should work in combination with baseUri"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Actually it is a set"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A RESTful API can be reached HTTP, HTTPS, or both. The protocols property MAY be used to specify the protocols that an API supports. If the protocols property is not specified, the protocol specified at the baseUri property is used. The protocols property MUST be an array of strings, of values `HTTP` and/or `HTTPS`."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "mediaType",
							"type": {
								"typeName": "Bodies.MimeType",
								"nameSpace": "Bodies",
								"basicName": "MimeType",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional) The media types returned by API responses, and expected from API requests that accept a body, MAY be defaulted by specifying the mediaType property. This property is specified at the root level of the API definition. The property's value MAY be a single string with a valid media type:\nOne of the following YAML media types:\ntext/yaml\ntext/x-yaml\napplication/yaml\napplication/x-yaml*\nAny type from the list of IANA MIME Media Types, http://www.iana.org/assignments/media-types\nA custom type that conforms to the regular expression, \"application/[A-Za-z.-0-1]*+?(json|xml)\"\nFor any combination of resource and operation in the API, if a media type is specified as a key of the body property for that resource and operation, or if a media type is specified in the mediaType property, the body MUST be in the specified media types. Moreover, if the client specifies an Accepts header containing multiple media types that are allowed by the specification for the requested resource and operation, the server SHOULD return a body using the media type in the Accepts header's mediaType list.\n"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"should be open enum"
									]
								},
								{
									"name": "MetaModel.inherited",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schemas",
							"type": {
								"base": {
									"typeName": "GlobalSchema",
									"nameSpace": "",
									"basicName": "GlobalSchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"To better achieve consistency and simplicity, the API definition SHOULD include an OPTIONAL schemas property in the root section. The schemas property specifies collections of schemas that could be used anywhere in the API definition. The value of the schemas property is an array of maps; in each map, the keys are the schema name, and the values are schema definitions. The schema definitions MAY be included inline or by using the RAML !include user-defined data type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "traits",
							"type": {
								"base": {
									"typeName": "RM.Trait",
									"nameSpace": "RM",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declarations of traits used in this API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchemaRef",
									"nameSpace": "RM",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Not stated clearly in spec"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the security schemas to apply to all methods, these must be defined in the securitySchemes declaration."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securitySchemes",
							"type": {
								"base": {
									"typeName": "RM.SecuritySchema",
									"nameSpace": "RM",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Security schemas that can be applied with securedBy"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resourceTypes",
							"type": {
								"base": {
									"typeName": "RM.ResourceType",
									"nameSpace": "RM",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.embeddedInMaps",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Declaration of resource types used in this API"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "RM.Resource",
									"nameSpace": "RM",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Resources are identified by their relative URI, which MUST begin with a slash (/).\nA resource defined as a root-level property is called a top-level resource. Its property's key is the resource's URI relative to the baseUri.\nA resource defined as a child property of another resource is called a nested resource, and its property's key is its URI relative to its parent resource's URI.\nEvery property whose key begins with a slash (/), and is either at the root of the API definition or is the child property of a resource property, is a resource property. The key of a resource, i.e. its relative URI, MAY consist of multiple URI path fragments separated by slashes; e.g. \"/bom/items\" may indicate the collection of items in a bill of materials as a single resource. However, if the individual URI path fragments are themselves resources, the API definition SHOULD use nested resources to describe this structure; e.g. if \"/bom\" is itself a resource then \"/items\" should be a nested resource of \"/bom\", while \"/bom/items\" should not be used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "documentation",
							"type": {
								"base": {
									"typeName": "DocumentationItem",
									"nameSpace": "",
									"basicName": "DocumentationItem",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The API definition can include a variety of documents that serve as a user guides and reference documentation for the API. Such documents can clarify how the API works or provide business context.\n            Documentation-generators MUST include all the sections in an API definition's documentation property in the documentation output, and they MUST preserve the order in which the documentation is declared.\n            To add user documentation to the API, include the documentation property at the root of the API definition. The documentation property MUST be an array of documents. Each document MUST contain title and content attributes, both of which are REQUIRED. If the documentation property is specified, it MUST include at least one document.\n            Documentation-generators MUST process the content field as if it was defined using Markdown [MARKDOWN].\n\n        This example shows an API definition with a single user document."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				},
				{
					"name": "DocumentationItem",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"title of documentation section"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "content",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Content of documentation section"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Needs better documentation, I would like to polish it in 1.0"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
						}
					],
					"moduleName": "RAMLSpec",
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"RM": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts",
				"Params": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\common.ts",
				"Bodies": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\api.ts"
		},
		{
			"classes": [
				{
					"name": "SpecPartMetaData",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "title",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "RAMLVersion",
					"members": [
						"RAML08",
						"RAML10"
					]
				}
			],
			"imports": {},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts"
		},
		{
			"classes": [
				{
					"name": "ValueType",
					"methods": [
						{
							"name": "parse",
							"start": 87,
							"end": 253,
							"text": "\n\n    /**\n     * parses inner structure of value type if value type has invalid value you should throw error\n     * with descriptive message\n     */\n    parse():any{}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StringType",
					"methods": [
						{
							"name": "value",
							"start": 339,
							"end": 367,
							"text": " value():string{return null}"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"string"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"number"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.nameAtRuntime",
							"arguments": [
								"boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Referencable",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Reference",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "ValueType",
							"nameSpace": "",
							"basicName": "ValueType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DeclaresDynamicType",
					"methods": [],
					"typeParameters": [
						"T"
					],
					"typeParameterConstraint": [
						null
					],
					"implements": [],
					"fields": [],
					"isInterface": true,
					"annotations": [],
					"extends": [
						{
							"typeName": "Referencable",
							"nameSpace": "",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "T",
									"nameSpace": "",
									"basicName": "T",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "UriTemplate",
					"methods": [
						{
							"name": "templateArguments",
							"start": 1159,
							"end": 1597,
							"text": "\n\n    templateArguments():string[]{\n        var pos=0;\n        var str=this.value();\n        var result=[];\n        while(true){\n            var start=str.indexOf(\"{\",pos)\n            if (start!=-1){\n                var end=str.indexOf(\"}\",start+1);\n                result.push(str.substring(start+1,end))\n                pos=end;\n            }\n            else{\n                break;\n            }\n        }\n        return result;\n    }"
						},
						{
							"name": "validate",
							"start": 1597,
							"end": 1697,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This type currently serves both for absolute and relative urls"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/115"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RelativeUri",
					"methods": [
						{
							"name": "parse",
							"start": 1822,
							"end": 2616,
							"text": "\n    parse():string[]{\n        //FIXME INHERITANCE\n        var value=this.value();\n        var result=[]\n        var temp=\"\";\n        var inPar=false;\n        var count=0;\n        for (var a=0;a<value.length;a++){\n            var c=value[a];\n            if (c=='{'){\n                count++;\n                inPar=true;\n                continue;\n            }\n            if (c=='}'){\n                count--;\n                inPar=false;\n                result.push(temp);\n                temp=\"\";\n                continue;\n            }\n            if (inPar){\n                temp+=c;\n            }\n        }\n        if (count>0){\n            throw new Error(\"Unmatched '{'\")\n        }\n        if (count<0){\n            throw new Error(\"Unmatched '}'\")\n        }\n        return result;\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes relative uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FullUriTemplate",
					"methods": [
						{
							"name": "parse",
							"start": 2745,
							"end": 3530,
							"text": "\n    parse():string[]{//FIXME INHERITANCE\n        var value=this.value();\n        var result=[]\n        var temp=\"\";\n        var inPar=false;\n        var count=0;\n        for (var a=0;a<value.length;a++){\n            var c=value[a];\n            if (c=='{'){\n                count++;\n                inPar=true;\n                continue;\n            }\n            if (c=='}'){\n                count--;\n                inPar=false;\n                result.push(temp);\n                temp=\"\";\n                continue;\n            }\n            if (inPar){\n                temp+=c;\n            }\n        }\n        if (count>0){\n            throw new Error(\"Unmatched '{'\")\n        }\n        if (count<0){\n            throw new Error(\"Unmatched '}'\")\n        }\n        return result;\n    }"
						},
						{
							"name": "validate",
							"start": 3530,
							"end": 3629,
							"text": "\n    validate(){\n        var str=this.value();\n        //write something to validate Url here\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes absolute uri templates"
							]
						}
					],
					"extends": [
						{
							"typeName": "UriTemplate",
							"nameSpace": "",
							"basicName": "UriTemplate",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FixedUri",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This  type describes fixed uris"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MarkdownString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"markdown"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/80"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Mardown string is a string which can contain markdown as an extension this markdown should support links with RAML Pointers since 1.0"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SchemaString",
					"methods": [
						{
							"name": "validate",
							"start": 4242,
							"end": 4425,
							"text": "\n\n    validate(){\n        var str=this.value();\n        //write something to validate schema here here\n        //in fact it should check that content is valid json or xsd schema\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Schema at this moment only two subtypes are supported (json schema and xsd)"
							]
						}
					],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSonSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType&&this.mediaType.isJSON()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"JSON schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLSchemaString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.innerType",
							"arguments": [
								"xml"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"XSD schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "SchemaString",
							"nameSpace": "",
							"basicName": "SchemaString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ExampleString",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StatusCode",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "StringType",
							"nameSpace": "",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSONExample",
					"methods": [
						{
							"name": "parse",
							"start": 4957,
							"end": 5359,
							"text": "\n\n    parse():any{\n        try {\n            JSON.parse(this.value());\n        } catch (e){\n            var ne=new Error(\"Warning: Can not parse JSON:\"+e.message);\n            throw ne\n        }\n        var a=this.$$.parent().attr('schema');\n        if (a) {\n          var sm=  a.findReferencedValue()\n          if (sm&&sm.validate){\n              sm.validate(this.value());\n          }\n        }\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType.isJSON()"
							]
						}
					],
					"extends": [
						{
							"typeName": "ExampleString",
							"nameSpace": "",
							"basicName": "ExampleString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLExample",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mediaType.isXML()"
							]
						}
					],
					"extends": [
						{
							"typeName": "ExampleString",
							"nameSpace": "",
							"basicName": "ExampleString",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
		},
		{
			"classes": [
				{
					"name": "ResourceTypeRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "TraitRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaPart",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLSimpleElement",
							"nameSpace": "Common",
							"basicName": "RAMLSimpleElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth1SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "requestTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tokenCredentialsUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Request endpoint as defined in RFC5849 Section 2.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 1.0'"
							]
						},
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "OAuth2SecuritySchemeSettings",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "accessTokenUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationUri",
							"type": {
								"typeName": "Sys.FixedUri",
								"nameSpace": "Sys",
								"basicName": "FixedUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "authorizationGrants",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the Authorization grants supported by the API As defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of: code, token, owner or credentials."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "scopes",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of scopes supported by the API as defined in RFC6749 [RFC6749] Section 3.3"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"$parent.type=='OAuth 2.0'"
							]
						},
						{
							"name": "MetaModel.allowAny",
							"arguments": []
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Specification is actually very vague here"
							]
						}
					],
					"extends": [
						{
							"typeName": "SecuritySchemaSettings",
							"nameSpace": "",
							"basicName": "SecuritySchemaSettings",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchemaRef",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Sys.Reference",
							"nameSpace": "Sys",
							"basicName": "Reference",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "SecuritySchema",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.Referencable",
							"nameSpace": "Sys",
							"basicName": "Referencable",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "SecuritySchema",
									"nameSpace": "",
									"basicName": "SecuritySchema",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.required",
									"arguments": []
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"OAuth 1.0",
											"OAuth 2.0",
											"Basic Authentication",
											"Digest Authentication",
											"x-{other}"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The securitySchemes property MUST be used to specify an API's security mechanisms, including the required settings and the authentication methods that the API supports. one authentication method is allowed if the API supports them."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute MAY be used to describe a securitySchemes property."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "describedBy",
							"type": {
								"typeName": "SecuritySchemaPart",
								"nameSpace": "",
								"basicName": "SecuritySchemaPart",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The describedBy attribute MAY be used to apply a trait-like structure to a security scheme mechanism so as to extend the mechanism, such as specifying response codes, HTTP headers or custom documentation.\n        This extension allows API designers to describe security schemes. As a best practice, even for standard security schemes, API designers SHOULD describe the security schemes' required artifacts, such as headers, URI parameters, and so on. Including the security schemes' description completes an API's documentation."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "settings",
							"type": {
								"typeName": "SecuritySchemaSettings",
								"nameSpace": "",
								"basicName": "SecuritySchemaSettings",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The settings attribute MAY be used to provide security schema-specific information. Depending on the value of the type parameter, its attributes can vary.\n        The following lists describe the minimum set of properties which any processing application MUST provide and validate if it chooses to implement the Security Scheme type. Processing applications MAY choose to recognize other properties for things such as token lifetime, preferred cryptographic algorithms, an so on."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Declares globally referenceable security schema definition"
							]
						},
						{
							"name": "MetaModel.actuallyExports",
							"arguments": [
								"$self"
							]
						},
						{
							"name": "MetaModel.referenceIs",
							"arguments": [
								"settings"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MethodBase",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "responses",
							"type": {
								"base": {
									"typeName": "Bodies.Response",
									"nameSpace": "Bodies",
									"basicName": "Response",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Response"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Resource methods MAY have one or more responses. Responses MAY be described using the description property, and MAY include example attributes or schema properties.\n"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "Bodies.BodyLike",
									"nameSpace": "Bodies",
									"basicName": "BodyLike",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Some method verbs expect the resource to be sent as a request body. For example, to create a resource, the request must include the details of the resource to create.\nResources CAN have alternate representations. For example, an API might support both JSON and XML representations.\nA method's body is defined in the body property as a hashmap, in which the key MUST be a valid media type."
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Ensure that forms spec is consistent with it"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A list of the security schemas to apply, these must be defined in the securitySchemes declaration.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme.\nSecurity schemas may also be applied to a resource with securedBy, which is equivalent to applying the security schemas to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Params.HasNormalParameters",
							"nameSpace": "Params",
							"basicName": "HasNormalParameters",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Trait",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "Trait",
									"nameSpace": "",
									"basicName": "Trait",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the trait"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "ResourceType",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [
						{
							"typeName": "Sys.DeclaresDynamicType",
							"nameSpace": "Sys",
							"basicName": "DeclaresDynamicType",
							"typeKind": 0,
							"typeArguments": [
								{
									"typeName": "ResourceType",
									"nameSpace": "",
									"basicName": "ResourceType",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								}
							],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Name of the resource type"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "usage",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Method",
									"nameSpace": "",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that are part of this resource type definition"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"definition system did not represents that ? is allowed after method names here"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed resource type"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/71"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.URI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Uri parameters of this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.inlinedTemplates",
							"arguments": []
						},
						{
							"name": "MetaModel.allowQuestion",
							"arguments": []
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Method",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "method",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"methods"
									]
								},
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"get",
											"put",
											"post",
											"delete",
											"patch",
											"options",
											"head"
										]
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Method that can be called"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/95"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "protocols",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.oneOf",
									"arguments": [
										[
											"HTTP",
											"HTTPS"
										]
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"Not clear how it should work in combination with baseUri also is it also related to resources and types/traits"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Actually it is a set"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A method can override an API's protocols value for that single method by setting a different value for the fields."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Method object allows description of http methods"
							]
						}
					],
					"extends": [
						{
							"typeName": "MethodBase",
							"nameSpace": "",
							"basicName": "MethodBase",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Resource",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "relativeUri",
							"type": {
								"typeName": "Sys.RelativeUri",
								"nameSpace": "Sys",
								"basicName": "RelativeUri",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/73"
									]
								},
								{
									"name": "MetaModel.startFrom",
									"arguments": [
										"/"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Relative URL of this resource from the parent resource"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/87"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "ResourceTypeRef",
								"nameSpace": "",
								"basicName": "ResourceTypeRef",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed resource type"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "is",
							"type": {
								"base": {
									"typeName": "TraitRef",
									"nameSpace": "",
									"basicName": "TraitRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Instantiation of applyed traits"
									]
								},
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/98"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "securedBy",
							"type": {
								"base": {
									"typeName": "SecuritySchemaRef",
									"nameSpace": "",
									"basicName": "SecuritySchemaRef",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.allowNull",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										" securityScheme may also be applied to a resource by using the securedBy key, which is equivalent to applying the securityScheme to all methods that may be declared, explicitly or implicitly, by defining the resourceTypes or traits property for that resource.\nTo indicate that the method may be called without applying any securityScheme, the method may be annotated with the null securityScheme."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "uriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/71"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.URI"
									]
								},
								{
									"name": "MetaModel.valueRestriction",
									"arguments": [
										"_.find(relativeUri.parse(),$value.name)",
										"Uri parameter names should match to template names in relative uri"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Uri parameters of this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "methods",
							"type": {
								"base": {
									"typeName": "Method",
									"nameSpace": "",
									"basicName": "Method",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Method"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Methods that can be called on this resource"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "resources",
							"type": {
								"base": {
									"typeName": "Resource",
									"nameSpace": "",
									"basicName": "Resource",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Resource"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Children resources"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "baseUriParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"fieldOrParam",
										true
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.BURI"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"A resource or a method can override a base URI template's values. This is useful to restrict or change the default or parameter selection in the base URI. The baseUriParameters property MAY be used to override any or all parameters defined at the root level baseUriParameters property, as well as base URI parameters not specified at the root level."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"This feature is not consistent (causes not solvable overloading)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Params": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts",
				"Bodies": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\common.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\methodsAndResources.ts"
		},
		{
			"classes": [
				{
					"name": "Parameter",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"name of the parameter"
									]
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"headers"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.defaultValue",
									"arguments": [
										"string"
									]
								},
								{
									"name": "MetaModel.descriminatingProperty",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"The type attribute specifies the primitive type of the parameter's resolved value. API clients MUST return/throw an error if the parameter's resolved value does not match the specified type. If type is not specified, it defaults to string."
									]
								},
								{
									"name": "MetaModel.canBeDuplicator",
									"arguments": []
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "location",
							"type": {
								"typeName": "ParameterLocation",
								"nameSpace": "",
								"basicName": "ParameterLocation",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.system",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Location of the parameter (can not be edited by user)"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "required",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"Set to true if parameter is required"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "default",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The default attribute specifies the default value to use for the property if the property is omitted or its value is not specified. This SHOULD NOT be interpreted as a requirement for the client to send the default attribute's value if there is no other value to send. Instead, the default attribute's value is the value the server uses if the client does not send a value."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/86"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional) The example attribute shows an example value for the property. This can be used, e.g., by documentation generators to generate sample values for the property."
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"It sounds consistent to allow multiple examples for parameters, but it will make hard to describe difference between 0.8 and 1.0 in terms of def system"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "repeat",
							"type": {
								"typeName": "boolean",
								"nameSpace": "",
								"basicName": "boolean",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The repeat attribute specifies that the parameter can be repeated. If the parameter can be used multiple times, the repeat parameter value MUST be set to 'true'. Otherwise, the default value is 'false' and the parameter may not be repeated."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"semantic of repeat is not clearly specified and actually multiple possible reasonable options exists at the same time "
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/152"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.issue",
							"arguments": [
								"Multiple  parameter types are not supported in this specification we should think about how to cover them properly using same key and redefining parameter looks pretty reasonable for 1.0"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "StrElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "pattern",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.thisFeatureCovers",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/97"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The pattern attribute is a regular expression that a parameter of type string MUST match. Regular expressions MUST follow the regular expression specification from ECMA 262/Perl 5. The pattern MAY be enclosed in double quotes for readability and clarity."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "enum",
							"type": {
								"base": {
									"typeName": "string",
									"nameSpace": "",
									"basicName": "string",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": null
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/82"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The enum attribute provides an enumeration of the parameter's valid values. This MUST be an array. If the enum attribute is defined, API clients and servers MUST verify that a parameter's value matches a value in the enum array. If there is no matching value, the clients and servers MUST treat this as an error."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "minLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/93"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/141"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The minLength attribute specifies the parameter value's minimum number of characters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maxLength",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type string) The maxLength attribute specifies the parameter value's maximum number of characters."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "string"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a string"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BooleanElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "boolean"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value must be a boolean"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "NumberElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "number"
							},
							"optional": false
						},
						{
							"name": "minimum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The minimum attribute specifies the parameter's minimum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "maximum",
							"type": {
								"typeName": "number",
								"nameSpace": "",
								"basicName": "number",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"(Optional, applicable only for parameters of type number or integer) The maximum attribute specifies the parameter's maximum value."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a number. Indicate floating point numbers as defined by YAML."
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "IntegerElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "integer"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a integer."
							]
						}
					],
					"extends": [
						{
							"typeName": "NumberElement",
							"nameSpace": "",
							"basicName": "NumberElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "DateElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "date"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"Value MUST be a string representation of a date as defined in RFC2616 Section 3.3 [RFC2616]. "
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/105"
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "FileElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": null,
							"annotations": [],
							"valueConstraint": {
								"isCallConstraint": false,
								"value": "file"
							},
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.requireValue",
							"arguments": [
								"location",
								"ParameterLocation.FORM"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/94"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"(Applicable only to Form properties) Value is a file. Client generators SHOULD use this type to handle file uploads correctly."
							]
						}
					],
					"extends": [
						{
							"typeName": "Parameter",
							"nameSpace": "",
							"basicName": "Parameter",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "HasNormalParameters",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "queryParameters",
							"type": {
								"base": {
									"typeName": "Parameter",
									"nameSpace": "",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/53"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/78"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/46"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"ParameterLocation.QUERY"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New query parameter"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An APIs resources MAY be filtered (to return a subset of results) or altered (such as transforming a response body from JSON to XML format) by the use of query strings. If the resource or its method supports a query string, the query string MUST be defined by the queryParameters property"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "displayName",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"I am not sure that it should be here but it is actually used"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "Parameter",
									"nameSpace": "",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/59"
									]
								},
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"ParameterLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Headers that allowed at this position"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"It is not clear if this also allowed for resources(check)"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"cover wildcards ({*})"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [
				{
					"name": "ParameterLocation",
					"members": [
						"QUERY",
						"HEADERS",
						"URI",
						"FORM",
						"BURI"
					]
				}
			],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\common.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts"
		},
		{
			"classes": [
				{
					"name": "RAMLLanguageElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "description",
							"type": {
								"typeName": "Sys.MarkdownString",
								"nameSpace": "Sys",
								"basicName": "MarkdownString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\common.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"The description attribute describes the intended use or meaning of the $self. This value MAY be formatted using Markdown [MARKDOWN]"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "RAMLSimpleElement",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\common.ts"
		},
		{
			"classes": [
				{
					"name": "MimeTypeModel",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "type",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "tree",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "subtype",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "suffix",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						},
						{
							"name": "parameters",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [],
							"valueConstraint": null,
							"optional": true
						}
					],
					"isInterface": true,
					"annotations": [],
					"extends": [],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "MimeType",
					"methods": [
						{
							"name": "isForm",
							"start": 448,
							"end": 649,
							"text": "\n    isForm(){\n        if (this.value()==\"application/x-www-form-urlencoded\"||this.value()=='multipart/form-data'){\n            return true;\n        }\n\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isXML",
							"start": 649,
							"end": 794,
							"text": "\n\n    isXML(){\n        if (this.value()==\"application/xml\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						},
						{
							"name": "isJSON",
							"start": 794,
							"end": 941,
							"text": "\n\n    isJSON(){\n        if (this.value()==\"application/json\"){\n            return true;\n        }\n        return false;//more smart code here\n    }"
						},
						{
							"name": "parse",
							"start": 1024,
							"end": 1566,
							"text": "\n    parse(){\n        /**\n         * top-level type name / subtype name [ ; parameters ]\n         *\n         * top-level type name / [ tree. ] subtype name [ +suffix ] [ ; parameters ]\n         */\n        var v=this.value();\n        if (v==\"*/*\"){\n            return\n        }\n        var res= mediaTypeParser.parse(v);\n        var types={application:1, audio:1, example:1, image:1, message:1, model:1, multipart:1, text:1, video:1}\n        if (!types[res.type]){\n            throw new Error(\"Unknown media type 'type' value\")\n        }\n    }"
						}
					],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.description",
							"arguments": [
								"This sub type of the string represents mime types"
							]
						}
					],
					"extends": [
						{
							"typeName": "Sys.StringType",
							"nameSpace": "Sys",
							"basicName": "StringType",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "BodyLike",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "name",
							"type": {
								"typeName": "string",
								"nameSpace": "",
								"basicName": "string",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": null
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Mime type of the request or response body"
									]
								},
								{
									"name": "MetaModel.canInherit",
									"arguments": [
										"mediaType"
									]
								},
								{
									"name": "MetaModel.oftenKeys",
									"arguments": [
										[
											"application/json",
											"application/xml",
											"application/x-www-form-urlencoded",
											"multipart/formdata"
										]
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.SchemaString",
								"nameSpace": "Sys",
								"basicName": "SchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/8"
									]
								},
								{
									"name": "MetaModel.requireValue",
									"arguments": [
										"this.name.isForm()",
										"false"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"\n    The structure of a request or response body MAY be further specified by the schema property under the appropriate media type.\n\nThe schema key CANNOT be specified if a body's media type is application/x-www-form-urlencoded or multipart/form-data.\n\nAll parsers of RAML MUST be able to interpret JSON Schema [JSON_SCHEMA] and XML Schema [XML_SCHEMA].\n\nSchema MAY be declared inline or in an external file. However, if the schema is sufficiently large so as to make it difficult for a person to read the API definition, or the schema is reused across multiple APIs or across multiple miles in the same API, the !include user-defined data type SHOULD be used instead of including the content inline.\nAlternatively, the value of the schema field MAY be the name of a schema specified in the root-level schemas property (see Named Parameters, or it MAY be declared in an external file and included by using the by using the RAML !include user-defined data type."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "example",
							"type": {
								"typeName": "Sys.ExampleString",
								"nameSpace": "Sys",
								"basicName": "ExampleString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/75"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/70"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/24"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Documentation generators MUST use body properties' example attributes to generate example invocations.\n\nThis example shows example attributes for two body property media types."
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/107"
									]
								},
								{
									"name": "MetaModel.needsClarification",
									"arguments": [
										"Multiple examples"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"https://github.com/raml-org/raml-spec/issues/113"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "formParameters",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.FORM"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Web forms REQUIRE special encoding and custom declaration.\nIf the API's media type is either application/x-www-form-urlencoded or multipart/form-data, the formParameters property MUST specify the name-value pairs that the API is expecting.\nThe formParameters property is a map in which the key is the name of the web form parameter, and the value is itself a map the specifies the web form parameter's attributes"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.canInherit",
							"arguments": [
								"mediaType"
							]
						}
					],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "XMLBody",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.XMLSchemaString",
								"nameSpace": "Sys",
								"basicName": "XMLSchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"XSD Schema"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mime.isXML()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Needed to set connection between xml related mime types and xsd schema"
							]
						}
					],
					"extends": [
						{
							"typeName": "BodyLike",
							"nameSpace": "",
							"basicName": "BodyLike",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "JSONBody",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "schema",
							"type": {
								"typeName": "Sys.JSonSchemaString",
								"nameSpace": "Sys",
								"basicName": "JSonSchemaString",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.description",
									"arguments": [
										"JSON Schema"
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [
						{
							"name": "MetaModel.functionalDescriminator",
							"arguments": [
								"this.mime.isJSON()"
							]
						},
						{
							"name": "MetaModel.description",
							"arguments": [
								"Needed to set connection between json related mime types and json schema"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/160"
							]
						},
						{
							"name": "MetaModel.issue",
							"arguments": [
								"https://github.com/raml-org/raml-spec/issues/81"
							]
						}
					],
					"extends": [
						{
							"typeName": "BodyLike",
							"nameSpace": "",
							"basicName": "BodyLike",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				},
				{
					"name": "Response",
					"methods": [],
					"typeParameters": [],
					"typeParameterConstraint": [],
					"implements": [],
					"fields": [
						{
							"name": "code",
							"type": {
								"typeName": "Sys.StatusCode",
								"nameSpace": "Sys",
								"basicName": "StatusCode",
								"typeKind": 0,
								"typeArguments": [],
								"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
							},
							"annotations": [
								{
									"name": "MetaModel.key",
									"arguments": []
								},
								{
									"name": "MetaModel.extraMetaKey",
									"arguments": [
										"statusCodes"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Responses MUST be a map of one or more HTTP status codes, where each status code itself is a map that describes that status code."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "headers",
							"type": {
								"base": {
									"typeName": "Params.Parameter",
									"nameSpace": "Params",
									"basicName": "Parameter",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.setsContextValue",
									"arguments": [
										"location",
										"Params.ParameterLocation.HEADERS"
									]
								},
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Header"
									]
								},
								{
									"name": "MetaModel.issue",
									"arguments": [
										"it seems to use different wildcard then in methods and resources"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"An API's methods may support custom header values in responses. The custom, non-standard HTTP headers MUST be specified by the headers property.\n        API's may include the the placeholder token {?} in a header name to indicate that any number of headers that conform to the specified format can be sent in responses. This is particularly useful for APIs that allow HTTP headers that conform to some naming convention to send arbitrary, custom data.\n\nIn the following example, the header x-metadata-{?} is used to send metadata that has been saved with the media."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						},
						{
							"name": "body",
							"type": {
								"base": {
									"typeName": "BodyLike",
									"nameSpace": "",
									"basicName": "BodyLike",
									"typeKind": 0,
									"typeArguments": [],
									"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
								},
								"typeKind": 1
							},
							"annotations": [
								{
									"name": "MetaModel.newInstanceName",
									"arguments": [
										"New Body"
									]
								},
								{
									"name": "MetaModel.description",
									"arguments": [
										"Each response MAY contain a body property, which conforms to the same structure as request body properties (see Body). Responses that can return more than one response code MAY therefore have multiple bodies defined.\nFor APIs without a priori knowledge of the response types for their responses, \"*/*\" MAY be used to indicate that responses that do not matching other defined data types MUST be accepted. Processing applications MUST match the most descriptive media type first if \"*/*\" is used."
									]
								}
							],
							"valueConstraint": null,
							"optional": false
						}
					],
					"isInterface": false,
					"annotations": [],
					"extends": [
						{
							"typeName": "Common.RAMLLanguageElement",
							"nameSpace": "Common",
							"basicName": "RAMLLanguageElement",
							"typeKind": 0,
							"typeArguments": [],
							"modulePath": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
						}
					],
					"moduleName": null,
					"annotationOverridings": {}
				}
			],
			"aliases": [],
			"enumDeclarations": [],
			"imports": {
				"MetaModel": "c:\\GIT-repos\\api-workbench\\src\\raml1\\definition-system\\metamodel.ts",
				"Sys": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\systemTypes.ts",
				"Params": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\parameters.ts",
				"Common": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\common.ts"
			},
			"name": "c:\\GIT-repos\\api-workbench\\src\\raml1\\spec-0.8\\bodies.ts"
		}
	];

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var RamlWrapper = __webpack_require__(84);
	var hl = __webpack_require__(2);
	var hlimpl = __webpack_require__(5);
	var expander = __webpack_require__(87);
	var lowLevelProxy = __webpack_require__(59);
	var Opt = __webpack_require__(55);
	var util = __webpack_require__(54);
	var search = __webpack_require__(65);
	var ll = __webpack_require__(6);
	var path = __webpack_require__(9);
	//export function resolveType(p:RamlWrapper.DataElement):hl.ITypeDefinition{
	//    var tpe=typeexpression.typeFromNode(p.highLevel());
	//    return tpe.toRuntime();
	//}
	function load(pth) {
	    var m = new ll.Project(path.dirname(pth));
	    var unit = m.unit(path.basename(pth));
	    if (unit) {
	        if (unit.isRAMLUnit()) {
	            return hl.fromUnit(unit).wrapperNode();
	        }
	    }
	    return null;
	}
	exports.load = load;
	//__$helperMethod__ Equivalent API with traits and resource types expanded
	function expandTraitsAndResourceTypes(api) {
	    var lowLevelNode = api.highLevel().lowLevel();
	    if (lowLevelNode instanceof lowLevelProxy.LowLevelProxyNode) {
	        return api;
	    }
	    return expander.expandTraitsAndResourceTypes(api);
	}
	exports.expandTraitsAndResourceTypes = expandTraitsAndResourceTypes;
	//__$helperMethod__ Path relative to API root
	function completeRelativeUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    return uri;
	}
	exports.completeRelativeUri = completeRelativeUri;
	//__$helperMethod__ baseUri of owning Api concatenated with completeRelativeUri
	function absoluteUri(res) {
	    var uri = '';
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        uri = res.relativeUri().value() + uri;
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    uri = uri.replace(/\/\//g, '/');
	    var buri = parent.baseUri();
	    var base = buri ? buri.value() : "";
	    base = base ? base : '';
	    if (util.stringEndsWith(base, '/')) {
	        uri = uri.substring(1);
	    }
	    uri = base + uri;
	    return uri;
	}
	exports.absoluteUri = absoluteUri;
	function qName(c) {
	    return hlimpl.qName(c.highLevel(), c.highLevel().root());
	}
	exports.qName = qName;
	//__$helperMethod__ Retrieve all traits including those defined in libraries
	function allTraits(a) {
	    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().nameId() == "Trait"; }).map(function (x) { return x.wrapperNode(); });
	}
	exports.allTraits = allTraits;
	//__$helperMethod__ Retrieve all resource types including those defined in libraries
	function allResourceTypes(a) {
	    return search.globalDeclarations(a.highLevel()).filter(function (x) { return x.definition().nameId() == "ResourceType"; }).map(function (x) { return x.wrapperNode(); });
	}
	exports.allResourceTypes = allResourceTypes;
	function relativeUriSegments(res) {
	    var result = [];
	    var parent = res;
	    do {
	        res = parent; //(parent instanceof RamlWrapper.ResourceImpl) ? <RamlWrapper.Resource>parent : null;
	        result.push(res.relativeUri().value());
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    return result.reverse();
	}
	exports.relativeUriSegments = relativeUriSegments;
	//__$helperMethod__ For methods of Resources returns parent resource. For methods of ResourceTypes returns undefined Opt.
	function parentResource(method) {
	    if (method.parent() instanceof RamlWrapper.ResourceImpl) {
	        return new Opt(method.parent());
	    }
	    return Opt.empty();
	}
	exports.parentResource = parentResource;
	//__$helperMethod__ Parent resource for non top level resources __$meta__={"name":"parentResource"}
	function parent(resource) {
	    var parent = resource.parent();
	    if (isApi(parent)) {
	        return Opt.empty();
	    }
	    return new Opt(parent);
	}
	exports.parent = parent;
	//__$helperMethod__ Get child resource by its relative path
	function getChildResource(container, relPath) {
	    if (container == null) {
	        return Opt.empty();
	    }
	    var resources = container.resources();
	    if (!resources) {
	        return Opt.empty();
	    }
	    resources = resources.filter(function (x) { return x.relativeUri().value() == relPath; });
	    if (resources.length == 0) {
	        return Opt.empty();
	    }
	    return new Opt(resources[0]);
	}
	exports.getChildResource = getChildResource;
	function getResource(container, path) {
	    if (!container) {
	        return null;
	    }
	    var opt = Opt.empty();
	    for (var i = 0; i < path.length; i++) {
	        opt = getChildResource(container, path[i]);
	        if (!opt.isDefined()) {
	            return opt;
	        }
	        container = opt.getOrThrow();
	    }
	    return opt;
	}
	exports.getResource = getResource;
	//__$helperMethod__ Get child method by its name
	function getChildMethod(resource, method) {
	    if (!resource) {
	        return null;
	    }
	    return resource.methods().filter(function (x) { return x.method() == method; });
	}
	exports.getChildMethod = getChildMethod;
	function getMethod(container, path, method) {
	    var resource = getResource(container, path);
	    return getChildMethod(resource.getOrElse(null), method);
	}
	exports.getMethod = getMethod;
	function isApi(obj) {
	    return (obj['title'] && obj['version'] && obj['baseUri']);
	}
	;
	//__$helperMethod__ Api owning the resource as a sibling
	function ownerApi(method) {
	    var obj = method;
	    while (!isApi(obj)) {
	        obj = obj.parent();
	    }
	    return obj;
	}
	exports.ownerApi = ownerApi;
	//__$helperMethod__
	// For methods of Resources: `{parent Resource relative path} {methodName}`.
	// For methods of ResourceTypes: `{parent ResourceType name} {methodName}`.
	// For other methods throws Exception.
	function methodId(method) {
	    var parent = method.parent();
	    if (parent instanceof RamlWrapper.ResourceImpl) {
	        return completeRelativeUri(parent) + ' ' + method.method().toLowerCase();
	    }
	    else if (parent instanceof RamlWrapper.ResourceTypeImpl) {
	        return parent.name() + ' ' + method.method().toLowerCase();
	    }
	    throw new Error("Method is supposed to be owned by Resource or ResourceType");
	}
	exports.methodId = methodId;
	//__$helperMethod__ true for codes < 400 and false otherwise
	function isOkRange(response) {
	    return parseInt(response.code().value()) < 400;
	}
	exports.isOkRange = isOkRange;
	//__$helperMethod__  Retrieve all resources ofthe Api
	function allResources(api) {
	    var resources = [];
	    var visitor = function (res) {
	        resources.push(res);
	        res.resources().forEach(function (x) { return visitor(x); });
	    };
	    api.resources().forEach(function (x) { return visitor(x); });
	    return resources;
	}
	exports.allResources = allResources;
	//export function matchUri(apiRootRelativeUri:string, resource:RamlWrapper.Resource):Opt<ParamValue[]>{
	//
	//    var allParameters:Raml08Parser.NamedParameterMap = {}
	//    var opt:Opt<RamlWrapper.Resource> = new Opt<RamlWrapper.Resource>(resource);
	//    while(opt.isDefined()){
	//        var res:RamlWrapper.Resource = opt.getOrThrow();
	//        uriParameters(res).forEach(x=>allParameters[x.name()]=new ParamWrapper(x));
	//        opt = parent(res);
	//    }
	//    var result = ramlPathMatch(completeRelativeUri(resource), allParameters, {})(apiRootRelativeUri);
	//    if (result) {
	//        return new Opt<ParamValue[]>(Object.keys((<any>result).params)
	//            .map(x=>new ParamValue(x, result['params'][x])));
	//    }
	//    return Opt.empty<ParamValue[]>();
	//}
	var schemaContentChars = ['{', '<'];
	//export function schema(body:RamlWrapper.DataElement, api:RamlWrapper.Api):Opt<SchemaDef>{
	//
	//    var schemaNode = body.schema();
	//    if(!schemaNode){
	//        return Opt.empty<SchemaDef>();
	//    }
	//    var schemaString = schemaNode;
	//    var isContent:boolean = false;
	//    schemaContentChars.forEach(x=>{try{ isContent = isContent||schemaString.indexOf(x)>=0}catch(e){}});
	//    var schDef:SchemaDef;
	//    if(isContent) {
	//        schDef = new SchemaDef(schemaString);
	//    }
	//    else{
	//        var globalSchemes = api.schemas().filter(x=>x.key()==schemaString);
	//        if(globalSchemes.length>0){
	//            schDef = new SchemaDef(globalSchemes[0].value().value(),globalSchemes[0].key());
	//        }
	//        else{
	//            return Opt.empty<SchemaDef>();
	//        }
	//    }
	//    return new Opt<SchemaDef>(schDef);
	//}
	//__$helperMethod__ Retrieve all uri parameters regardless of whether they are described in `uriParameters` or not
	// __$meta__={"name":"allUriParameters"}
	function uriParameters(resource) {
	    var uri = resource.relativeUri().value();
	    var params = resource.uriParameters();
	    return extractParams(params, uri, resource);
	}
	exports.uriParameters = uriParameters;
	//__$helperMethod__ Retrieve all base uri parameters regardless of whether they are described in `baseUriParameters` or not
	//__$meta__={"name":"allBaseUriParameters"}
	function baseUriParameters(api) {
	    var uri = api.baseUri() ? api.baseUri().value() : '';
	    var params = api.baseUriParameters();
	    return extractParams(params, uri, api);
	}
	exports.baseUriParameters = baseUriParameters;
	//__$helperMethod__ Retrieve all absolute uri parameters regardless of whether they are described in
	//`baseUriParameters` and `uriParameters` or not
	function absoluteUriParameters(res) {
	    var params = [];
	    var parent = res;
	    do {
	        res = parent;
	        var uri = res.relativeUri().value();
	        var uriParams = res.uriParameters();
	        params = extractParams(uriParams, uri, res).concat(params);
	        parent = res.parent();
	    } while (parent['relativeUri']);
	    var api = parent;
	    var baseUri = api.baseUri().value();
	    var baseUriParams = api.baseUriParameters();
	    params = extractParams(baseUriParams, baseUri, api).concat(params);
	    return params;
	}
	exports.absoluteUriParameters = absoluteUriParameters;
	function extractParams(params, uri, resource) {
	    if (!uri) {
	        return [];
	    }
	    var describedParams = {};
	    params.forEach(function (x) { return describedParams[x.name()] = x; });
	    var allParams = [];
	    var prev = 0;
	    for (var i = uri.indexOf('{'); i >= 0; i = uri.indexOf('{', prev)) {
	        prev = uri.indexOf('}', ++i);
	        var paramName = uri.substring(i, prev);
	        if (describedParams[paramName]) {
	            allParams.push(describedParams[paramName]);
	        }
	        else {
	            allParams.push(new HelperUriParam(paramName, resource));
	        }
	    }
	    return allParams;
	}
	;
	var HelperUriParam = (function () {
	    function HelperUriParam(_name, _parent) {
	        this._name = _name;
	        this._parent = _parent;
	    }
	    HelperUriParam.prototype.wrapperClassName = function () {
	        return "HelperUriParam";
	    };
	    HelperUriParam.prototype.getKind = function () {
	        return "HelperUriParam";
	    };
	    HelperUriParam.prototype.name = function () {
	        return this._name;
	    };
	    HelperUriParam.prototype["type"] = function () {
	        return "string";
	    };
	    HelperUriParam.prototype.location = function () {
	        return {
	            wrapperClassName: function () { return "HelperModelLocation"; },
	            getKind: function () { return "HelperModelLocation"; }
	        };
	    };
	    //    locationKind(  ):RamlWrapper.LocationKind{ return { wrapperClassName: ()=>"HelperLocationKind" }; }
	    HelperUriParam.prototype["default"] = function () {
	        return null;
	    };
	    HelperUriParam.prototype.xml = function () {
	        return null;
	    };
	    HelperUriParam.prototype.sendDefaultByClient = function () {
	        return false;
	    };
	    HelperUriParam.prototype.example = function () {
	        return '';
	    };
	    HelperUriParam.prototype.schema = function () {
	        return null;
	    };
	    //    formParameters():RamlWrapper.DataElement[]{return []}
	    //    examples(  ):RamlWrapper.ExampleSpec[]{ return []}
	    HelperUriParam.prototype.repeat = function () {
	        return false;
	    };
	    HelperUriParam.prototype.enum = function () {
	        return [];
	    };
	    HelperUriParam.prototype.collectionFormat = function () {
	        return 'multi';
	    };
	    HelperUriParam.prototype.required = function () {
	        return true;
	    };
	    HelperUriParam.prototype.readOnly = function () {
	        return false;
	    };
	    HelperUriParam.prototype.facets = function () {
	        return [];
	    };
	    HelperUriParam.prototype.scope = function () {
	        return [];
	    };
	    //xml(  ):RamlWrapper.XMLInfo{ return null; }
	    //    validWhen(  ):RamlWrapper.ramlexpression{ return null; }
	    //    requiredWhen(  ):RamlWrapper.ramlexpression{ return null; }
	    HelperUriParam.prototype.displayName = function () {
	        return this._name;
	    };
	    HelperUriParam.prototype.description = function () {
	        return null;
	    };
	    //    annotations(  ):RamlWrapper.AnnotationRef[]{ return []; }
	    HelperUriParam.prototype.usage = function () {
	        return null;
	    };
	    HelperUriParam.prototype.parent = function () {
	        return this._parent;
	    };
	    HelperUriParam.prototype.highLevel = function () {
	        return null;
	    };
	    HelperUriParam.prototype.errors = function () {
	        return [];
	    };
	    HelperUriParam.prototype.definition = function () {
	        return null;
	    };
	    HelperUriParam.prototype.runtimeDefinition = function () {
	        return null;
	    };
	    HelperUriParam.prototype.toJSON = function () {
	        return { "name": this.name() };
	    };
	    return HelperUriParam;
	})();
	exports.HelperUriParam = HelperUriParam;
	//
	//export class SchemaDef{
	//
	//    constructor(private _content:string, private _name?:string){}
	//
	//    name():string{return this._name}
	//
	//    content(): string{return this._content}
	//}
	//
	//
	//export class ParamValue{
	//    key:string
	//    value:any
	//
	//    constructor(key:string, value:any) {
	//        this.key = key;
	//        this.value = value;
	//    }
	//}
	//
	//
	//class ParamWrapper implements Raml08Parser.BasicNamedParameter{
	//
	//    constructor(private _param:RamlWrapper.DataElement){
	//
	//        this.description = _param.description() ? _param.description().value() : this.description;
	//
	//        this.displayName = _param.displayName();
	//
	////        this.enum = _param.enum();
	//
	//        this.type = _param.type().length > 0 ? _param.type()[0] : "string";
	//
	//        this.example = _param.example();
	//
	//        this.repeat = _param.repeat();
	//
	//        this.required = _param.required();
	//
	//        this.default = _param.default();
	//    }
	//
	//    description: Raml08Parser.MarkdownString
	//
	//    displayName: string
	//
	//    'enum': any[]
	//
	//    type: string
	//
	//    example: any
	//
	//    repeat: boolean
	//
	//    required: boolean
	//
	//    'default': any
	//
	//}


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var hl = __webpack_require__(2);
	var _ = __webpack_require__(4);
	var linter = __webpack_require__(72);
	var wrapperHelper = __webpack_require__(88);
	function escapeUri(u) {
	    var ss = "";
	    var level = 0;
	    for (var i = 0; i < u.length; i++) {
	        var c = u.charAt(i);
	        if (level == 0) {
	            ss = ss + c;
	        }
	        if (c == '{') {
	            level++;
	        }
	        if (c == '}') {
	            level--;
	        }
	    }
	    return ss;
	}
	var OverloadingValidator = (function () {
	    function OverloadingValidator() {
	        this.holder = {};
	        this.conflicting = {};
	    }
	    OverloadingValidator.prototype.validateApi = function (q, v) {
	        var _this = this;
	        q.resources().forEach(function (x) {
	            _this.acceptResource(x);
	            x.resources().forEach(function (y) { return _this.acceptResource(y); });
	        });
	        for (var c in this.conflicting) {
	            var ms = this.conflicting[c];
	            //now we should layout parameters by items
	            var overmapQuery = {};
	            var overmapHeaders = {};
	            var pushed = [];
	            ms.forEach(function (m) {
	                m.queryParameters().forEach(function (q) {
	                    var key = q.name();
	                    if (!q.required()) {
	                        return;
	                    }
	                    var set = overmapQuery[key];
	                    if (!set) {
	                        set = [];
	                        overmapQuery[key] = set;
	                    }
	                    set.push(m);
	                    pushed.push(m);
	                });
	                m.headers().forEach(function (q) {
	                    var key = q.name();
	                    if (!q.required()) {
	                        return;
	                    }
	                    var set = overmapHeaders[key];
	                    if (!set) {
	                        set = [];
	                        overmapHeaders[key] = set;
	                    }
	                    set.push(m);
	                    pushed.push(m);
	                });
	            });
	            var notPushed = ms.filter(function (x) { return !_.find(pushed, function (y) { return y == x; }); });
	            if (notPushed.length > 0) {
	                notPushed.forEach(function (m) {
	                    v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous", m.highLevel(), true));
	                });
	            }
	            for (var key in overmapQuery) {
	                var cm = overmapQuery[key];
	                if (cm.length > 1) {
	                    var over = {};
	                    var pushed2 = [];
	                    cm.forEach(function (m) {
	                        var pr = _.find(m.queryParameters(), function (x) { return x.name() == key; });
	                        if (pr['enum']) {
	                            var ev = pr['enum']();
	                            if (ev && ev.length > 0) {
	                                ev.forEach(function (value) {
	                                    var t = over[value];
	                                    if (!t) {
	                                        t = [];
	                                        over[value] = t;
	                                    }
	                                    t.push(m);
	                                    pushed2.push(m);
	                                });
	                            }
	                        }
	                    });
	                    var notPushed2 = cm.filter(function (x) { return !_.find(pushed2, function (y) { return y == x; }); });
	                    if (notPushed2.length > 0) {
	                        notPushed2.forEach(function (m) {
	                            v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous no domain restrictions", m.highLevel(), true));
	                        });
	                    }
	                    for (var k in over) {
	                        var rs = over[k];
	                        if (rs.length > 1) {
	                            rs.forEach(function (m) { return v.accept(linter.createIssue(5 /* KEY_SHOULD_BE_UNIQUE_INTHISCONTEXT */, "method overloading is ambiguous ( enum value " + k + ")", m.highLevel(), true)); });
	                        }
	                    }
	                }
	            }
	        }
	    };
	    OverloadingValidator.prototype.acceptResource = function (x) {
	        var _this = this;
	        x.methods().forEach(function (m) {
	            _this.acceptMethod(x, m);
	        });
	    };
	    OverloadingValidator.prototype.acceptMethod = function (x, m) {
	        var uri = escapeUri(wrapperHelper.absoluteUri(x)) + m.method();
	        var pos = this.holder[uri];
	        if (!pos) {
	            pos = [];
	            this.holder[uri] = pos;
	        }
	        pos.push(m);
	        if (pos.length > 1) {
	            this.conflicting[uri] = pos;
	        }
	        //wrapperHelper.absoluteUri(m.parent().)
	    };
	    return OverloadingValidator;
	})();
	exports.OverloadingValidator = OverloadingValidator;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../typings/tsd.d.ts" />
	var __extends = this.__extends || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var _ = __webpack_require__(4);
	var sel = __webpack_require__(99);
	var Selector = (function () {
	    function Selector() {
	    }
	    Selector.prototype.candidates = function (context) {
	        return context;
	    };
	    Selector.prototype.apply = function (h) {
	        return this.candidates([h]);
	    };
	    return Selector;
	})();
	exports.Selector = Selector;
	var OrMatch = (function (_super) {
	    __extends(OrMatch, _super);
	    function OrMatch(left, right) {
	        _super.call(this);
	        this.left = left;
	        this.right = right;
	    }
	    OrMatch.prototype.candidates = function (context) {
	        var l = this.left.candidates(context);
	        l = l.concat(this.right.candidates(context));
	        return _.unique(l);
	    };
	    return OrMatch;
	})(Selector);
	exports.OrMatch = OrMatch;
	var DotMatch = (function (_super) {
	    __extends(DotMatch, _super);
	    function DotMatch(left, right) {
	        _super.call(this);
	        this.left = left;
	        this.right = right;
	    }
	    DotMatch.prototype.candidates = function (context) {
	        var l = this.left.candidates(context);
	        if (this.left instanceof AnyParentMatch) {
	            l = this.right.candidates(new AnyChildMatch().candidates(l));
	            return _.unique(l);
	        }
	        if (this.left instanceof ParentMatch) {
	            l = this.right.candidates(new AnyChildMatch().candidates(l));
	            return _.unique(l);
	        }
	        l = this.right.candidates(l);
	        return _.unique(l);
	    };
	    return DotMatch;
	})(Selector);
	exports.DotMatch = DotMatch;
	function resolveSelector(s, n) {
	    if (s.type == "or") {
	        var b = s;
	        var l = resolveSelector(b.left, n);
	        var r = resolveSelector(b.right, n);
	        return new OrMatch(l, r);
	    }
	    if (s.type == "dot") {
	        var b = s;
	        var l = resolveSelector(b.left, n);
	        var r = resolveSelector(b.right, n);
	        return new DotMatch(l, r);
	    }
	    if (s.type == 'classLiteral') {
	        var literal = s;
	        var tp = n.definition().universe().getType(literal.name);
	        if (tp == null || tp.isValueType()) {
	            throw new Error("Referencing unknown type:" + literal.name);
	        }
	        return new IdMatch(literal.name);
	    }
	    if (s.type == 'parent') {
	        return new ParentMatch();
	    }
	    if (s.type == 'ancestor') {
	        return new AnyParentMatch();
	    }
	    if (s.type == 'descendant') {
	        return new AnyChildMatch();
	    }
	    if (s.type == 'child') {
	        return new ChildMatch();
	    }
	}
	exports.resolveSelector = resolveSelector;
	var IdMatch = (function (_super) {
	    __extends(IdMatch, _super);
	    function IdMatch(name) {
	        _super.call(this);
	        this.name = name;
	    }
	    IdMatch.prototype.candidates = function (context) {
	        var _this = this;
	        return context.filter(function (x) {
	            if (!x) {
	                return false;
	            }
	            if (x.definition().nameId() == _this.name) {
	                return true;
	            }
	            var superTypes = x.definition().allSuperTypes();
	            if (_.find(superTypes, function (x) { return x.nameId() == _this.name; })) {
	                return true;
	            }
	            return false;
	        });
	    };
	    return IdMatch;
	})(Selector);
	exports.IdMatch = IdMatch;
	var AnyParentMatch = (function (_super) {
	    __extends(AnyParentMatch, _super);
	    function AnyParentMatch() {
	        _super.apply(this, arguments);
	    }
	    AnyParentMatch.prototype.candidates = function (context) {
	        var res = [];
	        context.forEach(function (x) {
	            if (x) {
	                var z = x.parent();
	                while (z) {
	                    res.push(z);
	                    z = z.parent();
	                }
	            }
	        });
	        return _.unique(res);
	    };
	    return AnyParentMatch;
	})(Selector);
	exports.AnyParentMatch = AnyParentMatch;
	function addChildren(x, r) {
	    r.push(x);
	    x.elements().forEach(function (y) { return addChildren(y, r); });
	}
	var AnyChildMatch = (function (_super) {
	    __extends(AnyChildMatch, _super);
	    function AnyChildMatch() {
	        _super.apply(this, arguments);
	    }
	    AnyChildMatch.prototype.candidates = function (context) {
	        var res = [];
	        context.forEach(function (x) {
	            if (x) {
	                addChildren(x, res);
	            }
	        });
	        return _.unique(res);
	    };
	    return AnyChildMatch;
	})(Selector);
	exports.AnyChildMatch = AnyChildMatch;
	var ParentMatch = (function (_super) {
	    __extends(ParentMatch, _super);
	    function ParentMatch() {
	        _super.apply(this, arguments);
	    }
	    ParentMatch.prototype.candidates = function (context) {
	        return context.map(function (x) { return x.parent(); });
	    };
	    return ParentMatch;
	})(Selector);
	exports.ParentMatch = ParentMatch;
	var ChildMatch = (function (_super) {
	    __extends(ChildMatch, _super);
	    function ChildMatch() {
	        _super.apply(this, arguments);
	    }
	    ChildMatch.prototype.candidates = function (context) {
	        var res = [];
	        context.forEach(function (x) {
	            if (x) {
	                res = res.concat(x.elements());
	            }
	        });
	        return res;
	    };
	    return ChildMatch;
	})(Selector);
	exports.ChildMatch = ChildMatch;
	function parse(h, path) {
	    return resolveSelector(sel.parse(path), h);
	}
	exports.parse = parse;


/***/ },
/* 99 */
/***/ function(module, exports) {

	var mod = (function () {
	    /*
	     * Generated by PEG.js 0.8.0.
	     *
	     * http://pegjs.majda.cz/
	     */
	    function peg$subclass(child, parent) {
	        function ctor() {
	            this.constructor = child;
	        }
	        ctor.prototype = parent.prototype;
	        child.prototype = new ctor();
	    }
	    function SyntaxError(message, expected, found, offset, line, column) {
	        this.message = message;
	        this.expected = expected;
	        this.found = found;
	        this.offset = offset;
	        this.line = line;
	        this.column = column;
	        this.name = "SyntaxError";
	    }
	    peg$subclass(SyntaxError, Error);
	    function parse(input) {
	        var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = peg$FAILED, peg$c1 = "|", peg$c2 = { type: "literal", value: "|", description: "\"|\"" }, peg$c3 = function (left, r) {
	            return { 'type': 'or', 'left': left, 'right': r ? r : null };
	        }, peg$c4 = ".", peg$c5 = { type: "literal", value: ".", description: "\".\"" }, peg$c6 = function (left, r) {
	            return { 'type': 'dot', 'left': left, 'right': r };
	        }, peg$c7 = "$", peg$c8 = { type: "literal", value: "$", description: "\"$\"" }, peg$c9 = function () {
	            return { 'type': 'parent' };
	        }, peg$c10 = "$$", peg$c11 = { type: "literal", value: "$$", description: "\"$$\"" }, peg$c12 = function () {
	            return { 'type': 'ancestor' };
	        }, peg$c13 = "**", peg$c14 = { type: "literal", value: "**", description: "\"**\"" }, peg$c15 = function () {
	            return { 'type': 'descendant' };
	        }, peg$c16 = "*", peg$c17 = { type: "literal", value: "*", description: "\"*\"" }, peg$c18 = function () {
	            return { 'type': 'child' };
	        }, peg$c19 = [], peg$c20 = /^[A-z]/, peg$c21 = { type: "class", value: "[A-z]", description: "[A-z]" }, peg$c22 = function (chars) {
	            return { 'type': 'classLiteral', "name": chars.join("") };
	        }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
	        if ("startRule" in options) {
	            if (!(options.startRule in peg$startRuleFunctions)) {
	                throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	            }
	            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	        }
	        function text() {
	            return input.substring(peg$reportedPos, peg$currPos);
	        }
	        function offset() {
	            return peg$reportedPos;
	        }
	        function line() {
	            return peg$computePosDetails(peg$reportedPos).line;
	        }
	        function column() {
	            return peg$computePosDetails(peg$reportedPos).column;
	        }
	        function expected(description) {
	            throw peg$buildException(null, [{ type: "other", description: description }], peg$reportedPos);
	        }
	        function error(message) {
	            throw peg$buildException(message, null, peg$reportedPos);
	        }
	        function peg$computePosDetails(pos) {
	            function advance(details, startPos, endPos) {
	                var p, ch;
	                for (p = startPos; p < endPos; p++) {
	                    ch = input.charAt(p);
	                    if (ch === "\n") {
	                        if (!details.seenCR) {
	                            details.line++;
	                        }
	                        details.column = 1;
	                        details.seenCR = false;
	                    }
	                    else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
	                        details.line++;
	                        details.column = 1;
	                        details.seenCR = true;
	                    }
	                    else {
	                        details.column++;
	                        details.seenCR = false;
	                    }
	                }
	            }
	            if (peg$cachedPos !== pos) {
	                if (peg$cachedPos > pos) {
	                    peg$cachedPos = 0;
	                    peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
	                }
	                advance(peg$cachedPosDetails, peg$cachedPos, pos);
	                peg$cachedPos = pos;
	            }
	            return peg$cachedPosDetails;
	        }
	        function peg$fail(expected) {
	            if (peg$currPos < peg$maxFailPos) {
	                return;
	            }
	            if (peg$currPos > peg$maxFailPos) {
	                peg$maxFailPos = peg$currPos;
	                peg$maxFailExpected = [];
	            }
	            peg$maxFailExpected.push(expected);
	        }
	        function peg$buildException(message, expected, pos) {
	            function cleanupExpected(expected) {
	                var i = 1;
	                expected.sort(function (a, b) {
	                    if (a.description < b.description) {
	                        return -1;
	                    }
	                    else if (a.description > b.description) {
	                        return 1;
	                    }
	                    else {
	                        return 0;
	                    }
	                });
	                while (i < expected.length) {
	                    if (expected[i - 1] === expected[i]) {
	                        expected.splice(i, 1);
	                    }
	                    else {
	                        i++;
	                    }
	                }
	            }
	            function buildMessage(expected, found) {
	                function stringEscape(s) {
	                    function hex(ch) {
	                        return ch.charCodeAt(0).toString(16).toUpperCase();
	                    }
	                    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\x08/g, '\\b').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\f/g, '\\f').replace(/\r/g, '\\r').replace(/[\x00-\x07\x0B\x0E\x0F]/g, function (ch) {
	                        return '\\x0' + hex(ch);
	                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function (ch) {
	                        return '\\x' + hex(ch);
	                    }).replace(/[\u0180-\u0FFF]/g, function (ch) {
	                        return '\\u0' + hex(ch);
	                    }).replace(/[\u1080-\uFFFF]/g, function (ch) {
	                        return '\\u' + hex(ch);
	                    });
	                }
	                var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i;
	                for (i = 0; i < expected.length; i++) {
	                    expectedDescs[i] = expected[i].description;
	                }
	                expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0];
	                foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";
	                return "Expected " + expectedDesc + " but " + foundDesc + " found.";
	            }
	            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
	            if (expected !== null) {
	                cleanupExpected(expected);
	            }
	            return new SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
	        }
	        function peg$parsestart() {
	            var s0;
	            s0 = peg$parseor();
	            return s0;
	        }
	        function peg$parseor() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parsesequence();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 124) {
	                    s2 = peg$c1;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c2);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parseor();
	                    if (s3 !== peg$FAILED) {
	                        peg$reportedPos = s0;
	                        s1 = peg$c3(s1, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$c0;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$c0;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$c0;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsesequence();
	            }
	            return s0;
	        }
	        function peg$parsesequence() {
	            var s0, s1, s2, s3;
	            s0 = peg$currPos;
	            s1 = peg$parseprimary();
	            if (s1 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 46) {
	                    s2 = peg$c4;
	                    peg$currPos++;
	                }
	                else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) {
	                        peg$fail(peg$c5);
	                    }
	                }
	                if (s2 !== peg$FAILED) {
	                    s3 = peg$parsesequence();
	                    if (s3 !== peg$FAILED) {
	                        peg$reportedPos = s0;
	                        s1 = peg$c6(s1, s3);
	                        s0 = s1;
	                    }
	                    else {
	                        peg$currPos = s0;
	                        s0 = peg$c0;
	                    }
	                }
	                else {
	                    peg$currPos = s0;
	                    s0 = peg$c0;
	                }
	            }
	            else {
	                peg$currPos = s0;
	                s0 = peg$c0;
	            }
	            if (s0 === peg$FAILED) {
	                s0 = peg$parseprimary();
	            }
	            return s0;
	        }
	        function peg$parseprimary() {
	            var s0;
	            s0 = peg$parsechildRef();
	            if (s0 === peg$FAILED) {
	                s0 = peg$parsedoubleStar();
	                if (s0 === peg$FAILED) {
	                    s0 = peg$parsestar();
	                    if (s0 === peg$FAILED) {
	                        s0 = peg$parsedoubleDollar();
	                        if (s0 === peg$FAILED) {
	                            s0 = peg$parsedollar();
	                        }
	                    }
	                }
	            }
	            return s0;
	        }
	        function peg$parsedollar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 36) {
	                s1 = peg$c7;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c8);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c9();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsedoubleDollar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 2) === peg$c10) {
	                s1 = peg$c10;
	                peg$currPos += 2;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c11);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c12();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsedoubleStar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.substr(peg$currPos, 2) === peg$c13) {
	                s1 = peg$c13;
	                peg$currPos += 2;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c14);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c15();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsestar() {
	            var s0, s1;
	            s0 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 42) {
	                s1 = peg$c16;
	                peg$currPos++;
	            }
	            else {
	                s1 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c17);
	                }
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c18();
	            }
	            s0 = s1;
	            return s0;
	        }
	        function peg$parsechildRef() {
	            var s0, s1, s2;
	            s0 = peg$currPos;
	            s1 = [];
	            if (peg$c20.test(input.charAt(peg$currPos))) {
	                s2 = input.charAt(peg$currPos);
	                peg$currPos++;
	            }
	            else {
	                s2 = peg$FAILED;
	                if (peg$silentFails === 0) {
	                    peg$fail(peg$c21);
	                }
	            }
	            if (s2 !== peg$FAILED) {
	                while (s2 !== peg$FAILED) {
	                    s1.push(s2);
	                    if (peg$c20.test(input.charAt(peg$currPos))) {
	                        s2 = input.charAt(peg$currPos);
	                        peg$currPos++;
	                    }
	                    else {
	                        s2 = peg$FAILED;
	                        if (peg$silentFails === 0) {
	                            peg$fail(peg$c21);
	                        }
	                    }
	                }
	            }
	            else {
	                s1 = peg$c0;
	            }
	            if (s1 !== peg$FAILED) {
	                peg$reportedPos = s0;
	                s1 = peg$c22(s1);
	            }
	            s0 = s1;
	            return s0;
	        }
	        peg$result = peg$startRuleFunction();
	        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	            return peg$result;
	        }
	        else {
	            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	                peg$fail({ type: "end", description: "end of input" });
	            }
	            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
	        }
	    }
	    return {
	        SyntaxError: SyntaxError,
	        parse: parse
	    };
	})();
	module.exports = mod;


/***/ }
/******/ ]);